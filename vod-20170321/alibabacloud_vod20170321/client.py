# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from typing import Dict
from Tea.core import TeaCore

from alibabacloud_tea_openapi.client import Client as OpenApiClient
from alibabacloud_tea_openapi import models as open_api_models
from alibabacloud_tea_util.client import Client as UtilClient
from alibabacloud_endpoint_util.client import Client as EndpointUtilClient
from alibabacloud_vod20170321 import models as vod_20170321_models
from alibabacloud_tea_util import models as util_models
from alibabacloud_openapi_util.client import Client as OpenApiUtilClient


class Client(OpenApiClient):
    """
    *\
    """
    def __init__(
        self, 
        config: open_api_models.Config,
    ):
        super().__init__(config)
        self._signature_algorithm = 'v2'
        self._endpoint_rule = 'regional'
        self._endpoint_map = {
            'cn-hangzhou': 'vod.cn-shanghai.aliyuncs.com',
            'ap-northeast-2-pop': 'vod.aliyuncs.com',
            'ap-southeast-2': 'vod.aliyuncs.com',
            'ap-southeast-3': 'vod.aliyuncs.com',
            'cn-beijing-finance-1': 'vod.aliyuncs.com',
            'cn-beijing-finance-pop': 'vod.aliyuncs.com',
            'cn-beijing-gov-1': 'vod.aliyuncs.com',
            'cn-beijing-nu16-b01': 'vod.aliyuncs.com',
            'cn-chengdu': 'vod.aliyuncs.com',
            'cn-edge-1': 'vod.aliyuncs.com',
            'cn-fujian': 'vod.aliyuncs.com',
            'cn-haidian-cm12-c01': 'vod.aliyuncs.com',
            'cn-hangzhou-bj-b01': 'vod.aliyuncs.com',
            'cn-hangzhou-finance': 'vod.aliyuncs.com',
            'cn-hangzhou-internal-prod-1': 'vod.aliyuncs.com',
            'cn-hangzhou-internal-test-1': 'vod.aliyuncs.com',
            'cn-hangzhou-internal-test-2': 'vod.aliyuncs.com',
            'cn-hangzhou-internal-test-3': 'vod.aliyuncs.com',
            'cn-hangzhou-test-306': 'vod.aliyuncs.com',
            'cn-hongkong-finance-pop': 'vod.aliyuncs.com',
            'cn-huhehaote': 'vod.aliyuncs.com',
            'cn-huhehaote-nebula-1': 'vod.aliyuncs.com',
            'cn-qingdao': 'vod.aliyuncs.com',
            'cn-qingdao-nebula': 'vod.aliyuncs.com',
            'cn-shanghai-et15-b01': 'vod.aliyuncs.com',
            'cn-shanghai-et2-b01': 'vod.aliyuncs.com',
            'cn-shanghai-finance-1': 'vod.aliyuncs.com',
            'cn-shanghai-inner': 'vod.aliyuncs.com',
            'cn-shanghai-internal-test-1': 'vod.aliyuncs.com',
            'cn-shenzhen-finance-1': 'vod.aliyuncs.com',
            'cn-shenzhen-inner': 'vod.aliyuncs.com',
            'cn-shenzhen-st4-d01': 'vod.aliyuncs.com',
            'cn-shenzhen-su18-b01': 'vod.aliyuncs.com',
            'cn-wuhan': 'vod.aliyuncs.com',
            'cn-wulanchabu': 'vod.aliyuncs.com',
            'cn-yushanfang': 'vod.aliyuncs.com',
            'cn-zhangbei': 'vod.aliyuncs.com',
            'cn-zhangbei-na61-b01': 'vod.aliyuncs.com',
            'cn-zhangjiakou-na62-a01': 'vod.aliyuncs.com',
            'cn-zhengzhou-nebula-1': 'vod.aliyuncs.com',
            'eu-west-1-oxs': 'vod.aliyuncs.com',
            'me-east-1': 'vod.aliyuncs.com',
            'rus-west-1-pop': 'vod.aliyuncs.com',
            'us-east-1': 'vod.aliyuncs.com'
        }
        self.check_config(config)
        self._endpoint = self.get_endpoint('vod', self._region_id, self._endpoint_rule, self._network, self._suffix, self._endpoint_map, self._endpoint)

    def get_endpoint(
        self,
        product_id: str,
        region_id: str,
        endpoint_rule: str,
        network: str,
        suffix: str,
        endpoint_map: Dict[str, str],
        endpoint: str,
    ) -> str:
        if not UtilClient.empty(endpoint):
            return endpoint
        if not UtilClient.is_unset(endpoint_map) and not UtilClient.empty(endpoint_map.get(region_id)):
            return endpoint_map.get(region_id)
        return EndpointUtilClient.get_endpoint_rules(product_id, region_id, endpoint_rule, network, suffix)

    def add_aitemplate_with_options(
        self,
        request: vod_20170321_models.AddAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddAITemplateResponse:
        """
        @summary Adds an AI template for automated review and smart thumbnail tasks.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        Before you add an AI template for automated review and smart thumbnail tasks, make sure that [automated review](https://ai.aliyun.com/vi/censor) and [smart thumbnail](https://ai.aliyun.com/vi/cover) are enabled.
        
        @param request: AddAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_config):
            query['TemplateConfig'] = request.template_config
        if not UtilClient.is_unset(request.template_name):
            query['TemplateName'] = request.template_name
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddAITemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_aitemplate_with_options_async(
        self,
        request: vod_20170321_models.AddAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddAITemplateResponse:
        """
        @summary Adds an AI template for automated review and smart thumbnail tasks.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        Before you add an AI template for automated review and smart thumbnail tasks, make sure that [automated review](https://ai.aliyun.com/vi/censor) and [smart thumbnail](https://ai.aliyun.com/vi/cover) are enabled.
        
        @param request: AddAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_config):
            query['TemplateConfig'] = request.template_config
        if not UtilClient.is_unset(request.template_name):
            query['TemplateName'] = request.template_name
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddAITemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_aitemplate(
        self,
        request: vod_20170321_models.AddAITemplateRequest,
    ) -> vod_20170321_models.AddAITemplateResponse:
        """
        @summary Adds an AI template for automated review and smart thumbnail tasks.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        Before you add an AI template for automated review and smart thumbnail tasks, make sure that [automated review](https://ai.aliyun.com/vi/censor) and [smart thumbnail](https://ai.aliyun.com/vi/cover) are enabled.
        
        @param request: AddAITemplateRequest
        @return: AddAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_aitemplate_with_options(request, runtime)

    async def add_aitemplate_async(
        self,
        request: vod_20170321_models.AddAITemplateRequest,
    ) -> vod_20170321_models.AddAITemplateResponse:
        """
        @summary Adds an AI template for automated review and smart thumbnail tasks.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        Before you add an AI template for automated review and smart thumbnail tasks, make sure that [automated review](https://ai.aliyun.com/vi/censor) and [smart thumbnail](https://ai.aliyun.com/vi/cover) are enabled.
        
        @param request: AddAITemplateRequest
        @return: AddAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_aitemplate_with_options_async(request, runtime)

    def add_category_with_options(
        self,
        request: vod_20170321_models.AddCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddCategoryResponse:
        """
        @summary Creates a video category. You can call this operation to categorize media assets including audio or video files, images, and short video materials in ApsaraVideo VOD. This simplifies the query and management of media assets.
        
        @description    You can create a maximum of 3 levels of categories for audio, video, and image files and 2 levels of categories for short video materials. Each category level can contain a maximum of 100 subcategories. To create categories for audio and video files, set `Type` to `default`. To create categories for short video materials, set `Type` to `material`.
        After you create a category, you can categorize media resources during upload or categorize the uploaded media resources. For more information, see [Manage video categories](https://help.aliyun.com/document_detail/86070.html).
        
        @param request: AddCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cate_name):
            query['CateName'] = request.cate_name
        if not UtilClient.is_unset(request.parent_id):
            query['ParentId'] = request.parent_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCategory',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddCategoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_category_with_options_async(
        self,
        request: vod_20170321_models.AddCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddCategoryResponse:
        """
        @summary Creates a video category. You can call this operation to categorize media assets including audio or video files, images, and short video materials in ApsaraVideo VOD. This simplifies the query and management of media assets.
        
        @description    You can create a maximum of 3 levels of categories for audio, video, and image files and 2 levels of categories for short video materials. Each category level can contain a maximum of 100 subcategories. To create categories for audio and video files, set `Type` to `default`. To create categories for short video materials, set `Type` to `material`.
        After you create a category, you can categorize media resources during upload or categorize the uploaded media resources. For more information, see [Manage video categories](https://help.aliyun.com/document_detail/86070.html).
        
        @param request: AddCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cate_name):
            query['CateName'] = request.cate_name
        if not UtilClient.is_unset(request.parent_id):
            query['ParentId'] = request.parent_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCategory',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddCategoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_category(
        self,
        request: vod_20170321_models.AddCategoryRequest,
    ) -> vod_20170321_models.AddCategoryResponse:
        """
        @summary Creates a video category. You can call this operation to categorize media assets including audio or video files, images, and short video materials in ApsaraVideo VOD. This simplifies the query and management of media assets.
        
        @description    You can create a maximum of 3 levels of categories for audio, video, and image files and 2 levels of categories for short video materials. Each category level can contain a maximum of 100 subcategories. To create categories for audio and video files, set `Type` to `default`. To create categories for short video materials, set `Type` to `material`.
        After you create a category, you can categorize media resources during upload or categorize the uploaded media resources. For more information, see [Manage video categories](https://help.aliyun.com/document_detail/86070.html).
        
        @param request: AddCategoryRequest
        @return: AddCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_category_with_options(request, runtime)

    async def add_category_async(
        self,
        request: vod_20170321_models.AddCategoryRequest,
    ) -> vod_20170321_models.AddCategoryResponse:
        """
        @summary Creates a video category. You can call this operation to categorize media assets including audio or video files, images, and short video materials in ApsaraVideo VOD. This simplifies the query and management of media assets.
        
        @description    You can create a maximum of 3 levels of categories for audio, video, and image files and 2 levels of categories for short video materials. Each category level can contain a maximum of 100 subcategories. To create categories for audio and video files, set `Type` to `default`. To create categories for short video materials, set `Type` to `material`.
        After you create a category, you can categorize media resources during upload or categorize the uploaded media resources. For more information, see [Manage video categories](https://help.aliyun.com/document_detail/86070.html).
        
        @param request: AddCategoryRequest
        @return: AddCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_category_with_options_async(request, runtime)

    def add_custom_template_and_group_console_with_options(
        self,
        request: vod_20170321_models.AddCustomTemplateAndGroupConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddCustomTemplateAndGroupConsoleResponse:
        """
        @summary 创建模版
        
        @param request: AddCustomTemplateAndGroupConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCustomTemplateAndGroupConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.configs):
            query['Configs'] = request.configs
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCustomTemplateAndGroupConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddCustomTemplateAndGroupConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_custom_template_and_group_console_with_options_async(
        self,
        request: vod_20170321_models.AddCustomTemplateAndGroupConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddCustomTemplateAndGroupConsoleResponse:
        """
        @summary 创建模版
        
        @param request: AddCustomTemplateAndGroupConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddCustomTemplateAndGroupConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.configs):
            query['Configs'] = request.configs
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddCustomTemplateAndGroupConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddCustomTemplateAndGroupConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_custom_template_and_group_console(
        self,
        request: vod_20170321_models.AddCustomTemplateAndGroupConsoleRequest,
    ) -> vod_20170321_models.AddCustomTemplateAndGroupConsoleResponse:
        """
        @summary 创建模版
        
        @param request: AddCustomTemplateAndGroupConsoleRequest
        @return: AddCustomTemplateAndGroupConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_custom_template_and_group_console_with_options(request, runtime)

    async def add_custom_template_and_group_console_async(
        self,
        request: vod_20170321_models.AddCustomTemplateAndGroupConsoleRequest,
    ) -> vod_20170321_models.AddCustomTemplateAndGroupConsoleResponse:
        """
        @summary 创建模版
        
        @param request: AddCustomTemplateAndGroupConsoleRequest
        @return: AddCustomTemplateAndGroupConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_custom_template_and_group_console_with_options_async(request, runtime)

    def add_editing_project_with_options(
        self,
        request: vod_20170321_models.AddEditingProjectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddEditingProjectResponse:
        """
        @summary Creates an online editing project.
        
        @description    For more information about the online editing feature, see [Overview](https://help.aliyun.com/document_detail/95482.html).
        
        @param request: AddEditingProjectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddEditingProjectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cover_url):
            query['CoverURL'] = request.cover_url
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.division):
            query['Division'] = request.division
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.timeline):
            query['Timeline'] = request.timeline
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddEditingProject',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddEditingProjectResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_editing_project_with_options_async(
        self,
        request: vod_20170321_models.AddEditingProjectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddEditingProjectResponse:
        """
        @summary Creates an online editing project.
        
        @description    For more information about the online editing feature, see [Overview](https://help.aliyun.com/document_detail/95482.html).
        
        @param request: AddEditingProjectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddEditingProjectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cover_url):
            query['CoverURL'] = request.cover_url
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.division):
            query['Division'] = request.division
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.timeline):
            query['Timeline'] = request.timeline
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddEditingProject',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddEditingProjectResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_editing_project(
        self,
        request: vod_20170321_models.AddEditingProjectRequest,
    ) -> vod_20170321_models.AddEditingProjectResponse:
        """
        @summary Creates an online editing project.
        
        @description    For more information about the online editing feature, see [Overview](https://help.aliyun.com/document_detail/95482.html).
        
        @param request: AddEditingProjectRequest
        @return: AddEditingProjectResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_editing_project_with_options(request, runtime)

    async def add_editing_project_async(
        self,
        request: vod_20170321_models.AddEditingProjectRequest,
    ) -> vod_20170321_models.AddEditingProjectResponse:
        """
        @summary Creates an online editing project.
        
        @description    For more information about the online editing feature, see [Overview](https://help.aliyun.com/document_detail/95482.html).
        
        @param request: AddEditingProjectRequest
        @return: AddEditingProjectResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_editing_project_with_options_async(request, runtime)

    def add_editing_project_materials_with_options(
        self,
        request: vod_20170321_models.AddEditingProjectMaterialsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddEditingProjectMaterialsResponse:
        """
        @summary Adds one or more materials to an editing project.
        
        @param request: AddEditingProjectMaterialsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddEditingProjectMaterialsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.material_ids):
            query['MaterialIds'] = request.material_ids
        if not UtilClient.is_unset(request.material_type):
            query['MaterialType'] = request.material_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddEditingProjectMaterials',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddEditingProjectMaterialsResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_editing_project_materials_with_options_async(
        self,
        request: vod_20170321_models.AddEditingProjectMaterialsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddEditingProjectMaterialsResponse:
        """
        @summary Adds one or more materials to an editing project.
        
        @param request: AddEditingProjectMaterialsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddEditingProjectMaterialsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.material_ids):
            query['MaterialIds'] = request.material_ids
        if not UtilClient.is_unset(request.material_type):
            query['MaterialType'] = request.material_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddEditingProjectMaterials',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddEditingProjectMaterialsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_editing_project_materials(
        self,
        request: vod_20170321_models.AddEditingProjectMaterialsRequest,
    ) -> vod_20170321_models.AddEditingProjectMaterialsResponse:
        """
        @summary Adds one or more materials to an editing project.
        
        @param request: AddEditingProjectMaterialsRequest
        @return: AddEditingProjectMaterialsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_editing_project_materials_with_options(request, runtime)

    async def add_editing_project_materials_async(
        self,
        request: vod_20170321_models.AddEditingProjectMaterialsRequest,
    ) -> vod_20170321_models.AddEditingProjectMaterialsResponse:
        """
        @summary Adds one or more materials to an editing project.
        
        @param request: AddEditingProjectMaterialsRequest
        @return: AddEditingProjectMaterialsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_editing_project_materials_with_options_async(request, runtime)

    def add_filter_configs_with_options(
        self,
        request: vod_20170321_models.AddFilterConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddFilterConfigsResponse:
        """
        @summary 添加过滤条件
        
        @param request: AddFilterConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddFilterConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter_name):
            query['FilterName'] = request.filter_name
        if not UtilClient.is_unset(request.item_configs):
            query['ItemConfigs'] = request.item_configs
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddFilterConfigs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddFilterConfigsResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_filter_configs_with_options_async(
        self,
        request: vod_20170321_models.AddFilterConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddFilterConfigsResponse:
        """
        @summary 添加过滤条件
        
        @param request: AddFilterConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddFilterConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter_name):
            query['FilterName'] = request.filter_name
        if not UtilClient.is_unset(request.item_configs):
            query['ItemConfigs'] = request.item_configs
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddFilterConfigs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddFilterConfigsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_filter_configs(
        self,
        request: vod_20170321_models.AddFilterConfigsRequest,
    ) -> vod_20170321_models.AddFilterConfigsResponse:
        """
        @summary 添加过滤条件
        
        @param request: AddFilterConfigsRequest
        @return: AddFilterConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_filter_configs_with_options(request, runtime)

    async def add_filter_configs_async(
        self,
        request: vod_20170321_models.AddFilterConfigsRequest,
    ) -> vod_20170321_models.AddFilterConfigsResponse:
        """
        @summary 添加过滤条件
        
        @param request: AddFilterConfigsRequest
        @return: AddFilterConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_filter_configs_with_options_async(request, runtime)

    def add_free_license_with_options(
        self,
        request: vod_20170321_models.AddFreeLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddFreeLicenseResponse:
        """
        @summary 新增免费license
        
        @param request: AddFreeLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddFreeLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.app_platforms):
            query['AppPlatforms'] = request.app_platforms
        if not UtilClient.is_unset(request.sdk_models):
            query['SdkModels'] = request.sdk_models
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddFreeLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddFreeLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_free_license_with_options_async(
        self,
        request: vod_20170321_models.AddFreeLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddFreeLicenseResponse:
        """
        @summary 新增免费license
        
        @param request: AddFreeLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddFreeLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.app_platforms):
            query['AppPlatforms'] = request.app_platforms
        if not UtilClient.is_unset(request.sdk_models):
            query['SdkModels'] = request.sdk_models
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddFreeLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddFreeLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_free_license(
        self,
        request: vod_20170321_models.AddFreeLicenseRequest,
    ) -> vod_20170321_models.AddFreeLicenseResponse:
        """
        @summary 新增免费license
        
        @param request: AddFreeLicenseRequest
        @return: AddFreeLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_free_license_with_options(request, runtime)

    async def add_free_license_async(
        self,
        request: vod_20170321_models.AddFreeLicenseRequest,
    ) -> vod_20170321_models.AddFreeLicenseResponse:
        """
        @summary 新增免费license
        
        @param request: AddFreeLicenseRequest
        @return: AddFreeLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_free_license_with_options_async(request, runtime)

    def add_license_with_options(
        self,
        request: vod_20170321_models.AddLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddLicenseResponse:
        """
        @summary 新增license
        
        @param request: AddLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.app_platforms):
            query['AppPlatforms'] = request.app_platforms
        if not UtilClient.is_unset(request.contract_no):
            query['ContractNo'] = request.contract_no
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.sdk_models):
            query['SdkModels'] = request.sdk_models
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_license_with_options_async(
        self,
        request: vod_20170321_models.AddLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddLicenseResponse:
        """
        @summary 新增license
        
        @param request: AddLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.app_platforms):
            query['AppPlatforms'] = request.app_platforms
        if not UtilClient.is_unset(request.contract_no):
            query['ContractNo'] = request.contract_no
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.sdk_models):
            query['SdkModels'] = request.sdk_models
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_license(
        self,
        request: vod_20170321_models.AddLicenseRequest,
    ) -> vod_20170321_models.AddLicenseResponse:
        """
        @summary 新增license
        
        @param request: AddLicenseRequest
        @return: AddLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_license_with_options(request, runtime)

    async def add_license_async(
        self,
        request: vod_20170321_models.AddLicenseRequest,
    ) -> vod_20170321_models.AddLicenseResponse:
        """
        @summary 新增license
        
        @param request: AddLicenseRequest
        @return: AddLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_license_with_options_async(request, runtime)

    def add_media_sequences_with_options(
        self,
        request: vod_20170321_models.AddMediaSequencesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddMediaSequencesResponse:
        """
        @summary 添加媒资序列
        
        @param request: AddMediaSequencesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddMediaSequencesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.media_sequences):
            query['MediaSequences'] = request.media_sequences
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.media_url):
            query['MediaURL'] = request.media_url
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddMediaSequences',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddMediaSequencesResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_media_sequences_with_options_async(
        self,
        request: vod_20170321_models.AddMediaSequencesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddMediaSequencesResponse:
        """
        @summary 添加媒资序列
        
        @param request: AddMediaSequencesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddMediaSequencesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.media_sequences):
            query['MediaSequences'] = request.media_sequences
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.media_url):
            query['MediaURL'] = request.media_url
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddMediaSequences',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddMediaSequencesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_media_sequences(
        self,
        request: vod_20170321_models.AddMediaSequencesRequest,
    ) -> vod_20170321_models.AddMediaSequencesResponse:
        """
        @summary 添加媒资序列
        
        @param request: AddMediaSequencesRequest
        @return: AddMediaSequencesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_media_sequences_with_options(request, runtime)

    async def add_media_sequences_async(
        self,
        request: vod_20170321_models.AddMediaSequencesRequest,
    ) -> vod_20170321_models.AddMediaSequencesResponse:
        """
        @summary 添加媒资序列
        
        @param request: AddMediaSequencesRequest
        @return: AddMediaSequencesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_media_sequences_with_options_async(request, runtime)

    def add_storage_with_options(
        self,
        request: vod_20170321_models.AddStorageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddStorageResponse:
        """
        @summary 新增存储
        
        @param request: AddStorageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddStorageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.storage_redundancy_type):
            query['StorageRedundancyType'] = request.storage_redundancy_type
        if not UtilClient.is_unset(request.storage_region):
            query['StorageRegion'] = request.storage_region
        if not UtilClient.is_unset(request.storage_type):
            query['StorageType'] = request.storage_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddStorage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddStorageResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_storage_with_options_async(
        self,
        request: vod_20170321_models.AddStorageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddStorageResponse:
        """
        @summary 新增存储
        
        @param request: AddStorageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddStorageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.storage_redundancy_type):
            query['StorageRedundancyType'] = request.storage_redundancy_type
        if not UtilClient.is_unset(request.storage_region):
            query['StorageRegion'] = request.storage_region
        if not UtilClient.is_unset(request.storage_type):
            query['StorageType'] = request.storage_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddStorage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddStorageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_storage(
        self,
        request: vod_20170321_models.AddStorageRequest,
    ) -> vod_20170321_models.AddStorageResponse:
        """
        @summary 新增存储
        
        @param request: AddStorageRequest
        @return: AddStorageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_storage_with_options(request, runtime)

    async def add_storage_async(
        self,
        request: vod_20170321_models.AddStorageRequest,
    ) -> vod_20170321_models.AddStorageResponse:
        """
        @summary 新增存储
        
        @param request: AddStorageRequest
        @return: AddStorageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_storage_with_options_async(request, runtime)

    def add_transcode_template_group_with_options(
        self,
        request: vod_20170321_models.AddTranscodeTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddTranscodeTemplateGroupResponse:
        """
        @summary Creates a transcoding template group or adds transcoding templates to a transcoding template group.
        
        @description    You cannot perform custom operations on transcoding template groups that are **locked** in the ApsaraVideo VOD console. You can call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation to query the information about a transcoding template group and check whether the transcoding template group is locked based on the value of the Locked parameter. You can call the [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to unlock a transcoding template group if it is locked. Then, you can perform custom operations on the transcoding template group.
        An Object Storage Service (OSS) bucket is required to store files that are used for transcoding. You cannot create a transcoding template group if no bucket is available. To activate a bucket, perform the following operations: Log on to the ApsaraVideo VOD console. In the left-side navigation pane, choose **Configuration Management > Media Management > Storage**. On the **Storage** page, activate the bucket that is allocated by ApsaraVideo VOD.
        You cannot add transcoding templates to the **No Transcoding** template group.
        You can create a maximum of 20 transcoding template groups.
        You can add a maximum of 20 transcoding templates to a transcoding template group.
        If you want to generate a URL for adaptive bitrate streaming, you can add video packaging templates to a transcoding template group. You can add a maximum of 10 video packaging templates to a transcoding template group. If you add more than 10 video packaging templates, URLs of the video transcoded based on the video packaging templates are generated but the URL for adaptive bitrate streaming is not generated.
        ### QPS limits
        You can call this operation up to five times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: AddTranscodeTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddTranscodeTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.transcode_template_group_id):
            query['TranscodeTemplateGroupId'] = request.transcode_template_group_id
        if not UtilClient.is_unset(request.transcode_template_list):
            query['TranscodeTemplateList'] = request.transcode_template_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddTranscodeTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddTranscodeTemplateGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_transcode_template_group_with_options_async(
        self,
        request: vod_20170321_models.AddTranscodeTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddTranscodeTemplateGroupResponse:
        """
        @summary Creates a transcoding template group or adds transcoding templates to a transcoding template group.
        
        @description    You cannot perform custom operations on transcoding template groups that are **locked** in the ApsaraVideo VOD console. You can call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation to query the information about a transcoding template group and check whether the transcoding template group is locked based on the value of the Locked parameter. You can call the [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to unlock a transcoding template group if it is locked. Then, you can perform custom operations on the transcoding template group.
        An Object Storage Service (OSS) bucket is required to store files that are used for transcoding. You cannot create a transcoding template group if no bucket is available. To activate a bucket, perform the following operations: Log on to the ApsaraVideo VOD console. In the left-side navigation pane, choose **Configuration Management > Media Management > Storage**. On the **Storage** page, activate the bucket that is allocated by ApsaraVideo VOD.
        You cannot add transcoding templates to the **No Transcoding** template group.
        You can create a maximum of 20 transcoding template groups.
        You can add a maximum of 20 transcoding templates to a transcoding template group.
        If you want to generate a URL for adaptive bitrate streaming, you can add video packaging templates to a transcoding template group. You can add a maximum of 10 video packaging templates to a transcoding template group. If you add more than 10 video packaging templates, URLs of the video transcoded based on the video packaging templates are generated but the URL for adaptive bitrate streaming is not generated.
        ### QPS limits
        You can call this operation up to five times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: AddTranscodeTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddTranscodeTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.transcode_template_group_id):
            query['TranscodeTemplateGroupId'] = request.transcode_template_group_id
        if not UtilClient.is_unset(request.transcode_template_list):
            query['TranscodeTemplateList'] = request.transcode_template_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddTranscodeTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddTranscodeTemplateGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_transcode_template_group(
        self,
        request: vod_20170321_models.AddTranscodeTemplateGroupRequest,
    ) -> vod_20170321_models.AddTranscodeTemplateGroupResponse:
        """
        @summary Creates a transcoding template group or adds transcoding templates to a transcoding template group.
        
        @description    You cannot perform custom operations on transcoding template groups that are **locked** in the ApsaraVideo VOD console. You can call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation to query the information about a transcoding template group and check whether the transcoding template group is locked based on the value of the Locked parameter. You can call the [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to unlock a transcoding template group if it is locked. Then, you can perform custom operations on the transcoding template group.
        An Object Storage Service (OSS) bucket is required to store files that are used for transcoding. You cannot create a transcoding template group if no bucket is available. To activate a bucket, perform the following operations: Log on to the ApsaraVideo VOD console. In the left-side navigation pane, choose **Configuration Management > Media Management > Storage**. On the **Storage** page, activate the bucket that is allocated by ApsaraVideo VOD.
        You cannot add transcoding templates to the **No Transcoding** template group.
        You can create a maximum of 20 transcoding template groups.
        You can add a maximum of 20 transcoding templates to a transcoding template group.
        If you want to generate a URL for adaptive bitrate streaming, you can add video packaging templates to a transcoding template group. You can add a maximum of 10 video packaging templates to a transcoding template group. If you add more than 10 video packaging templates, URLs of the video transcoded based on the video packaging templates are generated but the URL for adaptive bitrate streaming is not generated.
        ### QPS limits
        You can call this operation up to five times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: AddTranscodeTemplateGroupRequest
        @return: AddTranscodeTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_transcode_template_group_with_options(request, runtime)

    async def add_transcode_template_group_async(
        self,
        request: vod_20170321_models.AddTranscodeTemplateGroupRequest,
    ) -> vod_20170321_models.AddTranscodeTemplateGroupResponse:
        """
        @summary Creates a transcoding template group or adds transcoding templates to a transcoding template group.
        
        @description    You cannot perform custom operations on transcoding template groups that are **locked** in the ApsaraVideo VOD console. You can call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation to query the information about a transcoding template group and check whether the transcoding template group is locked based on the value of the Locked parameter. You can call the [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to unlock a transcoding template group if it is locked. Then, you can perform custom operations on the transcoding template group.
        An Object Storage Service (OSS) bucket is required to store files that are used for transcoding. You cannot create a transcoding template group if no bucket is available. To activate a bucket, perform the following operations: Log on to the ApsaraVideo VOD console. In the left-side navigation pane, choose **Configuration Management > Media Management > Storage**. On the **Storage** page, activate the bucket that is allocated by ApsaraVideo VOD.
        You cannot add transcoding templates to the **No Transcoding** template group.
        You can create a maximum of 20 transcoding template groups.
        You can add a maximum of 20 transcoding templates to a transcoding template group.
        If you want to generate a URL for adaptive bitrate streaming, you can add video packaging templates to a transcoding template group. You can add a maximum of 10 video packaging templates to a transcoding template group. If you add more than 10 video packaging templates, URLs of the video transcoded based on the video packaging templates are generated but the URL for adaptive bitrate streaming is not generated.
        ### QPS limits
        You can call this operation up to five times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: AddTranscodeTemplateGroupRequest
        @return: AddTranscodeTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_transcode_template_group_with_options_async(request, runtime)

    def add_vod_domain_with_options(
        self,
        request: vod_20170321_models.AddVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddVodDomainResponse:
        """
        @summary Adds a domain name to accelerate in ApsaraVideo VOD.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        Before you add a domain name to accelerate, you must activate ApsaraVideo VOD and apply for an Internet content provider (ICP) filing for the domain name. For more information about how to activate ApsaraVideo VOD, see [Activate ApsaraVideo VOD](https://help.aliyun.com/document_detail/51512.html).
        If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed by Alibaba Cloud. The review will be complete by the end of the next business day after you submit an application.
        You can add only one domain name to accelerate in a request. You can add a maximum of 20 accelerated domain names within an Alibaba Cloud account.
        
        @param request: AddVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.check_url):
            query['CheckUrl'] = request.check_url
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.sources):
            query['Sources'] = request.sources
        if not UtilClient.is_unset(request.top_level_domain):
            query['TopLevelDomain'] = request.top_level_domain
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddVodDomainResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_vod_domain_with_options_async(
        self,
        request: vod_20170321_models.AddVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddVodDomainResponse:
        """
        @summary Adds a domain name to accelerate in ApsaraVideo VOD.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        Before you add a domain name to accelerate, you must activate ApsaraVideo VOD and apply for an Internet content provider (ICP) filing for the domain name. For more information about how to activate ApsaraVideo VOD, see [Activate ApsaraVideo VOD](https://help.aliyun.com/document_detail/51512.html).
        If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed by Alibaba Cloud. The review will be complete by the end of the next business day after you submit an application.
        You can add only one domain name to accelerate in a request. You can add a maximum of 20 accelerated domain names within an Alibaba Cloud account.
        
        @param request: AddVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.check_url):
            query['CheckUrl'] = request.check_url
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.sources):
            query['Sources'] = request.sources
        if not UtilClient.is_unset(request.top_level_domain):
            query['TopLevelDomain'] = request.top_level_domain
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddVodDomainResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_vod_domain(
        self,
        request: vod_20170321_models.AddVodDomainRequest,
    ) -> vod_20170321_models.AddVodDomainResponse:
        """
        @summary Adds a domain name to accelerate in ApsaraVideo VOD.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        Before you add a domain name to accelerate, you must activate ApsaraVideo VOD and apply for an Internet content provider (ICP) filing for the domain name. For more information about how to activate ApsaraVideo VOD, see [Activate ApsaraVideo VOD](https://help.aliyun.com/document_detail/51512.html).
        If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed by Alibaba Cloud. The review will be complete by the end of the next business day after you submit an application.
        You can add only one domain name to accelerate in a request. You can add a maximum of 20 accelerated domain names within an Alibaba Cloud account.
        
        @param request: AddVodDomainRequest
        @return: AddVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_vod_domain_with_options(request, runtime)

    async def add_vod_domain_async(
        self,
        request: vod_20170321_models.AddVodDomainRequest,
    ) -> vod_20170321_models.AddVodDomainResponse:
        """
        @summary Adds a domain name to accelerate in ApsaraVideo VOD.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        Before you add a domain name to accelerate, you must activate ApsaraVideo VOD and apply for an Internet content provider (ICP) filing for the domain name. For more information about how to activate ApsaraVideo VOD, see [Activate ApsaraVideo VOD](https://help.aliyun.com/document_detail/51512.html).
        If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed by Alibaba Cloud. The review will be complete by the end of the next business day after you submit an application.
        You can add only one domain name to accelerate in a request. You can add a maximum of 20 accelerated domain names within an Alibaba Cloud account.
        
        @param request: AddVodDomainRequest
        @return: AddVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_vod_domain_with_options_async(request, runtime)

    def add_vod_storage_for_app_with_options(
        self,
        request: vod_20170321_models.AddVodStorageForAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddVodStorageForAppResponse:
        """
        @summary Binds a storage bucket to one or more applications in ApsaraVideo VOD.
        
        @description You can call this operation to add a buckets to an ApsaraVideo VOD applications.
        > You can add only one ApsaraVideo VOD bucket for each application. If you specify an AppId that does not exist or the ID of an application for which an VOD bucket is enabled, an error is returned.
        
        @param request: AddVodStorageForAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddVodStorageForAppResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.storage_type):
            query['StorageType'] = request.storage_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddVodStorageForApp',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddVodStorageForAppResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_vod_storage_for_app_with_options_async(
        self,
        request: vod_20170321_models.AddVodStorageForAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddVodStorageForAppResponse:
        """
        @summary Binds a storage bucket to one or more applications in ApsaraVideo VOD.
        
        @description You can call this operation to add a buckets to an ApsaraVideo VOD applications.
        > You can add only one ApsaraVideo VOD bucket for each application. If you specify an AppId that does not exist or the ID of an application for which an VOD bucket is enabled, an error is returned.
        
        @param request: AddVodStorageForAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddVodStorageForAppResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.storage_type):
            query['StorageType'] = request.storage_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddVodStorageForApp',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddVodStorageForAppResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_vod_storage_for_app(
        self,
        request: vod_20170321_models.AddVodStorageForAppRequest,
    ) -> vod_20170321_models.AddVodStorageForAppResponse:
        """
        @summary Binds a storage bucket to one or more applications in ApsaraVideo VOD.
        
        @description You can call this operation to add a buckets to an ApsaraVideo VOD applications.
        > You can add only one ApsaraVideo VOD bucket for each application. If you specify an AppId that does not exist or the ID of an application for which an VOD bucket is enabled, an error is returned.
        
        @param request: AddVodStorageForAppRequest
        @return: AddVodStorageForAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_vod_storage_for_app_with_options(request, runtime)

    async def add_vod_storage_for_app_async(
        self,
        request: vod_20170321_models.AddVodStorageForAppRequest,
    ) -> vod_20170321_models.AddVodStorageForAppResponse:
        """
        @summary Binds a storage bucket to one or more applications in ApsaraVideo VOD.
        
        @description You can call this operation to add a buckets to an ApsaraVideo VOD applications.
        > You can add only one ApsaraVideo VOD bucket for each application. If you specify an AppId that does not exist or the ID of an application for which an VOD bucket is enabled, an error is returned.
        
        @param request: AddVodStorageForAppRequest
        @return: AddVodStorageForAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_vod_storage_for_app_with_options_async(request, runtime)

    def add_vod_template_with_options(
        self,
        request: vod_20170321_models.AddVodTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddVodTemplateResponse:
        """
        @summary Adds a snapshot template or frame animation template.
        
        @description    After you add a snapshot template, you can call the [SubmitSnapshotJob](https://help.aliyun.com/document_detail/72213.html) operation and specify the template ID to submit a snapshot job.
        You can use the HTTP (HTTPS compatible) callback or MNS callback method to receive the [SnapshotComplete](https://help.aliyun.com/document_detail/57337.html) callback. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: AddVodTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddVodTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.template_config):
            query['TemplateConfig'] = request.template_config
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddVodTemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddVodTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_vod_template_with_options_async(
        self,
        request: vod_20170321_models.AddVodTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddVodTemplateResponse:
        """
        @summary Adds a snapshot template or frame animation template.
        
        @description    After you add a snapshot template, you can call the [SubmitSnapshotJob](https://help.aliyun.com/document_detail/72213.html) operation and specify the template ID to submit a snapshot job.
        You can use the HTTP (HTTPS compatible) callback or MNS callback method to receive the [SnapshotComplete](https://help.aliyun.com/document_detail/57337.html) callback. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: AddVodTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddVodTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.template_config):
            query['TemplateConfig'] = request.template_config
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddVodTemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddVodTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_vod_template(
        self,
        request: vod_20170321_models.AddVodTemplateRequest,
    ) -> vod_20170321_models.AddVodTemplateResponse:
        """
        @summary Adds a snapshot template or frame animation template.
        
        @description    After you add a snapshot template, you can call the [SubmitSnapshotJob](https://help.aliyun.com/document_detail/72213.html) operation and specify the template ID to submit a snapshot job.
        You can use the HTTP (HTTPS compatible) callback or MNS callback method to receive the [SnapshotComplete](https://help.aliyun.com/document_detail/57337.html) callback. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: AddVodTemplateRequest
        @return: AddVodTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_vod_template_with_options(request, runtime)

    async def add_vod_template_async(
        self,
        request: vod_20170321_models.AddVodTemplateRequest,
    ) -> vod_20170321_models.AddVodTemplateResponse:
        """
        @summary Adds a snapshot template or frame animation template.
        
        @description    After you add a snapshot template, you can call the [SubmitSnapshotJob](https://help.aliyun.com/document_detail/72213.html) operation and specify the template ID to submit a snapshot job.
        You can use the HTTP (HTTPS compatible) callback or MNS callback method to receive the [SnapshotComplete](https://help.aliyun.com/document_detail/57337.html) callback. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: AddVodTemplateRequest
        @return: AddVodTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_vod_template_with_options_async(request, runtime)

    def add_watermark_with_options(
        self,
        request: vod_20170321_models.AddWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddWatermarkResponse:
        """
        @summary Creates an image or text watermark. ApsaraVideo VOD allows you to create watermark templates to reuse your parameter configurations such as watermark position, size, font, and color. Each watermark template is assigned a unique ID. This simplifies the progress of creating watermark tasks.
        
        @description    You can call this operation to create an `Image` watermark template or a `Text` watermark template. You can use static images in the PNG format or dynamic images in the GIF, APNG, and MOV formats as image watermarks.
        After you call this operation to create a watermark template, you must call the [AddTranscodeTemplateGroup](~~AddTranscodeTemplateGroup~~) or [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to associate the watermark template with a transcoding template group. This way, you can add watermarks to videos during transcoding.
        For more information, see [Video watermarks](https://help.aliyun.com/document_detail/99369.html).
        
        @param request: AddWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.file_url):
            query['FileUrl'] = request.file_url
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.watermark_config):
            query['WatermarkConfig'] = request.watermark_config
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddWatermark',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddWatermarkResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_watermark_with_options_async(
        self,
        request: vod_20170321_models.AddWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddWatermarkResponse:
        """
        @summary Creates an image or text watermark. ApsaraVideo VOD allows you to create watermark templates to reuse your parameter configurations such as watermark position, size, font, and color. Each watermark template is assigned a unique ID. This simplifies the progress of creating watermark tasks.
        
        @description    You can call this operation to create an `Image` watermark template or a `Text` watermark template. You can use static images in the PNG format or dynamic images in the GIF, APNG, and MOV formats as image watermarks.
        After you call this operation to create a watermark template, you must call the [AddTranscodeTemplateGroup](~~AddTranscodeTemplateGroup~~) or [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to associate the watermark template with a transcoding template group. This way, you can add watermarks to videos during transcoding.
        For more information, see [Video watermarks](https://help.aliyun.com/document_detail/99369.html).
        
        @param request: AddWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.file_url):
            query['FileUrl'] = request.file_url
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.watermark_config):
            query['WatermarkConfig'] = request.watermark_config
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddWatermark',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddWatermarkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_watermark(
        self,
        request: vod_20170321_models.AddWatermarkRequest,
    ) -> vod_20170321_models.AddWatermarkResponse:
        """
        @summary Creates an image or text watermark. ApsaraVideo VOD allows you to create watermark templates to reuse your parameter configurations such as watermark position, size, font, and color. Each watermark template is assigned a unique ID. This simplifies the progress of creating watermark tasks.
        
        @description    You can call this operation to create an `Image` watermark template or a `Text` watermark template. You can use static images in the PNG format or dynamic images in the GIF, APNG, and MOV formats as image watermarks.
        After you call this operation to create a watermark template, you must call the [AddTranscodeTemplateGroup](~~AddTranscodeTemplateGroup~~) or [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to associate the watermark template with a transcoding template group. This way, you can add watermarks to videos during transcoding.
        For more information, see [Video watermarks](https://help.aliyun.com/document_detail/99369.html).
        
        @param request: AddWatermarkRequest
        @return: AddWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_watermark_with_options(request, runtime)

    async def add_watermark_async(
        self,
        request: vod_20170321_models.AddWatermarkRequest,
    ) -> vod_20170321_models.AddWatermarkResponse:
        """
        @summary Creates an image or text watermark. ApsaraVideo VOD allows you to create watermark templates to reuse your parameter configurations such as watermark position, size, font, and color. Each watermark template is assigned a unique ID. This simplifies the progress of creating watermark tasks.
        
        @description    You can call this operation to create an `Image` watermark template or a `Text` watermark template. You can use static images in the PNG format or dynamic images in the GIF, APNG, and MOV formats as image watermarks.
        After you call this operation to create a watermark template, you must call the [AddTranscodeTemplateGroup](~~AddTranscodeTemplateGroup~~) or [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to associate the watermark template with a transcoding template group. This way, you can add watermarks to videos during transcoding.
        For more information, see [Video watermarks](https://help.aliyun.com/document_detail/99369.html).
        
        @param request: AddWatermarkRequest
        @return: AddWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_watermark_with_options_async(request, runtime)

    def add_watermark_console_with_options(
        self,
        request: vod_20170321_models.AddWatermarkConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddWatermarkConsoleResponse:
        """
        @summary 添加水印
        
        @param request: AddWatermarkConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddWatermarkConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.active):
            query['Active'] = request.active
        if not UtilClient.is_unset(request.bucket):
            query['Bucket'] = request.bucket
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.horizontal_offet):
            query['HorizontalOffet'] = request.horizontal_offet
        if not UtilClient.is_unset(request.horizontal_offset):
            query['HorizontalOffset'] = request.horizontal_offset
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.object):
            query['Object'] = request.object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.position):
            query['Position'] = request.position
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.screen_mode):
            query['ScreenMode'] = request.screen_mode
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.vertical_offset):
            query['VerticalOffset'] = request.vertical_offset
        if not UtilClient.is_unset(request.video_height):
            query['VideoHeight'] = request.video_height
        if not UtilClient.is_unset(request.video_width):
            query['VideoWidth'] = request.video_width
        if not UtilClient.is_unset(request.watermark_config):
            query['WatermarkConfig'] = request.watermark_config
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddWatermarkConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddWatermarkConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_watermark_console_with_options_async(
        self,
        request: vod_20170321_models.AddWatermarkConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddWatermarkConsoleResponse:
        """
        @summary 添加水印
        
        @param request: AddWatermarkConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddWatermarkConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.active):
            query['Active'] = request.active
        if not UtilClient.is_unset(request.bucket):
            query['Bucket'] = request.bucket
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.horizontal_offet):
            query['HorizontalOffet'] = request.horizontal_offet
        if not UtilClient.is_unset(request.horizontal_offset):
            query['HorizontalOffset'] = request.horizontal_offset
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.object):
            query['Object'] = request.object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.position):
            query['Position'] = request.position
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.screen_mode):
            query['ScreenMode'] = request.screen_mode
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.vertical_offset):
            query['VerticalOffset'] = request.vertical_offset
        if not UtilClient.is_unset(request.video_height):
            query['VideoHeight'] = request.video_height
        if not UtilClient.is_unset(request.video_width):
            query['VideoWidth'] = request.video_width
        if not UtilClient.is_unset(request.watermark_config):
            query['WatermarkConfig'] = request.watermark_config
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddWatermarkConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddWatermarkConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_watermark_console(
        self,
        request: vod_20170321_models.AddWatermarkConsoleRequest,
    ) -> vod_20170321_models.AddWatermarkConsoleResponse:
        """
        @summary 添加水印
        
        @param request: AddWatermarkConsoleRequest
        @return: AddWatermarkConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_watermark_console_with_options(request, runtime)

    async def add_watermark_console_async(
        self,
        request: vod_20170321_models.AddWatermarkConsoleRequest,
    ) -> vod_20170321_models.AddWatermarkConsoleResponse:
        """
        @summary 添加水印
        
        @param request: AddWatermarkConsoleRequest
        @return: AddWatermarkConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_watermark_console_with_options_async(request, runtime)

    def add_workflow_with_options(
        self,
        request: vod_20170321_models.AddWorkflowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddWorkflowResponse:
        """
        @summary 添加工作流
        
        @param request: AddWorkflowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddWorkflowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_list):
            query['ActionList'] = request.action_list
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.biz_version):
            query['BizVersion'] = request.biz_version
        if not UtilClient.is_unset(request.callback_config):
            query['CallbackConfig'] = request.callback_config
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddWorkflow',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddWorkflowResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_workflow_with_options_async(
        self,
        request: vod_20170321_models.AddWorkflowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AddWorkflowResponse:
        """
        @summary 添加工作流
        
        @param request: AddWorkflowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddWorkflowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_list):
            query['ActionList'] = request.action_list
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.biz_version):
            query['BizVersion'] = request.biz_version
        if not UtilClient.is_unset(request.callback_config):
            query['CallbackConfig'] = request.callback_config
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddWorkflow',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AddWorkflowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_workflow(
        self,
        request: vod_20170321_models.AddWorkflowRequest,
    ) -> vod_20170321_models.AddWorkflowResponse:
        """
        @summary 添加工作流
        
        @param request: AddWorkflowRequest
        @return: AddWorkflowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_workflow_with_options(request, runtime)

    async def add_workflow_async(
        self,
        request: vod_20170321_models.AddWorkflowRequest,
    ) -> vod_20170321_models.AddWorkflowResponse:
        """
        @summary 添加工作流
        
        @param request: AddWorkflowRequest
        @return: AddWorkflowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_workflow_with_options_async(request, runtime)

    def assign_product_account_id_with_options(
        self,
        request: vod_20170321_models.AssignProductAccountIdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AssignProductAccountIdResponse:
        """
        @summary 为用户绑定点播生产账号ID
        
        @param request: AssignProductAccountIdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssignProductAccountIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_region):
            query['StorageRegion'] = request.storage_region
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssignProductAccountId',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AssignProductAccountIdResponse(),
            self.call_api(params, req, runtime)
        )

    async def assign_product_account_id_with_options_async(
        self,
        request: vod_20170321_models.AssignProductAccountIdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AssignProductAccountIdResponse:
        """
        @summary 为用户绑定点播生产账号ID
        
        @param request: AssignProductAccountIdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssignProductAccountIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_region):
            query['StorageRegion'] = request.storage_region
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssignProductAccountId',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AssignProductAccountIdResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def assign_product_account_id(
        self,
        request: vod_20170321_models.AssignProductAccountIdRequest,
    ) -> vod_20170321_models.AssignProductAccountIdResponse:
        """
        @summary 为用户绑定点播生产账号ID
        
        @param request: AssignProductAccountIdRequest
        @return: AssignProductAccountIdResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.assign_product_account_id_with_options(request, runtime)

    async def assign_product_account_id_async(
        self,
        request: vod_20170321_models.AssignProductAccountIdRequest,
    ) -> vod_20170321_models.AssignProductAccountIdResponse:
        """
        @summary 为用户绑定点播生产账号ID
        
        @param request: AssignProductAccountIdRequest
        @return: AssignProductAccountIdResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.assign_product_account_id_with_options_async(request, runtime)

    def assume_experience_role_with_options(
        self,
        request: vod_20170321_models.AssumeExperienceRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AssumeExperienceRoleResponse:
        """
        @param request: AssumeExperienceRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssumeExperienceRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cookie):
            query['Cookie'] = request.cookie
        if not UtilClient.is_unset(request.data):
            query['Data'] = request.data
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssumeExperienceRole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AssumeExperienceRoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def assume_experience_role_with_options_async(
        self,
        request: vod_20170321_models.AssumeExperienceRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AssumeExperienceRoleResponse:
        """
        @param request: AssumeExperienceRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssumeExperienceRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cookie):
            query['Cookie'] = request.cookie
        if not UtilClient.is_unset(request.data):
            query['Data'] = request.data
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssumeExperienceRole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AssumeExperienceRoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def assume_experience_role(
        self,
        request: vod_20170321_models.AssumeExperienceRoleRequest,
    ) -> vod_20170321_models.AssumeExperienceRoleResponse:
        """
        @param request: AssumeExperienceRoleRequest
        @return: AssumeExperienceRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.assume_experience_role_with_options(request, runtime)

    async def assume_experience_role_async(
        self,
        request: vod_20170321_models.AssumeExperienceRoleRequest,
    ) -> vod_20170321_models.AssumeExperienceRoleResponse:
        """
        @param request: AssumeExperienceRoleRequest
        @return: AssumeExperienceRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.assume_experience_role_with_options_async(request, runtime)

    def assume_oss_role_with_options(
        self,
        request: vod_20170321_models.AssumeOssRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AssumeOssRoleResponse:
        """
        @param request: AssumeOssRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssumeOssRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_version):
            query['AppVersion'] = request.app_version
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.auth_timestamp):
            query['AuthTimestamp'] = request.auth_timestamp
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.client_id):
            query['ClientId'] = request.client_id
        if not UtilClient.is_unset(request.device_model):
            query['DeviceModel'] = request.device_model
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix):
            query['Prefix'] = request.prefix
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.source):
            query['Source'] = request.source
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssumeOssRole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AssumeOssRoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def assume_oss_role_with_options_async(
        self,
        request: vod_20170321_models.AssumeOssRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AssumeOssRoleResponse:
        """
        @param request: AssumeOssRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssumeOssRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_version):
            query['AppVersion'] = request.app_version
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.auth_timestamp):
            query['AuthTimestamp'] = request.auth_timestamp
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.client_id):
            query['ClientId'] = request.client_id
        if not UtilClient.is_unset(request.device_model):
            query['DeviceModel'] = request.device_model
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix):
            query['Prefix'] = request.prefix
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.source):
            query['Source'] = request.source
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssumeOssRole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AssumeOssRoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def assume_oss_role(
        self,
        request: vod_20170321_models.AssumeOssRoleRequest,
    ) -> vod_20170321_models.AssumeOssRoleResponse:
        """
        @param request: AssumeOssRoleRequest
        @return: AssumeOssRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.assume_oss_role_with_options(request, runtime)

    async def assume_oss_role_async(
        self,
        request: vod_20170321_models.AssumeOssRoleRequest,
    ) -> vod_20170321_models.AssumeOssRoleResponse:
        """
        @param request: AssumeOssRoleRequest
        @return: AssumeOssRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.assume_oss_role_with_options_async(request, runtime)

    def assume_sls_role_with_options(
        self,
        request: vod_20170321_models.AssumeSlsRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AssumeSlsRoleResponse:
        """
        @param request: AssumeSlsRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssumeSlsRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_version):
            query['AppVersion'] = request.app_version
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.auth_timestamp):
            query['AuthTimestamp'] = request.auth_timestamp
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.client_id):
            query['ClientId'] = request.client_id
        if not UtilClient.is_unset(request.device_model):
            query['DeviceModel'] = request.device_model
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssumeSlsRole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AssumeSlsRoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def assume_sls_role_with_options_async(
        self,
        request: vod_20170321_models.AssumeSlsRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AssumeSlsRoleResponse:
        """
        @param request: AssumeSlsRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssumeSlsRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_version):
            query['AppVersion'] = request.app_version
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.auth_timestamp):
            query['AuthTimestamp'] = request.auth_timestamp
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.client_id):
            query['ClientId'] = request.client_id
        if not UtilClient.is_unset(request.device_model):
            query['DeviceModel'] = request.device_model
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssumeSlsRole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AssumeSlsRoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def assume_sls_role(
        self,
        request: vod_20170321_models.AssumeSlsRoleRequest,
    ) -> vod_20170321_models.AssumeSlsRoleResponse:
        """
        @param request: AssumeSlsRoleRequest
        @return: AssumeSlsRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.assume_sls_role_with_options(request, runtime)

    async def assume_sls_role_async(
        self,
        request: vod_20170321_models.AssumeSlsRoleRequest,
    ) -> vod_20170321_models.AssumeSlsRoleResponse:
        """
        @param request: AssumeSlsRoleRequest
        @return: AssumeSlsRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.assume_sls_role_with_options_async(request, runtime)

    def assume_sls_role_v2with_options(
        self,
        request: vod_20170321_models.AssumeSlsRoleV2Request,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AssumeSlsRoleV2Response:
        """
        @param request: AssumeSlsRoleV2Request
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssumeSlsRoleV2Response
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_version):
            query['AppVersion'] = request.app_version
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.auth_timestamp):
            query['AuthTimestamp'] = request.auth_timestamp
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.client_id):
            query['ClientId'] = request.client_id
        if not UtilClient.is_unset(request.device_model):
            query['DeviceModel'] = request.device_model
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssumeSlsRoleV2',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AssumeSlsRoleV2Response(),
            self.call_api(params, req, runtime)
        )

    async def assume_sls_role_v2with_options_async(
        self,
        request: vod_20170321_models.AssumeSlsRoleV2Request,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AssumeSlsRoleV2Response:
        """
        @param request: AssumeSlsRoleV2Request
        @param runtime: runtime options for this request RuntimeOptions
        @return: AssumeSlsRoleV2Response
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_version):
            query['AppVersion'] = request.app_version
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.auth_timestamp):
            query['AuthTimestamp'] = request.auth_timestamp
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.client_id):
            query['ClientId'] = request.client_id
        if not UtilClient.is_unset(request.device_model):
            query['DeviceModel'] = request.device_model
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AssumeSlsRoleV2',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AssumeSlsRoleV2Response(),
            await self.call_api_async(params, req, runtime)
        )

    def assume_sls_role_v2(
        self,
        request: vod_20170321_models.AssumeSlsRoleV2Request,
    ) -> vod_20170321_models.AssumeSlsRoleV2Response:
        """
        @param request: AssumeSlsRoleV2Request
        @return: AssumeSlsRoleV2Response
        """
        runtime = util_models.RuntimeOptions()
        return self.assume_sls_role_v2with_options(request, runtime)

    async def assume_sls_role_v2_async(
        self,
        request: vod_20170321_models.AssumeSlsRoleV2Request,
    ) -> vod_20170321_models.AssumeSlsRoleV2Response:
        """
        @param request: AssumeSlsRoleV2Request
        @return: AssumeSlsRoleV2Response
        """
        runtime = util_models.RuntimeOptions()
        return await self.assume_sls_role_v2with_options_async(request, runtime)

    def attach_app_policy_to_identity_with_options(
        self,
        request: vod_20170321_models.AttachAppPolicyToIdentityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AttachAppPolicyToIdentityResponse:
        """
        @summary Grants a RAM user or RAM role permissions to access ApsaraVideo VOD applications.
        
        @description > You can grant a RAM user or RAM role permissions to access up to 10 applications.
        
        @param request: AttachAppPolicyToIdentityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachAppPolicyToIdentityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.identity_name):
            query['IdentityName'] = request.identity_name
        if not UtilClient.is_unset(request.identity_type):
            query['IdentityType'] = request.identity_type
        if not UtilClient.is_unset(request.policy_names):
            query['PolicyNames'] = request.policy_names
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachAppPolicyToIdentity',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AttachAppPolicyToIdentityResponse(),
            self.call_api(params, req, runtime)
        )

    async def attach_app_policy_to_identity_with_options_async(
        self,
        request: vod_20170321_models.AttachAppPolicyToIdentityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.AttachAppPolicyToIdentityResponse:
        """
        @summary Grants a RAM user or RAM role permissions to access ApsaraVideo VOD applications.
        
        @description > You can grant a RAM user or RAM role permissions to access up to 10 applications.
        
        @param request: AttachAppPolicyToIdentityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AttachAppPolicyToIdentityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.identity_name):
            query['IdentityName'] = request.identity_name
        if not UtilClient.is_unset(request.identity_type):
            query['IdentityType'] = request.identity_type
        if not UtilClient.is_unset(request.policy_names):
            query['PolicyNames'] = request.policy_names
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AttachAppPolicyToIdentity',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.AttachAppPolicyToIdentityResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def attach_app_policy_to_identity(
        self,
        request: vod_20170321_models.AttachAppPolicyToIdentityRequest,
    ) -> vod_20170321_models.AttachAppPolicyToIdentityResponse:
        """
        @summary Grants a RAM user or RAM role permissions to access ApsaraVideo VOD applications.
        
        @description > You can grant a RAM user or RAM role permissions to access up to 10 applications.
        
        @param request: AttachAppPolicyToIdentityRequest
        @return: AttachAppPolicyToIdentityResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.attach_app_policy_to_identity_with_options(request, runtime)

    async def attach_app_policy_to_identity_async(
        self,
        request: vod_20170321_models.AttachAppPolicyToIdentityRequest,
    ) -> vod_20170321_models.AttachAppPolicyToIdentityResponse:
        """
        @summary Grants a RAM user or RAM role permissions to access ApsaraVideo VOD applications.
        
        @description > You can grant a RAM user or RAM role permissions to access up to 10 applications.
        
        @param request: AttachAppPolicyToIdentityRequest
        @return: AttachAppPolicyToIdentityResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.attach_app_policy_to_identity_with_options_async(request, runtime)

    def batch_get_media_infos_with_options(
        self,
        request: vod_20170321_models.BatchGetMediaInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.BatchGetMediaInfosResponse:
        """
        @summary Obtains the basic information and source file information of multiple media assets.
        
        @description    You can specify up to 20 audio or video file IDs in each request.
        After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: BatchGetMediaInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchGetMediaInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchGetMediaInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.BatchGetMediaInfosResponse(),
            self.call_api(params, req, runtime)
        )

    async def batch_get_media_infos_with_options_async(
        self,
        request: vod_20170321_models.BatchGetMediaInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.BatchGetMediaInfosResponse:
        """
        @summary Obtains the basic information and source file information of multiple media assets.
        
        @description    You can specify up to 20 audio or video file IDs in each request.
        After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: BatchGetMediaInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchGetMediaInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchGetMediaInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.BatchGetMediaInfosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def batch_get_media_infos(
        self,
        request: vod_20170321_models.BatchGetMediaInfosRequest,
    ) -> vod_20170321_models.BatchGetMediaInfosResponse:
        """
        @summary Obtains the basic information and source file information of multiple media assets.
        
        @description    You can specify up to 20 audio or video file IDs in each request.
        After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: BatchGetMediaInfosRequest
        @return: BatchGetMediaInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.batch_get_media_infos_with_options(request, runtime)

    async def batch_get_media_infos_async(
        self,
        request: vod_20170321_models.BatchGetMediaInfosRequest,
    ) -> vod_20170321_models.BatchGetMediaInfosResponse:
        """
        @summary Obtains the basic information and source file information of multiple media assets.
        
        @description    You can specify up to 20 audio or video file IDs in each request.
        After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: BatchGetMediaInfosRequest
        @return: BatchGetMediaInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.batch_get_media_infos_with_options_async(request, runtime)

    def batch_set_vod_domain_configs_with_options(
        self,
        request: vod_20170321_models.BatchSetVodDomainConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.BatchSetVodDomainConfigsResponse:
        """
        @summary Configures one or more domain names for CDN.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: BatchSetVodDomainConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchSetVodDomainConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_names):
            query['DomainNames'] = request.domain_names
        if not UtilClient.is_unset(request.functions):
            query['Functions'] = request.functions
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchSetVodDomainConfigs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.BatchSetVodDomainConfigsResponse(),
            self.call_api(params, req, runtime)
        )

    async def batch_set_vod_domain_configs_with_options_async(
        self,
        request: vod_20170321_models.BatchSetVodDomainConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.BatchSetVodDomainConfigsResponse:
        """
        @summary Configures one or more domain names for CDN.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: BatchSetVodDomainConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchSetVodDomainConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_names):
            query['DomainNames'] = request.domain_names
        if not UtilClient.is_unset(request.functions):
            query['Functions'] = request.functions
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchSetVodDomainConfigs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.BatchSetVodDomainConfigsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def batch_set_vod_domain_configs(
        self,
        request: vod_20170321_models.BatchSetVodDomainConfigsRequest,
    ) -> vod_20170321_models.BatchSetVodDomainConfigsResponse:
        """
        @summary Configures one or more domain names for CDN.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: BatchSetVodDomainConfigsRequest
        @return: BatchSetVodDomainConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.batch_set_vod_domain_configs_with_options(request, runtime)

    async def batch_set_vod_domain_configs_async(
        self,
        request: vod_20170321_models.BatchSetVodDomainConfigsRequest,
    ) -> vod_20170321_models.BatchSetVodDomainConfigsResponse:
        """
        @summary Configures one or more domain names for CDN.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: BatchSetVodDomainConfigsRequest
        @return: BatchSetVodDomainConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.batch_set_vod_domain_configs_with_options_async(request, runtime)

    def batch_start_vod_domain_with_options(
        self,
        request: vod_20170321_models.BatchStartVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.BatchStartVodDomainResponse:
        """
        @summary Enables accelerated domain names that are in the disabled state.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If the domain name that you want to enable is invalid or your Alibaba Cloud account has overdue payments, you cannot call this operation to enable the domain name.
        
        @param request: BatchStartVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchStartVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_names):
            query['DomainNames'] = request.domain_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchStartVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.BatchStartVodDomainResponse(),
            self.call_api(params, req, runtime)
        )

    async def batch_start_vod_domain_with_options_async(
        self,
        request: vod_20170321_models.BatchStartVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.BatchStartVodDomainResponse:
        """
        @summary Enables accelerated domain names that are in the disabled state.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If the domain name that you want to enable is invalid or your Alibaba Cloud account has overdue payments, you cannot call this operation to enable the domain name.
        
        @param request: BatchStartVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchStartVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_names):
            query['DomainNames'] = request.domain_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchStartVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.BatchStartVodDomainResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def batch_start_vod_domain(
        self,
        request: vod_20170321_models.BatchStartVodDomainRequest,
    ) -> vod_20170321_models.BatchStartVodDomainResponse:
        """
        @summary Enables accelerated domain names that are in the disabled state.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If the domain name that you want to enable is invalid or your Alibaba Cloud account has overdue payments, you cannot call this operation to enable the domain name.
        
        @param request: BatchStartVodDomainRequest
        @return: BatchStartVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.batch_start_vod_domain_with_options(request, runtime)

    async def batch_start_vod_domain_async(
        self,
        request: vod_20170321_models.BatchStartVodDomainRequest,
    ) -> vod_20170321_models.BatchStartVodDomainResponse:
        """
        @summary Enables accelerated domain names that are in the disabled state.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If the domain name that you want to enable is invalid or your Alibaba Cloud account has overdue payments, you cannot call this operation to enable the domain name.
        
        @param request: BatchStartVodDomainRequest
        @return: BatchStartVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.batch_start_vod_domain_with_options_async(request, runtime)

    def batch_stop_vod_domain_with_options(
        self,
        request: vod_20170321_models.BatchStopVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.BatchStopVodDomainResponse:
        """
        @summary Disables accelerated domain names.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        After you disable an accelerated domain name, the information about the domain name is retained. The system automatically reroutes all the requests that are destined for the domain name to the origin server.
        
        @param request: BatchStopVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchStopVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_names):
            query['DomainNames'] = request.domain_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchStopVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.BatchStopVodDomainResponse(),
            self.call_api(params, req, runtime)
        )

    async def batch_stop_vod_domain_with_options_async(
        self,
        request: vod_20170321_models.BatchStopVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.BatchStopVodDomainResponse:
        """
        @summary Disables accelerated domain names.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        After you disable an accelerated domain name, the information about the domain name is retained. The system automatically reroutes all the requests that are destined for the domain name to the origin server.
        
        @param request: BatchStopVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchStopVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_names):
            query['DomainNames'] = request.domain_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchStopVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.BatchStopVodDomainResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def batch_stop_vod_domain(
        self,
        request: vod_20170321_models.BatchStopVodDomainRequest,
    ) -> vod_20170321_models.BatchStopVodDomainResponse:
        """
        @summary Disables accelerated domain names.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        After you disable an accelerated domain name, the information about the domain name is retained. The system automatically reroutes all the requests that are destined for the domain name to the origin server.
        
        @param request: BatchStopVodDomainRequest
        @return: BatchStopVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.batch_stop_vod_domain_with_options(request, runtime)

    async def batch_stop_vod_domain_async(
        self,
        request: vod_20170321_models.BatchStopVodDomainRequest,
    ) -> vod_20170321_models.BatchStopVodDomainResponse:
        """
        @summary Disables accelerated domain names.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        After you disable an accelerated domain name, the information about the domain name is retained. The system automatically reroutes all the requests that are destined for the domain name to the origin server.
        
        @param request: BatchStopVodDomainRequest
        @return: BatchStopVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.batch_stop_vod_domain_with_options_async(request, runtime)

    def block_vod_object_caches_with_options(
        self,
        request: vod_20170321_models.BlockVodObjectCachesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.BlockVodObjectCachesResponse:
        """
        @summary 屏蔽缓存
        
        @param request: BlockVodObjectCachesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BlockVodObjectCachesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.maxage):
            query['Maxage'] = request.maxage
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BlockVodObjectCaches',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.BlockVodObjectCachesResponse(),
            self.call_api(params, req, runtime)
        )

    async def block_vod_object_caches_with_options_async(
        self,
        request: vod_20170321_models.BlockVodObjectCachesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.BlockVodObjectCachesResponse:
        """
        @summary 屏蔽缓存
        
        @param request: BlockVodObjectCachesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BlockVodObjectCachesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.maxage):
            query['Maxage'] = request.maxage
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BlockVodObjectCaches',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.BlockVodObjectCachesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def block_vod_object_caches(
        self,
        request: vod_20170321_models.BlockVodObjectCachesRequest,
    ) -> vod_20170321_models.BlockVodObjectCachesResponse:
        """
        @summary 屏蔽缓存
        
        @param request: BlockVodObjectCachesRequest
        @return: BlockVodObjectCachesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.block_vod_object_caches_with_options(request, runtime)

    async def block_vod_object_caches_async(
        self,
        request: vod_20170321_models.BlockVodObjectCachesRequest,
    ) -> vod_20170321_models.BlockVodObjectCachesResponse:
        """
        @summary 屏蔽缓存
        
        @param request: BlockVodObjectCachesRequest
        @return: BlockVodObjectCachesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.block_vod_object_caches_with_options_async(request, runtime)

    def cancel_bucket_redundancy_transition_with_options(
        self,
        request: vod_20170321_models.CancelBucketRedundancyTransitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CancelBucketRedundancyTransitionResponse:
        """
        @summary 取消系统存储冗余类型转换任务
        
        @param request: CancelBucketRedundancyTransitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelBucketRedundancyTransitionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelBucketRedundancyTransition',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CancelBucketRedundancyTransitionResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_bucket_redundancy_transition_with_options_async(
        self,
        request: vod_20170321_models.CancelBucketRedundancyTransitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CancelBucketRedundancyTransitionResponse:
        """
        @summary 取消系统存储冗余类型转换任务
        
        @param request: CancelBucketRedundancyTransitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelBucketRedundancyTransitionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelBucketRedundancyTransition',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CancelBucketRedundancyTransitionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_bucket_redundancy_transition(
        self,
        request: vod_20170321_models.CancelBucketRedundancyTransitionRequest,
    ) -> vod_20170321_models.CancelBucketRedundancyTransitionResponse:
        """
        @summary 取消系统存储冗余类型转换任务
        
        @param request: CancelBucketRedundancyTransitionRequest
        @return: CancelBucketRedundancyTransitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_bucket_redundancy_transition_with_options(request, runtime)

    async def cancel_bucket_redundancy_transition_async(
        self,
        request: vod_20170321_models.CancelBucketRedundancyTransitionRequest,
    ) -> vod_20170321_models.CancelBucketRedundancyTransitionResponse:
        """
        @summary 取消系统存储冗余类型转换任务
        
        @param request: CancelBucketRedundancyTransitionRequest
        @return: CancelBucketRedundancyTransitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_bucket_redundancy_transition_with_options_async(request, runtime)

    def cancel_media_export_jobs_with_options(
        self,
        request: vod_20170321_models.CancelMediaExportJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CancelMediaExportJobsResponse:
        """
        @summary 取消媒资导出任务
        
        @param request: CancelMediaExportJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelMediaExportJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelMediaExportJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CancelMediaExportJobsResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_media_export_jobs_with_options_async(
        self,
        request: vod_20170321_models.CancelMediaExportJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CancelMediaExportJobsResponse:
        """
        @summary 取消媒资导出任务
        
        @param request: CancelMediaExportJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelMediaExportJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelMediaExportJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CancelMediaExportJobsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_media_export_jobs(
        self,
        request: vod_20170321_models.CancelMediaExportJobsRequest,
    ) -> vod_20170321_models.CancelMediaExportJobsResponse:
        """
        @summary 取消媒资导出任务
        
        @param request: CancelMediaExportJobsRequest
        @return: CancelMediaExportJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_media_export_jobs_with_options(request, runtime)

    async def cancel_media_export_jobs_async(
        self,
        request: vod_20170321_models.CancelMediaExportJobsRequest,
    ) -> vod_20170321_models.CancelMediaExportJobsResponse:
        """
        @summary 取消媒资导出任务
        
        @param request: CancelMediaExportJobsRequest
        @return: CancelMediaExportJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_media_export_jobs_with_options_async(request, runtime)

    def cancel_url_upload_jobs_with_options(
        self,
        request: vod_20170321_models.CancelUrlUploadJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CancelUrlUploadJobsResponse:
        """
        @summary Cancels URL-based upload jobs in the queue.
        
        @description    You can cancel only URL-based upload jobs in the **Pending** state. You can query the status of a URL-based upload job by calling the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
        You cannot cancel an upload job that already starts.
        You must specify either JobIds or UploadUrls. If you specify both parameters, only JobIds takes effect.
        
        @param request: CancelUrlUploadJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelUrlUploadJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.upload_urls):
            query['UploadUrls'] = request.upload_urls
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelUrlUploadJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CancelUrlUploadJobsResponse(),
            self.call_api(params, req, runtime)
        )

    async def cancel_url_upload_jobs_with_options_async(
        self,
        request: vod_20170321_models.CancelUrlUploadJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CancelUrlUploadJobsResponse:
        """
        @summary Cancels URL-based upload jobs in the queue.
        
        @description    You can cancel only URL-based upload jobs in the **Pending** state. You can query the status of a URL-based upload job by calling the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
        You cannot cancel an upload job that already starts.
        You must specify either JobIds or UploadUrls. If you specify both parameters, only JobIds takes effect.
        
        @param request: CancelUrlUploadJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CancelUrlUploadJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.upload_urls):
            query['UploadUrls'] = request.upload_urls
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CancelUrlUploadJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CancelUrlUploadJobsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def cancel_url_upload_jobs(
        self,
        request: vod_20170321_models.CancelUrlUploadJobsRequest,
    ) -> vod_20170321_models.CancelUrlUploadJobsResponse:
        """
        @summary Cancels URL-based upload jobs in the queue.
        
        @description    You can cancel only URL-based upload jobs in the **Pending** state. You can query the status of a URL-based upload job by calling the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
        You cannot cancel an upload job that already starts.
        You must specify either JobIds or UploadUrls. If you specify both parameters, only JobIds takes effect.
        
        @param request: CancelUrlUploadJobsRequest
        @return: CancelUrlUploadJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.cancel_url_upload_jobs_with_options(request, runtime)

    async def cancel_url_upload_jobs_async(
        self,
        request: vod_20170321_models.CancelUrlUploadJobsRequest,
    ) -> vod_20170321_models.CancelUrlUploadJobsResponse:
        """
        @summary Cancels URL-based upload jobs in the queue.
        
        @description    You can cancel only URL-based upload jobs in the **Pending** state. You can query the status of a URL-based upload job by calling the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
        You cannot cancel an upload job that already starts.
        You must specify either JobIds or UploadUrls. If you specify both parameters, only JobIds takes effect.
        
        @param request: CancelUrlUploadJobsRequest
        @return: CancelUrlUploadJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.cancel_url_upload_jobs_with_options_async(request, runtime)

    def change_resource_group_with_options(
        self,
        request: vod_20170321_models.ChangeResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ChangeResourceGroupResponse:
        """
        @summary Transfers a resource to a specified resource group.
        
        @param request: ChangeResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ChangeResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_region_id):
            query['ResourceRegionId'] = request.resource_region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ChangeResourceGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ChangeResourceGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def change_resource_group_with_options_async(
        self,
        request: vod_20170321_models.ChangeResourceGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ChangeResourceGroupResponse:
        """
        @summary Transfers a resource to a specified resource group.
        
        @param request: ChangeResourceGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ChangeResourceGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_region_id):
            query['ResourceRegionId'] = request.resource_region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ChangeResourceGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ChangeResourceGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def change_resource_group(
        self,
        request: vod_20170321_models.ChangeResourceGroupRequest,
    ) -> vod_20170321_models.ChangeResourceGroupResponse:
        """
        @summary Transfers a resource to a specified resource group.
        
        @param request: ChangeResourceGroupRequest
        @return: ChangeResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.change_resource_group_with_options(request, runtime)

    async def change_resource_group_async(
        self,
        request: vod_20170321_models.ChangeResourceGroupRequest,
    ) -> vod_20170321_models.ChangeResourceGroupResponse:
        """
        @summary Transfers a resource to a specified resource group.
        
        @param request: ChangeResourceGroupRequest
        @return: ChangeResourceGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.change_resource_group_with_options_async(request, runtime)

    def check_license_with_options(
        self,
        request: vod_20170321_models.CheckLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CheckLicenseResponse:
        """
        @param request: CheckLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.nonce):
            query['Nonce'] = request.nonce
        if not UtilClient.is_unset(request.sign):
            query['Sign'] = request.sign
        if not UtilClient.is_unset(request.time):
            query['Time'] = request.time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CheckLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CheckLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def check_license_with_options_async(
        self,
        request: vod_20170321_models.CheckLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CheckLicenseResponse:
        """
        @param request: CheckLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.filter):
            query['Filter'] = request.filter
        if not UtilClient.is_unset(request.nonce):
            query['Nonce'] = request.nonce
        if not UtilClient.is_unset(request.sign):
            query['Sign'] = request.sign
        if not UtilClient.is_unset(request.time):
            query['Time'] = request.time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CheckLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CheckLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def check_license(
        self,
        request: vod_20170321_models.CheckLicenseRequest,
    ) -> vod_20170321_models.CheckLicenseResponse:
        """
        @param request: CheckLicenseRequest
        @return: CheckLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.check_license_with_options(request, runtime)

    async def check_license_async(
        self,
        request: vod_20170321_models.CheckLicenseRequest,
    ) -> vod_20170321_models.CheckLicenseResponse:
        """
        @param request: CheckLicenseRequest
        @return: CheckLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.check_license_with_options_async(request, runtime)

    def check_vod_default_role_with_options(
        self,
        request: vod_20170321_models.CheckVodDefaultRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CheckVodDefaultRoleResponse:
        """
        @summary 检查用户是否授权 AliyunVODDefaultRole 系统角色
        
        @param request: CheckVodDefaultRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckVodDefaultRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CheckVodDefaultRole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CheckVodDefaultRoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def check_vod_default_role_with_options_async(
        self,
        request: vod_20170321_models.CheckVodDefaultRoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CheckVodDefaultRoleResponse:
        """
        @summary 检查用户是否授权 AliyunVODDefaultRole 系统角色
        
        @param request: CheckVodDefaultRoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckVodDefaultRoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CheckVodDefaultRole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CheckVodDefaultRoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def check_vod_default_role(
        self,
        request: vod_20170321_models.CheckVodDefaultRoleRequest,
    ) -> vod_20170321_models.CheckVodDefaultRoleResponse:
        """
        @summary 检查用户是否授权 AliyunVODDefaultRole 系统角色
        
        @param request: CheckVodDefaultRoleRequest
        @return: CheckVodDefaultRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.check_vod_default_role_with_options(request, runtime)

    async def check_vod_default_role_async(
        self,
        request: vod_20170321_models.CheckVodDefaultRoleRequest,
    ) -> vod_20170321_models.CheckVodDefaultRoleResponse:
        """
        @summary 检查用户是否授权 AliyunVODDefaultRole 系统角色
        
        @param request: CheckVodDefaultRoleRequest
        @return: CheckVodDefaultRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.check_vod_default_role_with_options_async(request, runtime)

    def control_vod_app_service_with_options(
        self,
        request: vod_20170321_models.ControlVodAppServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ControlVodAppServiceResponse:
        """
        @summary app开通
        
        @param request: ControlVodAppServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ControlVodAppServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command):
            query['Command'] = request.command
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ControlVodAppService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ControlVodAppServiceResponse(),
            self.call_api(params, req, runtime)
        )

    async def control_vod_app_service_with_options_async(
        self,
        request: vod_20170321_models.ControlVodAppServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ControlVodAppServiceResponse:
        """
        @summary app开通
        
        @param request: ControlVodAppServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ControlVodAppServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command):
            query['Command'] = request.command
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ControlVodAppService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ControlVodAppServiceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def control_vod_app_service(
        self,
        request: vod_20170321_models.ControlVodAppServiceRequest,
    ) -> vod_20170321_models.ControlVodAppServiceResponse:
        """
        @summary app开通
        
        @param request: ControlVodAppServiceRequest
        @return: ControlVodAppServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.control_vod_app_service_with_options(request, runtime)

    async def control_vod_app_service_async(
        self,
        request: vod_20170321_models.ControlVodAppServiceRequest,
    ) -> vod_20170321_models.ControlVodAppServiceResponse:
        """
        @summary app开通
        
        @param request: ControlVodAppServiceRequest
        @return: ControlVodAppServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.control_vod_app_service_with_options_async(request, runtime)

    def create_app_info_with_options(
        self,
        request: vod_20170321_models.CreateAppInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateAppInfoResponse:
        """
        @summary Creates an application.
        
        @description You can create up to 10 applications within an Alibaba Cloud account. For more information, see [Multi-application service](https://help.aliyun.com/document_detail/113600.html).
        ### QPS limits
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VOD](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: CreateAppInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAppInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAppInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateAppInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_app_info_with_options_async(
        self,
        request: vod_20170321_models.CreateAppInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateAppInfoResponse:
        """
        @summary Creates an application.
        
        @description You can create up to 10 applications within an Alibaba Cloud account. For more information, see [Multi-application service](https://help.aliyun.com/document_detail/113600.html).
        ### QPS limits
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VOD](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: CreateAppInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAppInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAppInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateAppInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_app_info(
        self,
        request: vod_20170321_models.CreateAppInfoRequest,
    ) -> vod_20170321_models.CreateAppInfoResponse:
        """
        @summary Creates an application.
        
        @description You can create up to 10 applications within an Alibaba Cloud account. For more information, see [Multi-application service](https://help.aliyun.com/document_detail/113600.html).
        ### QPS limits
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VOD](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: CreateAppInfoRequest
        @return: CreateAppInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_app_info_with_options(request, runtime)

    async def create_app_info_async(
        self,
        request: vod_20170321_models.CreateAppInfoRequest,
    ) -> vod_20170321_models.CreateAppInfoResponse:
        """
        @summary Creates an application.
        
        @description You can create up to 10 applications within an Alibaba Cloud account. For more information, see [Multi-application service](https://help.aliyun.com/document_detail/113600.html).
        ### QPS limits
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VOD](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: CreateAppInfoRequest
        @return: CreateAppInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_app_info_with_options_async(request, runtime)

    def create_app_policy_with_options(
        self,
        request: vod_20170321_models.CreateAppPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateAppPolicyResponse:
        """
        @summary 创建app策略
        
        @param request: CreateAppPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAppPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy_name):
            query['PolicyName'] = request.policy_name
        if not UtilClient.is_unset(request.policy_value):
            query['PolicyValue'] = request.policy_value
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAppPolicy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateAppPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_app_policy_with_options_async(
        self,
        request: vod_20170321_models.CreateAppPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateAppPolicyResponse:
        """
        @summary 创建app策略
        
        @param request: CreateAppPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAppPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy_name):
            query['PolicyName'] = request.policy_name
        if not UtilClient.is_unset(request.policy_value):
            query['PolicyValue'] = request.policy_value
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAppPolicy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateAppPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_app_policy(
        self,
        request: vod_20170321_models.CreateAppPolicyRequest,
    ) -> vod_20170321_models.CreateAppPolicyResponse:
        """
        @summary 创建app策略
        
        @param request: CreateAppPolicyRequest
        @return: CreateAppPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_app_policy_with_options(request, runtime)

    async def create_app_policy_async(
        self,
        request: vod_20170321_models.CreateAppPolicyRequest,
    ) -> vod_20170321_models.CreateAppPolicyResponse:
        """
        @summary 创建app策略
        
        @param request: CreateAppPolicyRequest
        @return: CreateAppPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_app_policy_with_options_async(request, runtime)

    def create_audit_with_options(
        self,
        request: vod_20170321_models.CreateAuditRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateAuditResponse:
        """
        @summary Performs manual review on media files, such as audio and video files.
        
        @param request: CreateAuditRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAuditResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.audit_content):
            query['AuditContent'] = request.audit_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAudit',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateAuditResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_audit_with_options_async(
        self,
        request: vod_20170321_models.CreateAuditRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateAuditResponse:
        """
        @summary Performs manual review on media files, such as audio and video files.
        
        @param request: CreateAuditRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAuditResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.audit_content):
            query['AuditContent'] = request.audit_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAudit',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateAuditResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_audit(
        self,
        request: vod_20170321_models.CreateAuditRequest,
    ) -> vod_20170321_models.CreateAuditResponse:
        """
        @summary Performs manual review on media files, such as audio and video files.
        
        @param request: CreateAuditRequest
        @return: CreateAuditResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_audit_with_options(request, runtime)

    async def create_audit_async(
        self,
        request: vod_20170321_models.CreateAuditRequest,
    ) -> vod_20170321_models.CreateAuditResponse:
        """
        @summary Performs manual review on media files, such as audio and video files.
        
        @param request: CreateAuditRequest
        @return: CreateAuditResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_audit_with_options_async(request, runtime)

    def create_dnadbwith_options(
        self,
        request: vod_20170321_models.CreateDNADBRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateDNADBResponse:
        """
        @summary 创建DNA
        
        @param request: CreateDNADBRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDNADBResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dbdescription):
            query['DBDescription'] = request.dbdescription
        if not UtilClient.is_unset(request.dbname):
            query['DBName'] = request.dbname
        if not UtilClient.is_unset(request.dbregion):
            query['DBRegion'] = request.dbregion
        if not UtilClient.is_unset(request.dbtype):
            query['DBType'] = request.dbtype
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDNADB',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateDNADBResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_dnadbwith_options_async(
        self,
        request: vod_20170321_models.CreateDNADBRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateDNADBResponse:
        """
        @summary 创建DNA
        
        @param request: CreateDNADBRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDNADBResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.dbdescription):
            query['DBDescription'] = request.dbdescription
        if not UtilClient.is_unset(request.dbname):
            query['DBName'] = request.dbname
        if not UtilClient.is_unset(request.dbregion):
            query['DBRegion'] = request.dbregion
        if not UtilClient.is_unset(request.dbtype):
            query['DBType'] = request.dbtype
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDNADB',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateDNADBResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_dnadb(
        self,
        request: vod_20170321_models.CreateDNADBRequest,
    ) -> vod_20170321_models.CreateDNADBResponse:
        """
        @summary 创建DNA
        
        @param request: CreateDNADBRequest
        @return: CreateDNADBResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_dnadbwith_options(request, runtime)

    async def create_dnadb_async(
        self,
        request: vod_20170321_models.CreateDNADBRequest,
    ) -> vod_20170321_models.CreateDNADBResponse:
        """
        @summary 创建DNA
        
        @param request: CreateDNADBRequest
        @return: CreateDNADBResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_dnadbwith_options_async(request, runtime)

    def create_intelligent_strategy_with_options(
        self,
        request: vod_20170321_models.CreateIntelligentStrategyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateIntelligentStrategyResponse:
        """
        @summary 创建智能策略
        
        @param request: CreateIntelligentStrategyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIntelligentStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.conditions):
            query['Conditions'] = request.conditions
        if not UtilClient.is_unset(request.execute_params):
            query['ExecuteParams'] = request.execute_params
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.state):
            query['State'] = request.state
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIntelligentStrategy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateIntelligentStrategyResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_intelligent_strategy_with_options_async(
        self,
        request: vod_20170321_models.CreateIntelligentStrategyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateIntelligentStrategyResponse:
        """
        @summary 创建智能策略
        
        @param request: CreateIntelligentStrategyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIntelligentStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.conditions):
            query['Conditions'] = request.conditions
        if not UtilClient.is_unset(request.execute_params):
            query['ExecuteParams'] = request.execute_params
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.state):
            query['State'] = request.state
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIntelligentStrategy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateIntelligentStrategyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_intelligent_strategy(
        self,
        request: vod_20170321_models.CreateIntelligentStrategyRequest,
    ) -> vod_20170321_models.CreateIntelligentStrategyResponse:
        """
        @summary 创建智能策略
        
        @param request: CreateIntelligentStrategyRequest
        @return: CreateIntelligentStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_intelligent_strategy_with_options(request, runtime)

    async def create_intelligent_strategy_async(
        self,
        request: vod_20170321_models.CreateIntelligentStrategyRequest,
    ) -> vod_20170321_models.CreateIntelligentStrategyResponse:
        """
        @summary 创建智能策略
        
        @param request: CreateIntelligentStrategyRequest
        @return: CreateIntelligentStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_intelligent_strategy_with_options_async(request, runtime)

    def create_kmsservice_key_with_options(
        self,
        request: vod_20170321_models.CreateKMSServiceKeyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateKMSServiceKeyResponse:
        """
        @summary 创建kmsKey
        
        @param request: CreateKMSServiceKeyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateKMSServiceKeyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.kms_region_id):
            query['KmsRegionId'] = request.kms_region_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateKMSServiceKey',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateKMSServiceKeyResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_kmsservice_key_with_options_async(
        self,
        request: vod_20170321_models.CreateKMSServiceKeyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateKMSServiceKeyResponse:
        """
        @summary 创建kmsKey
        
        @param request: CreateKMSServiceKeyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateKMSServiceKeyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.kms_region_id):
            query['KmsRegionId'] = request.kms_region_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateKMSServiceKey',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateKMSServiceKeyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_kmsservice_key(
        self,
        request: vod_20170321_models.CreateKMSServiceKeyRequest,
    ) -> vod_20170321_models.CreateKMSServiceKeyResponse:
        """
        @summary 创建kmsKey
        
        @param request: CreateKMSServiceKeyRequest
        @return: CreateKMSServiceKeyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_kmsservice_key_with_options(request, runtime)

    async def create_kmsservice_key_async(
        self,
        request: vod_20170321_models.CreateKMSServiceKeyRequest,
    ) -> vod_20170321_models.CreateKMSServiceKeyResponse:
        """
        @summary 创建kmsKey
        
        @param request: CreateKMSServiceKeyRequest
        @return: CreateKMSServiceKeyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_kmsservice_key_with_options_async(request, runtime)

    def create_license_with_options(
        self,
        request: vod_20170321_models.CreateLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateLicenseResponse:
        """
        @summary 创建license
        
        @param request: CreateLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.account_id):
            query['AccountId'] = request.account_id
        if not UtilClient.is_unset(request.begin_time):
            query['BeginTime'] = request.begin_time
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.contract_no):
            query['ContractNo'] = request.contract_no
        if not UtilClient.is_unset(request.customer_id):
            query['CustomerId'] = request.customer_id
        if not UtilClient.is_unset(request.expired_on):
            query['ExpiredOn'] = request.expired_on
        if not UtilClient.is_unset(request.extra_info):
            query['ExtraInfo'] = request.extra_info
        if not UtilClient.is_unset(request.operator):
            query['Operator'] = request.operator
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_license_with_options_async(
        self,
        request: vod_20170321_models.CreateLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateLicenseResponse:
        """
        @summary 创建license
        
        @param request: CreateLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.account_id):
            query['AccountId'] = request.account_id
        if not UtilClient.is_unset(request.begin_time):
            query['BeginTime'] = request.begin_time
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.contract_no):
            query['ContractNo'] = request.contract_no
        if not UtilClient.is_unset(request.customer_id):
            query['CustomerId'] = request.customer_id
        if not UtilClient.is_unset(request.expired_on):
            query['ExpiredOn'] = request.expired_on
        if not UtilClient.is_unset(request.extra_info):
            query['ExtraInfo'] = request.extra_info
        if not UtilClient.is_unset(request.operator):
            query['Operator'] = request.operator
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_license(
        self,
        request: vod_20170321_models.CreateLicenseRequest,
    ) -> vod_20170321_models.CreateLicenseResponse:
        """
        @summary 创建license
        
        @param request: CreateLicenseRequest
        @return: CreateLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_license_with_options(request, runtime)

    async def create_license_async(
        self,
        request: vod_20170321_models.CreateLicenseRequest,
    ) -> vod_20170321_models.CreateLicenseResponse:
        """
        @summary 创建license
        
        @param request: CreateLicenseRequest
        @return: CreateLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_license_with_options_async(request, runtime)

    def create_media_dnalib_with_options(
        self,
        request: vod_20170321_models.CreateMediaDNALibRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateMediaDNALibResponse:
        """
        @summary 创建DNA
        
        @param request: CreateMediaDNALibRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMediaDNALibResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.lib_region):
            query['LibRegion'] = request.lib_region
        if not UtilClient.is_unset(request.model_type):
            query['ModelType'] = request.model_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateMediaDNALib',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateMediaDNALibResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_media_dnalib_with_options_async(
        self,
        request: vod_20170321_models.CreateMediaDNALibRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateMediaDNALibResponse:
        """
        @summary 创建DNA
        
        @param request: CreateMediaDNALibRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMediaDNALibResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.lib_region):
            query['LibRegion'] = request.lib_region
        if not UtilClient.is_unset(request.model_type):
            query['ModelType'] = request.model_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateMediaDNALib',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateMediaDNALibResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_media_dnalib(
        self,
        request: vod_20170321_models.CreateMediaDNALibRequest,
    ) -> vod_20170321_models.CreateMediaDNALibResponse:
        """
        @summary 创建DNA
        
        @param request: CreateMediaDNALibRequest
        @return: CreateMediaDNALibResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_media_dnalib_with_options(request, runtime)

    async def create_media_dnalib_async(
        self,
        request: vod_20170321_models.CreateMediaDNALibRequest,
    ) -> vod_20170321_models.CreateMediaDNALibResponse:
        """
        @summary 创建DNA
        
        @param request: CreateMediaDNALibRequest
        @return: CreateMediaDNALibResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_media_dnalib_with_options_async(request, runtime)

    def create_media_lifecycle_rule_with_options(
        self,
        request: vod_20170321_models.CreateMediaLifecycleRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateMediaLifecycleRuleResponse:
        """
        @summary 创建生命周期
        
        @param request: CreateMediaLifecycleRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMediaLifecycleRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.rule_content):
            query['RuleContent'] = request.rule_content
        if not UtilClient.is_unset(request.rule_type):
            query['RuleType'] = request.rule_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateMediaLifecycleRule',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateMediaLifecycleRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_media_lifecycle_rule_with_options_async(
        self,
        request: vod_20170321_models.CreateMediaLifecycleRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateMediaLifecycleRuleResponse:
        """
        @summary 创建生命周期
        
        @param request: CreateMediaLifecycleRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMediaLifecycleRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.rule_content):
            query['RuleContent'] = request.rule_content
        if not UtilClient.is_unset(request.rule_type):
            query['RuleType'] = request.rule_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateMediaLifecycleRule',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateMediaLifecycleRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_media_lifecycle_rule(
        self,
        request: vod_20170321_models.CreateMediaLifecycleRuleRequest,
    ) -> vod_20170321_models.CreateMediaLifecycleRuleResponse:
        """
        @summary 创建生命周期
        
        @param request: CreateMediaLifecycleRuleRequest
        @return: CreateMediaLifecycleRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_media_lifecycle_rule_with_options(request, runtime)

    async def create_media_lifecycle_rule_async(
        self,
        request: vod_20170321_models.CreateMediaLifecycleRuleRequest,
    ) -> vod_20170321_models.CreateMediaLifecycleRuleResponse:
        """
        @summary 创建生命周期
        
        @param request: CreateMediaLifecycleRuleRequest
        @return: CreateMediaLifecycleRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_media_lifecycle_rule_with_options_async(request, runtime)

    def create_multi_order_for_license_with_options(
        self,
        request: vod_20170321_models.CreateMultiOrderForLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateMultiOrderForLicenseResponse:
        """
        @summary 组合下单
        
        @param request: CreateMultiOrderForLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMultiOrderForLicenseResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateMultiOrderForLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateMultiOrderForLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_multi_order_for_license_with_options_async(
        self,
        request: vod_20170321_models.CreateMultiOrderForLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateMultiOrderForLicenseResponse:
        """
        @summary 组合下单
        
        @param request: CreateMultiOrderForLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMultiOrderForLicenseResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateMultiOrderForLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateMultiOrderForLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_multi_order_for_license(
        self,
        request: vod_20170321_models.CreateMultiOrderForLicenseRequest,
    ) -> vod_20170321_models.CreateMultiOrderForLicenseResponse:
        """
        @summary 组合下单
        
        @param request: CreateMultiOrderForLicenseRequest
        @return: CreateMultiOrderForLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_multi_order_for_license_with_options(request, runtime)

    async def create_multi_order_for_license_async(
        self,
        request: vod_20170321_models.CreateMultiOrderForLicenseRequest,
    ) -> vod_20170321_models.CreateMultiOrderForLicenseResponse:
        """
        @summary 组合下单
        
        @param request: CreateMultiOrderForLicenseRequest
        @return: CreateMultiOrderForLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_multi_order_for_license_with_options_async(request, runtime)

    def create_order_with_options(
        self,
        request: vod_20170321_models.CreateOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateOrderResponse:
        """
        @summary 下单
        
        @param request: CreateOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateOrder',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_order_with_options_async(
        self,
        request: vod_20170321_models.CreateOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateOrderResponse:
        """
        @summary 下单
        
        @param request: CreateOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateOrder',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_order(
        self,
        request: vod_20170321_models.CreateOrderRequest,
    ) -> vod_20170321_models.CreateOrderResponse:
        """
        @summary 下单
        
        @param request: CreateOrderRequest
        @return: CreateOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_order_with_options(request, runtime)

    async def create_order_async(
        self,
        request: vod_20170321_models.CreateOrderRequest,
    ) -> vod_20170321_models.CreateOrderResponse:
        """
        @summary 下单
        
        @param request: CreateOrderRequest
        @return: CreateOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_order_with_options_async(request, runtime)

    def create_order_for_license_with_options(
        self,
        request: vod_20170321_models.CreateOrderForLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateOrderForLicenseResponse:
        """
        @summary 创建订单
        
        @param request: CreateOrderForLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateOrderForLicenseResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateOrderForLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateOrderForLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_order_for_license_with_options_async(
        self,
        request: vod_20170321_models.CreateOrderForLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateOrderForLicenseResponse:
        """
        @summary 创建订单
        
        @param request: CreateOrderForLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateOrderForLicenseResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateOrderForLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateOrderForLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_order_for_license(
        self,
        request: vod_20170321_models.CreateOrderForLicenseRequest,
    ) -> vod_20170321_models.CreateOrderForLicenseResponse:
        """
        @summary 创建订单
        
        @param request: CreateOrderForLicenseRequest
        @return: CreateOrderForLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_order_for_license_with_options(request, runtime)

    async def create_order_for_license_async(
        self,
        request: vod_20170321_models.CreateOrderForLicenseRequest,
    ) -> vod_20170321_models.CreateOrderForLicenseResponse:
        """
        @summary 创建订单
        
        @param request: CreateOrderForLicenseRequest
        @return: CreateOrderForLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_order_for_license_with_options_async(request, runtime)

    def create_upload_attached_media_with_options(
        self,
        request: vod_20170321_models.CreateUploadAttachedMediaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateUploadAttachedMediaResponse:
        """
        @summary Obtains an upload URL and an upload credential for an auxiliary media asset such as a watermark image, subtitle file, or material and generates the media ID. ApsaraVideo VOD issues upload URLs and credentials to perform authorization and ensure security. This prevents unauthorized users from uploading media files. ApsaraVideo VOD generates media IDs together with upload URLs and credentials. Media IDs are used in lifecycle management and media processing.
        
        @description    **Make sure that you understand the billing method and prices of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        You can call this operation only to obtain the upload URLs and credentials for media files and create media assets in ApsaraVideo VOD. You cannot call this operation to upload media files. For more information about how to upload media files by calling API operations, see [Upload media files by calling API operations](https://help.aliyun.com/document_detail/476208.html).
        If the upload credential expires after 3,000 seconds, you can call the CreateUploadAttachedMedia operation again to obtain a new upload URL and a new upload credential.
        You can configure a callback to receive an [AttachedMediaUploadComplete](https://help.aliyun.com/document_detail/103250.html) event notification to determine whether the upload is successful.
        You must obtain a URL and a credential before you upload a media file to ApsaraVideo VOD. ApsaraVideo VOD supports multiple upload methods. Each method has different requirements on upload URLs and credentials. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        
        @param request: CreateUploadAttachedMediaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateUploadAttachedMediaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.cate_ids):
            query['CateIds'] = request.cate_ids
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.file_size):
            query['FileSize'] = request.file_size
        if not UtilClient.is_unset(request.media_ext):
            query['MediaExt'] = request.media_ext
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateUploadAttachedMedia',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateUploadAttachedMediaResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_upload_attached_media_with_options_async(
        self,
        request: vod_20170321_models.CreateUploadAttachedMediaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateUploadAttachedMediaResponse:
        """
        @summary Obtains an upload URL and an upload credential for an auxiliary media asset such as a watermark image, subtitle file, or material and generates the media ID. ApsaraVideo VOD issues upload URLs and credentials to perform authorization and ensure security. This prevents unauthorized users from uploading media files. ApsaraVideo VOD generates media IDs together with upload URLs and credentials. Media IDs are used in lifecycle management and media processing.
        
        @description    **Make sure that you understand the billing method and prices of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        You can call this operation only to obtain the upload URLs and credentials for media files and create media assets in ApsaraVideo VOD. You cannot call this operation to upload media files. For more information about how to upload media files by calling API operations, see [Upload media files by calling API operations](https://help.aliyun.com/document_detail/476208.html).
        If the upload credential expires after 3,000 seconds, you can call the CreateUploadAttachedMedia operation again to obtain a new upload URL and a new upload credential.
        You can configure a callback to receive an [AttachedMediaUploadComplete](https://help.aliyun.com/document_detail/103250.html) event notification to determine whether the upload is successful.
        You must obtain a URL and a credential before you upload a media file to ApsaraVideo VOD. ApsaraVideo VOD supports multiple upload methods. Each method has different requirements on upload URLs and credentials. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        
        @param request: CreateUploadAttachedMediaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateUploadAttachedMediaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.cate_ids):
            query['CateIds'] = request.cate_ids
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.file_size):
            query['FileSize'] = request.file_size
        if not UtilClient.is_unset(request.media_ext):
            query['MediaExt'] = request.media_ext
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateUploadAttachedMedia',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateUploadAttachedMediaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_upload_attached_media(
        self,
        request: vod_20170321_models.CreateUploadAttachedMediaRequest,
    ) -> vod_20170321_models.CreateUploadAttachedMediaResponse:
        """
        @summary Obtains an upload URL and an upload credential for an auxiliary media asset such as a watermark image, subtitle file, or material and generates the media ID. ApsaraVideo VOD issues upload URLs and credentials to perform authorization and ensure security. This prevents unauthorized users from uploading media files. ApsaraVideo VOD generates media IDs together with upload URLs and credentials. Media IDs are used in lifecycle management and media processing.
        
        @description    **Make sure that you understand the billing method and prices of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        You can call this operation only to obtain the upload URLs and credentials for media files and create media assets in ApsaraVideo VOD. You cannot call this operation to upload media files. For more information about how to upload media files by calling API operations, see [Upload media files by calling API operations](https://help.aliyun.com/document_detail/476208.html).
        If the upload credential expires after 3,000 seconds, you can call the CreateUploadAttachedMedia operation again to obtain a new upload URL and a new upload credential.
        You can configure a callback to receive an [AttachedMediaUploadComplete](https://help.aliyun.com/document_detail/103250.html) event notification to determine whether the upload is successful.
        You must obtain a URL and a credential before you upload a media file to ApsaraVideo VOD. ApsaraVideo VOD supports multiple upload methods. Each method has different requirements on upload URLs and credentials. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        
        @param request: CreateUploadAttachedMediaRequest
        @return: CreateUploadAttachedMediaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_upload_attached_media_with_options(request, runtime)

    async def create_upload_attached_media_async(
        self,
        request: vod_20170321_models.CreateUploadAttachedMediaRequest,
    ) -> vod_20170321_models.CreateUploadAttachedMediaResponse:
        """
        @summary Obtains an upload URL and an upload credential for an auxiliary media asset such as a watermark image, subtitle file, or material and generates the media ID. ApsaraVideo VOD issues upload URLs and credentials to perform authorization and ensure security. This prevents unauthorized users from uploading media files. ApsaraVideo VOD generates media IDs together with upload URLs and credentials. Media IDs are used in lifecycle management and media processing.
        
        @description    **Make sure that you understand the billing method and prices of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        You can call this operation only to obtain the upload URLs and credentials for media files and create media assets in ApsaraVideo VOD. You cannot call this operation to upload media files. For more information about how to upload media files by calling API operations, see [Upload media files by calling API operations](https://help.aliyun.com/document_detail/476208.html).
        If the upload credential expires after 3,000 seconds, you can call the CreateUploadAttachedMedia operation again to obtain a new upload URL and a new upload credential.
        You can configure a callback to receive an [AttachedMediaUploadComplete](https://help.aliyun.com/document_detail/103250.html) event notification to determine whether the upload is successful.
        You must obtain a URL and a credential before you upload a media file to ApsaraVideo VOD. ApsaraVideo VOD supports multiple upload methods. Each method has different requirements on upload URLs and credentials. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        
        @param request: CreateUploadAttachedMediaRequest
        @return: CreateUploadAttachedMediaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_upload_attached_media_with_options_async(request, runtime)

    def create_upload_image_with_options(
        self,
        request: vod_20170321_models.CreateUploadImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateUploadImageResponse:
        """
        @summary Queries a URL and a credential for uploading an image.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        You must obtain a URL and a credential before you upload an image to ApsaraVideo VOD. ApsaraVideo VOD provides multiple upload methods. You can upload files by using server upload SDKs, client upload SDKs, URLs, Object Storage Service (OSS) API, or OSS SDKs. Each upload method has different requirements for obtaining upload URLs and credentials. For more information, see the "Usage notes" section of the [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html) topic.
        You cannot refresh the upload URL or credential when you upload images. If the image upload credential expires, you can call this operation to obtain a new upload URL and credential. By default, the validity period of an image upload credential is 3,000 seconds.
        You can call the [CreateUploadAttachedMedia](https://help.aliyun.com/document_detail/98467.html) operation to upload image watermarks.
        You can configure a callback for [ImageUploadComplete](https://help.aliyun.com/document_detail/91968.html) to receive notifications about the image upload status.
        
        @param request: CreateUploadImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateUploadImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.image_ext):
            query['ImageExt'] = request.image_ext
        if not UtilClient.is_unset(request.image_type):
            query['ImageType'] = request.image_type
        if not UtilClient.is_unset(request.original_file_name):
            query['OriginalFileName'] = request.original_file_name
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateUploadImage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateUploadImageResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_upload_image_with_options_async(
        self,
        request: vod_20170321_models.CreateUploadImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateUploadImageResponse:
        """
        @summary Queries a URL and a credential for uploading an image.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        You must obtain a URL and a credential before you upload an image to ApsaraVideo VOD. ApsaraVideo VOD provides multiple upload methods. You can upload files by using server upload SDKs, client upload SDKs, URLs, Object Storage Service (OSS) API, or OSS SDKs. Each upload method has different requirements for obtaining upload URLs and credentials. For more information, see the "Usage notes" section of the [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html) topic.
        You cannot refresh the upload URL or credential when you upload images. If the image upload credential expires, you can call this operation to obtain a new upload URL and credential. By default, the validity period of an image upload credential is 3,000 seconds.
        You can call the [CreateUploadAttachedMedia](https://help.aliyun.com/document_detail/98467.html) operation to upload image watermarks.
        You can configure a callback for [ImageUploadComplete](https://help.aliyun.com/document_detail/91968.html) to receive notifications about the image upload status.
        
        @param request: CreateUploadImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateUploadImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.image_ext):
            query['ImageExt'] = request.image_ext
        if not UtilClient.is_unset(request.image_type):
            query['ImageType'] = request.image_type
        if not UtilClient.is_unset(request.original_file_name):
            query['OriginalFileName'] = request.original_file_name
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateUploadImage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateUploadImageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_upload_image(
        self,
        request: vod_20170321_models.CreateUploadImageRequest,
    ) -> vod_20170321_models.CreateUploadImageResponse:
        """
        @summary Queries a URL and a credential for uploading an image.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        You must obtain a URL and a credential before you upload an image to ApsaraVideo VOD. ApsaraVideo VOD provides multiple upload methods. You can upload files by using server upload SDKs, client upload SDKs, URLs, Object Storage Service (OSS) API, or OSS SDKs. Each upload method has different requirements for obtaining upload URLs and credentials. For more information, see the "Usage notes" section of the [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html) topic.
        You cannot refresh the upload URL or credential when you upload images. If the image upload credential expires, you can call this operation to obtain a new upload URL and credential. By default, the validity period of an image upload credential is 3,000 seconds.
        You can call the [CreateUploadAttachedMedia](https://help.aliyun.com/document_detail/98467.html) operation to upload image watermarks.
        You can configure a callback for [ImageUploadComplete](https://help.aliyun.com/document_detail/91968.html) to receive notifications about the image upload status.
        
        @param request: CreateUploadImageRequest
        @return: CreateUploadImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_upload_image_with_options(request, runtime)

    async def create_upload_image_async(
        self,
        request: vod_20170321_models.CreateUploadImageRequest,
    ) -> vod_20170321_models.CreateUploadImageResponse:
        """
        @summary Queries a URL and a credential for uploading an image.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        You must obtain a URL and a credential before you upload an image to ApsaraVideo VOD. ApsaraVideo VOD provides multiple upload methods. You can upload files by using server upload SDKs, client upload SDKs, URLs, Object Storage Service (OSS) API, or OSS SDKs. Each upload method has different requirements for obtaining upload URLs and credentials. For more information, see the "Usage notes" section of the [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html) topic.
        You cannot refresh the upload URL or credential when you upload images. If the image upload credential expires, you can call this operation to obtain a new upload URL and credential. By default, the validity period of an image upload credential is 3,000 seconds.
        You can call the [CreateUploadAttachedMedia](https://help.aliyun.com/document_detail/98467.html) operation to upload image watermarks.
        You can configure a callback for [ImageUploadComplete](https://help.aliyun.com/document_detail/91968.html) to receive notifications about the image upload status.
        
        @param request: CreateUploadImageRequest
        @return: CreateUploadImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_upload_image_with_options_async(request, runtime)

    def create_upload_video_with_options(
        self,
        request: vod_20170321_models.CreateUploadVideoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateUploadVideoResponse:
        """
        @summary Obtains an upload URL and an upload credential for uploading an audio or video file and generates the audio or video ID. ApsaraVideo VOD issues upload URLs and credentials to perform authorization and ensure security. This prevents unauthorized users from uploading media files. ApsaraVideo VOD generates media IDs, video IDs, and image IDs together with upload URLs and credentials. Media IDs are used in lifecycle management and media processing.
        
        @description    **Make sure that you understand the billing method and prices of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        You can call this operation to obtain upload URLs and credentials for video and audio files. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        You can call this operation only to obtain the upload URLs and credentials for media files and create media assets in ApsaraVideo VOD. You cannot call this operation to upload media files. For more information about how to upload media files by calling API operations, see [Upload media files by calling API operations](https://help.aliyun.com/document_detail/476208.html).
        If the upload credential expires, call the [RefreshUploadVideo](~~RefreshUploadVideo~~) operation to obtain a new upload credential. The default validity period of an upload credential is 3,000 seconds.
        You can configure a callback to receive an event notification when an audio or video file is uploaded. Alternatively, after you upload an audio or video file, you can call the [GetMezzanineInfo](https://help.aliyun.com/document_detail/59624.html) operation to determine whether the upload is successful. For more information, see [Overview](https://help.aliyun.com/document_detail/55396.html).
        The value of the VideoId parameter that is returned after you call this operation can be used for media processing or the lifecycle management of media assets.
        You must obtain a URL and a credential before you upload a media file to ApsaraVideo VOD. ApsaraVideo VOD supports multiple upload methods. Each method has different requirements on upload URLs and credentials. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        
        @param request: CreateUploadVideoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateUploadVideoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        if not UtilClient.is_unset(request.cover_url):
            query['CoverURL'] = request.cover_url
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.file_size):
            query['FileSize'] = request.file_size
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.template_group_id):
            query['TemplateGroupId'] = request.template_group_id
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateUploadVideo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateUploadVideoResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_upload_video_with_options_async(
        self,
        request: vod_20170321_models.CreateUploadVideoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateUploadVideoResponse:
        """
        @summary Obtains an upload URL and an upload credential for uploading an audio or video file and generates the audio or video ID. ApsaraVideo VOD issues upload URLs and credentials to perform authorization and ensure security. This prevents unauthorized users from uploading media files. ApsaraVideo VOD generates media IDs, video IDs, and image IDs together with upload URLs and credentials. Media IDs are used in lifecycle management and media processing.
        
        @description    **Make sure that you understand the billing method and prices of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        You can call this operation to obtain upload URLs and credentials for video and audio files. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        You can call this operation only to obtain the upload URLs and credentials for media files and create media assets in ApsaraVideo VOD. You cannot call this operation to upload media files. For more information about how to upload media files by calling API operations, see [Upload media files by calling API operations](https://help.aliyun.com/document_detail/476208.html).
        If the upload credential expires, call the [RefreshUploadVideo](~~RefreshUploadVideo~~) operation to obtain a new upload credential. The default validity period of an upload credential is 3,000 seconds.
        You can configure a callback to receive an event notification when an audio or video file is uploaded. Alternatively, after you upload an audio or video file, you can call the [GetMezzanineInfo](https://help.aliyun.com/document_detail/59624.html) operation to determine whether the upload is successful. For more information, see [Overview](https://help.aliyun.com/document_detail/55396.html).
        The value of the VideoId parameter that is returned after you call this operation can be used for media processing or the lifecycle management of media assets.
        You must obtain a URL and a credential before you upload a media file to ApsaraVideo VOD. ApsaraVideo VOD supports multiple upload methods. Each method has different requirements on upload URLs and credentials. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        
        @param request: CreateUploadVideoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateUploadVideoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        if not UtilClient.is_unset(request.cover_url):
            query['CoverURL'] = request.cover_url
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.file_size):
            query['FileSize'] = request.file_size
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.template_group_id):
            query['TemplateGroupId'] = request.template_group_id
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateUploadVideo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateUploadVideoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_upload_video(
        self,
        request: vod_20170321_models.CreateUploadVideoRequest,
    ) -> vod_20170321_models.CreateUploadVideoResponse:
        """
        @summary Obtains an upload URL and an upload credential for uploading an audio or video file and generates the audio or video ID. ApsaraVideo VOD issues upload URLs and credentials to perform authorization and ensure security. This prevents unauthorized users from uploading media files. ApsaraVideo VOD generates media IDs, video IDs, and image IDs together with upload URLs and credentials. Media IDs are used in lifecycle management and media processing.
        
        @description    **Make sure that you understand the billing method and prices of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        You can call this operation to obtain upload URLs and credentials for video and audio files. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        You can call this operation only to obtain the upload URLs and credentials for media files and create media assets in ApsaraVideo VOD. You cannot call this operation to upload media files. For more information about how to upload media files by calling API operations, see [Upload media files by calling API operations](https://help.aliyun.com/document_detail/476208.html).
        If the upload credential expires, call the [RefreshUploadVideo](~~RefreshUploadVideo~~) operation to obtain a new upload credential. The default validity period of an upload credential is 3,000 seconds.
        You can configure a callback to receive an event notification when an audio or video file is uploaded. Alternatively, after you upload an audio or video file, you can call the [GetMezzanineInfo](https://help.aliyun.com/document_detail/59624.html) operation to determine whether the upload is successful. For more information, see [Overview](https://help.aliyun.com/document_detail/55396.html).
        The value of the VideoId parameter that is returned after you call this operation can be used for media processing or the lifecycle management of media assets.
        You must obtain a URL and a credential before you upload a media file to ApsaraVideo VOD. ApsaraVideo VOD supports multiple upload methods. Each method has different requirements on upload URLs and credentials. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        
        @param request: CreateUploadVideoRequest
        @return: CreateUploadVideoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_upload_video_with_options(request, runtime)

    async def create_upload_video_async(
        self,
        request: vod_20170321_models.CreateUploadVideoRequest,
    ) -> vod_20170321_models.CreateUploadVideoResponse:
        """
        @summary Obtains an upload URL and an upload credential for uploading an audio or video file and generates the audio or video ID. ApsaraVideo VOD issues upload URLs and credentials to perform authorization and ensure security. This prevents unauthorized users from uploading media files. ApsaraVideo VOD generates media IDs, video IDs, and image IDs together with upload URLs and credentials. Media IDs are used in lifecycle management and media processing.
        
        @description    **Make sure that you understand the billing method and prices of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        You can call this operation to obtain upload URLs and credentials for video and audio files. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        You can call this operation only to obtain the upload URLs and credentials for media files and create media assets in ApsaraVideo VOD. You cannot call this operation to upload media files. For more information about how to upload media files by calling API operations, see [Upload media files by calling API operations](https://help.aliyun.com/document_detail/476208.html).
        If the upload credential expires, call the [RefreshUploadVideo](~~RefreshUploadVideo~~) operation to obtain a new upload credential. The default validity period of an upload credential is 3,000 seconds.
        You can configure a callback to receive an event notification when an audio or video file is uploaded. Alternatively, after you upload an audio or video file, you can call the [GetMezzanineInfo](https://help.aliyun.com/document_detail/59624.html) operation to determine whether the upload is successful. For more information, see [Overview](https://help.aliyun.com/document_detail/55396.html).
        The value of the VideoId parameter that is returned after you call this operation can be used for media processing or the lifecycle management of media assets.
        You must obtain a URL and a credential before you upload a media file to ApsaraVideo VOD. ApsaraVideo VOD supports multiple upload methods. Each method has different requirements on upload URLs and credentials. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        
        @param request: CreateUploadVideoRequest
        @return: CreateUploadVideoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_upload_video_with_options_async(request, runtime)

    def create_vod_real_time_log_delivery_with_options(
        self,
        request: vod_20170321_models.CreateVodRealTimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateVodRealTimeLogDeliveryResponse:
        """
        @summary 创建日志
        
        @param request: CreateVodRealTimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVodRealTimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVodRealTimeLogDelivery',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateVodRealTimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vod_real_time_log_delivery_with_options_async(
        self,
        request: vod_20170321_models.CreateVodRealTimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateVodRealTimeLogDeliveryResponse:
        """
        @summary 创建日志
        
        @param request: CreateVodRealTimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVodRealTimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVodRealTimeLogDelivery',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateVodRealTimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vod_real_time_log_delivery(
        self,
        request: vod_20170321_models.CreateVodRealTimeLogDeliveryRequest,
    ) -> vod_20170321_models.CreateVodRealTimeLogDeliveryResponse:
        """
        @summary 创建日志
        
        @param request: CreateVodRealTimeLogDeliveryRequest
        @return: CreateVodRealTimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vod_real_time_log_delivery_with_options(request, runtime)

    async def create_vod_real_time_log_delivery_async(
        self,
        request: vod_20170321_models.CreateVodRealTimeLogDeliveryRequest,
    ) -> vod_20170321_models.CreateVodRealTimeLogDeliveryResponse:
        """
        @summary 创建日志
        
        @param request: CreateVodRealTimeLogDeliveryRequest
        @return: CreateVodRealTimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vod_real_time_log_delivery_with_options_async(request, runtime)

    def create_vod_user_usage_detail_data_export_task_with_options(
        self,
        request: vod_20170321_models.CreateVodUserUsageDetailDataExportTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateVodUserUsageDetailDataExportTaskResponse:
        """
        @summary 创建用量导出任务
        
        @param request: CreateVodUserUsageDetailDataExportTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVodUserUsageDetailDataExportTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dimension):
            query['Dimension'] = request.dimension
        if not UtilClient.is_unset(request.domain_names):
            query['DomainNames'] = request.domain_names
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.group):
            query['Group'] = request.group
        if not UtilClient.is_unset(request.language):
            query['Language'] = request.language
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.task_name):
            query['TaskName'] = request.task_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVodUserUsageDetailDataExportTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateVodUserUsageDetailDataExportTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_vod_user_usage_detail_data_export_task_with_options_async(
        self,
        request: vod_20170321_models.CreateVodUserUsageDetailDataExportTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.CreateVodUserUsageDetailDataExportTaskResponse:
        """
        @summary 创建用量导出任务
        
        @param request: CreateVodUserUsageDetailDataExportTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateVodUserUsageDetailDataExportTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dimension):
            query['Dimension'] = request.dimension
        if not UtilClient.is_unset(request.domain_names):
            query['DomainNames'] = request.domain_names
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.group):
            query['Group'] = request.group
        if not UtilClient.is_unset(request.language):
            query['Language'] = request.language
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.task_name):
            query['TaskName'] = request.task_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateVodUserUsageDetailDataExportTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.CreateVodUserUsageDetailDataExportTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_vod_user_usage_detail_data_export_task(
        self,
        request: vod_20170321_models.CreateVodUserUsageDetailDataExportTaskRequest,
    ) -> vod_20170321_models.CreateVodUserUsageDetailDataExportTaskResponse:
        """
        @summary 创建用量导出任务
        
        @param request: CreateVodUserUsageDetailDataExportTaskRequest
        @return: CreateVodUserUsageDetailDataExportTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_vod_user_usage_detail_data_export_task_with_options(request, runtime)

    async def create_vod_user_usage_detail_data_export_task_async(
        self,
        request: vod_20170321_models.CreateVodUserUsageDetailDataExportTaskRequest,
    ) -> vod_20170321_models.CreateVodUserUsageDetailDataExportTaskResponse:
        """
        @summary 创建用量导出任务
        
        @param request: CreateVodUserUsageDetailDataExportTaskRequest
        @return: CreateVodUserUsageDetailDataExportTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_vod_user_usage_detail_data_export_task_with_options_async(request, runtime)

    def decrypt_kmsdata_key_with_options(
        self,
        request: vod_20170321_models.DecryptKMSDataKeyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DecryptKMSDataKeyResponse:
        """
        @summary Decrypts the ciphertext specified by CiphertextBlob in the Key Management Service (KMS) data key.
        
        @param request: DecryptKMSDataKeyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DecryptKMSDataKeyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cipher_text):
            query['CipherText'] = request.cipher_text
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DecryptKMSDataKey',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DecryptKMSDataKeyResponse(),
            self.call_api(params, req, runtime)
        )

    async def decrypt_kmsdata_key_with_options_async(
        self,
        request: vod_20170321_models.DecryptKMSDataKeyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DecryptKMSDataKeyResponse:
        """
        @summary Decrypts the ciphertext specified by CiphertextBlob in the Key Management Service (KMS) data key.
        
        @param request: DecryptKMSDataKeyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DecryptKMSDataKeyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cipher_text):
            query['CipherText'] = request.cipher_text
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DecryptKMSDataKey',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DecryptKMSDataKeyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def decrypt_kmsdata_key(
        self,
        request: vod_20170321_models.DecryptKMSDataKeyRequest,
    ) -> vod_20170321_models.DecryptKMSDataKeyResponse:
        """
        @summary Decrypts the ciphertext specified by CiphertextBlob in the Key Management Service (KMS) data key.
        
        @param request: DecryptKMSDataKeyRequest
        @return: DecryptKMSDataKeyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.decrypt_kmsdata_key_with_options(request, runtime)

    async def decrypt_kmsdata_key_async(
        self,
        request: vod_20170321_models.DecryptKMSDataKeyRequest,
    ) -> vod_20170321_models.DecryptKMSDataKeyResponse:
        """
        @summary Decrypts the ciphertext specified by CiphertextBlob in the Key Management Service (KMS) data key.
        
        @param request: DecryptKMSDataKeyRequest
        @return: DecryptKMSDataKeyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.decrypt_kmsdata_key_with_options_async(request, runtime)

    def del_app_with_options(
        self,
        request: vod_20170321_models.DelAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DelAppResponse:
        """
        @summary 删除app
        
        @param request: DelAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DelAppResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_item_id):
            body['AppItemId'] = request.app_item_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='DelApp',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DelAppResponse(),
            self.call_api(params, req, runtime)
        )

    async def del_app_with_options_async(
        self,
        request: vod_20170321_models.DelAppRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DelAppResponse:
        """
        @summary 删除app
        
        @param request: DelAppRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DelAppResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_item_id):
            body['AppItemId'] = request.app_item_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='DelApp',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DelAppResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def del_app(
        self,
        request: vod_20170321_models.DelAppRequest,
    ) -> vod_20170321_models.DelAppResponse:
        """
        @summary 删除app
        
        @param request: DelAppRequest
        @return: DelAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.del_app_with_options(request, runtime)

    async def del_app_async(
        self,
        request: vod_20170321_models.DelAppRequest,
    ) -> vod_20170321_models.DelAppResponse:
        """
        @summary 删除app
        
        @param request: DelAppRequest
        @return: DelAppResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.del_app_with_options_async(request, runtime)

    def del_free_license_with_options(
        self,
        request: vod_20170321_models.DelFreeLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DelFreeLicenseResponse:
        """
        @summary 删除免费license
        
        @param request: DelFreeLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DelFreeLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.license_item_id):
            query['LicenseItemId'] = request.license_item_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DelFreeLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DelFreeLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def del_free_license_with_options_async(
        self,
        request: vod_20170321_models.DelFreeLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DelFreeLicenseResponse:
        """
        @summary 删除免费license
        
        @param request: DelFreeLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DelFreeLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.license_item_id):
            query['LicenseItemId'] = request.license_item_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DelFreeLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DelFreeLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def del_free_license(
        self,
        request: vod_20170321_models.DelFreeLicenseRequest,
    ) -> vod_20170321_models.DelFreeLicenseResponse:
        """
        @summary 删除免费license
        
        @param request: DelFreeLicenseRequest
        @return: DelFreeLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.del_free_license_with_options(request, runtime)

    async def del_free_license_async(
        self,
        request: vod_20170321_models.DelFreeLicenseRequest,
    ) -> vod_20170321_models.DelFreeLicenseResponse:
        """
        @summary 删除免费license
        
        @param request: DelFreeLicenseRequest
        @return: DelFreeLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.del_free_license_with_options_async(request, runtime)

    def delete_aiimage_infos_with_options(
        self,
        request: vod_20170321_models.DeleteAIImageInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteAIImageInfosResponse:
        """
        @summary Deletes the information about one or more images that are submitted for AI processing.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        This operation deletes only information about images that are submitted for AI processing. The image files are not deleted.
        
        @param request: DeleteAIImageInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAIImageInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aiimage_info_ids):
            query['AIImageInfoIds'] = request.aiimage_info_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAIImageInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteAIImageInfosResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_aiimage_infos_with_options_async(
        self,
        request: vod_20170321_models.DeleteAIImageInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteAIImageInfosResponse:
        """
        @summary Deletes the information about one or more images that are submitted for AI processing.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        This operation deletes only information about images that are submitted for AI processing. The image files are not deleted.
        
        @param request: DeleteAIImageInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAIImageInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aiimage_info_ids):
            query['AIImageInfoIds'] = request.aiimage_info_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAIImageInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteAIImageInfosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_aiimage_infos(
        self,
        request: vod_20170321_models.DeleteAIImageInfosRequest,
    ) -> vod_20170321_models.DeleteAIImageInfosResponse:
        """
        @summary Deletes the information about one or more images that are submitted for AI processing.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        This operation deletes only information about images that are submitted for AI processing. The image files are not deleted.
        
        @param request: DeleteAIImageInfosRequest
        @return: DeleteAIImageInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_aiimage_infos_with_options(request, runtime)

    async def delete_aiimage_infos_async(
        self,
        request: vod_20170321_models.DeleteAIImageInfosRequest,
    ) -> vod_20170321_models.DeleteAIImageInfosResponse:
        """
        @summary Deletes the information about one or more images that are submitted for AI processing.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        This operation deletes only information about images that are submitted for AI processing. The image files are not deleted.
        
        @param request: DeleteAIImageInfosRequest
        @return: DeleteAIImageInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_aiimage_infos_with_options_async(request, runtime)

    def delete_aitemplate_with_options(
        self,
        request: vod_20170321_models.DeleteAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteAITemplateResponse:
        """
        @summary Deletes an AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You cannot delete an AI template that is set as the default template.
        
        @param request: DeleteAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteAITemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_aitemplate_with_options_async(
        self,
        request: vod_20170321_models.DeleteAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteAITemplateResponse:
        """
        @summary Deletes an AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You cannot delete an AI template that is set as the default template.
        
        @param request: DeleteAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteAITemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_aitemplate(
        self,
        request: vod_20170321_models.DeleteAITemplateRequest,
    ) -> vod_20170321_models.DeleteAITemplateResponse:
        """
        @summary Deletes an AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You cannot delete an AI template that is set as the default template.
        
        @param request: DeleteAITemplateRequest
        @return: DeleteAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_aitemplate_with_options(request, runtime)

    async def delete_aitemplate_async(
        self,
        request: vod_20170321_models.DeleteAITemplateRequest,
    ) -> vod_20170321_models.DeleteAITemplateResponse:
        """
        @summary Deletes an AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You cannot delete an AI template that is set as the default template.
        
        @param request: DeleteAITemplateRequest
        @return: DeleteAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_aitemplate_with_options_async(request, runtime)

    def delete_app_info_with_options(
        self,
        request: vod_20170321_models.DeleteAppInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteAppInfoResponse:
        """
        @summary Deletes an application.
        
        @description Application with resources can not be deleted.
        
        @param request: DeleteAppInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAppInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAppInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteAppInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_app_info_with_options_async(
        self,
        request: vod_20170321_models.DeleteAppInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteAppInfoResponse:
        """
        @summary Deletes an application.
        
        @description Application with resources can not be deleted.
        
        @param request: DeleteAppInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAppInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAppInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteAppInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_app_info(
        self,
        request: vod_20170321_models.DeleteAppInfoRequest,
    ) -> vod_20170321_models.DeleteAppInfoResponse:
        """
        @summary Deletes an application.
        
        @description Application with resources can not be deleted.
        
        @param request: DeleteAppInfoRequest
        @return: DeleteAppInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_app_info_with_options(request, runtime)

    async def delete_app_info_async(
        self,
        request: vod_20170321_models.DeleteAppInfoRequest,
    ) -> vod_20170321_models.DeleteAppInfoResponse:
        """
        @summary Deletes an application.
        
        @description Application with resources can not be deleted.
        
        @param request: DeleteAppInfoRequest
        @return: DeleteAppInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_app_info_with_options_async(request, runtime)

    def delete_app_license_with_options(
        self,
        request: vod_20170321_models.DeleteAppLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteAppLicenseResponse:
        """
        @summary 删除应用授权
        
        @param request: DeleteAppLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAppLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.license_item_ids):
            query['LicenseItemIds'] = request.license_item_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAppLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteAppLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_app_license_with_options_async(
        self,
        request: vod_20170321_models.DeleteAppLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteAppLicenseResponse:
        """
        @summary 删除应用授权
        
        @param request: DeleteAppLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAppLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.license_item_ids):
            query['LicenseItemIds'] = request.license_item_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAppLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteAppLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_app_license(
        self,
        request: vod_20170321_models.DeleteAppLicenseRequest,
    ) -> vod_20170321_models.DeleteAppLicenseResponse:
        """
        @summary 删除应用授权
        
        @param request: DeleteAppLicenseRequest
        @return: DeleteAppLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_app_license_with_options(request, runtime)

    async def delete_app_license_async(
        self,
        request: vod_20170321_models.DeleteAppLicenseRequest,
    ) -> vod_20170321_models.DeleteAppLicenseResponse:
        """
        @summary 删除应用授权
        
        @param request: DeleteAppLicenseRequest
        @return: DeleteAppLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_app_license_with_options_async(request, runtime)

    def delete_app_policy_with_options(
        self,
        request: vod_20170321_models.DeleteAppPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteAppPolicyResponse:
        """
        @summary 删除App策略
        
        @param request: DeleteAppPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAppPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy_names):
            query['PolicyNames'] = request.policy_names
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAppPolicy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteAppPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_app_policy_with_options_async(
        self,
        request: vod_20170321_models.DeleteAppPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteAppPolicyResponse:
        """
        @summary 删除App策略
        
        @param request: DeleteAppPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAppPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy_names):
            query['PolicyNames'] = request.policy_names
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAppPolicy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteAppPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_app_policy(
        self,
        request: vod_20170321_models.DeleteAppPolicyRequest,
    ) -> vod_20170321_models.DeleteAppPolicyResponse:
        """
        @summary 删除App策略
        
        @param request: DeleteAppPolicyRequest
        @return: DeleteAppPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_app_policy_with_options(request, runtime)

    async def delete_app_policy_async(
        self,
        request: vod_20170321_models.DeleteAppPolicyRequest,
    ) -> vod_20170321_models.DeleteAppPolicyResponse:
        """
        @summary 删除App策略
        
        @param request: DeleteAppPolicyRequest
        @return: DeleteAppPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_app_policy_with_options_async(request, runtime)

    def delete_attached_media_with_options(
        self,
        request: vod_20170321_models.DeleteAttachedMediaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteAttachedMediaResponse:
        """
        @summary Deletes auxiliary media assets from ApsaraVideo VOD. You can delete multiple auxiliary media assets such as watermark images, subtitle files, and materials in a batch.
        
        @description    **This operation physically deletes auxiliary media assets. You cannot recover the auxiliary media assets that you deleted. Exercise caution when you call this operation.**\
        You can delete a maximum of 20 auxiliary media assets in one request.
        
        @param request: DeleteAttachedMediaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAttachedMediaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAttachedMedia',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteAttachedMediaResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_attached_media_with_options_async(
        self,
        request: vod_20170321_models.DeleteAttachedMediaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteAttachedMediaResponse:
        """
        @summary Deletes auxiliary media assets from ApsaraVideo VOD. You can delete multiple auxiliary media assets such as watermark images, subtitle files, and materials in a batch.
        
        @description    **This operation physically deletes auxiliary media assets. You cannot recover the auxiliary media assets that you deleted. Exercise caution when you call this operation.**\
        You can delete a maximum of 20 auxiliary media assets in one request.
        
        @param request: DeleteAttachedMediaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAttachedMediaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAttachedMedia',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteAttachedMediaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_attached_media(
        self,
        request: vod_20170321_models.DeleteAttachedMediaRequest,
    ) -> vod_20170321_models.DeleteAttachedMediaResponse:
        """
        @summary Deletes auxiliary media assets from ApsaraVideo VOD. You can delete multiple auxiliary media assets such as watermark images, subtitle files, and materials in a batch.
        
        @description    **This operation physically deletes auxiliary media assets. You cannot recover the auxiliary media assets that you deleted. Exercise caution when you call this operation.**\
        You can delete a maximum of 20 auxiliary media assets in one request.
        
        @param request: DeleteAttachedMediaRequest
        @return: DeleteAttachedMediaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_attached_media_with_options(request, runtime)

    async def delete_attached_media_async(
        self,
        request: vod_20170321_models.DeleteAttachedMediaRequest,
    ) -> vod_20170321_models.DeleteAttachedMediaResponse:
        """
        @summary Deletes auxiliary media assets from ApsaraVideo VOD. You can delete multiple auxiliary media assets such as watermark images, subtitle files, and materials in a batch.
        
        @description    **This operation physically deletes auxiliary media assets. You cannot recover the auxiliary media assets that you deleted. Exercise caution when you call this operation.**\
        You can delete a maximum of 20 auxiliary media assets in one request.
        
        @param request: DeleteAttachedMediaRequest
        @return: DeleteAttachedMediaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_attached_media_with_options_async(request, runtime)

    def delete_category_with_options(
        self,
        request: vod_20170321_models.DeleteCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteCategoryResponse:
        """
        @summary Deletes a category and its subcategories.
        
        @description    **After you call this operation to delete a category, all subcategories including level 2 and level 3 categories are deleted at the same time. Exercise caution when you call this operation.**\
        If you have classified specific media resources to a category, the category names labeled on these media resources are automatically deleted when you delete the category.
        
        @param request: DeleteCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCategory',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteCategoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_category_with_options_async(
        self,
        request: vod_20170321_models.DeleteCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteCategoryResponse:
        """
        @summary Deletes a category and its subcategories.
        
        @description    **After you call this operation to delete a category, all subcategories including level 2 and level 3 categories are deleted at the same time. Exercise caution when you call this operation.**\
        If you have classified specific media resources to a category, the category names labeled on these media resources are automatically deleted when you delete the category.
        
        @param request: DeleteCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCategory',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteCategoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_category(
        self,
        request: vod_20170321_models.DeleteCategoryRequest,
    ) -> vod_20170321_models.DeleteCategoryResponse:
        """
        @summary Deletes a category and its subcategories.
        
        @description    **After you call this operation to delete a category, all subcategories including level 2 and level 3 categories are deleted at the same time. Exercise caution when you call this operation.**\
        If you have classified specific media resources to a category, the category names labeled on these media resources are automatically deleted when you delete the category.
        
        @param request: DeleteCategoryRequest
        @return: DeleteCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_category_with_options(request, runtime)

    async def delete_category_async(
        self,
        request: vod_20170321_models.DeleteCategoryRequest,
    ) -> vod_20170321_models.DeleteCategoryResponse:
        """
        @summary Deletes a category and its subcategories.
        
        @description    **After you call this operation to delete a category, all subcategories including level 2 and level 3 categories are deleted at the same time. Exercise caution when you call this operation.**\
        If you have classified specific media resources to a category, the category names labeled on these media resources are automatically deleted when you delete the category.
        
        @param request: DeleteCategoryRequest
        @return: DeleteCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_category_with_options_async(request, runtime)

    def delete_custom_template_console_with_options(
        self,
        request: vod_20170321_models.DeleteCustomTemplateConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteCustomTemplateConsoleResponse:
        """
        @summary 删除模版
        
        @param request: DeleteCustomTemplateConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCustomTemplateConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.template_ids):
            query['TemplateIds'] = request.template_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCustomTemplateConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteCustomTemplateConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_custom_template_console_with_options_async(
        self,
        request: vod_20170321_models.DeleteCustomTemplateConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteCustomTemplateConsoleResponse:
        """
        @summary 删除模版
        
        @param request: DeleteCustomTemplateConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCustomTemplateConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.template_ids):
            query['TemplateIds'] = request.template_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteCustomTemplateConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteCustomTemplateConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_custom_template_console(
        self,
        request: vod_20170321_models.DeleteCustomTemplateConsoleRequest,
    ) -> vod_20170321_models.DeleteCustomTemplateConsoleResponse:
        """
        @summary 删除模版
        
        @param request: DeleteCustomTemplateConsoleRequest
        @return: DeleteCustomTemplateConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_custom_template_console_with_options(request, runtime)

    async def delete_custom_template_console_async(
        self,
        request: vod_20170321_models.DeleteCustomTemplateConsoleRequest,
    ) -> vod_20170321_models.DeleteCustomTemplateConsoleResponse:
        """
        @summary 删除模版
        
        @param request: DeleteCustomTemplateConsoleRequest
        @return: DeleteCustomTemplateConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_custom_template_console_with_options_async(request, runtime)

    def delete_dnadbwith_options(
        self,
        request: vod_20170321_models.DeleteDNADBRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteDNADBResponse:
        """
        @summary 删除DNA
        
        @param request: DeleteDNADBRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDNADBResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dbid):
            query['DBId'] = request.dbid
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDNADB',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteDNADBResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_dnadbwith_options_async(
        self,
        request: vod_20170321_models.DeleteDNADBRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteDNADBResponse:
        """
        @summary 删除DNA
        
        @param request: DeleteDNADBRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDNADBResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dbid):
            query['DBId'] = request.dbid
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDNADB',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteDNADBResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_dnadb(
        self,
        request: vod_20170321_models.DeleteDNADBRequest,
    ) -> vod_20170321_models.DeleteDNADBResponse:
        """
        @summary 删除DNA
        
        @param request: DeleteDNADBRequest
        @return: DeleteDNADBResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_dnadbwith_options(request, runtime)

    async def delete_dnadb_async(
        self,
        request: vod_20170321_models.DeleteDNADBRequest,
    ) -> vod_20170321_models.DeleteDNADBResponse:
        """
        @summary 删除DNA
        
        @param request: DeleteDNADBRequest
        @return: DeleteDNADBResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_dnadbwith_options_async(request, runtime)

    def delete_drmcert_info_with_options(
        self,
        request: vod_20170321_models.DeleteDRMCertInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteDRMCertInfoResponse:
        """
        @summary 删除drm证书
        
        @param request: DeleteDRMCertInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDRMCertInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_id):
            query['CertId'] = request.cert_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDRMCertInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteDRMCertInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_drmcert_info_with_options_async(
        self,
        request: vod_20170321_models.DeleteDRMCertInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteDRMCertInfoResponse:
        """
        @summary 删除drm证书
        
        @param request: DeleteDRMCertInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDRMCertInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_id):
            query['CertId'] = request.cert_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDRMCertInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteDRMCertInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_drmcert_info(
        self,
        request: vod_20170321_models.DeleteDRMCertInfoRequest,
    ) -> vod_20170321_models.DeleteDRMCertInfoResponse:
        """
        @summary 删除drm证书
        
        @param request: DeleteDRMCertInfoRequest
        @return: DeleteDRMCertInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_drmcert_info_with_options(request, runtime)

    async def delete_drmcert_info_async(
        self,
        request: vod_20170321_models.DeleteDRMCertInfoRequest,
    ) -> vod_20170321_models.DeleteDRMCertInfoResponse:
        """
        @summary 删除drm证书
        
        @param request: DeleteDRMCertInfoRequest
        @return: DeleteDRMCertInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_drmcert_info_with_options_async(request, runtime)

    def delete_dynamic_image_with_options(
        self,
        request: vod_20170321_models.DeleteDynamicImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteDynamicImageResponse:
        """
        @summary Deletes the information about animated stickers.
        
        @description > This operation deletes only the information about animated stickers, but not the animated stickers themselves.
        
        @param request: DeleteDynamicImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDynamicImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dynamic_image_ids):
            query['DynamicImageIds'] = request.dynamic_image_ids
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDynamicImage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteDynamicImageResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_dynamic_image_with_options_async(
        self,
        request: vod_20170321_models.DeleteDynamicImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteDynamicImageResponse:
        """
        @summary Deletes the information about animated stickers.
        
        @description > This operation deletes only the information about animated stickers, but not the animated stickers themselves.
        
        @param request: DeleteDynamicImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDynamicImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dynamic_image_ids):
            query['DynamicImageIds'] = request.dynamic_image_ids
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDynamicImage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteDynamicImageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_dynamic_image(
        self,
        request: vod_20170321_models.DeleteDynamicImageRequest,
    ) -> vod_20170321_models.DeleteDynamicImageResponse:
        """
        @summary Deletes the information about animated stickers.
        
        @description > This operation deletes only the information about animated stickers, but not the animated stickers themselves.
        
        @param request: DeleteDynamicImageRequest
        @return: DeleteDynamicImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_dynamic_image_with_options(request, runtime)

    async def delete_dynamic_image_async(
        self,
        request: vod_20170321_models.DeleteDynamicImageRequest,
    ) -> vod_20170321_models.DeleteDynamicImageResponse:
        """
        @summary Deletes the information about animated stickers.
        
        @description > This operation deletes only the information about animated stickers, but not the animated stickers themselves.
        
        @param request: DeleteDynamicImageRequest
        @return: DeleteDynamicImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_dynamic_image_with_options_async(request, runtime)

    def delete_editing_project_with_options(
        self,
        request: vod_20170321_models.DeleteEditingProjectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteEditingProjectResponse:
        """
        @summary Deletes online editing projects.
        
        @description    You can call this operation to delete multiple online editing projects at a time.
        
        @param request: DeleteEditingProjectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEditingProjectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_ids):
            query['ProjectIds'] = request.project_ids
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEditingProject',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteEditingProjectResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_editing_project_with_options_async(
        self,
        request: vod_20170321_models.DeleteEditingProjectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteEditingProjectResponse:
        """
        @summary Deletes online editing projects.
        
        @description    You can call this operation to delete multiple online editing projects at a time.
        
        @param request: DeleteEditingProjectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEditingProjectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_ids):
            query['ProjectIds'] = request.project_ids
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEditingProject',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteEditingProjectResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_editing_project(
        self,
        request: vod_20170321_models.DeleteEditingProjectRequest,
    ) -> vod_20170321_models.DeleteEditingProjectResponse:
        """
        @summary Deletes online editing projects.
        
        @description    You can call this operation to delete multiple online editing projects at a time.
        
        @param request: DeleteEditingProjectRequest
        @return: DeleteEditingProjectResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_editing_project_with_options(request, runtime)

    async def delete_editing_project_async(
        self,
        request: vod_20170321_models.DeleteEditingProjectRequest,
    ) -> vod_20170321_models.DeleteEditingProjectResponse:
        """
        @summary Deletes online editing projects.
        
        @description    You can call this operation to delete multiple online editing projects at a time.
        
        @param request: DeleteEditingProjectRequest
        @return: DeleteEditingProjectResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_editing_project_with_options_async(request, runtime)

    def delete_editing_project_materials_with_options(
        self,
        request: vod_20170321_models.DeleteEditingProjectMaterialsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteEditingProjectMaterialsResponse:
        """
        @summary 删除剪辑资源
        
        @param request: DeleteEditingProjectMaterialsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEditingProjectMaterialsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.material_ids):
            query['MaterialIds'] = request.material_ids
        if not UtilClient.is_unset(request.material_type):
            query['MaterialType'] = request.material_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEditingProjectMaterials',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteEditingProjectMaterialsResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_editing_project_materials_with_options_async(
        self,
        request: vod_20170321_models.DeleteEditingProjectMaterialsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteEditingProjectMaterialsResponse:
        """
        @summary 删除剪辑资源
        
        @param request: DeleteEditingProjectMaterialsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEditingProjectMaterialsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.material_ids):
            query['MaterialIds'] = request.material_ids
        if not UtilClient.is_unset(request.material_type):
            query['MaterialType'] = request.material_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEditingProjectMaterials',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteEditingProjectMaterialsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_editing_project_materials(
        self,
        request: vod_20170321_models.DeleteEditingProjectMaterialsRequest,
    ) -> vod_20170321_models.DeleteEditingProjectMaterialsResponse:
        """
        @summary 删除剪辑资源
        
        @param request: DeleteEditingProjectMaterialsRequest
        @return: DeleteEditingProjectMaterialsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_editing_project_materials_with_options(request, runtime)

    async def delete_editing_project_materials_async(
        self,
        request: vod_20170321_models.DeleteEditingProjectMaterialsRequest,
    ) -> vod_20170321_models.DeleteEditingProjectMaterialsResponse:
        """
        @summary 删除剪辑资源
        
        @param request: DeleteEditingProjectMaterialsRequest
        @return: DeleteEditingProjectMaterialsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_editing_project_materials_with_options_async(request, runtime)

    def delete_filter_configs_with_options(
        self,
        request: vod_20170321_models.DeleteFilterConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteFilterConfigsResponse:
        """
        @summary 删除过滤条件
        
        @param request: DeleteFilterConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteFilterConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.uu_id):
            query['UuId'] = request.uu_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteFilterConfigs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteFilterConfigsResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_filter_configs_with_options_async(
        self,
        request: vod_20170321_models.DeleteFilterConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteFilterConfigsResponse:
        """
        @summary 删除过滤条件
        
        @param request: DeleteFilterConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteFilterConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.uu_id):
            query['UuId'] = request.uu_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteFilterConfigs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteFilterConfigsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_filter_configs(
        self,
        request: vod_20170321_models.DeleteFilterConfigsRequest,
    ) -> vod_20170321_models.DeleteFilterConfigsResponse:
        """
        @summary 删除过滤条件
        
        @param request: DeleteFilterConfigsRequest
        @return: DeleteFilterConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_filter_configs_with_options(request, runtime)

    async def delete_filter_configs_async(
        self,
        request: vod_20170321_models.DeleteFilterConfigsRequest,
    ) -> vod_20170321_models.DeleteFilterConfigsResponse:
        """
        @summary 删除过滤条件
        
        @param request: DeleteFilterConfigsRequest
        @return: DeleteFilterConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_filter_configs_with_options_async(request, runtime)

    def delete_free_license_with_options(
        self,
        request: vod_20170321_models.DeleteFreeLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteFreeLicenseResponse:
        """
        @summary 删除免费license
        
        @param request: DeleteFreeLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteFreeLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.license_item_id):
            query['LicenseItemId'] = request.license_item_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteFreeLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteFreeLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_free_license_with_options_async(
        self,
        request: vod_20170321_models.DeleteFreeLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteFreeLicenseResponse:
        """
        @summary 删除免费license
        
        @param request: DeleteFreeLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteFreeLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.license_item_id):
            query['LicenseItemId'] = request.license_item_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteFreeLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteFreeLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_free_license(
        self,
        request: vod_20170321_models.DeleteFreeLicenseRequest,
    ) -> vod_20170321_models.DeleteFreeLicenseResponse:
        """
        @summary 删除免费license
        
        @param request: DeleteFreeLicenseRequest
        @return: DeleteFreeLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_free_license_with_options(request, runtime)

    async def delete_free_license_async(
        self,
        request: vod_20170321_models.DeleteFreeLicenseRequest,
    ) -> vod_20170321_models.DeleteFreeLicenseResponse:
        """
        @summary 删除免费license
        
        @param request: DeleteFreeLicenseRequest
        @return: DeleteFreeLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_free_license_with_options_async(request, runtime)

    def delete_image_with_options(
        self,
        request: vod_20170321_models.DeleteImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteImageResponse:
        """
        @summary Deletes uploaded images and video snapshots that are automatically captured.
        
        @description    **After you call this operation to delete an image, the source file is permanently deleted and cannot be recovered. Exercise caution when you call this operation.**\
        If some images are cached on Alibaba Cloud CDN points of presence (POPs), the image URLs do not immediately become invalid.
        You can call this operation to delete uploaded images and video snapshots.
        
        @param request: DeleteImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.delete_image_type):
            query['DeleteImageType'] = request.delete_image_type
        if not UtilClient.is_unset(request.image_ids):
            query['ImageIds'] = request.image_ids
        if not UtilClient.is_unset(request.image_type):
            query['ImageType'] = request.image_type
        if not UtilClient.is_unset(request.image_urls):
            query['ImageURLs'] = request.image_urls
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteImage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteImageResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_image_with_options_async(
        self,
        request: vod_20170321_models.DeleteImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteImageResponse:
        """
        @summary Deletes uploaded images and video snapshots that are automatically captured.
        
        @description    **After you call this operation to delete an image, the source file is permanently deleted and cannot be recovered. Exercise caution when you call this operation.**\
        If some images are cached on Alibaba Cloud CDN points of presence (POPs), the image URLs do not immediately become invalid.
        You can call this operation to delete uploaded images and video snapshots.
        
        @param request: DeleteImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.delete_image_type):
            query['DeleteImageType'] = request.delete_image_type
        if not UtilClient.is_unset(request.image_ids):
            query['ImageIds'] = request.image_ids
        if not UtilClient.is_unset(request.image_type):
            query['ImageType'] = request.image_type
        if not UtilClient.is_unset(request.image_urls):
            query['ImageURLs'] = request.image_urls
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteImage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteImageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_image(
        self,
        request: vod_20170321_models.DeleteImageRequest,
    ) -> vod_20170321_models.DeleteImageResponse:
        """
        @summary Deletes uploaded images and video snapshots that are automatically captured.
        
        @description    **After you call this operation to delete an image, the source file is permanently deleted and cannot be recovered. Exercise caution when you call this operation.**\
        If some images are cached on Alibaba Cloud CDN points of presence (POPs), the image URLs do not immediately become invalid.
        You can call this operation to delete uploaded images and video snapshots.
        
        @param request: DeleteImageRequest
        @return: DeleteImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_image_with_options(request, runtime)

    async def delete_image_async(
        self,
        request: vod_20170321_models.DeleteImageRequest,
    ) -> vod_20170321_models.DeleteImageResponse:
        """
        @summary Deletes uploaded images and video snapshots that are automatically captured.
        
        @description    **After you call this operation to delete an image, the source file is permanently deleted and cannot be recovered. Exercise caution when you call this operation.**\
        If some images are cached on Alibaba Cloud CDN points of presence (POPs), the image URLs do not immediately become invalid.
        You can call this operation to delete uploaded images and video snapshots.
        
        @param request: DeleteImageRequest
        @return: DeleteImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_image_with_options_async(request, runtime)

    def delete_intelligent_strategy_with_options(
        self,
        request: vod_20170321_models.DeleteIntelligentStrategyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteIntelligentStrategyResponse:
        """
        @summary 删除智能策略信息
        
        @param request: DeleteIntelligentStrategyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIntelligentStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.strategy_id):
            query['StrategyId'] = request.strategy_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIntelligentStrategy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteIntelligentStrategyResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_intelligent_strategy_with_options_async(
        self,
        request: vod_20170321_models.DeleteIntelligentStrategyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteIntelligentStrategyResponse:
        """
        @summary 删除智能策略信息
        
        @param request: DeleteIntelligentStrategyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIntelligentStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.strategy_id):
            query['StrategyId'] = request.strategy_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIntelligentStrategy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteIntelligentStrategyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_intelligent_strategy(
        self,
        request: vod_20170321_models.DeleteIntelligentStrategyRequest,
    ) -> vod_20170321_models.DeleteIntelligentStrategyResponse:
        """
        @summary 删除智能策略信息
        
        @param request: DeleteIntelligentStrategyRequest
        @return: DeleteIntelligentStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_intelligent_strategy_with_options(request, runtime)

    async def delete_intelligent_strategy_async(
        self,
        request: vod_20170321_models.DeleteIntelligentStrategyRequest,
    ) -> vod_20170321_models.DeleteIntelligentStrategyResponse:
        """
        @summary 删除智能策略信息
        
        @param request: DeleteIntelligentStrategyRequest
        @return: DeleteIntelligentStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_intelligent_strategy_with_options_async(request, runtime)

    def delete_media_export_jobs_with_options(
        self,
        request: vod_20170321_models.DeleteMediaExportJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteMediaExportJobsResponse:
        """
        @summary 删除媒资导出任务
        
        @param request: DeleteMediaExportJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMediaExportJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMediaExportJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteMediaExportJobsResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_media_export_jobs_with_options_async(
        self,
        request: vod_20170321_models.DeleteMediaExportJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteMediaExportJobsResponse:
        """
        @summary 删除媒资导出任务
        
        @param request: DeleteMediaExportJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMediaExportJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMediaExportJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteMediaExportJobsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_media_export_jobs(
        self,
        request: vod_20170321_models.DeleteMediaExportJobsRequest,
    ) -> vod_20170321_models.DeleteMediaExportJobsResponse:
        """
        @summary 删除媒资导出任务
        
        @param request: DeleteMediaExportJobsRequest
        @return: DeleteMediaExportJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_media_export_jobs_with_options(request, runtime)

    async def delete_media_export_jobs_async(
        self,
        request: vod_20170321_models.DeleteMediaExportJobsRequest,
    ) -> vod_20170321_models.DeleteMediaExportJobsResponse:
        """
        @summary 删除媒资导出任务
        
        @param request: DeleteMediaExportJobsRequest
        @return: DeleteMediaExportJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_media_export_jobs_with_options_async(request, runtime)

    def delete_media_lifecycle_rule_with_options(
        self,
        request: vod_20170321_models.DeleteMediaLifecycleRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteMediaLifecycleRuleResponse:
        """
        @summary 删除生命周期
        
        @param request: DeleteMediaLifecycleRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMediaLifecycleRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.rule_ids):
            query['RuleIds'] = request.rule_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMediaLifecycleRule',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteMediaLifecycleRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_media_lifecycle_rule_with_options_async(
        self,
        request: vod_20170321_models.DeleteMediaLifecycleRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteMediaLifecycleRuleResponse:
        """
        @summary 删除生命周期
        
        @param request: DeleteMediaLifecycleRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMediaLifecycleRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.rule_ids):
            query['RuleIds'] = request.rule_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMediaLifecycleRule',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteMediaLifecycleRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_media_lifecycle_rule(
        self,
        request: vod_20170321_models.DeleteMediaLifecycleRuleRequest,
    ) -> vod_20170321_models.DeleteMediaLifecycleRuleResponse:
        """
        @summary 删除生命周期
        
        @param request: DeleteMediaLifecycleRuleRequest
        @return: DeleteMediaLifecycleRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_media_lifecycle_rule_with_options(request, runtime)

    async def delete_media_lifecycle_rule_async(
        self,
        request: vod_20170321_models.DeleteMediaLifecycleRuleRequest,
    ) -> vod_20170321_models.DeleteMediaLifecycleRuleResponse:
        """
        @summary 删除生命周期
        
        @param request: DeleteMediaLifecycleRuleRequest
        @return: DeleteMediaLifecycleRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_media_lifecycle_rule_with_options_async(request, runtime)

    def delete_message_callback_with_options(
        self,
        request: vod_20170321_models.DeleteMessageCallbackRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteMessageCallbackResponse:
        """
        @summary Deletes the callback method, callback URL, and event type of an event notification.
        
        @description > For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: DeleteMessageCallbackRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMessageCallbackResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMessageCallback',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteMessageCallbackResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_message_callback_with_options_async(
        self,
        request: vod_20170321_models.DeleteMessageCallbackRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteMessageCallbackResponse:
        """
        @summary Deletes the callback method, callback URL, and event type of an event notification.
        
        @description > For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: DeleteMessageCallbackRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMessageCallbackResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMessageCallback',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteMessageCallbackResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_message_callback(
        self,
        request: vod_20170321_models.DeleteMessageCallbackRequest,
    ) -> vod_20170321_models.DeleteMessageCallbackResponse:
        """
        @summary Deletes the callback method, callback URL, and event type of an event notification.
        
        @description > For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: DeleteMessageCallbackRequest
        @return: DeleteMessageCallbackResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_message_callback_with_options(request, runtime)

    async def delete_message_callback_async(
        self,
        request: vod_20170321_models.DeleteMessageCallbackRequest,
    ) -> vod_20170321_models.DeleteMessageCallbackResponse:
        """
        @summary Deletes the callback method, callback URL, and event type of an event notification.
        
        @description > For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: DeleteMessageCallbackRequest
        @return: DeleteMessageCallbackResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_message_callback_with_options_async(request, runtime)

    def delete_message_cloud_monitor_config_with_options(
        self,
        request: vod_20170321_models.DeleteMessageCloudMonitorConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteMessageCloudMonitorConfigResponse:
        """
        @summary 删除云监控配置
        
        @param request: DeleteMessageCloudMonitorConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMessageCloudMonitorConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMessageCloudMonitorConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteMessageCloudMonitorConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_message_cloud_monitor_config_with_options_async(
        self,
        request: vod_20170321_models.DeleteMessageCloudMonitorConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteMessageCloudMonitorConfigResponse:
        """
        @summary 删除云监控配置
        
        @param request: DeleteMessageCloudMonitorConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMessageCloudMonitorConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMessageCloudMonitorConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteMessageCloudMonitorConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_message_cloud_monitor_config(
        self,
        request: vod_20170321_models.DeleteMessageCloudMonitorConfigRequest,
    ) -> vod_20170321_models.DeleteMessageCloudMonitorConfigResponse:
        """
        @summary 删除云监控配置
        
        @param request: DeleteMessageCloudMonitorConfigRequest
        @return: DeleteMessageCloudMonitorConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_message_cloud_monitor_config_with_options(request, runtime)

    async def delete_message_cloud_monitor_config_async(
        self,
        request: vod_20170321_models.DeleteMessageCloudMonitorConfigRequest,
    ) -> vod_20170321_models.DeleteMessageCloudMonitorConfigResponse:
        """
        @summary 删除云监控配置
        
        @param request: DeleteMessageCloudMonitorConfigRequest
        @return: DeleteMessageCloudMonitorConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_message_cloud_monitor_config_with_options_async(request, runtime)

    def delete_mezzanines_with_options(
        self,
        request: vod_20170321_models.DeleteMezzaninesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteMezzaninesResponse:
        """
        @summary Deletes one or more source files at a time.
        
        @description All media processing operations in ApsaraVideo VOD, such as transcoding, snapshot capture, and content moderation, are performed based on source files. If you delete the source files, you cannot perform media processing operations. Exercise caution when you call this operation.
        
        @param request: DeleteMezzaninesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMezzaninesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.video_ids):
            query['VideoIds'] = request.video_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMezzanines',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteMezzaninesResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_mezzanines_with_options_async(
        self,
        request: vod_20170321_models.DeleteMezzaninesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteMezzaninesResponse:
        """
        @summary Deletes one or more source files at a time.
        
        @description All media processing operations in ApsaraVideo VOD, such as transcoding, snapshot capture, and content moderation, are performed based on source files. If you delete the source files, you cannot perform media processing operations. Exercise caution when you call this operation.
        
        @param request: DeleteMezzaninesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMezzaninesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.video_ids):
            query['VideoIds'] = request.video_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMezzanines',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteMezzaninesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_mezzanines(
        self,
        request: vod_20170321_models.DeleteMezzaninesRequest,
    ) -> vod_20170321_models.DeleteMezzaninesResponse:
        """
        @summary Deletes one or more source files at a time.
        
        @description All media processing operations in ApsaraVideo VOD, such as transcoding, snapshot capture, and content moderation, are performed based on source files. If you delete the source files, you cannot perform media processing operations. Exercise caution when you call this operation.
        
        @param request: DeleteMezzaninesRequest
        @return: DeleteMezzaninesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_mezzanines_with_options(request, runtime)

    async def delete_mezzanines_async(
        self,
        request: vod_20170321_models.DeleteMezzaninesRequest,
    ) -> vod_20170321_models.DeleteMezzaninesResponse:
        """
        @summary Deletes one or more source files at a time.
        
        @description All media processing operations in ApsaraVideo VOD, such as transcoding, snapshot capture, and content moderation, are performed based on source files. If you delete the source files, you cannot perform media processing operations. Exercise caution when you call this operation.
        
        @param request: DeleteMezzaninesRequest
        @return: DeleteMezzaninesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_mezzanines_with_options_async(request, runtime)

    def delete_multipart_upload_with_options(
        self,
        request: vod_20170321_models.DeleteMultipartUploadRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteMultipartUploadResponse:
        """
        @summary Deletes the parts generated during an upload.
        
        @description    During multipart upload, useless parts may be retained if the upload fails. These useless parts are automatically deleted after 7 days. You can call this operation to delete the generated parts after the upload is successful or fails.
        This operation does not delete the source file or transcoded file, but deletes only the parts generated during the upload.
        If you call the [DeleteVideo](https://help.aliyun.com/document_detail/52837.html) operation, the entire video file is deleted, including the generated parts.
        
        @param request: DeleteMultipartUploadRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMultipartUploadResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMultipartUpload',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteMultipartUploadResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_multipart_upload_with_options_async(
        self,
        request: vod_20170321_models.DeleteMultipartUploadRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteMultipartUploadResponse:
        """
        @summary Deletes the parts generated during an upload.
        
        @description    During multipart upload, useless parts may be retained if the upload fails. These useless parts are automatically deleted after 7 days. You can call this operation to delete the generated parts after the upload is successful or fails.
        This operation does not delete the source file or transcoded file, but deletes only the parts generated during the upload.
        If you call the [DeleteVideo](https://help.aliyun.com/document_detail/52837.html) operation, the entire video file is deleted, including the generated parts.
        
        @param request: DeleteMultipartUploadRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMultipartUploadResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMultipartUpload',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteMultipartUploadResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_multipart_upload(
        self,
        request: vod_20170321_models.DeleteMultipartUploadRequest,
    ) -> vod_20170321_models.DeleteMultipartUploadResponse:
        """
        @summary Deletes the parts generated during an upload.
        
        @description    During multipart upload, useless parts may be retained if the upload fails. These useless parts are automatically deleted after 7 days. You can call this operation to delete the generated parts after the upload is successful or fails.
        This operation does not delete the source file or transcoded file, but deletes only the parts generated during the upload.
        If you call the [DeleteVideo](https://help.aliyun.com/document_detail/52837.html) operation, the entire video file is deleted, including the generated parts.
        
        @param request: DeleteMultipartUploadRequest
        @return: DeleteMultipartUploadResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_multipart_upload_with_options(request, runtime)

    async def delete_multipart_upload_async(
        self,
        request: vod_20170321_models.DeleteMultipartUploadRequest,
    ) -> vod_20170321_models.DeleteMultipartUploadResponse:
        """
        @summary Deletes the parts generated during an upload.
        
        @description    During multipart upload, useless parts may be retained if the upload fails. These useless parts are automatically deleted after 7 days. You can call this operation to delete the generated parts after the upload is successful or fails.
        This operation does not delete the source file or transcoded file, but deletes only the parts generated during the upload.
        If you call the [DeleteVideo](https://help.aliyun.com/document_detail/52837.html) operation, the entire video file is deleted, including the generated parts.
        
        @param request: DeleteMultipartUploadRequest
        @return: DeleteMultipartUploadResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_multipart_upload_with_options_async(request, runtime)

    def delete_storage_with_options(
        self,
        request: vod_20170321_models.DeleteStorageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteStorageResponse:
        """
        @summary 删除存储信息
        
        @param request: DeleteStorageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteStorageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteStorage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteStorageResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_storage_with_options_async(
        self,
        request: vod_20170321_models.DeleteStorageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteStorageResponse:
        """
        @summary 删除存储信息
        
        @param request: DeleteStorageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteStorageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteStorage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteStorageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_storage(
        self,
        request: vod_20170321_models.DeleteStorageRequest,
    ) -> vod_20170321_models.DeleteStorageResponse:
        """
        @summary 删除存储信息
        
        @param request: DeleteStorageRequest
        @return: DeleteStorageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_storage_with_options(request, runtime)

    async def delete_storage_async(
        self,
        request: vod_20170321_models.DeleteStorageRequest,
    ) -> vod_20170321_models.DeleteStorageResponse:
        """
        @summary 删除存储信息
        
        @param request: DeleteStorageRequest
        @return: DeleteStorageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_storage_with_options_async(request, runtime)

    def delete_stream_with_options(
        self,
        request: vod_20170321_models.DeleteStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteStreamResponse:
        """
        @summary Deletes one or more video or audio streams and their storage files at a time.
        
        @param request: DeleteStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteStream',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteStreamResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_stream_with_options_async(
        self,
        request: vod_20170321_models.DeleteStreamRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteStreamResponse:
        """
        @summary Deletes one or more video or audio streams and their storage files at a time.
        
        @param request: DeleteStreamRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteStreamResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteStream',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteStreamResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_stream(
        self,
        request: vod_20170321_models.DeleteStreamRequest,
    ) -> vod_20170321_models.DeleteStreamResponse:
        """
        @summary Deletes one or more video or audio streams and their storage files at a time.
        
        @param request: DeleteStreamRequest
        @return: DeleteStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_stream_with_options(request, runtime)

    async def delete_stream_async(
        self,
        request: vod_20170321_models.DeleteStreamRequest,
    ) -> vod_20170321_models.DeleteStreamResponse:
        """
        @summary Deletes one or more video or audio streams and their storage files at a time.
        
        @param request: DeleteStreamRequest
        @return: DeleteStreamResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_stream_with_options_async(request, runtime)

    def delete_template_group_console_with_options(
        self,
        request: vod_20170321_models.DeleteTemplateGroupConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteTemplateGroupConsoleResponse:
        """
        @summary 删除模版
        
        @param request: DeleteTemplateGroupConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTemplateGroupConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTemplateGroupConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteTemplateGroupConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_template_group_console_with_options_async(
        self,
        request: vod_20170321_models.DeleteTemplateGroupConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteTemplateGroupConsoleResponse:
        """
        @summary 删除模版
        
        @param request: DeleteTemplateGroupConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTemplateGroupConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTemplateGroupConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteTemplateGroupConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_template_group_console(
        self,
        request: vod_20170321_models.DeleteTemplateGroupConsoleRequest,
    ) -> vod_20170321_models.DeleteTemplateGroupConsoleResponse:
        """
        @summary 删除模版
        
        @param request: DeleteTemplateGroupConsoleRequest
        @return: DeleteTemplateGroupConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_template_group_console_with_options(request, runtime)

    async def delete_template_group_console_async(
        self,
        request: vod_20170321_models.DeleteTemplateGroupConsoleRequest,
    ) -> vod_20170321_models.DeleteTemplateGroupConsoleResponse:
        """
        @summary 删除模版
        
        @param request: DeleteTemplateGroupConsoleRequest
        @return: DeleteTemplateGroupConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_template_group_console_with_options_async(request, runtime)

    def delete_transcode_template_group_with_options(
        self,
        request: vod_20170321_models.DeleteTranscodeTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteTranscodeTemplateGroupResponse:
        """
        @summary Deletes one or more transcoding templates from a transcoding template group or forcibly deletes a transcoding template group.
        
        @description    You cannot call this operation to delete the default transcoding template. You can delete the transcoding template when it is no longer specified as the default one.
        For security purposes, you cannot add, modify, or delete transcoding templates in a transcoding template group that is locked. To check whether a transcoding template group is locked, call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation and obtain the Locked parameter from the response. To modify transcoding templates within a locked transcoding template group, you must call the [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to unlock the transcoding template group first.
        
        @param request: DeleteTranscodeTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTranscodeTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force_del_group):
            query['ForceDelGroup'] = request.force_del_group
        if not UtilClient.is_unset(request.transcode_template_group_id):
            query['TranscodeTemplateGroupId'] = request.transcode_template_group_id
        if not UtilClient.is_unset(request.transcode_template_ids):
            query['TranscodeTemplateIds'] = request.transcode_template_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTranscodeTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteTranscodeTemplateGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_transcode_template_group_with_options_async(
        self,
        request: vod_20170321_models.DeleteTranscodeTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteTranscodeTemplateGroupResponse:
        """
        @summary Deletes one or more transcoding templates from a transcoding template group or forcibly deletes a transcoding template group.
        
        @description    You cannot call this operation to delete the default transcoding template. You can delete the transcoding template when it is no longer specified as the default one.
        For security purposes, you cannot add, modify, or delete transcoding templates in a transcoding template group that is locked. To check whether a transcoding template group is locked, call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation and obtain the Locked parameter from the response. To modify transcoding templates within a locked transcoding template group, you must call the [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to unlock the transcoding template group first.
        
        @param request: DeleteTranscodeTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTranscodeTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force_del_group):
            query['ForceDelGroup'] = request.force_del_group
        if not UtilClient.is_unset(request.transcode_template_group_id):
            query['TranscodeTemplateGroupId'] = request.transcode_template_group_id
        if not UtilClient.is_unset(request.transcode_template_ids):
            query['TranscodeTemplateIds'] = request.transcode_template_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTranscodeTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteTranscodeTemplateGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_transcode_template_group(
        self,
        request: vod_20170321_models.DeleteTranscodeTemplateGroupRequest,
    ) -> vod_20170321_models.DeleteTranscodeTemplateGroupResponse:
        """
        @summary Deletes one or more transcoding templates from a transcoding template group or forcibly deletes a transcoding template group.
        
        @description    You cannot call this operation to delete the default transcoding template. You can delete the transcoding template when it is no longer specified as the default one.
        For security purposes, you cannot add, modify, or delete transcoding templates in a transcoding template group that is locked. To check whether a transcoding template group is locked, call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation and obtain the Locked parameter from the response. To modify transcoding templates within a locked transcoding template group, you must call the [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to unlock the transcoding template group first.
        
        @param request: DeleteTranscodeTemplateGroupRequest
        @return: DeleteTranscodeTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_transcode_template_group_with_options(request, runtime)

    async def delete_transcode_template_group_async(
        self,
        request: vod_20170321_models.DeleteTranscodeTemplateGroupRequest,
    ) -> vod_20170321_models.DeleteTranscodeTemplateGroupResponse:
        """
        @summary Deletes one or more transcoding templates from a transcoding template group or forcibly deletes a transcoding template group.
        
        @description    You cannot call this operation to delete the default transcoding template. You can delete the transcoding template when it is no longer specified as the default one.
        For security purposes, you cannot add, modify, or delete transcoding templates in a transcoding template group that is locked. To check whether a transcoding template group is locked, call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation and obtain the Locked parameter from the response. To modify transcoding templates within a locked transcoding template group, you must call the [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to unlock the transcoding template group first.
        
        @param request: DeleteTranscodeTemplateGroupRequest
        @return: DeleteTranscodeTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_transcode_template_group_with_options_async(request, runtime)

    def delete_transcode_templates_with_options(
        self,
        request: vod_20170321_models.DeleteTranscodeTemplatesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteTranscodeTemplatesResponse:
        """
        @summary 删除模版
        
        @param request: DeleteTranscodeTemplatesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTranscodeTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.transcode_template_group_id):
            query['TranscodeTemplateGroupId'] = request.transcode_template_group_id
        if not UtilClient.is_unset(request.transcode_template_id_list):
            query['TranscodeTemplateIdList'] = request.transcode_template_id_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTranscodeTemplates',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteTranscodeTemplatesResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_transcode_templates_with_options_async(
        self,
        request: vod_20170321_models.DeleteTranscodeTemplatesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteTranscodeTemplatesResponse:
        """
        @summary 删除模版
        
        @param request: DeleteTranscodeTemplatesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTranscodeTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.transcode_template_group_id):
            query['TranscodeTemplateGroupId'] = request.transcode_template_group_id
        if not UtilClient.is_unset(request.transcode_template_id_list):
            query['TranscodeTemplateIdList'] = request.transcode_template_id_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTranscodeTemplates',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteTranscodeTemplatesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_transcode_templates(
        self,
        request: vod_20170321_models.DeleteTranscodeTemplatesRequest,
    ) -> vod_20170321_models.DeleteTranscodeTemplatesResponse:
        """
        @summary 删除模版
        
        @param request: DeleteTranscodeTemplatesRequest
        @return: DeleteTranscodeTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_transcode_templates_with_options(request, runtime)

    async def delete_transcode_templates_async(
        self,
        request: vod_20170321_models.DeleteTranscodeTemplatesRequest,
    ) -> vod_20170321_models.DeleteTranscodeTemplatesResponse:
        """
        @summary 删除模版
        
        @param request: DeleteTranscodeTemplatesRequest
        @return: DeleteTranscodeTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_transcode_templates_with_options_async(request, runtime)

    def delete_video_with_options(
        self,
        request: vod_20170321_models.DeleteVideoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteVideoResponse:
        """
        @summary Deletes one or more videos at a time, including their mezzanine files, transcoded stream files, and thumbnail snapshots.
        
        @description    This operation physically deletes videos. Deleted videos cannot be recovered. Exercise caution when you call this operation.
        You can call this operation to delete multiple videos at a time.
        When you delete a video, its source file, transcoded stream file, and thumbnail screenshot are also deleted. However, the Alibaba Cloud Content Delivery Network (CDN) cache is not refreshed simultaneously. You can use the refresh feature in the ApsaraVideo VOD console to clear garbage data on CDN nodes. For more information, see [Refresh and prefetch](https://help.aliyun.com/document_detail/86098.html).
        
        @param request: DeleteVideoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVideoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.video_ids):
            query['VideoIds'] = request.video_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVideo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteVideoResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_video_with_options_async(
        self,
        request: vod_20170321_models.DeleteVideoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteVideoResponse:
        """
        @summary Deletes one or more videos at a time, including their mezzanine files, transcoded stream files, and thumbnail snapshots.
        
        @description    This operation physically deletes videos. Deleted videos cannot be recovered. Exercise caution when you call this operation.
        You can call this operation to delete multiple videos at a time.
        When you delete a video, its source file, transcoded stream file, and thumbnail screenshot are also deleted. However, the Alibaba Cloud Content Delivery Network (CDN) cache is not refreshed simultaneously. You can use the refresh feature in the ApsaraVideo VOD console to clear garbage data on CDN nodes. For more information, see [Refresh and prefetch](https://help.aliyun.com/document_detail/86098.html).
        
        @param request: DeleteVideoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVideoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.video_ids):
            query['VideoIds'] = request.video_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVideo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteVideoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_video(
        self,
        request: vod_20170321_models.DeleteVideoRequest,
    ) -> vod_20170321_models.DeleteVideoResponse:
        """
        @summary Deletes one or more videos at a time, including their mezzanine files, transcoded stream files, and thumbnail snapshots.
        
        @description    This operation physically deletes videos. Deleted videos cannot be recovered. Exercise caution when you call this operation.
        You can call this operation to delete multiple videos at a time.
        When you delete a video, its source file, transcoded stream file, and thumbnail screenshot are also deleted. However, the Alibaba Cloud Content Delivery Network (CDN) cache is not refreshed simultaneously. You can use the refresh feature in the ApsaraVideo VOD console to clear garbage data on CDN nodes. For more information, see [Refresh and prefetch](https://help.aliyun.com/document_detail/86098.html).
        
        @param request: DeleteVideoRequest
        @return: DeleteVideoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_video_with_options(request, runtime)

    async def delete_video_async(
        self,
        request: vod_20170321_models.DeleteVideoRequest,
    ) -> vod_20170321_models.DeleteVideoResponse:
        """
        @summary Deletes one or more videos at a time, including their mezzanine files, transcoded stream files, and thumbnail snapshots.
        
        @description    This operation physically deletes videos. Deleted videos cannot be recovered. Exercise caution when you call this operation.
        You can call this operation to delete multiple videos at a time.
        When you delete a video, its source file, transcoded stream file, and thumbnail screenshot are also deleted. However, the Alibaba Cloud Content Delivery Network (CDN) cache is not refreshed simultaneously. You can use the refresh feature in the ApsaraVideo VOD console to clear garbage data on CDN nodes. For more information, see [Refresh and prefetch](https://help.aliyun.com/document_detail/86098.html).
        
        @param request: DeleteVideoRequest
        @return: DeleteVideoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_video_with_options_async(request, runtime)

    def delete_vod_domain_with_options(
        self,
        request: vod_20170321_models.DeleteVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteVodDomainResponse:
        """
        @summary Removes a domain name for CDN from ApsaraVideo VOD.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    After a domain name for CDN is removed from ApsaraVideo VOD, the domain name becomes unavailable. Proceed with caution. We recommend that you restore the A record at your DNS service provider before you remove the domain name for CDN.
        >    After you call this operation to remove a domain name for CDN from ApsaraVideo VOD, all records that are related to the domain name are deleted. If you only want to disable a domain name for CDN, call the [BatchStopVodDomain](https://help.aliyun.com/document_detail/120208.html) operation.
        
        @param request: DeleteVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteVodDomainResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vod_domain_with_options_async(
        self,
        request: vod_20170321_models.DeleteVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteVodDomainResponse:
        """
        @summary Removes a domain name for CDN from ApsaraVideo VOD.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    After a domain name for CDN is removed from ApsaraVideo VOD, the domain name becomes unavailable. Proceed with caution. We recommend that you restore the A record at your DNS service provider before you remove the domain name for CDN.
        >    After you call this operation to remove a domain name for CDN from ApsaraVideo VOD, all records that are related to the domain name are deleted. If you only want to disable a domain name for CDN, call the [BatchStopVodDomain](https://help.aliyun.com/document_detail/120208.html) operation.
        
        @param request: DeleteVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteVodDomainResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vod_domain(
        self,
        request: vod_20170321_models.DeleteVodDomainRequest,
    ) -> vod_20170321_models.DeleteVodDomainResponse:
        """
        @summary Removes a domain name for CDN from ApsaraVideo VOD.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    After a domain name for CDN is removed from ApsaraVideo VOD, the domain name becomes unavailable. Proceed with caution. We recommend that you restore the A record at your DNS service provider before you remove the domain name for CDN.
        >    After you call this operation to remove a domain name for CDN from ApsaraVideo VOD, all records that are related to the domain name are deleted. If you only want to disable a domain name for CDN, call the [BatchStopVodDomain](https://help.aliyun.com/document_detail/120208.html) operation.
        
        @param request: DeleteVodDomainRequest
        @return: DeleteVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vod_domain_with_options(request, runtime)

    async def delete_vod_domain_async(
        self,
        request: vod_20170321_models.DeleteVodDomainRequest,
    ) -> vod_20170321_models.DeleteVodDomainResponse:
        """
        @summary Removes a domain name for CDN from ApsaraVideo VOD.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    After a domain name for CDN is removed from ApsaraVideo VOD, the domain name becomes unavailable. Proceed with caution. We recommend that you restore the A record at your DNS service provider before you remove the domain name for CDN.
        >    After you call this operation to remove a domain name for CDN from ApsaraVideo VOD, all records that are related to the domain name are deleted. If you only want to disable a domain name for CDN, call the [BatchStopVodDomain](https://help.aliyun.com/document_detail/120208.html) operation.
        
        @param request: DeleteVodDomainRequest
        @return: DeleteVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vod_domain_with_options_async(request, runtime)

    def delete_vod_real_time_log_logstore_with_options(
        self,
        request: vod_20170321_models.DeleteVodRealTimeLogLogstoreRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteVodRealTimeLogLogstoreResponse:
        """
        @summary 删除实时日志LogStore
        
        @param request: DeleteVodRealTimeLogLogstoreRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVodRealTimeLogLogstoreResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVodRealTimeLogLogstore',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteVodRealTimeLogLogstoreResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vod_real_time_log_logstore_with_options_async(
        self,
        request: vod_20170321_models.DeleteVodRealTimeLogLogstoreRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteVodRealTimeLogLogstoreResponse:
        """
        @summary 删除实时日志LogStore
        
        @param request: DeleteVodRealTimeLogLogstoreRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVodRealTimeLogLogstoreResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVodRealTimeLogLogstore',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteVodRealTimeLogLogstoreResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vod_real_time_log_logstore(
        self,
        request: vod_20170321_models.DeleteVodRealTimeLogLogstoreRequest,
    ) -> vod_20170321_models.DeleteVodRealTimeLogLogstoreResponse:
        """
        @summary 删除实时日志LogStore
        
        @param request: DeleteVodRealTimeLogLogstoreRequest
        @return: DeleteVodRealTimeLogLogstoreResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vod_real_time_log_logstore_with_options(request, runtime)

    async def delete_vod_real_time_log_logstore_async(
        self,
        request: vod_20170321_models.DeleteVodRealTimeLogLogstoreRequest,
    ) -> vod_20170321_models.DeleteVodRealTimeLogLogstoreResponse:
        """
        @summary 删除实时日志LogStore
        
        @param request: DeleteVodRealTimeLogLogstoreRequest
        @return: DeleteVodRealTimeLogLogstoreResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vod_real_time_log_logstore_with_options_async(request, runtime)

    def delete_vod_realtime_log_delivery_with_options(
        self,
        request: vod_20170321_models.DeleteVodRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteVodRealtimeLogDeliveryResponse:
        """
        @summary 删除实时日志
        
        @param request: DeleteVodRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVodRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVodRealtimeLogDelivery',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteVodRealtimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vod_realtime_log_delivery_with_options_async(
        self,
        request: vod_20170321_models.DeleteVodRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteVodRealtimeLogDeliveryResponse:
        """
        @summary 删除实时日志
        
        @param request: DeleteVodRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVodRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVodRealtimeLogDelivery',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteVodRealtimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vod_realtime_log_delivery(
        self,
        request: vod_20170321_models.DeleteVodRealtimeLogDeliveryRequest,
    ) -> vod_20170321_models.DeleteVodRealtimeLogDeliveryResponse:
        """
        @summary 删除实时日志
        
        @param request: DeleteVodRealtimeLogDeliveryRequest
        @return: DeleteVodRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vod_realtime_log_delivery_with_options(request, runtime)

    async def delete_vod_realtime_log_delivery_async(
        self,
        request: vod_20170321_models.DeleteVodRealtimeLogDeliveryRequest,
    ) -> vod_20170321_models.DeleteVodRealtimeLogDeliveryResponse:
        """
        @summary 删除实时日志
        
        @param request: DeleteVodRealtimeLogDeliveryRequest
        @return: DeleteVodRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vod_realtime_log_delivery_with_options_async(request, runtime)

    def delete_vod_specific_config_with_options(
        self,
        request: vod_20170321_models.DeleteVodSpecificConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteVodSpecificConfigResponse:
        """
        @summary Deletes the configurations of a domain name for CDN.
        
        @description >
        This operation is available only in the **China (Shanghai)** region.
        After the configurations of a domain name for CDN are deleted, the domain name becomes unavailable. We recommend that you restore the A record at your DNS service provider before you delete the configurations of the domain name for CDN.
        After you call this operation to remove a domain name for CDN from ApsaraVideo VOD, all records that are related to the domain name are deleted. If you only want to disable a domain name for CDN, call the [BatchStopVodDomain](https://help.aliyun.com/document_detail/120208.html) operation.
        
        @param request: DeleteVodSpecificConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVodSpecificConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.config_id):
            query['ConfigId'] = request.config_id
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.env):
            query['Env'] = request.env
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVodSpecificConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteVodSpecificConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vod_specific_config_with_options_async(
        self,
        request: vod_20170321_models.DeleteVodSpecificConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteVodSpecificConfigResponse:
        """
        @summary Deletes the configurations of a domain name for CDN.
        
        @description >
        This operation is available only in the **China (Shanghai)** region.
        After the configurations of a domain name for CDN are deleted, the domain name becomes unavailable. We recommend that you restore the A record at your DNS service provider before you delete the configurations of the domain name for CDN.
        After you call this operation to remove a domain name for CDN from ApsaraVideo VOD, all records that are related to the domain name are deleted. If you only want to disable a domain name for CDN, call the [BatchStopVodDomain](https://help.aliyun.com/document_detail/120208.html) operation.
        
        @param request: DeleteVodSpecificConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVodSpecificConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.config_id):
            query['ConfigId'] = request.config_id
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.env):
            query['Env'] = request.env
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVodSpecificConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteVodSpecificConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vod_specific_config(
        self,
        request: vod_20170321_models.DeleteVodSpecificConfigRequest,
    ) -> vod_20170321_models.DeleteVodSpecificConfigResponse:
        """
        @summary Deletes the configurations of a domain name for CDN.
        
        @description >
        This operation is available only in the **China (Shanghai)** region.
        After the configurations of a domain name for CDN are deleted, the domain name becomes unavailable. We recommend that you restore the A record at your DNS service provider before you delete the configurations of the domain name for CDN.
        After you call this operation to remove a domain name for CDN from ApsaraVideo VOD, all records that are related to the domain name are deleted. If you only want to disable a domain name for CDN, call the [BatchStopVodDomain](https://help.aliyun.com/document_detail/120208.html) operation.
        
        @param request: DeleteVodSpecificConfigRequest
        @return: DeleteVodSpecificConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vod_specific_config_with_options(request, runtime)

    async def delete_vod_specific_config_async(
        self,
        request: vod_20170321_models.DeleteVodSpecificConfigRequest,
    ) -> vod_20170321_models.DeleteVodSpecificConfigResponse:
        """
        @summary Deletes the configurations of a domain name for CDN.
        
        @description >
        This operation is available only in the **China (Shanghai)** region.
        After the configurations of a domain name for CDN are deleted, the domain name becomes unavailable. We recommend that you restore the A record at your DNS service provider before you delete the configurations of the domain name for CDN.
        After you call this operation to remove a domain name for CDN from ApsaraVideo VOD, all records that are related to the domain name are deleted. If you only want to disable a domain name for CDN, call the [BatchStopVodDomain](https://help.aliyun.com/document_detail/120208.html) operation.
        
        @param request: DeleteVodSpecificConfigRequest
        @return: DeleteVodSpecificConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vod_specific_config_with_options_async(request, runtime)

    def delete_vod_template_with_options(
        self,
        request: vod_20170321_models.DeleteVodTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteVodTemplateResponse:
        """
        @summary Deletes a snapshot template.
        
        @param request: DeleteVodTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVodTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.vod_template_id):
            query['VodTemplateId'] = request.vod_template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVodTemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteVodTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_vod_template_with_options_async(
        self,
        request: vod_20170321_models.DeleteVodTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteVodTemplateResponse:
        """
        @summary Deletes a snapshot template.
        
        @param request: DeleteVodTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteVodTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.vod_template_id):
            query['VodTemplateId'] = request.vod_template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteVodTemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteVodTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_vod_template(
        self,
        request: vod_20170321_models.DeleteVodTemplateRequest,
    ) -> vod_20170321_models.DeleteVodTemplateResponse:
        """
        @summary Deletes a snapshot template.
        
        @param request: DeleteVodTemplateRequest
        @return: DeleteVodTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_vod_template_with_options(request, runtime)

    async def delete_vod_template_async(
        self,
        request: vod_20170321_models.DeleteVodTemplateRequest,
    ) -> vod_20170321_models.DeleteVodTemplateResponse:
        """
        @summary Deletes a snapshot template.
        
        @param request: DeleteVodTemplateRequest
        @return: DeleteVodTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_vod_template_with_options_async(request, runtime)

    def delete_watermark_with_options(
        self,
        request: vod_20170321_models.DeleteWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteWatermarkResponse:
        """
        @summary Deletes an image watermark or text watermark template.
        
        @description    **After you delete an image watermark template, the source watermark file is physically deleted and cannot be restored. Exercise caution when you call this operation.**\
        You cannot delete the default watermark template. To delete a default watermark template, call the [SetDefaultWatermark](~~SetDefaultWatermark~~) operation to set another watermark template as the default one.
        
        @param request: DeleteWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteWatermark',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteWatermarkResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_watermark_with_options_async(
        self,
        request: vod_20170321_models.DeleteWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteWatermarkResponse:
        """
        @summary Deletes an image watermark or text watermark template.
        
        @description    **After you delete an image watermark template, the source watermark file is physically deleted and cannot be restored. Exercise caution when you call this operation.**\
        You cannot delete the default watermark template. To delete a default watermark template, call the [SetDefaultWatermark](~~SetDefaultWatermark~~) operation to set another watermark template as the default one.
        
        @param request: DeleteWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteWatermark',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteWatermarkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_watermark(
        self,
        request: vod_20170321_models.DeleteWatermarkRequest,
    ) -> vod_20170321_models.DeleteWatermarkResponse:
        """
        @summary Deletes an image watermark or text watermark template.
        
        @description    **After you delete an image watermark template, the source watermark file is physically deleted and cannot be restored. Exercise caution when you call this operation.**\
        You cannot delete the default watermark template. To delete a default watermark template, call the [SetDefaultWatermark](~~SetDefaultWatermark~~) operation to set another watermark template as the default one.
        
        @param request: DeleteWatermarkRequest
        @return: DeleteWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_watermark_with_options(request, runtime)

    async def delete_watermark_async(
        self,
        request: vod_20170321_models.DeleteWatermarkRequest,
    ) -> vod_20170321_models.DeleteWatermarkResponse:
        """
        @summary Deletes an image watermark or text watermark template.
        
        @description    **After you delete an image watermark template, the source watermark file is physically deleted and cannot be restored. Exercise caution when you call this operation.**\
        You cannot delete the default watermark template. To delete a default watermark template, call the [SetDefaultWatermark](~~SetDefaultWatermark~~) operation to set another watermark template as the default one.
        
        @param request: DeleteWatermarkRequest
        @return: DeleteWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_watermark_with_options_async(request, runtime)

    def delete_watermark_console_with_options(
        self,
        request: vod_20170321_models.DeleteWatermarkConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteWatermarkConsoleResponse:
        """
        @summary 删除水印
        
        @param request: DeleteWatermarkConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteWatermarkConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteWatermarkConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteWatermarkConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_watermark_console_with_options_async(
        self,
        request: vod_20170321_models.DeleteWatermarkConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteWatermarkConsoleResponse:
        """
        @summary 删除水印
        
        @param request: DeleteWatermarkConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteWatermarkConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteWatermarkConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteWatermarkConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_watermark_console(
        self,
        request: vod_20170321_models.DeleteWatermarkConsoleRequest,
    ) -> vod_20170321_models.DeleteWatermarkConsoleResponse:
        """
        @summary 删除水印
        
        @param request: DeleteWatermarkConsoleRequest
        @return: DeleteWatermarkConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_watermark_console_with_options(request, runtime)

    async def delete_watermark_console_async(
        self,
        request: vod_20170321_models.DeleteWatermarkConsoleRequest,
    ) -> vod_20170321_models.DeleteWatermarkConsoleResponse:
        """
        @summary 删除水印
        
        @param request: DeleteWatermarkConsoleRequest
        @return: DeleteWatermarkConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_watermark_console_with_options_async(request, runtime)

    def delete_workflow_with_options(
        self,
        request: vod_20170321_models.DeleteWorkflowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteWorkflowResponse:
        """
        @summary 删除工作流
        
        @param request: DeleteWorkflowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteWorkflowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteWorkflow',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteWorkflowResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_workflow_with_options_async(
        self,
        request: vod_20170321_models.DeleteWorkflowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DeleteWorkflowResponse:
        """
        @summary 删除工作流
        
        @param request: DeleteWorkflowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteWorkflowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteWorkflow',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DeleteWorkflowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_workflow(
        self,
        request: vod_20170321_models.DeleteWorkflowRequest,
    ) -> vod_20170321_models.DeleteWorkflowResponse:
        """
        @summary 删除工作流
        
        @param request: DeleteWorkflowRequest
        @return: DeleteWorkflowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_workflow_with_options(request, runtime)

    async def delete_workflow_async(
        self,
        request: vod_20170321_models.DeleteWorkflowRequest,
    ) -> vod_20170321_models.DeleteWorkflowResponse:
        """
        @summary 删除工作流
        
        @param request: DeleteWorkflowRequest
        @return: DeleteWorkflowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_workflow_with_options_async(request, runtime)

    def describe_biz_user_type_with_options(
        self,
        request: vod_20170321_models.DescribeBizUserTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeBizUserTypeResponse:
        """
        @summary 查询用户付费类型
        
        @param request: DescribeBizUserTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeBizUserTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeBizUserType',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeBizUserTypeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_biz_user_type_with_options_async(
        self,
        request: vod_20170321_models.DescribeBizUserTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeBizUserTypeResponse:
        """
        @summary 查询用户付费类型
        
        @param request: DescribeBizUserTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeBizUserTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeBizUserType',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeBizUserTypeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_biz_user_type(
        self,
        request: vod_20170321_models.DescribeBizUserTypeRequest,
    ) -> vod_20170321_models.DescribeBizUserTypeResponse:
        """
        @summary 查询用户付费类型
        
        @param request: DescribeBizUserTypeRequest
        @return: DescribeBizUserTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_biz_user_type_with_options(request, runtime)

    async def describe_biz_user_type_async(
        self,
        request: vod_20170321_models.DescribeBizUserTypeRequest,
    ) -> vod_20170321_models.DescribeBizUserTypeResponse:
        """
        @summary 查询用户付费类型
        
        @param request: DescribeBizUserTypeRequest
        @return: DescribeBizUserTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_biz_user_type_with_options_async(request, runtime)

    def describe_cdn_domain_logs_with_options(
        self,
        request: vod_20170321_models.DescribeCdnDomainLogsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeCdnDomainLogsResponse:
        """
        @summary 获取日志
        
        @param request: DescribeCdnDomainLogsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCdnDomainLogsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.log_day):
            query['LogDay'] = request.log_day
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCdnDomainLogs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeCdnDomainLogsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_cdn_domain_logs_with_options_async(
        self,
        request: vod_20170321_models.DescribeCdnDomainLogsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeCdnDomainLogsResponse:
        """
        @summary 获取日志
        
        @param request: DescribeCdnDomainLogsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCdnDomainLogsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.log_day):
            query['LogDay'] = request.log_day
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCdnDomainLogs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeCdnDomainLogsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_cdn_domain_logs(
        self,
        request: vod_20170321_models.DescribeCdnDomainLogsRequest,
    ) -> vod_20170321_models.DescribeCdnDomainLogsResponse:
        """
        @summary 获取日志
        
        @param request: DescribeCdnDomainLogsRequest
        @return: DescribeCdnDomainLogsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_cdn_domain_logs_with_options(request, runtime)

    async def describe_cdn_domain_logs_async(
        self,
        request: vod_20170321_models.DescribeCdnDomainLogsRequest,
    ) -> vod_20170321_models.DescribeCdnDomainLogsResponse:
        """
        @summary 获取日志
        
        @param request: DescribeCdnDomainLogsRequest
        @return: DescribeCdnDomainLogsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_cdn_domain_logs_with_options_async(request, runtime)

    def describe_daily_async_job_with_options(
        self,
        request: vod_20170321_models.DescribeDailyAsyncJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeDailyAsyncJobResponse:
        """
        @summary 异步任务管理能力建设
        
        @param request: DescribeDailyAsyncJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDailyAsyncJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.job_state):
            query['JobState'] = request.job_state
        if not UtilClient.is_unset(request.job_type):
            query['JobType'] = request.job_type
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDailyAsyncJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeDailyAsyncJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_daily_async_job_with_options_async(
        self,
        request: vod_20170321_models.DescribeDailyAsyncJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeDailyAsyncJobResponse:
        """
        @summary 异步任务管理能力建设
        
        @param request: DescribeDailyAsyncJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDailyAsyncJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.job_state):
            query['JobState'] = request.job_state
        if not UtilClient.is_unset(request.job_type):
            query['JobType'] = request.job_type
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDailyAsyncJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeDailyAsyncJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_daily_async_job(
        self,
        request: vod_20170321_models.DescribeDailyAsyncJobRequest,
    ) -> vod_20170321_models.DescribeDailyAsyncJobResponse:
        """
        @summary 异步任务管理能力建设
        
        @param request: DescribeDailyAsyncJobRequest
        @return: DescribeDailyAsyncJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_daily_async_job_with_options(request, runtime)

    async def describe_daily_async_job_async(
        self,
        request: vod_20170321_models.DescribeDailyAsyncJobRequest,
    ) -> vod_20170321_models.DescribeDailyAsyncJobResponse:
        """
        @summary 异步任务管理能力建设
        
        @param request: DescribeDailyAsyncJobRequest
        @return: DescribeDailyAsyncJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_daily_async_job_with_options_async(request, runtime)

    def describe_domain_bps_data_with_options(
        self,
        request: vod_20170321_models.DescribeDomainBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeDomainBpsDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeDomainBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDomainBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.time_merge):
            query['TimeMerge'] = request.time_merge
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDomainBpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeDomainBpsDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_domain_bps_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeDomainBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeDomainBpsDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeDomainBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDomainBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.time_merge):
            query['TimeMerge'] = request.time_merge
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDomainBpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeDomainBpsDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_domain_bps_data(
        self,
        request: vod_20170321_models.DescribeDomainBpsDataRequest,
    ) -> vod_20170321_models.DescribeDomainBpsDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeDomainBpsDataRequest
        @return: DescribeDomainBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_domain_bps_data_with_options(request, runtime)

    async def describe_domain_bps_data_async(
        self,
        request: vod_20170321_models.DescribeDomainBpsDataRequest,
    ) -> vod_20170321_models.DescribeDomainBpsDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeDomainBpsDataRequest
        @return: DescribeDomainBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_domain_bps_data_with_options_async(request, runtime)

    def describe_domain_flow_data_with_options(
        self,
        request: vod_20170321_models.DescribeDomainFlowDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeDomainFlowDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeDomainFlowDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDomainFlowDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.time_merge):
            query['TimeMerge'] = request.time_merge
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDomainFlowData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeDomainFlowDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_domain_flow_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeDomainFlowDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeDomainFlowDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeDomainFlowDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDomainFlowDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.time_merge):
            query['TimeMerge'] = request.time_merge
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDomainFlowData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeDomainFlowDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_domain_flow_data(
        self,
        request: vod_20170321_models.DescribeDomainFlowDataRequest,
    ) -> vod_20170321_models.DescribeDomainFlowDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeDomainFlowDataRequest
        @return: DescribeDomainFlowDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_domain_flow_data_with_options(request, runtime)

    async def describe_domain_flow_data_async(
        self,
        request: vod_20170321_models.DescribeDomainFlowDataRequest,
    ) -> vod_20170321_models.DescribeDomainFlowDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeDomainFlowDataRequest
        @return: DescribeDomainFlowDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_domain_flow_data_with_options_async(request, runtime)

    def describe_file_id_play_statis_by_edge_with_options(
        self,
        request: vod_20170321_models.DescribeFileIdPlayStatisByEdgeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeFileIdPlayStatisByEdgeResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeFileIdPlayStatisByEdgeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeFileIdPlayStatisByEdgeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['From'] = request.from_
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.scroll_token):
            query['ScrollToken'] = request.scroll_token
        if not UtilClient.is_unset(request.to):
            query['To'] = request.to
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeFileIdPlayStatisByEdge',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeFileIdPlayStatisByEdgeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_file_id_play_statis_by_edge_with_options_async(
        self,
        request: vod_20170321_models.DescribeFileIdPlayStatisByEdgeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeFileIdPlayStatisByEdgeResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeFileIdPlayStatisByEdgeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeFileIdPlayStatisByEdgeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['From'] = request.from_
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.scroll_token):
            query['ScrollToken'] = request.scroll_token
        if not UtilClient.is_unset(request.to):
            query['To'] = request.to
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeFileIdPlayStatisByEdge',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeFileIdPlayStatisByEdgeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_file_id_play_statis_by_edge(
        self,
        request: vod_20170321_models.DescribeFileIdPlayStatisByEdgeRequest,
    ) -> vod_20170321_models.DescribeFileIdPlayStatisByEdgeResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeFileIdPlayStatisByEdgeRequest
        @return: DescribeFileIdPlayStatisByEdgeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_file_id_play_statis_by_edge_with_options(request, runtime)

    async def describe_file_id_play_statis_by_edge_async(
        self,
        request: vod_20170321_models.DescribeFileIdPlayStatisByEdgeRequest,
    ) -> vod_20170321_models.DescribeFileIdPlayStatisByEdgeResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeFileIdPlayStatisByEdgeRequest
        @return: DescribeFileIdPlayStatisByEdgeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_file_id_play_statis_by_edge_with_options_async(request, runtime)

    def describe_file_id_play_statis_by_origin_with_options(
        self,
        request: vod_20170321_models.DescribeFileIdPlayStatisByOriginRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeFileIdPlayStatisByOriginResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeFileIdPlayStatisByOriginRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeFileIdPlayStatisByOriginResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['From'] = request.from_
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.scroll_token):
            query['ScrollToken'] = request.scroll_token
        if not UtilClient.is_unset(request.to):
            query['To'] = request.to
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeFileIdPlayStatisByOrigin',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeFileIdPlayStatisByOriginResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_file_id_play_statis_by_origin_with_options_async(
        self,
        request: vod_20170321_models.DescribeFileIdPlayStatisByOriginRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeFileIdPlayStatisByOriginResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeFileIdPlayStatisByOriginRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeFileIdPlayStatisByOriginResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['From'] = request.from_
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.scroll_token):
            query['ScrollToken'] = request.scroll_token
        if not UtilClient.is_unset(request.to):
            query['To'] = request.to
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeFileIdPlayStatisByOrigin',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeFileIdPlayStatisByOriginResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_file_id_play_statis_by_origin(
        self,
        request: vod_20170321_models.DescribeFileIdPlayStatisByOriginRequest,
    ) -> vod_20170321_models.DescribeFileIdPlayStatisByOriginResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeFileIdPlayStatisByOriginRequest
        @return: DescribeFileIdPlayStatisByOriginResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_file_id_play_statis_by_origin_with_options(request, runtime)

    async def describe_file_id_play_statis_by_origin_async(
        self,
        request: vod_20170321_models.DescribeFileIdPlayStatisByOriginRequest,
    ) -> vod_20170321_models.DescribeFileIdPlayStatisByOriginResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeFileIdPlayStatisByOriginRequest
        @return: DescribeFileIdPlayStatisByOriginResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_file_id_play_statis_by_origin_with_options_async(request, runtime)

    def describe_filter_configs_with_options(
        self,
        request: vod_20170321_models.DescribeFilterConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeFilterConfigsResponse:
        """
        @summary 查询已保存的筛选过滤条件
        
        @param request: DescribeFilterConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeFilterConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeFilterConfigs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeFilterConfigsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_filter_configs_with_options_async(
        self,
        request: vod_20170321_models.DescribeFilterConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeFilterConfigsResponse:
        """
        @summary 查询已保存的筛选过滤条件
        
        @param request: DescribeFilterConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeFilterConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeFilterConfigs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeFilterConfigsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_filter_configs(
        self,
        request: vod_20170321_models.DescribeFilterConfigsRequest,
    ) -> vod_20170321_models.DescribeFilterConfigsResponse:
        """
        @summary 查询已保存的筛选过滤条件
        
        @param request: DescribeFilterConfigsRequest
        @return: DescribeFilterConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_filter_configs_with_options(request, runtime)

    async def describe_filter_configs_async(
        self,
        request: vod_20170321_models.DescribeFilterConfigsRequest,
    ) -> vod_20170321_models.DescribeFilterConfigsResponse:
        """
        @summary 查询已保存的筛选过滤条件
        
        @param request: DescribeFilterConfigsRequest
        @return: DescribeFilterConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_filter_configs_with_options_async(request, runtime)

    def describe_media_distribution_with_options(
        self,
        request: vod_20170321_models.DescribeMediaDistributionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeMediaDistributionResponse:
        """
        @summary Queries the distribution of media asset data by time. The maximum time range to query is 6 months.
        
        @description    This operation is available only in the China (Shanghai) region.
        If you do not set the StartTime or EndTime parameter, the request returns the data collected in the previous 7 days. If you set both the parameters, the request returns the data collected within the specified time range.
        
        @param request: DescribeMediaDistributionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeMediaDistributionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.storage_class):
            query['StorageClass'] = request.storage_class
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeMediaDistribution',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeMediaDistributionResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_media_distribution_with_options_async(
        self,
        request: vod_20170321_models.DescribeMediaDistributionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeMediaDistributionResponse:
        """
        @summary Queries the distribution of media asset data by time. The maximum time range to query is 6 months.
        
        @description    This operation is available only in the China (Shanghai) region.
        If you do not set the StartTime or EndTime parameter, the request returns the data collected in the previous 7 days. If you set both the parameters, the request returns the data collected within the specified time range.
        
        @param request: DescribeMediaDistributionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeMediaDistributionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.storage_class):
            query['StorageClass'] = request.storage_class
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeMediaDistribution',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeMediaDistributionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_media_distribution(
        self,
        request: vod_20170321_models.DescribeMediaDistributionRequest,
    ) -> vod_20170321_models.DescribeMediaDistributionResponse:
        """
        @summary Queries the distribution of media asset data by time. The maximum time range to query is 6 months.
        
        @description    This operation is available only in the China (Shanghai) region.
        If you do not set the StartTime or EndTime parameter, the request returns the data collected in the previous 7 days. If you set both the parameters, the request returns the data collected within the specified time range.
        
        @param request: DescribeMediaDistributionRequest
        @return: DescribeMediaDistributionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_media_distribution_with_options(request, runtime)

    async def describe_media_distribution_async(
        self,
        request: vod_20170321_models.DescribeMediaDistributionRequest,
    ) -> vod_20170321_models.DescribeMediaDistributionResponse:
        """
        @summary Queries the distribution of media asset data by time. The maximum time range to query is 6 months.
        
        @description    This operation is available only in the China (Shanghai) region.
        If you do not set the StartTime or EndTime parameter, the request returns the data collected in the previous 7 days. If you set both the parameters, the request returns the data collected within the specified time range.
        
        @param request: DescribeMediaDistributionRequest
        @return: DescribeMediaDistributionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_media_distribution_with_options_async(request, runtime)

    def describe_multi_price_for_license_with_options(
        self,
        request: vod_20170321_models.DescribeMultiPriceForLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeMultiPriceForLicenseResponse:
        """
        @summary 订单询价
        
        @param request: DescribeMultiPriceForLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeMultiPriceForLicenseResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeMultiPriceForLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeMultiPriceForLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_multi_price_for_license_with_options_async(
        self,
        request: vod_20170321_models.DescribeMultiPriceForLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeMultiPriceForLicenseResponse:
        """
        @summary 订单询价
        
        @param request: DescribeMultiPriceForLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeMultiPriceForLicenseResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeMultiPriceForLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeMultiPriceForLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_multi_price_for_license(
        self,
        request: vod_20170321_models.DescribeMultiPriceForLicenseRequest,
    ) -> vod_20170321_models.DescribeMultiPriceForLicenseResponse:
        """
        @summary 订单询价
        
        @param request: DescribeMultiPriceForLicenseRequest
        @return: DescribeMultiPriceForLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_multi_price_for_license_with_options(request, runtime)

    async def describe_multi_price_for_license_async(
        self,
        request: vod_20170321_models.DescribeMultiPriceForLicenseRequest,
    ) -> vod_20170321_models.DescribeMultiPriceForLicenseResponse:
        """
        @summary 订单询价
        
        @param request: DescribeMultiPriceForLicenseRequest
        @return: DescribeMultiPriceForLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_multi_price_for_license_with_options_async(request, runtime)

    def describe_play_detail_with_options(
        self,
        request: vod_20170321_models.DescribePlayDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayDetailResponse:
        """
        @summary 获取客户播放详情信息
        
        @param request: DescribePlayDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.language):
            query['Language'] = request.language
        if not UtilClient.is_unset(request.play_ts):
            query['PlayTs'] = request.play_ts
        if not UtilClient.is_unset(request.session_id):
            query['SessionId'] = request.session_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_play_detail_with_options_async(
        self,
        request: vod_20170321_models.DescribePlayDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayDetailResponse:
        """
        @summary 获取客户播放详情信息
        
        @param request: DescribePlayDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.language):
            query['Language'] = request.language
        if not UtilClient.is_unset(request.play_ts):
            query['PlayTs'] = request.play_ts
        if not UtilClient.is_unset(request.session_id):
            query['SessionId'] = request.session_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_play_detail(
        self,
        request: vod_20170321_models.DescribePlayDetailRequest,
    ) -> vod_20170321_models.DescribePlayDetailResponse:
        """
        @summary 获取客户播放详情信息
        
        @param request: DescribePlayDetailRequest
        @return: DescribePlayDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_play_detail_with_options(request, runtime)

    async def describe_play_detail_async(
        self,
        request: vod_20170321_models.DescribePlayDetailRequest,
    ) -> vod_20170321_models.DescribePlayDetailResponse:
        """
        @summary 获取客户播放详情信息
        
        @param request: DescribePlayDetailRequest
        @return: DescribePlayDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_play_detail_with_options_async(request, runtime)

    def describe_play_event_list_with_options(
        self,
        request: vod_20170321_models.DescribePlayEventListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayEventListResponse:
        """
        @summary 获取客户播放事件列表
        
        @param request: DescribePlayEventListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayEventListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.language):
            query['Language'] = request.language
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.play_ts):
            query['PlayTs'] = request.play_ts
        if not UtilClient.is_unset(request.session_id):
            query['SessionId'] = request.session_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayEventList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayEventListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_play_event_list_with_options_async(
        self,
        request: vod_20170321_models.DescribePlayEventListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayEventListResponse:
        """
        @summary 获取客户播放事件列表
        
        @param request: DescribePlayEventListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayEventListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.language):
            query['Language'] = request.language
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.play_ts):
            query['PlayTs'] = request.play_ts
        if not UtilClient.is_unset(request.session_id):
            query['SessionId'] = request.session_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayEventList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayEventListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_play_event_list(
        self,
        request: vod_20170321_models.DescribePlayEventListRequest,
    ) -> vod_20170321_models.DescribePlayEventListResponse:
        """
        @summary 获取客户播放事件列表
        
        @param request: DescribePlayEventListRequest
        @return: DescribePlayEventListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_play_event_list_with_options(request, runtime)

    async def describe_play_event_list_async(
        self,
        request: vod_20170321_models.DescribePlayEventListRequest,
    ) -> vod_20170321_models.DescribePlayEventListResponse:
        """
        @summary 获取客户播放事件列表
        
        @param request: DescribePlayEventListRequest
        @return: DescribePlayEventListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_play_event_list_with_options_async(request, runtime)

    def describe_play_first_frame_duration_metric_data_with_options(
        self,
        request: vod_20170321_models.DescribePlayFirstFrameDurationMetricDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayFirstFrameDurationMetricDataResponse:
        """
        @summary 获取单点首帧耗时数据
        
        @param request: DescribePlayFirstFrameDurationMetricDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayFirstFrameDurationMetricDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.begin_ts):
            query['BeginTs'] = request.begin_ts
        if not UtilClient.is_unset(request.end_ts):
            query['EndTs'] = request.end_ts
        if not UtilClient.is_unset(request.trace_id):
            query['TraceId'] = request.trace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayFirstFrameDurationMetricData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayFirstFrameDurationMetricDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_play_first_frame_duration_metric_data_with_options_async(
        self,
        request: vod_20170321_models.DescribePlayFirstFrameDurationMetricDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayFirstFrameDurationMetricDataResponse:
        """
        @summary 获取单点首帧耗时数据
        
        @param request: DescribePlayFirstFrameDurationMetricDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayFirstFrameDurationMetricDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.begin_ts):
            query['BeginTs'] = request.begin_ts
        if not UtilClient.is_unset(request.end_ts):
            query['EndTs'] = request.end_ts
        if not UtilClient.is_unset(request.trace_id):
            query['TraceId'] = request.trace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayFirstFrameDurationMetricData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayFirstFrameDurationMetricDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_play_first_frame_duration_metric_data(
        self,
        request: vod_20170321_models.DescribePlayFirstFrameDurationMetricDataRequest,
    ) -> vod_20170321_models.DescribePlayFirstFrameDurationMetricDataResponse:
        """
        @summary 获取单点首帧耗时数据
        
        @param request: DescribePlayFirstFrameDurationMetricDataRequest
        @return: DescribePlayFirstFrameDurationMetricDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_play_first_frame_duration_metric_data_with_options(request, runtime)

    async def describe_play_first_frame_duration_metric_data_async(
        self,
        request: vod_20170321_models.DescribePlayFirstFrameDurationMetricDataRequest,
    ) -> vod_20170321_models.DescribePlayFirstFrameDurationMetricDataResponse:
        """
        @summary 获取单点首帧耗时数据
        
        @param request: DescribePlayFirstFrameDurationMetricDataRequest
        @return: DescribePlayFirstFrameDurationMetricDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_play_first_frame_duration_metric_data_with_options_async(request, runtime)

    def describe_play_list_with_options(
        self,
        request: vod_20170321_models.DescribePlayListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayListResponse:
        """
        @summary 获取播放信息列表
        
        @param request: DescribePlayListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.begin_ts):
            query['BeginTs'] = request.begin_ts
        if not UtilClient.is_unset(request.end_ts):
            query['EndTs'] = request.end_ts
        if not UtilClient.is_unset(request.order_name):
            query['OrderName'] = request.order_name
        if not UtilClient.is_unset(request.order_type):
            query['OrderType'] = request.order_type
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.play_type):
            query['PlayType'] = request.play_type
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.trace_id):
            query['TraceId'] = request.trace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_play_list_with_options_async(
        self,
        request: vod_20170321_models.DescribePlayListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayListResponse:
        """
        @summary 获取播放信息列表
        
        @param request: DescribePlayListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.begin_ts):
            query['BeginTs'] = request.begin_ts
        if not UtilClient.is_unset(request.end_ts):
            query['EndTs'] = request.end_ts
        if not UtilClient.is_unset(request.order_name):
            query['OrderName'] = request.order_name
        if not UtilClient.is_unset(request.order_type):
            query['OrderType'] = request.order_type
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.play_type):
            query['PlayType'] = request.play_type
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.trace_id):
            query['TraceId'] = request.trace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_play_list(
        self,
        request: vod_20170321_models.DescribePlayListRequest,
    ) -> vod_20170321_models.DescribePlayListResponse:
        """
        @summary 获取播放信息列表
        
        @param request: DescribePlayListRequest
        @return: DescribePlayListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_play_list_with_options(request, runtime)

    async def describe_play_list_async(
        self,
        request: vod_20170321_models.DescribePlayListRequest,
    ) -> vod_20170321_models.DescribePlayListResponse:
        """
        @summary 获取播放信息列表
        
        @param request: DescribePlayListRequest
        @return: DescribePlayListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_play_list_with_options_async(request, runtime)

    def describe_play_metric_auth_with_options(
        self,
        request: vod_20170321_models.DescribePlayMetricAuthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayMetricAuthResponse:
        """
        @summary 查询用户能够查询的数据指标
        
        @param request: DescribePlayMetricAuthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayMetricAuthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayMetricAuth',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayMetricAuthResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_play_metric_auth_with_options_async(
        self,
        request: vod_20170321_models.DescribePlayMetricAuthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayMetricAuthResponse:
        """
        @summary 查询用户能够查询的数据指标
        
        @param request: DescribePlayMetricAuthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayMetricAuthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayMetricAuth',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayMetricAuthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_play_metric_auth(
        self,
        request: vod_20170321_models.DescribePlayMetricAuthRequest,
    ) -> vod_20170321_models.DescribePlayMetricAuthResponse:
        """
        @summary 查询用户能够查询的数据指标
        
        @param request: DescribePlayMetricAuthRequest
        @return: DescribePlayMetricAuthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_play_metric_auth_with_options(request, runtime)

    async def describe_play_metric_auth_async(
        self,
        request: vod_20170321_models.DescribePlayMetricAuthRequest,
    ) -> vod_20170321_models.DescribePlayMetricAuthResponse:
        """
        @summary 查询用户能够查询的数据指标
        
        @param request: DescribePlayMetricAuthRequest
        @return: DescribePlayMetricAuthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_play_metric_auth_with_options_async(request, runtime)

    def describe_play_metric_data_with_options(
        self,
        request: vod_20170321_models.DescribePlayMetricDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayMetricDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribePlayMetricDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayMetricDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.definition):
            query['Definition'] = request.definition
        if not UtilClient.is_unset(request.item_configs):
            query['ItemConfigs'] = request.item_configs
        if not UtilClient.is_unset(request.network):
            query['Network'] = request.network
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.sdk_version):
            query['SdkVersion'] = request.sdk_version
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        body = {}
        if not UtilClient.is_unset(request.begin_ts):
            body['BeginTs'] = request.begin_ts
        if not UtilClient.is_unset(request.end_ts):
            body['EndTs'] = request.end_ts
        if not UtilClient.is_unset(request.experience_level):
            body['ExperienceLevel'] = request.experience_level
        if not UtilClient.is_unset(request.metric_type):
            body['MetricType'] = request.metric_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='DescribePlayMetricData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayMetricDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_play_metric_data_with_options_async(
        self,
        request: vod_20170321_models.DescribePlayMetricDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayMetricDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribePlayMetricDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayMetricDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.definition):
            query['Definition'] = request.definition
        if not UtilClient.is_unset(request.item_configs):
            query['ItemConfigs'] = request.item_configs
        if not UtilClient.is_unset(request.network):
            query['Network'] = request.network
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.sdk_version):
            query['SdkVersion'] = request.sdk_version
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        body = {}
        if not UtilClient.is_unset(request.begin_ts):
            body['BeginTs'] = request.begin_ts
        if not UtilClient.is_unset(request.end_ts):
            body['EndTs'] = request.end_ts
        if not UtilClient.is_unset(request.experience_level):
            body['ExperienceLevel'] = request.experience_level
        if not UtilClient.is_unset(request.metric_type):
            body['MetricType'] = request.metric_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='DescribePlayMetricData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayMetricDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_play_metric_data(
        self,
        request: vod_20170321_models.DescribePlayMetricDataRequest,
    ) -> vod_20170321_models.DescribePlayMetricDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribePlayMetricDataRequest
        @return: DescribePlayMetricDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_play_metric_data_with_options(request, runtime)

    async def describe_play_metric_data_async(
        self,
        request: vod_20170321_models.DescribePlayMetricDataRequest,
    ) -> vod_20170321_models.DescribePlayMetricDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribePlayMetricDataRequest
        @return: DescribePlayMetricDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_play_metric_data_with_options_async(request, runtime)

    def describe_play_qoe_list_with_options(
        self,
        tmp_req: vod_20170321_models.DescribePlayQoeListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayQoeListResponse:
        """
        @summary 获取Ooe播放信息列表
        
        @param tmp_req: DescribePlayQoeListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayQoeListResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vod_20170321_models.DescribePlayQoeListShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.metric_types):
            request.metric_types_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.metric_types, 'MetricTypes', 'json')
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.begin_ts):
            query['BeginTs'] = request.begin_ts
        if not UtilClient.is_unset(request.definition):
            query['Definition'] = request.definition
        if not UtilClient.is_unset(request.end_ts):
            query['EndTs'] = request.end_ts
        if not UtilClient.is_unset(request.item_configs):
            query['ItemConfigs'] = request.item_configs
        if not UtilClient.is_unset(request.metric_types_shrink):
            query['MetricTypes'] = request.metric_types_shrink
        if not UtilClient.is_unset(request.network):
            query['Network'] = request.network
        if not UtilClient.is_unset(request.order_name):
            query['OrderName'] = request.order_name
        if not UtilClient.is_unset(request.order_type):
            query['OrderType'] = request.order_type
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayQoeList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayQoeListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_play_qoe_list_with_options_async(
        self,
        tmp_req: vod_20170321_models.DescribePlayQoeListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayQoeListResponse:
        """
        @summary 获取Ooe播放信息列表
        
        @param tmp_req: DescribePlayQoeListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayQoeListResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vod_20170321_models.DescribePlayQoeListShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.metric_types):
            request.metric_types_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.metric_types, 'MetricTypes', 'json')
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.begin_ts):
            query['BeginTs'] = request.begin_ts
        if not UtilClient.is_unset(request.definition):
            query['Definition'] = request.definition
        if not UtilClient.is_unset(request.end_ts):
            query['EndTs'] = request.end_ts
        if not UtilClient.is_unset(request.item_configs):
            query['ItemConfigs'] = request.item_configs
        if not UtilClient.is_unset(request.metric_types_shrink):
            query['MetricTypes'] = request.metric_types_shrink
        if not UtilClient.is_unset(request.network):
            query['Network'] = request.network
        if not UtilClient.is_unset(request.order_name):
            query['OrderName'] = request.order_name
        if not UtilClient.is_unset(request.order_type):
            query['OrderType'] = request.order_type
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayQoeList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayQoeListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_play_qoe_list(
        self,
        request: vod_20170321_models.DescribePlayQoeListRequest,
    ) -> vod_20170321_models.DescribePlayQoeListResponse:
        """
        @summary 获取Ooe播放信息列表
        
        @param request: DescribePlayQoeListRequest
        @return: DescribePlayQoeListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_play_qoe_list_with_options(request, runtime)

    async def describe_play_qoe_list_async(
        self,
        request: vod_20170321_models.DescribePlayQoeListRequest,
    ) -> vod_20170321_models.DescribePlayQoeListResponse:
        """
        @summary 获取Ooe播放信息列表
        
        @param request: DescribePlayQoeListRequest
        @return: DescribePlayQoeListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_play_qoe_list_with_options_async(request, runtime)

    def describe_play_qos_list_with_options(
        self,
        tmp_req: vod_20170321_models.DescribePlayQosListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayQosListResponse:
        """
        @summary 获取Oos播放信息列表
        
        @param tmp_req: DescribePlayQosListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayQosListResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vod_20170321_models.DescribePlayQosListShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.metric_types):
            request.metric_types_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.metric_types, 'MetricTypes', 'json')
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.begin_ts):
            query['BeginTs'] = request.begin_ts
        if not UtilClient.is_unset(request.definition):
            query['Definition'] = request.definition
        if not UtilClient.is_unset(request.end_ts):
            query['EndTs'] = request.end_ts
        if not UtilClient.is_unset(request.item_configs):
            query['ItemConfigs'] = request.item_configs
        if not UtilClient.is_unset(request.metric_types_shrink):
            query['MetricTypes'] = request.metric_types_shrink
        if not UtilClient.is_unset(request.network):
            query['Network'] = request.network
        if not UtilClient.is_unset(request.order_name):
            query['OrderName'] = request.order_name
        if not UtilClient.is_unset(request.order_type):
            query['OrderType'] = request.order_type
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayQosList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayQosListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_play_qos_list_with_options_async(
        self,
        tmp_req: vod_20170321_models.DescribePlayQosListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayQosListResponse:
        """
        @summary 获取Oos播放信息列表
        
        @param tmp_req: DescribePlayQosListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayQosListResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vod_20170321_models.DescribePlayQosListShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.metric_types):
            request.metric_types_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.metric_types, 'MetricTypes', 'json')
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.begin_ts):
            query['BeginTs'] = request.begin_ts
        if not UtilClient.is_unset(request.definition):
            query['Definition'] = request.definition
        if not UtilClient.is_unset(request.end_ts):
            query['EndTs'] = request.end_ts
        if not UtilClient.is_unset(request.item_configs):
            query['ItemConfigs'] = request.item_configs
        if not UtilClient.is_unset(request.metric_types_shrink):
            query['MetricTypes'] = request.metric_types_shrink
        if not UtilClient.is_unset(request.network):
            query['Network'] = request.network
        if not UtilClient.is_unset(request.order_name):
            query['OrderName'] = request.order_name
        if not UtilClient.is_unset(request.order_type):
            query['OrderType'] = request.order_type
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayQosList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayQosListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_play_qos_list(
        self,
        request: vod_20170321_models.DescribePlayQosListRequest,
    ) -> vod_20170321_models.DescribePlayQosListResponse:
        """
        @summary 获取Oos播放信息列表
        
        @param request: DescribePlayQosListRequest
        @return: DescribePlayQosListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_play_qos_list_with_options(request, runtime)

    async def describe_play_qos_list_async(
        self,
        request: vod_20170321_models.DescribePlayQosListRequest,
    ) -> vod_20170321_models.DescribePlayQosListResponse:
        """
        @summary 获取Oos播放信息列表
        
        @param request: DescribePlayQosListRequest
        @return: DescribePlayQosListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_play_qos_list_with_options_async(request, runtime)

    def describe_play_top_videos_with_options(
        self,
        request: vod_20170321_models.DescribePlayTopVideosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayTopVideosResponse:
        """
        @summary Queries daily playback statistics on top videos, including video views, unique visitors, and total playback duration.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can query playback statistics on top 1,000 videos at most on a specified day. By default, top videos are sorted in descending order based on video views.
        You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
        You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
        
        @param request: DescribePlayTopVideosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayTopVideosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.biz_date):
            query['BizDate'] = request.biz_date
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayTopVideos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayTopVideosResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_play_top_videos_with_options_async(
        self,
        request: vod_20170321_models.DescribePlayTopVideosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayTopVideosResponse:
        """
        @summary Queries daily playback statistics on top videos, including video views, unique visitors, and total playback duration.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can query playback statistics on top 1,000 videos at most on a specified day. By default, top videos are sorted in descending order based on video views.
        You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
        You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
        
        @param request: DescribePlayTopVideosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayTopVideosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.biz_date):
            query['BizDate'] = request.biz_date
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayTopVideos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayTopVideosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_play_top_videos(
        self,
        request: vod_20170321_models.DescribePlayTopVideosRequest,
    ) -> vod_20170321_models.DescribePlayTopVideosResponse:
        """
        @summary Queries daily playback statistics on top videos, including video views, unique visitors, and total playback duration.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can query playback statistics on top 1,000 videos at most on a specified day. By default, top videos are sorted in descending order based on video views.
        You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
        You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
        
        @param request: DescribePlayTopVideosRequest
        @return: DescribePlayTopVideosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_play_top_videos_with_options(request, runtime)

    async def describe_play_top_videos_async(
        self,
        request: vod_20170321_models.DescribePlayTopVideosRequest,
    ) -> vod_20170321_models.DescribePlayTopVideosResponse:
        """
        @summary Queries daily playback statistics on top videos, including video views, unique visitors, and total playback duration.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can query playback statistics on top 1,000 videos at most on a specified day. By default, top videos are sorted in descending order based on video views.
        You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
        You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
        
        @param request: DescribePlayTopVideosRequest
        @return: DescribePlayTopVideosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_play_top_videos_with_options_async(request, runtime)

    def describe_play_user_avg_with_options(
        self,
        request: vod_20170321_models.DescribePlayUserAvgRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayUserAvgResponse:
        """
        @summary Queries the statistics on average playback each day in a specified time range.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        >    Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
        >    You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
        
        @param request: DescribePlayUserAvgRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayUserAvgResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayUserAvg',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayUserAvgResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_play_user_avg_with_options_async(
        self,
        request: vod_20170321_models.DescribePlayUserAvgRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayUserAvgResponse:
        """
        @summary Queries the statistics on average playback each day in a specified time range.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        >    Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
        >    You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
        
        @param request: DescribePlayUserAvgRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayUserAvgResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayUserAvg',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayUserAvgResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_play_user_avg(
        self,
        request: vod_20170321_models.DescribePlayUserAvgRequest,
    ) -> vod_20170321_models.DescribePlayUserAvgResponse:
        """
        @summary Queries the statistics on average playback each day in a specified time range.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        >    Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
        >    You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
        
        @param request: DescribePlayUserAvgRequest
        @return: DescribePlayUserAvgResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_play_user_avg_with_options(request, runtime)

    async def describe_play_user_avg_async(
        self,
        request: vod_20170321_models.DescribePlayUserAvgRequest,
    ) -> vod_20170321_models.DescribePlayUserAvgResponse:
        """
        @summary Queries the statistics on average playback each day in a specified time range.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        >    Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
        >    You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
        
        @param request: DescribePlayUserAvgRequest
        @return: DescribePlayUserAvgResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_play_user_avg_with_options_async(request, runtime)

    def describe_play_user_total_with_options(
        self,
        request: vod_20170321_models.DescribePlayUserTotalRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayUserTotalResponse:
        """
        @summary Queries the daily playback statistics in a specified time range. The playback statistics include the total number of views, total number of viewers, total playback duration, and playback duration distribution.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        Playback statistics for the current day are generated at 09:00 (UTC+8) on the next day.
        You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
        
        @param request: DescribePlayUserTotalRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayUserTotalResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayUserTotal',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayUserTotalResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_play_user_total_with_options_async(
        self,
        request: vod_20170321_models.DescribePlayUserTotalRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayUserTotalResponse:
        """
        @summary Queries the daily playback statistics in a specified time range. The playback statistics include the total number of views, total number of viewers, total playback duration, and playback duration distribution.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        Playback statistics for the current day are generated at 09:00 (UTC+8) on the next day.
        You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
        
        @param request: DescribePlayUserTotalRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayUserTotalResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayUserTotal',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayUserTotalResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_play_user_total(
        self,
        request: vod_20170321_models.DescribePlayUserTotalRequest,
    ) -> vod_20170321_models.DescribePlayUserTotalResponse:
        """
        @summary Queries the daily playback statistics in a specified time range. The playback statistics include the total number of views, total number of viewers, total playback duration, and playback duration distribution.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        Playback statistics for the current day are generated at 09:00 (UTC+8) on the next day.
        You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
        
        @param request: DescribePlayUserTotalRequest
        @return: DescribePlayUserTotalResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_play_user_total_with_options(request, runtime)

    async def describe_play_user_total_async(
        self,
        request: vod_20170321_models.DescribePlayUserTotalRequest,
    ) -> vod_20170321_models.DescribePlayUserTotalResponse:
        """
        @summary Queries the daily playback statistics in a specified time range. The playback statistics include the total number of views, total number of viewers, total playback duration, and playback duration distribution.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        Playback statistics for the current day are generated at 09:00 (UTC+8) on the next day.
        You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
        
        @param request: DescribePlayUserTotalRequest
        @return: DescribePlayUserTotalResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_play_user_total_with_options_async(request, runtime)

    def describe_play_video_statis_with_options(
        self,
        request: vod_20170321_models.DescribePlayVideoStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayVideoStatisResponse:
        """
        @summary Queries daily playback statistics on a video in the specified time range.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        Playback statistics for the current day are generated at 09:00 (UTC+8) on the next day.
        You can query only data in the last 730 days. The maximum time range to query is 180 days.
        
        @param request: DescribePlayVideoStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayVideoStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayVideoStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayVideoStatisResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_play_video_statis_with_options_async(
        self,
        request: vod_20170321_models.DescribePlayVideoStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribePlayVideoStatisResponse:
        """
        @summary Queries daily playback statistics on a video in the specified time range.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        Playback statistics for the current day are generated at 09:00 (UTC+8) on the next day.
        You can query only data in the last 730 days. The maximum time range to query is 180 days.
        
        @param request: DescribePlayVideoStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePlayVideoStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePlayVideoStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribePlayVideoStatisResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_play_video_statis(
        self,
        request: vod_20170321_models.DescribePlayVideoStatisRequest,
    ) -> vod_20170321_models.DescribePlayVideoStatisResponse:
        """
        @summary Queries daily playback statistics on a video in the specified time range.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        Playback statistics for the current day are generated at 09:00 (UTC+8) on the next day.
        You can query only data in the last 730 days. The maximum time range to query is 180 days.
        
        @param request: DescribePlayVideoStatisRequest
        @return: DescribePlayVideoStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_play_video_statis_with_options(request, runtime)

    async def describe_play_video_statis_async(
        self,
        request: vod_20170321_models.DescribePlayVideoStatisRequest,
    ) -> vod_20170321_models.DescribePlayVideoStatisResponse:
        """
        @summary Queries daily playback statistics on a video in the specified time range.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
        Playback statistics for the current day are generated at 09:00 (UTC+8) on the next day.
        You can query only data in the last 730 days. The maximum time range to query is 180 days.
        
        @param request: DescribePlayVideoStatisRequest
        @return: DescribePlayVideoStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_play_video_statis_with_options_async(request, runtime)

    def describe_query_configs_with_options(
        self,
        request: vod_20170321_models.DescribeQueryConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeQueryConfigsResponse:
        """
        @summary 获取查询条件信息
        
        @param request: DescribeQueryConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeQueryConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeQueryConfigs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeQueryConfigsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_query_configs_with_options_async(
        self,
        request: vod_20170321_models.DescribeQueryConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeQueryConfigsResponse:
        """
        @summary 获取查询条件信息
        
        @param request: DescribeQueryConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeQueryConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeQueryConfigs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeQueryConfigsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_query_configs(
        self,
        request: vod_20170321_models.DescribeQueryConfigsRequest,
    ) -> vod_20170321_models.DescribeQueryConfigsResponse:
        """
        @summary 获取查询条件信息
        
        @param request: DescribeQueryConfigsRequest
        @return: DescribeQueryConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_query_configs_with_options(request, runtime)

    async def describe_query_configs_async(
        self,
        request: vod_20170321_models.DescribeQueryConfigsRequest,
    ) -> vod_20170321_models.DescribeQueryConfigsResponse:
        """
        @summary 获取查询条件信息
        
        @param request: DescribeQueryConfigsRequest
        @return: DescribeQueryConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_query_configs_with_options_async(request, runtime)

    def describe_refresh_quota_with_options(
        self,
        request: vod_20170321_models.DescribeRefreshQuotaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeRefreshQuotaResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeRefreshQuotaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRefreshQuotaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRefreshQuota',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeRefreshQuotaResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_refresh_quota_with_options_async(
        self,
        request: vod_20170321_models.DescribeRefreshQuotaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeRefreshQuotaResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeRefreshQuotaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRefreshQuotaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRefreshQuota',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeRefreshQuotaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_refresh_quota(
        self,
        request: vod_20170321_models.DescribeRefreshQuotaRequest,
    ) -> vod_20170321_models.DescribeRefreshQuotaResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeRefreshQuotaRequest
        @return: DescribeRefreshQuotaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_refresh_quota_with_options(request, runtime)

    async def describe_refresh_quota_async(
        self,
        request: vod_20170321_models.DescribeRefreshQuotaRequest,
    ) -> vod_20170321_models.DescribeRefreshQuotaResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeRefreshQuotaRequest
        @return: DescribeRefreshQuotaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_refresh_quota_with_options_async(request, runtime)

    def describe_refresh_tasks_with_options(
        self,
        request: vod_20170321_models.DescribeRefreshTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeRefreshTasksResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeRefreshTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRefreshTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.object_type):
            query['ObjectType'] = request.object_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRefreshTasks',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeRefreshTasksResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_refresh_tasks_with_options_async(
        self,
        request: vod_20170321_models.DescribeRefreshTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeRefreshTasksResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeRefreshTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeRefreshTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.object_type):
            query['ObjectType'] = request.object_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeRefreshTasks',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeRefreshTasksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_refresh_tasks(
        self,
        request: vod_20170321_models.DescribeRefreshTasksRequest,
    ) -> vod_20170321_models.DescribeRefreshTasksResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeRefreshTasksRequest
        @return: DescribeRefreshTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_refresh_tasks_with_options(request, runtime)

    async def describe_refresh_tasks_async(
        self,
        request: vod_20170321_models.DescribeRefreshTasksRequest,
    ) -> vod_20170321_models.DescribeRefreshTasksResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeRefreshTasksRequest
        @return: DescribeRefreshTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_refresh_tasks_with_options_async(request, runtime)

    def describe_user_vod_status_with_options(
        self,
        request: vod_20170321_models.DescribeUserVodStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeUserVodStatusResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeUserVodStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUserVodStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUserVodStatus',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeUserVodStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_user_vod_status_with_options_async(
        self,
        request: vod_20170321_models.DescribeUserVodStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeUserVodStatusResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeUserVodStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeUserVodStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeUserVodStatus',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeUserVodStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_user_vod_status(
        self,
        request: vod_20170321_models.DescribeUserVodStatusRequest,
    ) -> vod_20170321_models.DescribeUserVodStatusResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeUserVodStatusRequest
        @return: DescribeUserVodStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_user_vod_status_with_options(request, runtime)

    async def describe_user_vod_status_async(
        self,
        request: vod_20170321_models.DescribeUserVodStatusRequest,
    ) -> vod_20170321_models.DescribeUserVodStatusResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeUserVodStatusRequest
        @return: DescribeUserVodStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_user_vod_status_with_options_async(request, runtime)

    def describe_vod_aidata_with_options(
        self,
        request: vod_20170321_models.DescribeVodAIDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodAIDataResponse:
        """
        @summary Queries the statistics on video AI of different types, such as automated review and media fingerprinting.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
        
        @param request: DescribeVodAIDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodAIDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aitype):
            query['AIType'] = request.aitype
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodAIData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodAIDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_aidata_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodAIDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodAIDataResponse:
        """
        @summary Queries the statistics on video AI of different types, such as automated review and media fingerprinting.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
        
        @param request: DescribeVodAIDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodAIDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aitype):
            query['AIType'] = request.aitype
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodAIData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodAIDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_aidata(
        self,
        request: vod_20170321_models.DescribeVodAIDataRequest,
    ) -> vod_20170321_models.DescribeVodAIDataResponse:
        """
        @summary Queries the statistics on video AI of different types, such as automated review and media fingerprinting.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
        
        @param request: DescribeVodAIDataRequest
        @return: DescribeVodAIDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_aidata_with_options(request, runtime)

    async def describe_vod_aidata_async(
        self,
        request: vod_20170321_models.DescribeVodAIDataRequest,
    ) -> vod_20170321_models.DescribeVodAIDataResponse:
        """
        @summary Queries the statistics on video AI of different types, such as automated review and media fingerprinting.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
        
        @param request: DescribeVodAIDataRequest
        @return: DescribeVodAIDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_aidata_with_options_async(request, runtime)

    def describe_vod_app_name_with_options(
        self,
        request: vod_20170321_models.DescribeVodAppNameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodAppNameResponse:
        """
        @summary 查询App Name
        
        @param request: DescribeVodAppNameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodAppNameResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodAppName',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodAppNameResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_app_name_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodAppNameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodAppNameResponse:
        """
        @summary 查询App Name
        
        @param request: DescribeVodAppNameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodAppNameResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodAppName',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodAppNameResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_app_name(
        self,
        request: vod_20170321_models.DescribeVodAppNameRequest,
    ) -> vod_20170321_models.DescribeVodAppNameResponse:
        """
        @summary 查询App Name
        
        @param request: DescribeVodAppNameRequest
        @return: DescribeVodAppNameResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_app_name_with_options(request, runtime)

    async def describe_vod_app_name_async(
        self,
        request: vod_20170321_models.DescribeVodAppNameRequest,
    ) -> vod_20170321_models.DescribeVodAppNameResponse:
        """
        @summary 查询App Name
        
        @param request: DescribeVodAppNameRequest
        @return: DescribeVodAppNameResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_app_name_with_options_async(request, runtime)

    def describe_vod_certificate_detail_with_options(
        self,
        request: vod_20170321_models.DescribeVodCertificateDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodCertificateDetailResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodCertificateDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodCertificateDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_name):
            query['CertName'] = request.cert_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodCertificateDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodCertificateDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_certificate_detail_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodCertificateDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodCertificateDetailResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodCertificateDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodCertificateDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_name):
            query['CertName'] = request.cert_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodCertificateDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodCertificateDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_certificate_detail(
        self,
        request: vod_20170321_models.DescribeVodCertificateDetailRequest,
    ) -> vod_20170321_models.DescribeVodCertificateDetailResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodCertificateDetailRequest
        @return: DescribeVodCertificateDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_certificate_detail_with_options(request, runtime)

    async def describe_vod_certificate_detail_async(
        self,
        request: vod_20170321_models.DescribeVodCertificateDetailRequest,
    ) -> vod_20170321_models.DescribeVodCertificateDetailResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodCertificateDetailRequest
        @return: DescribeVodCertificateDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_certificate_detail_with_options_async(request, runtime)

    def describe_vod_certificate_detail_by_id_with_options(
        self,
        request: vod_20170321_models.DescribeVodCertificateDetailByIdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodCertificateDetailByIdResponse:
        """
        @summary 查询证书详情
        
        @param request: DescribeVodCertificateDetailByIdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodCertificateDetailByIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_id):
            query['CertId'] = request.cert_id
        if not UtilClient.is_unset(request.cert_region):
            query['CertRegion'] = request.cert_region
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodCertificateDetailById',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodCertificateDetailByIdResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_certificate_detail_by_id_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodCertificateDetailByIdRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodCertificateDetailByIdResponse:
        """
        @summary 查询证书详情
        
        @param request: DescribeVodCertificateDetailByIdRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodCertificateDetailByIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_id):
            query['CertId'] = request.cert_id
        if not UtilClient.is_unset(request.cert_region):
            query['CertRegion'] = request.cert_region
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodCertificateDetailById',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodCertificateDetailByIdResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_certificate_detail_by_id(
        self,
        request: vod_20170321_models.DescribeVodCertificateDetailByIdRequest,
    ) -> vod_20170321_models.DescribeVodCertificateDetailByIdResponse:
        """
        @summary 查询证书详情
        
        @param request: DescribeVodCertificateDetailByIdRequest
        @return: DescribeVodCertificateDetailByIdResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_certificate_detail_by_id_with_options(request, runtime)

    async def describe_vod_certificate_detail_by_id_async(
        self,
        request: vod_20170321_models.DescribeVodCertificateDetailByIdRequest,
    ) -> vod_20170321_models.DescribeVodCertificateDetailByIdResponse:
        """
        @summary 查询证书详情
        
        @param request: DescribeVodCertificateDetailByIdRequest
        @return: DescribeVodCertificateDetailByIdResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_certificate_detail_by_id_with_options_async(request, runtime)

    def describe_vod_certificate_list_with_options(
        self,
        request: vod_20170321_models.DescribeVodCertificateListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodCertificateListResponse:
        """
        @summary Queries the certificates of a specified domain name for CDN or all the domain names for CDN within your Alibaba Cloud account.
        
        @description >  This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodCertificateListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodCertificateListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodCertificateList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodCertificateListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_certificate_list_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodCertificateListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodCertificateListResponse:
        """
        @summary Queries the certificates of a specified domain name for CDN or all the domain names for CDN within your Alibaba Cloud account.
        
        @description >  This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodCertificateListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodCertificateListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodCertificateList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodCertificateListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_certificate_list(
        self,
        request: vod_20170321_models.DescribeVodCertificateListRequest,
    ) -> vod_20170321_models.DescribeVodCertificateListResponse:
        """
        @summary Queries the certificates of a specified domain name for CDN or all the domain names for CDN within your Alibaba Cloud account.
        
        @description >  This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodCertificateListRequest
        @return: DescribeVodCertificateListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_certificate_list_with_options(request, runtime)

    async def describe_vod_certificate_list_async(
        self,
        request: vod_20170321_models.DescribeVodCertificateListRequest,
    ) -> vod_20170321_models.DescribeVodCertificateListResponse:
        """
        @summary Queries the certificates of a specified domain name for CDN or all the domain names for CDN within your Alibaba Cloud account.
        
        @description >  This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodCertificateListRequest
        @return: DescribeVodCertificateListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_certificate_list_with_options_async(request, runtime)

    def describe_vod_domain_bps_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainBpsDataResponse:
        """
        @summary Queries the bandwidth for one or more specified domain names for CDN.
        
        @description If you specify neither the StartTime parameter nor the EndTime parameter, the data in the last 24 hours is queried. Alternatively, you can specify both the StartTime and EndTime parameters to query data that is generated in the specified duration. You can query data for the last 90 days at most.
        
        @param request: DescribeVodDomainBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainBpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainBpsDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_bps_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainBpsDataResponse:
        """
        @summary Queries the bandwidth for one or more specified domain names for CDN.
        
        @description If you specify neither the StartTime parameter nor the EndTime parameter, the data in the last 24 hours is queried. Alternatively, you can specify both the StartTime and EndTime parameters to query data that is generated in the specified duration. You can query data for the last 90 days at most.
        
        @param request: DescribeVodDomainBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainBpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainBpsDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_bps_data(
        self,
        request: vod_20170321_models.DescribeVodDomainBpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainBpsDataResponse:
        """
        @summary Queries the bandwidth for one or more specified domain names for CDN.
        
        @description If you specify neither the StartTime parameter nor the EndTime parameter, the data in the last 24 hours is queried. Alternatively, you can specify both the StartTime and EndTime parameters to query data that is generated in the specified duration. You can query data for the last 90 days at most.
        
        @param request: DescribeVodDomainBpsDataRequest
        @return: DescribeVodDomainBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_bps_data_with_options(request, runtime)

    async def describe_vod_domain_bps_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainBpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainBpsDataResponse:
        """
        @summary Queries the bandwidth for one or more specified domain names for CDN.
        
        @description If you specify neither the StartTime parameter nor the EndTime parameter, the data in the last 24 hours is queried. Alternatively, you can specify both the StartTime and EndTime parameters to query data that is generated in the specified duration. You can query data for the last 90 days at most.
        
        @param request: DescribeVodDomainBpsDataRequest
        @return: DescribeVodDomainBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_bps_data_with_options_async(request, runtime)

    def describe_vod_domain_bps_data_by_layer_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainBpsDataByLayerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainBpsDataByLayerResponse:
        """
        @summary Queries the bandwidth data by protocol.
        
        @description You can call this API operation up to 20 times per second per account. If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range. Time granularity
        The time granularity supported by Interval, the maximum time period within which historical data is available, and the data delay vary based on the time range to query, as described in the following table.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |15 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|3 to 4 hours|
        |1 day|90 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainBpsDataByLayerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainBpsDataByLayerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.layer):
            query['Layer'] = request.layer
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainBpsDataByLayer',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainBpsDataByLayerResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_bps_data_by_layer_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainBpsDataByLayerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainBpsDataByLayerResponse:
        """
        @summary Queries the bandwidth data by protocol.
        
        @description You can call this API operation up to 20 times per second per account. If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range. Time granularity
        The time granularity supported by Interval, the maximum time period within which historical data is available, and the data delay vary based on the time range to query, as described in the following table.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |15 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|3 to 4 hours|
        |1 day|90 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainBpsDataByLayerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainBpsDataByLayerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.layer):
            query['Layer'] = request.layer
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainBpsDataByLayer',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainBpsDataByLayerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_bps_data_by_layer(
        self,
        request: vod_20170321_models.DescribeVodDomainBpsDataByLayerRequest,
    ) -> vod_20170321_models.DescribeVodDomainBpsDataByLayerResponse:
        """
        @summary Queries the bandwidth data by protocol.
        
        @description You can call this API operation up to 20 times per second per account. If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range. Time granularity
        The time granularity supported by Interval, the maximum time period within which historical data is available, and the data delay vary based on the time range to query, as described in the following table.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |15 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|3 to 4 hours|
        |1 day|90 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainBpsDataByLayerRequest
        @return: DescribeVodDomainBpsDataByLayerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_bps_data_by_layer_with_options(request, runtime)

    async def describe_vod_domain_bps_data_by_layer_async(
        self,
        request: vod_20170321_models.DescribeVodDomainBpsDataByLayerRequest,
    ) -> vod_20170321_models.DescribeVodDomainBpsDataByLayerResponse:
        """
        @summary Queries the bandwidth data by protocol.
        
        @description You can call this API operation up to 20 times per second per account. If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range. Time granularity
        The time granularity supported by Interval, the maximum time period within which historical data is available, and the data delay vary based on the time range to query, as described in the following table.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |15 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|3 to 4 hours|
        |1 day|90 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainBpsDataByLayerRequest
        @return: DescribeVodDomainBpsDataByLayerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_bps_data_by_layer_with_options_async(request, runtime)

    def describe_vod_domain_certificate_info_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainCertificateInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainCertificateInfoResponse:
        """
        @summary Queries the certificate information about an accelerated domain name.
        
        @description This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodDomainCertificateInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainCertificateInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainCertificateInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainCertificateInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_certificate_info_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainCertificateInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainCertificateInfoResponse:
        """
        @summary Queries the certificate information about an accelerated domain name.
        
        @description This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodDomainCertificateInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainCertificateInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainCertificateInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainCertificateInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_certificate_info(
        self,
        request: vod_20170321_models.DescribeVodDomainCertificateInfoRequest,
    ) -> vod_20170321_models.DescribeVodDomainCertificateInfoResponse:
        """
        @summary Queries the certificate information about an accelerated domain name.
        
        @description This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodDomainCertificateInfoRequest
        @return: DescribeVodDomainCertificateInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_certificate_info_with_options(request, runtime)

    async def describe_vod_domain_certificate_info_async(
        self,
        request: vod_20170321_models.DescribeVodDomainCertificateInfoRequest,
    ) -> vod_20170321_models.DescribeVodDomainCertificateInfoResponse:
        """
        @summary Queries the certificate information about an accelerated domain name.
        
        @description This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodDomainCertificateInfoRequest
        @return: DescribeVodDomainCertificateInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_certificate_info_with_options_async(request, runtime)

    def describe_vod_domain_cname_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainCnameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainCnameResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainCnameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainCnameResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainCname',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainCnameResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_cname_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainCnameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainCnameResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainCnameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainCnameResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainCname',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainCnameResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_cname(
        self,
        request: vod_20170321_models.DescribeVodDomainCnameRequest,
    ) -> vod_20170321_models.DescribeVodDomainCnameResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainCnameRequest
        @return: DescribeVodDomainCnameResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_cname_with_options(request, runtime)

    async def describe_vod_domain_cname_async(
        self,
        request: vod_20170321_models.DescribeVodDomainCnameRequest,
    ) -> vod_20170321_models.DescribeVodDomainCnameResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainCnameRequest
        @return: DescribeVodDomainCnameResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_cname_with_options_async(request, runtime)

    def describe_vod_domain_configs_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainConfigsResponse:
        """
        @summary Queries the configurations of a domain name for CDN. You can query the configurations of multiple features at a time.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodDomainConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.function_names):
            query['FunctionNames'] = request.function_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainConfigs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainConfigsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_configs_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainConfigsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainConfigsResponse:
        """
        @summary Queries the configurations of a domain name for CDN. You can query the configurations of multiple features at a time.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodDomainConfigsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.function_names):
            query['FunctionNames'] = request.function_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainConfigs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainConfigsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_configs(
        self,
        request: vod_20170321_models.DescribeVodDomainConfigsRequest,
    ) -> vod_20170321_models.DescribeVodDomainConfigsResponse:
        """
        @summary Queries the configurations of a domain name for CDN. You can query the configurations of multiple features at a time.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodDomainConfigsRequest
        @return: DescribeVodDomainConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_configs_with_options(request, runtime)

    async def describe_vod_domain_configs_async(
        self,
        request: vod_20170321_models.DescribeVodDomainConfigsRequest,
    ) -> vod_20170321_models.DescribeVodDomainConfigsResponse:
        """
        @summary Queries the configurations of a domain name for CDN. You can query the configurations of multiple features at a time.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodDomainConfigsRequest
        @return: DescribeVodDomainConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_configs_with_options_async(request, runtime)

    def describe_vod_domain_detail_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainDetailResponse:
        """
        @summary Queries the basic information about a specified domain name for CDN.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodDomainDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_detail_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainDetailResponse:
        """
        @summary Queries the basic information about a specified domain name for CDN.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodDomainDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_detail(
        self,
        request: vod_20170321_models.DescribeVodDomainDetailRequest,
    ) -> vod_20170321_models.DescribeVodDomainDetailResponse:
        """
        @summary Queries the basic information about a specified domain name for CDN.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodDomainDetailRequest
        @return: DescribeVodDomainDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_detail_with_options(request, runtime)

    async def describe_vod_domain_detail_async(
        self,
        request: vod_20170321_models.DescribeVodDomainDetailRequest,
    ) -> vod_20170321_models.DescribeVodDomainDetailResponse:
        """
        @summary Queries the basic information about a specified domain name for CDN.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: DescribeVodDomainDetailRequest
        @return: DescribeVodDomainDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_detail_with_options_async(request, runtime)

    def describe_vod_domain_hit_rate_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainHitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainHitRateDataResponse:
        """
        @summary Queries the byte hit ratios of accelerated domain names. Byte hit ratios are measured in percentage.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time span of a single query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainHitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainHitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainHitRateData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainHitRateDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_hit_rate_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainHitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainHitRateDataResponse:
        """
        @summary Queries the byte hit ratios of accelerated domain names. Byte hit ratios are measured in percentage.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time span of a single query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainHitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainHitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainHitRateData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainHitRateDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_hit_rate_data(
        self,
        request: vod_20170321_models.DescribeVodDomainHitRateDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainHitRateDataResponse:
        """
        @summary Queries the byte hit ratios of accelerated domain names. Byte hit ratios are measured in percentage.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time span of a single query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainHitRateDataRequest
        @return: DescribeVodDomainHitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_hit_rate_data_with_options(request, runtime)

    async def describe_vod_domain_hit_rate_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainHitRateDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainHitRateDataResponse:
        """
        @summary Queries the byte hit ratios of accelerated domain names. Byte hit ratios are measured in percentage.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time span of a single query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainHitRateDataRequest
        @return: DescribeVodDomainHitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_hit_rate_data_with_options_async(request, runtime)

    def describe_vod_domain_http_code_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainHttpCodeDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainHttpCodeDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainHttpCodeDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainHttpCodeDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainHttpCodeData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainHttpCodeDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_http_code_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainHttpCodeDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainHttpCodeDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainHttpCodeDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainHttpCodeDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainHttpCodeData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainHttpCodeDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_http_code_data(
        self,
        request: vod_20170321_models.DescribeVodDomainHttpCodeDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainHttpCodeDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainHttpCodeDataRequest
        @return: DescribeVodDomainHttpCodeDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_http_code_data_with_options(request, runtime)

    async def describe_vod_domain_http_code_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainHttpCodeDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainHttpCodeDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainHttpCodeDataRequest
        @return: DescribeVodDomainHttpCodeDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_http_code_data_with_options_async(request, runtime)

    def describe_vod_domain_ispdata_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainISPDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainISPDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainISPDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainISPDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainISPData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainISPDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_ispdata_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainISPDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainISPDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainISPDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainISPDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainISPData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainISPDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_ispdata(
        self,
        request: vod_20170321_models.DescribeVodDomainISPDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainISPDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainISPDataRequest
        @return: DescribeVodDomainISPDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_ispdata_with_options(request, runtime)

    async def describe_vod_domain_ispdata_async(
        self,
        request: vod_20170321_models.DescribeVodDomainISPDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainISPDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainISPDataRequest
        @return: DescribeVodDomainISPDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_ispdata_with_options_async(request, runtime)

    def describe_vod_domain_log_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainLogResponse:
        """
        @summary Queries the information about the CDN access logs for a domain name, including the log path.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        For more information about the log format and latency, see [Download logs](https://help.aliyun.com/document_detail/86099.html).
        If you specify neither the StartTime parameter nor the EndTime parameter, the log data in the last 24 hours is queried.
        You can specify both the StartTime and EndTime parameters to query the log data that is generated in the specified time range.
        
        @param request: DescribeVodDomainLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainLog',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_log_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainLogResponse:
        """
        @summary Queries the information about the CDN access logs for a domain name, including the log path.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        For more information about the log format and latency, see [Download logs](https://help.aliyun.com/document_detail/86099.html).
        If you specify neither the StartTime parameter nor the EndTime parameter, the log data in the last 24 hours is queried.
        You can specify both the StartTime and EndTime parameters to query the log data that is generated in the specified time range.
        
        @param request: DescribeVodDomainLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainLog',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_log(
        self,
        request: vod_20170321_models.DescribeVodDomainLogRequest,
    ) -> vod_20170321_models.DescribeVodDomainLogResponse:
        """
        @summary Queries the information about the CDN access logs for a domain name, including the log path.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        For more information about the log format and latency, see [Download logs](https://help.aliyun.com/document_detail/86099.html).
        If you specify neither the StartTime parameter nor the EndTime parameter, the log data in the last 24 hours is queried.
        You can specify both the StartTime and EndTime parameters to query the log data that is generated in the specified time range.
        
        @param request: DescribeVodDomainLogRequest
        @return: DescribeVodDomainLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_log_with_options(request, runtime)

    async def describe_vod_domain_log_async(
        self,
        request: vod_20170321_models.DescribeVodDomainLogRequest,
    ) -> vod_20170321_models.DescribeVodDomainLogResponse:
        """
        @summary Queries the information about the CDN access logs for a domain name, including the log path.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        For more information about the log format and latency, see [Download logs](https://help.aliyun.com/document_detail/86099.html).
        If you specify neither the StartTime parameter nor the EndTime parameter, the log data in the last 24 hours is queried.
        You can specify both the StartTime and EndTime parameters to query the log data that is generated in the specified time range.
        
        @param request: DescribeVodDomainLogRequest
        @return: DescribeVodDomainLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_log_with_options_async(request, runtime)

    def describe_vod_domain_max_95bps_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainMax95BpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainMax95BpsDataResponse:
        """
        @summary Queries the 95th percentile bandwidth data of an accelerated domain name.
        
        @param request: DescribeVodDomainMax95BpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainMax95BpsDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainMax95BpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainMax95BpsDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_max_95bps_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainMax95BpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainMax95BpsDataResponse:
        """
        @summary Queries the 95th percentile bandwidth data of an accelerated domain name.
        
        @param request: DescribeVodDomainMax95BpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainMax95BpsDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainMax95BpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainMax95BpsDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_max_95bps_data(
        self,
        request: vod_20170321_models.DescribeVodDomainMax95BpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainMax95BpsDataResponse:
        """
        @summary Queries the 95th percentile bandwidth data of an accelerated domain name.
        
        @param request: DescribeVodDomainMax95BpsDataRequest
        @return: DescribeVodDomainMax95BpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_max_95bps_data_with_options(request, runtime)

    async def describe_vod_domain_max_95bps_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainMax95BpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainMax95BpsDataResponse:
        """
        @summary Queries the 95th percentile bandwidth data of an accelerated domain name.
        
        @param request: DescribeVodDomainMax95BpsDataRequest
        @return: DescribeVodDomainMax95BpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_max_95bps_data_with_options_async(request, runtime)

    def describe_vod_domain_pv_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainPvDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainPvDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainPvDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainPvDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainPvData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainPvDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_pv_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainPvDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainPvDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainPvDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainPvDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainPvData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainPvDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_pv_data(
        self,
        request: vod_20170321_models.DescribeVodDomainPvDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainPvDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainPvDataRequest
        @return: DescribeVodDomainPvDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_pv_data_with_options(request, runtime)

    async def describe_vod_domain_pv_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainPvDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainPvDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainPvDataRequest
        @return: DescribeVodDomainPvDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_pv_data_with_options_async(request, runtime)

    def describe_vod_domain_qps_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainQpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainQpsDataResponse:
        """
        @summary Queries the number of queries per second (QPS) for one or more accelerated domain names. Data is collected every 5 minutes. You can query data collected in the last 90 days.
        
        @description  This operation is available only in the China (Shanghai) region.
        You can call this operation up to 100 times per second per account.
        If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
        *Time granularity**\
        The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|3 to 4 hours|
        |1 day|366 days|366 days|4 to 24 hours|
        ---\
        
        @param request: DescribeVodDomainQpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainQpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainQpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainQpsDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_qps_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainQpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainQpsDataResponse:
        """
        @summary Queries the number of queries per second (QPS) for one or more accelerated domain names. Data is collected every 5 minutes. You can query data collected in the last 90 days.
        
        @description  This operation is available only in the China (Shanghai) region.
        You can call this operation up to 100 times per second per account.
        If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
        *Time granularity**\
        The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|3 to 4 hours|
        |1 day|366 days|366 days|4 to 24 hours|
        ---\
        
        @param request: DescribeVodDomainQpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainQpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainQpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainQpsDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_qps_data(
        self,
        request: vod_20170321_models.DescribeVodDomainQpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainQpsDataResponse:
        """
        @summary Queries the number of queries per second (QPS) for one or more accelerated domain names. Data is collected every 5 minutes. You can query data collected in the last 90 days.
        
        @description  This operation is available only in the China (Shanghai) region.
        You can call this operation up to 100 times per second per account.
        If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
        *Time granularity**\
        The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|3 to 4 hours|
        |1 day|366 days|366 days|4 to 24 hours|
        ---\
        
        @param request: DescribeVodDomainQpsDataRequest
        @return: DescribeVodDomainQpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_qps_data_with_options(request, runtime)

    async def describe_vod_domain_qps_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainQpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainQpsDataResponse:
        """
        @summary Queries the number of queries per second (QPS) for one or more accelerated domain names. Data is collected every 5 minutes. You can query data collected in the last 90 days.
        
        @description  This operation is available only in the China (Shanghai) region.
        You can call this operation up to 100 times per second per account.
        If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
        *Time granularity**\
        The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|3 days|93 days|15 minutes|
        |1 hour|31 days|186 days|3 to 4 hours|
        |1 day|366 days|366 days|4 to 24 hours|
        ---\
        
        @param request: DescribeVodDomainQpsDataRequest
        @return: DescribeVodDomainQpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_qps_data_with_options_async(request, runtime)

    def describe_vod_domain_real_time_bps_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeBpsDataResponse:
        """
        @summary Queries the bandwidth data for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days. Compared with the DescribeVodDomainBpsData operation, this operation provides a smaller time granularity, lower data latency, and allows you to query historical data within a shorter time period.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeBpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeBpsDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_real_time_bps_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeBpsDataResponse:
        """
        @summary Queries the bandwidth data for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days. Compared with the DescribeVodDomainBpsData operation, this operation provides a smaller time granularity, lower data latency, and allows you to query historical data within a shorter time period.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeBpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeBpsDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_real_time_bps_data(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeBpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeBpsDataResponse:
        """
        @summary Queries the bandwidth data for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days. Compared with the DescribeVodDomainBpsData operation, this operation provides a smaller time granularity, lower data latency, and allows you to query historical data within a shorter time period.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeBpsDataRequest
        @return: DescribeVodDomainRealTimeBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_real_time_bps_data_with_options(request, runtime)

    async def describe_vod_domain_real_time_bps_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeBpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeBpsDataResponse:
        """
        @summary Queries the bandwidth data for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days. Compared with the DescribeVodDomainBpsData operation, this operation provides a smaller time granularity, lower data latency, and allows you to query historical data within a shorter time period.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeBpsDataRequest
        @return: DescribeVodDomainRealTimeBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_real_time_bps_data_with_options_async(request, runtime)

    def describe_vod_domain_real_time_byte_hit_rate_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeByteHitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeByteHitRateDataResponse:
        """
        @summary Queries the byte hit ratio for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeByteHitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeByteHitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeByteHitRateData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeByteHitRateDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_real_time_byte_hit_rate_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeByteHitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeByteHitRateDataResponse:
        """
        @summary Queries the byte hit ratio for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeByteHitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeByteHitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeByteHitRateData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeByteHitRateDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_real_time_byte_hit_rate_data(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeByteHitRateDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeByteHitRateDataResponse:
        """
        @summary Queries the byte hit ratio for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeByteHitRateDataRequest
        @return: DescribeVodDomainRealTimeByteHitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_real_time_byte_hit_rate_data_with_options(request, runtime)

    async def describe_vod_domain_real_time_byte_hit_rate_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeByteHitRateDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeByteHitRateDataResponse:
        """
        @summary Queries the byte hit ratio for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeByteHitRateDataRequest
        @return: DescribeVodDomainRealTimeByteHitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_real_time_byte_hit_rate_data_with_options_async(request, runtime)

    def describe_vod_domain_real_time_detail_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeDetailDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeDetailDataResponse:
        """
        @summary Queries real-time monitoring data of one or more accelerated domain names.
        
        @description You can query data within the last seven days. Data is collected every minute. You can call this API operation up to 10 times per second per account.
        
        @param request: DescribeVodDomainRealTimeDetailDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeDetailDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeDetailData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeDetailDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_real_time_detail_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeDetailDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeDetailDataResponse:
        """
        @summary Queries real-time monitoring data of one or more accelerated domain names.
        
        @description You can query data within the last seven days. Data is collected every minute. You can call this API operation up to 10 times per second per account.
        
        @param request: DescribeVodDomainRealTimeDetailDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeDetailDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeDetailData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeDetailDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_real_time_detail_data(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeDetailDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeDetailDataResponse:
        """
        @summary Queries real-time monitoring data of one or more accelerated domain names.
        
        @description You can query data within the last seven days. Data is collected every minute. You can call this API operation up to 10 times per second per account.
        
        @param request: DescribeVodDomainRealTimeDetailDataRequest
        @return: DescribeVodDomainRealTimeDetailDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_real_time_detail_data_with_options(request, runtime)

    async def describe_vod_domain_real_time_detail_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeDetailDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeDetailDataResponse:
        """
        @summary Queries real-time monitoring data of one or more accelerated domain names.
        
        @description You can query data within the last seven days. Data is collected every minute. You can call this API operation up to 10 times per second per account.
        
        @param request: DescribeVodDomainRealTimeDetailDataRequest
        @return: DescribeVodDomainRealTimeDetailDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_real_time_detail_data_with_options_async(request, runtime)

    def describe_vod_domain_real_time_http_code_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeHttpCodeDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeHttpCodeDataResponse:
        """
        @summary Queries the total number of HTTP status codes and proportion of each HTTP status code for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available (days)|Data latency|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 hour &#x3C; Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeHttpCodeDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeHttpCodeDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeHttpCodeData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeHttpCodeDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_real_time_http_code_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeHttpCodeDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeHttpCodeDataResponse:
        """
        @summary Queries the total number of HTTP status codes and proportion of each HTTP status code for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available (days)|Data latency|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 hour &#x3C; Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeHttpCodeDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeHttpCodeDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeHttpCodeData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeHttpCodeDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_real_time_http_code_data(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeHttpCodeDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeHttpCodeDataResponse:
        """
        @summary Queries the total number of HTTP status codes and proportion of each HTTP status code for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available (days)|Data latency|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 hour &#x3C; Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeHttpCodeDataRequest
        @return: DescribeVodDomainRealTimeHttpCodeDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_real_time_http_code_data_with_options(request, runtime)

    async def describe_vod_domain_real_time_http_code_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeHttpCodeDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeHttpCodeDataResponse:
        """
        @summary Queries the total number of HTTP status codes and proportion of each HTTP status code for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available (days)|Data latency|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 hour &#x3C; Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeHttpCodeDataRequest
        @return: DescribeVodDomainRealTimeHttpCodeDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_real_time_http_code_data_with_options_async(request, runtime)

    def describe_vod_domain_real_time_qps_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeQpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeQpsDataResponse:
        """
        @summary Queries the number of queries per second (QPS) for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeQpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeQpsDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeQpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeQpsDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_real_time_qps_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeQpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeQpsDataResponse:
        """
        @summary Queries the number of queries per second (QPS) for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeQpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeQpsDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeQpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeQpsDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_real_time_qps_data(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeQpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeQpsDataResponse:
        """
        @summary Queries the number of queries per second (QPS) for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeQpsDataRequest
        @return: DescribeVodDomainRealTimeQpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_real_time_qps_data_with_options(request, runtime)

    async def describe_vod_domain_real_time_qps_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeQpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeQpsDataResponse:
        """
        @summary Queries the number of queries per second (QPS) for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeQpsDataRequest
        @return: DescribeVodDomainRealTimeQpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_real_time_qps_data_with_options_async(request, runtime)

    def describe_vod_domain_real_time_req_hit_rate_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeReqHitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeReqHitRateDataResponse:
        """
        @summary Queries the request hit ratio data for one or more accelerated domain names. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        By default, the POST method is used for Go. To use the FET method, you must declare `request.Method="GET"`.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 hour &#x3C; Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeReqHitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeReqHitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeReqHitRateData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeReqHitRateDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_real_time_req_hit_rate_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeReqHitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeReqHitRateDataResponse:
        """
        @summary Queries the request hit ratio data for one or more accelerated domain names. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        By default, the POST method is used for Go. To use the FET method, you must declare `request.Method="GET"`.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 hour &#x3C; Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeReqHitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeReqHitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeReqHitRateData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeReqHitRateDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_real_time_req_hit_rate_data(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeReqHitRateDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeReqHitRateDataResponse:
        """
        @summary Queries the request hit ratio data for one or more accelerated domain names. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        By default, the POST method is used for Go. To use the FET method, you must declare `request.Method="GET"`.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 hour &#x3C; Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeReqHitRateDataRequest
        @return: DescribeVodDomainRealTimeReqHitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_real_time_req_hit_rate_data_with_options(request, runtime)

    async def describe_vod_domain_real_time_req_hit_rate_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeReqHitRateDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeReqHitRateDataResponse:
        """
        @summary Queries the request hit ratio data for one or more accelerated domain names. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        By default, the POST method is used for Go. To use the FET method, you must declare `request.Method="GET"`.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 hour &#x3C; Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeReqHitRateDataRequest
        @return: DescribeVodDomainRealTimeReqHitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_real_time_req_hit_rate_data_with_options_async(request, runtime)

    def describe_vod_domain_real_time_src_bps_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeSrcBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeSrcBpsDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRealTimeSrcBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeSrcBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeSrcBpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeSrcBpsDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_real_time_src_bps_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeSrcBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeSrcBpsDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRealTimeSrcBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeSrcBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeSrcBpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeSrcBpsDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_real_time_src_bps_data(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeSrcBpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeSrcBpsDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRealTimeSrcBpsDataRequest
        @return: DescribeVodDomainRealTimeSrcBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_real_time_src_bps_data_with_options(request, runtime)

    async def describe_vod_domain_real_time_src_bps_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeSrcBpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeSrcBpsDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRealTimeSrcBpsDataRequest
        @return: DescribeVodDomainRealTimeSrcBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_real_time_src_bps_data_with_options_async(request, runtime)

    def describe_vod_domain_real_time_src_traffic_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeSrcTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeSrcTrafficDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRealTimeSrcTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeSrcTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeSrcTrafficData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeSrcTrafficDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_real_time_src_traffic_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeSrcTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeSrcTrafficDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRealTimeSrcTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeSrcTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeSrcTrafficData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeSrcTrafficDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_real_time_src_traffic_data(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeSrcTrafficDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeSrcTrafficDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRealTimeSrcTrafficDataRequest
        @return: DescribeVodDomainRealTimeSrcTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_real_time_src_traffic_data_with_options(request, runtime)

    async def describe_vod_domain_real_time_src_traffic_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeSrcTrafficDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeSrcTrafficDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRealTimeSrcTrafficDataRequest
        @return: DescribeVodDomainRealTimeSrcTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_real_time_src_traffic_data_with_options_async(request, runtime)

    def describe_vod_domain_real_time_traffic_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeTrafficDataResponse:
        """
        @summary Queries the traffic data for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days. Compared with the DescribeVodDomainTrafficData operation, this operation provides a smaller time granularity, lower data latency, and allows you to query historical data within a shorter time period.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeTrafficData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeTrafficDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_real_time_traffic_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeTrafficDataResponse:
        """
        @summary Queries the traffic data for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days. Compared with the DescribeVodDomainTrafficData operation, this operation provides a smaller time granularity, lower data latency, and allows you to query historical data within a shorter time period.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealTimeTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealTimeTrafficData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealTimeTrafficDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_real_time_traffic_data(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeTrafficDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeTrafficDataResponse:
        """
        @summary Queries the traffic data for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days. Compared with the DescribeVodDomainTrafficData operation, this operation provides a smaller time granularity, lower data latency, and allows you to query historical data within a shorter time period.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeTrafficDataRequest
        @return: DescribeVodDomainRealTimeTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_real_time_traffic_data_with_options(request, runtime)

    async def describe_vod_domain_real_time_traffic_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealTimeTrafficDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealTimeTrafficDataResponse:
        """
        @summary Queries the traffic data for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days. Compared with the DescribeVodDomainTrafficData operation, this operation provides a smaller time granularity, lower data latency, and allows you to query historical data within a shorter time period.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 100 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
        |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
        |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
        
        @param request: DescribeVodDomainRealTimeTrafficDataRequest
        @return: DescribeVodDomainRealTimeTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_real_time_traffic_data_with_options_async(request, runtime)

    def describe_vod_domain_realtime_log_delivery_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealtimeLogDeliveryResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealtimeLogDelivery',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealtimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_realtime_log_delivery_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRealtimeLogDeliveryResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRealtimeLogDelivery',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRealtimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_realtime_log_delivery(
        self,
        request: vod_20170321_models.DescribeVodDomainRealtimeLogDeliveryRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealtimeLogDeliveryResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRealtimeLogDeliveryRequest
        @return: DescribeVodDomainRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_realtime_log_delivery_with_options(request, runtime)

    async def describe_vod_domain_realtime_log_delivery_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRealtimeLogDeliveryRequest,
    ) -> vod_20170321_models.DescribeVodDomainRealtimeLogDeliveryResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRealtimeLogDeliveryRequest
        @return: DescribeVodDomainRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_realtime_log_delivery_with_options_async(request, runtime)

    def describe_vod_domain_region_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainRegionDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRegionDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRegionDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRegionDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRegionData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRegionDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_region_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRegionDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainRegionDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRegionDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainRegionDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainRegionData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainRegionDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_region_data(
        self,
        request: vod_20170321_models.DescribeVodDomainRegionDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRegionDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRegionDataRequest
        @return: DescribeVodDomainRegionDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_region_data_with_options(request, runtime)

    async def describe_vod_domain_region_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainRegionDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainRegionDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainRegionDataRequest
        @return: DescribeVodDomainRegionDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_region_data_with_options_async(request, runtime)

    def describe_vod_domain_req_hit_rate_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainReqHitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainReqHitRateDataResponse:
        """
        @summary Queries the byte hit ratio for one or more accelerated domains. Request hit ratios are measured in percentage.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time range per query ≤ 90 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainReqHitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainReqHitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainReqHitRateData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainReqHitRateDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_req_hit_rate_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainReqHitRateDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainReqHitRateDataResponse:
        """
        @summary Queries the byte hit ratio for one or more accelerated domains. Request hit ratios are measured in percentage.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time range per query ≤ 90 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainReqHitRateDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainReqHitRateDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainReqHitRateData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainReqHitRateDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_req_hit_rate_data(
        self,
        request: vod_20170321_models.DescribeVodDomainReqHitRateDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainReqHitRateDataResponse:
        """
        @summary Queries the byte hit ratio for one or more accelerated domains. Request hit ratios are measured in percentage.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time range per query ≤ 90 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainReqHitRateDataRequest
        @return: DescribeVodDomainReqHitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_req_hit_rate_data_with_options(request, runtime)

    async def describe_vod_domain_req_hit_rate_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainReqHitRateDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainReqHitRateDataResponse:
        """
        @summary Queries the byte hit ratio for one or more accelerated domains. Request hit ratios are measured in percentage.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time range per query ≤ 90 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainReqHitRateDataRequest
        @return: DescribeVodDomainReqHitRateDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_req_hit_rate_data_with_options_async(request, runtime)

    def describe_vod_domain_src_bps_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainSrcBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainSrcBpsDataResponse:
        """
        @summary Queries the bandwidth data during back-to-origin routing for one or more accelerated domain names.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time span of a single query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainSrcBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainSrcBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainSrcBpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainSrcBpsDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_src_bps_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainSrcBpsDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainSrcBpsDataResponse:
        """
        @summary Queries the bandwidth data during back-to-origin routing for one or more accelerated domain names.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time span of a single query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainSrcBpsDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainSrcBpsDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainSrcBpsData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainSrcBpsDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_src_bps_data(
        self,
        request: vod_20170321_models.DescribeVodDomainSrcBpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainSrcBpsDataResponse:
        """
        @summary Queries the bandwidth data during back-to-origin routing for one or more accelerated domain names.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time span of a single query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainSrcBpsDataRequest
        @return: DescribeVodDomainSrcBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_src_bps_data_with_options(request, runtime)

    async def describe_vod_domain_src_bps_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainSrcBpsDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainSrcBpsDataResponse:
        """
        @summary Queries the bandwidth data during back-to-origin routing for one or more accelerated domain names.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time span of a single query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainSrcBpsDataRequest
        @return: DescribeVodDomainSrcBpsDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_src_bps_data_with_options_async(request, runtime)

    def describe_vod_domain_src_traffic_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainSrcTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainSrcTrafficDataResponse:
        """
        @summary Queries origin traffic data for accelerated domain names in ApsaraVideo VOD. The traffic is measured in bytes.
        
        @description  This operation is available only in the **China (Shanghai)** region.
        ApsaraVideo VOD stores the origin traffic data for 90 days before the data is deleted.
        If you do not set the `StartTime` or `EndTime` parameter, the request returns the data collected in the last 24 hours. If you set both the `StartTime` and `EndTime` parameters, the request returns the data collected within the specified time range.
        You can specify a maximum of 500 domain names in a request. Separate multiple domain names with commas (,). If you specify multiple domain names in a request, aggregation results are returned.
        ### Time granularity
        The time granularity supported by the Interval parameter varies based on the time range per query specified by using `StartTime` and `EndTime`. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query (days)|Historical data available (days)|Data delay|
        |---|---|---|---|
        |5 minutes|(0, 3\\]|93|15 minutes|
        |1 hour|(3, 31\\]|186|4 hours|
        |1 day|(31, 366\\]|366|04:00 on the next day|
        
        @param request: DescribeVodDomainSrcTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainSrcTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainSrcTrafficData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainSrcTrafficDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_src_traffic_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainSrcTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainSrcTrafficDataResponse:
        """
        @summary Queries origin traffic data for accelerated domain names in ApsaraVideo VOD. The traffic is measured in bytes.
        
        @description  This operation is available only in the **China (Shanghai)** region.
        ApsaraVideo VOD stores the origin traffic data for 90 days before the data is deleted.
        If you do not set the `StartTime` or `EndTime` parameter, the request returns the data collected in the last 24 hours. If you set both the `StartTime` and `EndTime` parameters, the request returns the data collected within the specified time range.
        You can specify a maximum of 500 domain names in a request. Separate multiple domain names with commas (,). If you specify multiple domain names in a request, aggregation results are returned.
        ### Time granularity
        The time granularity supported by the Interval parameter varies based on the time range per query specified by using `StartTime` and `EndTime`. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query (days)|Historical data available (days)|Data delay|
        |---|---|---|---|
        |5 minutes|(0, 3\\]|93|15 minutes|
        |1 hour|(3, 31\\]|186|4 hours|
        |1 day|(31, 366\\]|366|04:00 on the next day|
        
        @param request: DescribeVodDomainSrcTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainSrcTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainSrcTrafficData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainSrcTrafficDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_src_traffic_data(
        self,
        request: vod_20170321_models.DescribeVodDomainSrcTrafficDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainSrcTrafficDataResponse:
        """
        @summary Queries origin traffic data for accelerated domain names in ApsaraVideo VOD. The traffic is measured in bytes.
        
        @description  This operation is available only in the **China (Shanghai)** region.
        ApsaraVideo VOD stores the origin traffic data for 90 days before the data is deleted.
        If you do not set the `StartTime` or `EndTime` parameter, the request returns the data collected in the last 24 hours. If you set both the `StartTime` and `EndTime` parameters, the request returns the data collected within the specified time range.
        You can specify a maximum of 500 domain names in a request. Separate multiple domain names with commas (,). If you specify multiple domain names in a request, aggregation results are returned.
        ### Time granularity
        The time granularity supported by the Interval parameter varies based on the time range per query specified by using `StartTime` and `EndTime`. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query (days)|Historical data available (days)|Data delay|
        |---|---|---|---|
        |5 minutes|(0, 3\\]|93|15 minutes|
        |1 hour|(3, 31\\]|186|4 hours|
        |1 day|(31, 366\\]|366|04:00 on the next day|
        
        @param request: DescribeVodDomainSrcTrafficDataRequest
        @return: DescribeVodDomainSrcTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_src_traffic_data_with_options(request, runtime)

    async def describe_vod_domain_src_traffic_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainSrcTrafficDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainSrcTrafficDataResponse:
        """
        @summary Queries origin traffic data for accelerated domain names in ApsaraVideo VOD. The traffic is measured in bytes.
        
        @description  This operation is available only in the **China (Shanghai)** region.
        ApsaraVideo VOD stores the origin traffic data for 90 days before the data is deleted.
        If you do not set the `StartTime` or `EndTime` parameter, the request returns the data collected in the last 24 hours. If you set both the `StartTime` and `EndTime` parameters, the request returns the data collected within the specified time range.
        You can specify a maximum of 500 domain names in a request. Separate multiple domain names with commas (,). If you specify multiple domain names in a request, aggregation results are returned.
        ### Time granularity
        The time granularity supported by the Interval parameter varies based on the time range per query specified by using `StartTime` and `EndTime`. The following table describes the time period within which historical data is available and the data delay.
        |Time granularity|Time range per query (days)|Historical data available (days)|Data delay|
        |---|---|---|---|
        |5 minutes|(0, 3\\]|93|15 minutes|
        |1 hour|(3, 31\\]|186|4 hours|
        |1 day|(31, 366\\]|366|04:00 on the next day|
        
        @param request: DescribeVodDomainSrcTrafficDataRequest
        @return: DescribeVodDomainSrcTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_src_traffic_data_with_options_async(request, runtime)

    def describe_vod_domain_staging_config_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainStagingConfigResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.function_names):
            query['FunctionNames'] = request.function_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainStagingConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainStagingConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_staging_config_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainStagingConfigResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.function_names):
            query['FunctionNames'] = request.function_names
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainStagingConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainStagingConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_staging_config(
        self,
        request: vod_20170321_models.DescribeVodDomainStagingConfigRequest,
    ) -> vod_20170321_models.DescribeVodDomainStagingConfigResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainStagingConfigRequest
        @return: DescribeVodDomainStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_staging_config_with_options(request, runtime)

    async def describe_vod_domain_staging_config_async(
        self,
        request: vod_20170321_models.DescribeVodDomainStagingConfigRequest,
    ) -> vod_20170321_models.DescribeVodDomainStagingConfigResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainStagingConfigRequest
        @return: DescribeVodDomainStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_staging_config_with_options_async(request, runtime)

    def describe_vod_domain_top_refer_visit_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainTopReferVisitRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainTopReferVisitResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainTopReferVisitRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainTopReferVisitResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.percent):
            query['Percent'] = request.percent
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainTopReferVisit',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainTopReferVisitResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_top_refer_visit_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainTopReferVisitRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainTopReferVisitResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainTopReferVisitRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainTopReferVisitResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.percent):
            query['Percent'] = request.percent
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainTopReferVisit',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainTopReferVisitResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_top_refer_visit(
        self,
        request: vod_20170321_models.DescribeVodDomainTopReferVisitRequest,
    ) -> vod_20170321_models.DescribeVodDomainTopReferVisitResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainTopReferVisitRequest
        @return: DescribeVodDomainTopReferVisitResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_top_refer_visit_with_options(request, runtime)

    async def describe_vod_domain_top_refer_visit_async(
        self,
        request: vod_20170321_models.DescribeVodDomainTopReferVisitRequest,
    ) -> vod_20170321_models.DescribeVodDomainTopReferVisitResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainTopReferVisitRequest
        @return: DescribeVodDomainTopReferVisitResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_top_refer_visit_with_options_async(request, runtime)

    def describe_vod_domain_top_url_visit_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainTopUrlVisitRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainTopUrlVisitResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainTopUrlVisitRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainTopUrlVisitResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.percent):
            query['Percent'] = request.percent
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainTopUrlVisit',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainTopUrlVisitResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_top_url_visit_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainTopUrlVisitRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainTopUrlVisitResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainTopUrlVisitRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainTopUrlVisitResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.percent):
            query['Percent'] = request.percent
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainTopUrlVisit',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainTopUrlVisitResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_top_url_visit(
        self,
        request: vod_20170321_models.DescribeVodDomainTopUrlVisitRequest,
    ) -> vod_20170321_models.DescribeVodDomainTopUrlVisitResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainTopUrlVisitRequest
        @return: DescribeVodDomainTopUrlVisitResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_top_url_visit_with_options(request, runtime)

    async def describe_vod_domain_top_url_visit_async(
        self,
        request: vod_20170321_models.DescribeVodDomainTopUrlVisitRequest,
    ) -> vod_20170321_models.DescribeVodDomainTopUrlVisitResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainTopUrlVisitRequest
        @return: DescribeVodDomainTopUrlVisitResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_top_url_visit_with_options_async(request, runtime)

    def describe_vod_domain_traffic_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainTrafficDataResponse:
        """
        @summary Queries the traffic data for one or more accelerated domains. The minimum time granularity is 5 minutes. You can query data in the last 366 days. Compared with the DescribeVodDomainRealTimeTrafficData operation, this operation provides a greater time granularity, higher data latency, but allows you to query historical data within a longer time period.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time range per query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainTrafficData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainTrafficDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_traffic_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainTrafficDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainTrafficDataResponse:
        """
        @summary Queries the traffic data for one or more accelerated domains. The minimum time granularity is 5 minutes. You can query data in the last 366 days. Compared with the DescribeVodDomainRealTimeTrafficData operation, this operation provides a greater time granularity, higher data latency, but allows you to query historical data within a longer time period.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time range per query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainTrafficDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainTrafficDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainTrafficData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainTrafficDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_traffic_data(
        self,
        request: vod_20170321_models.DescribeVodDomainTrafficDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainTrafficDataResponse:
        """
        @summary Queries the traffic data for one or more accelerated domains. The minimum time granularity is 5 minutes. You can query data in the last 366 days. Compared with the DescribeVodDomainRealTimeTrafficData operation, this operation provides a greater time granularity, higher data latency, but allows you to query historical data within a longer time period.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time range per query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainTrafficDataRequest
        @return: DescribeVodDomainTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_traffic_data_with_options(request, runtime)

    async def describe_vod_domain_traffic_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainTrafficDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainTrafficDataResponse:
        """
        @summary Queries the traffic data for one or more accelerated domains. The minimum time granularity is 5 minutes. You can query data in the last 366 days. Compared with the DescribeVodDomainRealTimeTrafficData operation, this operation provides a greater time granularity, higher data latency, but allows you to query historical data within a longer time period.
        
        @description  This operation is supported only in the **China (Shanghai)** region.
        You can specify a maximum of 500 accelerated domain names.
        If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
        *Time granularity**\
        The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
        |Time granularity|Time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
        |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
        |1 day|31 days ≤ Time range per query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
        
        @param request: DescribeVodDomainTrafficDataRequest
        @return: DescribeVodDomainTrafficDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_traffic_data_with_options_async(request, runtime)

    def describe_vod_domain_usage_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainUsageDataResponse:
        """
        @summary Queries the traffic or bandwidth data of one or more accelerated domain names.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can specify up to 100 accelerated domain names in a request. Separate multiple domain names with commas (,). If you do not specify an accelerated domain name, the data of all accelerated domain names within your Alibaba Cloud account is returned.
        You can query data in the last year. The maximum time range that can be queried is three months. If you specify a time range of one to three days, the system returns data on an hourly basis. If you specify a time range of four days or more, the system returns data on a daily basis.
        
        @param request: DescribeVodDomainUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.area):
            query['Area'] = request.area
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.field):
            query['Field'] = request.field
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainUsageData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainUsageDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_usage_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainUsageDataResponse:
        """
        @summary Queries the traffic or bandwidth data of one or more accelerated domain names.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can specify up to 100 accelerated domain names in a request. Separate multiple domain names with commas (,). If you do not specify an accelerated domain name, the data of all accelerated domain names within your Alibaba Cloud account is returned.
        You can query data in the last year. The maximum time range that can be queried is three months. If you specify a time range of one to three days, the system returns data on an hourly basis. If you specify a time range of four days or more, the system returns data on a daily basis.
        
        @param request: DescribeVodDomainUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.area):
            query['Area'] = request.area
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.field):
            query['Field'] = request.field
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainUsageData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainUsageDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_usage_data(
        self,
        request: vod_20170321_models.DescribeVodDomainUsageDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainUsageDataResponse:
        """
        @summary Queries the traffic or bandwidth data of one or more accelerated domain names.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can specify up to 100 accelerated domain names in a request. Separate multiple domain names with commas (,). If you do not specify an accelerated domain name, the data of all accelerated domain names within your Alibaba Cloud account is returned.
        You can query data in the last year. The maximum time range that can be queried is three months. If you specify a time range of one to three days, the system returns data on an hourly basis. If you specify a time range of four days or more, the system returns data on a daily basis.
        
        @param request: DescribeVodDomainUsageDataRequest
        @return: DescribeVodDomainUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_usage_data_with_options(request, runtime)

    async def describe_vod_domain_usage_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainUsageDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainUsageDataResponse:
        """
        @summary Queries the traffic or bandwidth data of one or more accelerated domain names.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can specify up to 100 accelerated domain names in a request. Separate multiple domain names with commas (,). If you do not specify an accelerated domain name, the data of all accelerated domain names within your Alibaba Cloud account is returned.
        You can query data in the last year. The maximum time range that can be queried is three months. If you specify a time range of one to three days, the system returns data on an hourly basis. If you specify a time range of four days or more, the system returns data on a daily basis.
        
        @param request: DescribeVodDomainUsageDataRequest
        @return: DescribeVodDomainUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_usage_data_with_options_async(request, runtime)

    def describe_vod_domain_uv_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainUvDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainUvDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainUvDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainUvDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainUvData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainUvDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domain_uv_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainUvDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainUvDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainUvDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainUvDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainUvData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainUvDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domain_uv_data(
        self,
        request: vod_20170321_models.DescribeVodDomainUvDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainUvDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainUvDataRequest
        @return: DescribeVodDomainUvDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domain_uv_data_with_options(request, runtime)

    async def describe_vod_domain_uv_data_async(
        self,
        request: vod_20170321_models.DescribeVodDomainUvDataRequest,
    ) -> vod_20170321_models.DescribeVodDomainUvDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainUvDataRequest
        @return: DescribeVodDomainUvDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domain_uv_data_with_options_async(request, runtime)

    def describe_vod_domains_usage_by_day_with_options(
        self,
        request: vod_20170321_models.DescribeVodDomainsUsageByDayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainsUsageByDayResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainsUsageByDayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainsUsageByDayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainsUsageByDay',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainsUsageByDayResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_domains_usage_by_day_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodDomainsUsageByDayRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodDomainsUsageByDayResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainsUsageByDayRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodDomainsUsageByDayResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodDomainsUsageByDay',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodDomainsUsageByDayResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_domains_usage_by_day(
        self,
        request: vod_20170321_models.DescribeVodDomainsUsageByDayRequest,
    ) -> vod_20170321_models.DescribeVodDomainsUsageByDayResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainsUsageByDayRequest
        @return: DescribeVodDomainsUsageByDayResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_domains_usage_by_day_with_options(request, runtime)

    async def describe_vod_domains_usage_by_day_async(
        self,
        request: vod_20170321_models.DescribeVodDomainsUsageByDayRequest,
    ) -> vod_20170321_models.DescribeVodDomainsUsageByDayResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodDomainsUsageByDayRequest
        @return: DescribeVodDomainsUsageByDayResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_domains_usage_by_day_with_options_async(request, runtime)

    def describe_vod_editing_usage_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodEditingUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodEditingUsageDataResponse:
        """
        @summary 点播云剪辑用量查询
        
        @param request: DescribeVodEditingUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodEditingUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.specification):
            query['Specification'] = request.specification
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodEditingUsageData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodEditingUsageDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_editing_usage_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodEditingUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodEditingUsageDataResponse:
        """
        @summary 点播云剪辑用量查询
        
        @param request: DescribeVodEditingUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodEditingUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.specification):
            query['Specification'] = request.specification
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodEditingUsageData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodEditingUsageDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_editing_usage_data(
        self,
        request: vod_20170321_models.DescribeVodEditingUsageDataRequest,
    ) -> vod_20170321_models.DescribeVodEditingUsageDataResponse:
        """
        @summary 点播云剪辑用量查询
        
        @param request: DescribeVodEditingUsageDataRequest
        @return: DescribeVodEditingUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_editing_usage_data_with_options(request, runtime)

    async def describe_vod_editing_usage_data_async(
        self,
        request: vod_20170321_models.DescribeVodEditingUsageDataRequest,
    ) -> vod_20170321_models.DescribeVodEditingUsageDataResponse:
        """
        @summary 点播云剪辑用量查询
        
        @param request: DescribeVodEditingUsageDataRequest
        @return: DescribeVodEditingUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_editing_usage_data_with_options_async(request, runtime)

    def describe_vod_media_play_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodMediaPlayDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodMediaPlayDataResponse:
        """
        @summary Queries the playback statistics based on the media ID. You can call this operation to query information such as the number of visits, average video views per viewer, total number of views, average playback duration per viewer, and total playback duration.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        Only playback data in ApsaraVideo Player SDK is collected.
        You can query only data within the last 30 days.
        Before you call this operation, make sure that the following requirements are met:
        ApsaraVideo Player SDK for Android or iOS
        ApsaraVideo Player SDK for Android or iOS V5.4.9.2 or later is used.
        A license for ApsaraVideo Player SDK is obtained. For more information, see [Manage licenses](https://help.aliyun.com/document_detail/469166.html).
        The log reporting feature is enabled. By default, the feature is enabled for ApsaraVideo Player SDKs. For more information, see [Integrate ApsaraVideo Player SDK for Android](~~311525#section-dc4-gp6-xk2~~) and [Integrate ApsaraVideo Player SDK for iOS](~~313855#section-cmf-k7d-jg5~~).
        ApsaraVideo Player SDK for Web
        ApsaraVideo Player SDK for Web V2.16.0 or later is used.
        A license for **playback quality monitoring** is obtained. To apply for the license, [submit a request on Yida to enable value-added features for ApsaraVideo Player SDK for Web](https://yida.alibaba-inc.com/o/webplayer#/). For more information, see the description of the `license` parameter in the [API operations](~~125572#section-3ty-gwp-6pa~~) topic.
        The log reporting feature is enabled. By default, the feature is enabled for ApsaraVideo Player SDKs.
        
        @param request: DescribeVodMediaPlayDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodMediaPlayDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.order_name):
            query['OrderName'] = request.order_name
        if not UtilClient.is_unset(request.order_type):
            query['OrderType'] = request.order_type
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.play_date):
            query['PlayDate'] = request.play_date
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodMediaPlayData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodMediaPlayDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_media_play_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodMediaPlayDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodMediaPlayDataResponse:
        """
        @summary Queries the playback statistics based on the media ID. You can call this operation to query information such as the number of visits, average video views per viewer, total number of views, average playback duration per viewer, and total playback duration.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        Only playback data in ApsaraVideo Player SDK is collected.
        You can query only data within the last 30 days.
        Before you call this operation, make sure that the following requirements are met:
        ApsaraVideo Player SDK for Android or iOS
        ApsaraVideo Player SDK for Android or iOS V5.4.9.2 or later is used.
        A license for ApsaraVideo Player SDK is obtained. For more information, see [Manage licenses](https://help.aliyun.com/document_detail/469166.html).
        The log reporting feature is enabled. By default, the feature is enabled for ApsaraVideo Player SDKs. For more information, see [Integrate ApsaraVideo Player SDK for Android](~~311525#section-dc4-gp6-xk2~~) and [Integrate ApsaraVideo Player SDK for iOS](~~313855#section-cmf-k7d-jg5~~).
        ApsaraVideo Player SDK for Web
        ApsaraVideo Player SDK for Web V2.16.0 or later is used.
        A license for **playback quality monitoring** is obtained. To apply for the license, [submit a request on Yida to enable value-added features for ApsaraVideo Player SDK for Web](https://yida.alibaba-inc.com/o/webplayer#/). For more information, see the description of the `license` parameter in the [API operations](~~125572#section-3ty-gwp-6pa~~) topic.
        The log reporting feature is enabled. By default, the feature is enabled for ApsaraVideo Player SDKs.
        
        @param request: DescribeVodMediaPlayDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodMediaPlayDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.order_name):
            query['OrderName'] = request.order_name
        if not UtilClient.is_unset(request.order_type):
            query['OrderType'] = request.order_type
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.play_date):
            query['PlayDate'] = request.play_date
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodMediaPlayData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodMediaPlayDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_media_play_data(
        self,
        request: vod_20170321_models.DescribeVodMediaPlayDataRequest,
    ) -> vod_20170321_models.DescribeVodMediaPlayDataResponse:
        """
        @summary Queries the playback statistics based on the media ID. You can call this operation to query information such as the number of visits, average video views per viewer, total number of views, average playback duration per viewer, and total playback duration.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        Only playback data in ApsaraVideo Player SDK is collected.
        You can query only data within the last 30 days.
        Before you call this operation, make sure that the following requirements are met:
        ApsaraVideo Player SDK for Android or iOS
        ApsaraVideo Player SDK for Android or iOS V5.4.9.2 or later is used.
        A license for ApsaraVideo Player SDK is obtained. For more information, see [Manage licenses](https://help.aliyun.com/document_detail/469166.html).
        The log reporting feature is enabled. By default, the feature is enabled for ApsaraVideo Player SDKs. For more information, see [Integrate ApsaraVideo Player SDK for Android](~~311525#section-dc4-gp6-xk2~~) and [Integrate ApsaraVideo Player SDK for iOS](~~313855#section-cmf-k7d-jg5~~).
        ApsaraVideo Player SDK for Web
        ApsaraVideo Player SDK for Web V2.16.0 or later is used.
        A license for **playback quality monitoring** is obtained. To apply for the license, [submit a request on Yida to enable value-added features for ApsaraVideo Player SDK for Web](https://yida.alibaba-inc.com/o/webplayer#/). For more information, see the description of the `license` parameter in the [API operations](~~125572#section-3ty-gwp-6pa~~) topic.
        The log reporting feature is enabled. By default, the feature is enabled for ApsaraVideo Player SDKs.
        
        @param request: DescribeVodMediaPlayDataRequest
        @return: DescribeVodMediaPlayDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_media_play_data_with_options(request, runtime)

    async def describe_vod_media_play_data_async(
        self,
        request: vod_20170321_models.DescribeVodMediaPlayDataRequest,
    ) -> vod_20170321_models.DescribeVodMediaPlayDataResponse:
        """
        @summary Queries the playback statistics based on the media ID. You can call this operation to query information such as the number of visits, average video views per viewer, total number of views, average playback duration per viewer, and total playback duration.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        Only playback data in ApsaraVideo Player SDK is collected.
        You can query only data within the last 30 days.
        Before you call this operation, make sure that the following requirements are met:
        ApsaraVideo Player SDK for Android or iOS
        ApsaraVideo Player SDK for Android or iOS V5.4.9.2 or later is used.
        A license for ApsaraVideo Player SDK is obtained. For more information, see [Manage licenses](https://help.aliyun.com/document_detail/469166.html).
        The log reporting feature is enabled. By default, the feature is enabled for ApsaraVideo Player SDKs. For more information, see [Integrate ApsaraVideo Player SDK for Android](~~311525#section-dc4-gp6-xk2~~) and [Integrate ApsaraVideo Player SDK for iOS](~~313855#section-cmf-k7d-jg5~~).
        ApsaraVideo Player SDK for Web
        ApsaraVideo Player SDK for Web V2.16.0 or later is used.
        A license for **playback quality monitoring** is obtained. To apply for the license, [submit a request on Yida to enable value-added features for ApsaraVideo Player SDK for Web](https://yida.alibaba-inc.com/o/webplayer#/). For more information, see the description of the `license` parameter in the [API operations](~~125572#section-3ty-gwp-6pa~~) topic.
        The log reporting feature is enabled. By default, the feature is enabled for ApsaraVideo Player SDKs.
        
        @param request: DescribeVodMediaPlayDataRequest
        @return: DescribeVodMediaPlayDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_media_play_data_with_options_async(request, runtime)

    def describe_vod_multi_usage_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodMultiUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodMultiUsageDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodMultiUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodMultiUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodMultiUsageData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodMultiUsageDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_multi_usage_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodMultiUsageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodMultiUsageDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodMultiUsageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodMultiUsageDataResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodMultiUsageData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodMultiUsageDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_multi_usage_data(
        self,
        request: vod_20170321_models.DescribeVodMultiUsageDataRequest,
    ) -> vod_20170321_models.DescribeVodMultiUsageDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodMultiUsageDataRequest
        @return: DescribeVodMultiUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_multi_usage_data_with_options(request, runtime)

    async def describe_vod_multi_usage_data_async(
        self,
        request: vod_20170321_models.DescribeVodMultiUsageDataRequest,
    ) -> vod_20170321_models.DescribeVodMultiUsageDataResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodMultiUsageDataRequest
        @return: DescribeVodMultiUsageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_multi_usage_data_with_options_async(request, runtime)

    def describe_vod_player_collect_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodPlayerCollectDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodPlayerCollectDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerCollectDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodPlayerCollectDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.metrics):
            query['Metrics'] = request.metrics
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodPlayerCollectData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodPlayerCollectDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_player_collect_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodPlayerCollectDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodPlayerCollectDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerCollectDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodPlayerCollectDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.metrics):
            query['Metrics'] = request.metrics
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodPlayerCollectData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodPlayerCollectDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_player_collect_data(
        self,
        request: vod_20170321_models.DescribeVodPlayerCollectDataRequest,
    ) -> vod_20170321_models.DescribeVodPlayerCollectDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerCollectDataRequest
        @return: DescribeVodPlayerCollectDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_player_collect_data_with_options(request, runtime)

    async def describe_vod_player_collect_data_async(
        self,
        request: vod_20170321_models.DescribeVodPlayerCollectDataRequest,
    ) -> vod_20170321_models.DescribeVodPlayerCollectDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerCollectDataRequest
        @return: DescribeVodPlayerCollectDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_player_collect_data_with_options_async(request, runtime)

    def describe_vod_player_collect_data_demo_with_options(
        self,
        request: vod_20170321_models.DescribeVodPlayerCollectDataDemoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodPlayerCollectDataDemoResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerCollectDataDemoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodPlayerCollectDataDemoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.metrics):
            query['Metrics'] = request.metrics
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodPlayerCollectDataDemo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodPlayerCollectDataDemoResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_player_collect_data_demo_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodPlayerCollectDataDemoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodPlayerCollectDataDemoResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerCollectDataDemoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodPlayerCollectDataDemoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.metrics):
            query['Metrics'] = request.metrics
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.period):
            query['Period'] = request.period
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodPlayerCollectDataDemo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodPlayerCollectDataDemoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_player_collect_data_demo(
        self,
        request: vod_20170321_models.DescribeVodPlayerCollectDataDemoRequest,
    ) -> vod_20170321_models.DescribeVodPlayerCollectDataDemoResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerCollectDataDemoRequest
        @return: DescribeVodPlayerCollectDataDemoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_player_collect_data_demo_with_options(request, runtime)

    async def describe_vod_player_collect_data_demo_async(
        self,
        request: vod_20170321_models.DescribeVodPlayerCollectDataDemoRequest,
    ) -> vod_20170321_models.DescribeVodPlayerCollectDataDemoResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerCollectDataDemoRequest
        @return: DescribeVodPlayerCollectDataDemoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_player_collect_data_demo_with_options_async(request, runtime)

    def describe_vod_player_dimension_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodPlayerDimensionDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodPlayerDimensionDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerDimensionDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodPlayerDimensionDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.dimension):
            query['Dimension'] = request.dimension
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodPlayerDimensionData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodPlayerDimensionDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_player_dimension_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodPlayerDimensionDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodPlayerDimensionDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerDimensionDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodPlayerDimensionDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.dimension):
            query['Dimension'] = request.dimension
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodPlayerDimensionData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodPlayerDimensionDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_player_dimension_data(
        self,
        request: vod_20170321_models.DescribeVodPlayerDimensionDataRequest,
    ) -> vod_20170321_models.DescribeVodPlayerDimensionDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerDimensionDataRequest
        @return: DescribeVodPlayerDimensionDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_player_dimension_data_with_options(request, runtime)

    async def describe_vod_player_dimension_data_async(
        self,
        request: vod_20170321_models.DescribeVodPlayerDimensionDataRequest,
    ) -> vod_20170321_models.DescribeVodPlayerDimensionDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerDimensionDataRequest
        @return: DescribeVodPlayerDimensionDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_player_dimension_data_with_options_async(request, runtime)

    def describe_vod_player_dimension_data_demo_with_options(
        self,
        request: vod_20170321_models.DescribeVodPlayerDimensionDataDemoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodPlayerDimensionDataDemoResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerDimensionDataDemoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodPlayerDimensionDataDemoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.dimension):
            query['Dimension'] = request.dimension
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodPlayerDimensionDataDemo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodPlayerDimensionDataDemoResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_player_dimension_data_demo_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodPlayerDimensionDataDemoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodPlayerDimensionDataDemoResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerDimensionDataDemoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodPlayerDimensionDataDemoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.dimension):
            query['Dimension'] = request.dimension
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodPlayerDimensionDataDemo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodPlayerDimensionDataDemoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_player_dimension_data_demo(
        self,
        request: vod_20170321_models.DescribeVodPlayerDimensionDataDemoRequest,
    ) -> vod_20170321_models.DescribeVodPlayerDimensionDataDemoResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerDimensionDataDemoRequest
        @return: DescribeVodPlayerDimensionDataDemoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_player_dimension_data_demo_with_options(request, runtime)

    async def describe_vod_player_dimension_data_demo_async(
        self,
        request: vod_20170321_models.DescribeVodPlayerDimensionDataDemoRequest,
    ) -> vod_20170321_models.DescribeVodPlayerDimensionDataDemoResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerDimensionDataDemoRequest
        @return: DescribeVodPlayerDimensionDataDemoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_player_dimension_data_demo_with_options_async(request, runtime)

    def describe_vod_player_metric_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodPlayerMetricDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodPlayerMetricDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerMetricDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodPlayerMetricDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.filters):
            query['Filters'] = request.filters
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.language):
            query['Language'] = request.language
        if not UtilClient.is_unset(request.metrics):
            query['Metrics'] = request.metrics
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        if not UtilClient.is_unset(request.top):
            query['Top'] = request.top
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodPlayerMetricData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodPlayerMetricDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_player_metric_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodPlayerMetricDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodPlayerMetricDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerMetricDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodPlayerMetricDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.filters):
            query['Filters'] = request.filters
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.language):
            query['Language'] = request.language
        if not UtilClient.is_unset(request.metrics):
            query['Metrics'] = request.metrics
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        if not UtilClient.is_unset(request.top):
            query['Top'] = request.top
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodPlayerMetricData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodPlayerMetricDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_player_metric_data(
        self,
        request: vod_20170321_models.DescribeVodPlayerMetricDataRequest,
    ) -> vod_20170321_models.DescribeVodPlayerMetricDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerMetricDataRequest
        @return: DescribeVodPlayerMetricDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_player_metric_data_with_options(request, runtime)

    async def describe_vod_player_metric_data_async(
        self,
        request: vod_20170321_models.DescribeVodPlayerMetricDataRequest,
    ) -> vod_20170321_models.DescribeVodPlayerMetricDataResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerMetricDataRequest
        @return: DescribeVodPlayerMetricDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_player_metric_data_with_options_async(request, runtime)

    def describe_vod_player_metric_data_demo_with_options(
        self,
        request: vod_20170321_models.DescribeVodPlayerMetricDataDemoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodPlayerMetricDataDemoResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerMetricDataDemoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodPlayerMetricDataDemoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.filters):
            query['Filters'] = request.filters
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.metrics):
            query['Metrics'] = request.metrics
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        if not UtilClient.is_unset(request.top):
            query['Top'] = request.top
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodPlayerMetricDataDemo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodPlayerMetricDataDemoResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_player_metric_data_demo_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodPlayerMetricDataDemoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodPlayerMetricDataDemoResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerMetricDataDemoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodPlayerMetricDataDemoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.filters):
            query['Filters'] = request.filters
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.metrics):
            query['Metrics'] = request.metrics
        if not UtilClient.is_unset(request.os):
            query['Os'] = request.os
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        if not UtilClient.is_unset(request.top):
            query['Top'] = request.top
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodPlayerMetricDataDemo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodPlayerMetricDataDemoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_player_metric_data_demo(
        self,
        request: vod_20170321_models.DescribeVodPlayerMetricDataDemoRequest,
    ) -> vod_20170321_models.DescribeVodPlayerMetricDataDemoResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerMetricDataDemoRequest
        @return: DescribeVodPlayerMetricDataDemoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_player_metric_data_demo_with_options(request, runtime)

    async def describe_vod_player_metric_data_demo_async(
        self,
        request: vod_20170321_models.DescribeVodPlayerMetricDataDemoRequest,
    ) -> vod_20170321_models.DescribeVodPlayerMetricDataDemoResponse:
        """
        @summary 查询播放器指标数据
        
        @param request: DescribeVodPlayerMetricDataDemoRequest
        @return: DescribeVodPlayerMetricDataDemoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_player_metric_data_demo_with_options_async(request, runtime)

    def describe_vod_range_data_by_locate_and_isp_service_with_options(
        self,
        request: vod_20170321_models.DescribeVodRangeDataByLocateAndIspServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodRangeDataByLocateAndIspServiceResponse:
        """
        @summary Queries the bandwidth data by Internet service provider (ISP) and region.
        
        @description The data is collected every 5 minutes. You can call this API operation up to 20 times per second per account. Time granularity
        The time granularity supported by Interval, the maximum time period within which historical data is available, and the data delay vary based on the time range to query, as described in the following table.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|1 hour|93 days|15 minutes|
        
        @param request: DescribeVodRangeDataByLocateAndIspServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodRangeDataByLocateAndIspServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodRangeDataByLocateAndIspService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodRangeDataByLocateAndIspServiceResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_range_data_by_locate_and_isp_service_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodRangeDataByLocateAndIspServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodRangeDataByLocateAndIspServiceResponse:
        """
        @summary Queries the bandwidth data by Internet service provider (ISP) and region.
        
        @description The data is collected every 5 minutes. You can call this API operation up to 20 times per second per account. Time granularity
        The time granularity supported by Interval, the maximum time period within which historical data is available, and the data delay vary based on the time range to query, as described in the following table.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|1 hour|93 days|15 minutes|
        
        @param request: DescribeVodRangeDataByLocateAndIspServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodRangeDataByLocateAndIspServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.isp_name_en):
            query['IspNameEn'] = request.isp_name_en
        if not UtilClient.is_unset(request.location_name_en):
            query['LocationNameEn'] = request.location_name_en
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodRangeDataByLocateAndIspService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodRangeDataByLocateAndIspServiceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_range_data_by_locate_and_isp_service(
        self,
        request: vod_20170321_models.DescribeVodRangeDataByLocateAndIspServiceRequest,
    ) -> vod_20170321_models.DescribeVodRangeDataByLocateAndIspServiceResponse:
        """
        @summary Queries the bandwidth data by Internet service provider (ISP) and region.
        
        @description The data is collected every 5 minutes. You can call this API operation up to 20 times per second per account. Time granularity
        The time granularity supported by Interval, the maximum time period within which historical data is available, and the data delay vary based on the time range to query, as described in the following table.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|1 hour|93 days|15 minutes|
        
        @param request: DescribeVodRangeDataByLocateAndIspServiceRequest
        @return: DescribeVodRangeDataByLocateAndIspServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_range_data_by_locate_and_isp_service_with_options(request, runtime)

    async def describe_vod_range_data_by_locate_and_isp_service_async(
        self,
        request: vod_20170321_models.DescribeVodRangeDataByLocateAndIspServiceRequest,
    ) -> vod_20170321_models.DescribeVodRangeDataByLocateAndIspServiceResponse:
        """
        @summary Queries the bandwidth data by Internet service provider (ISP) and region.
        
        @description The data is collected every 5 minutes. You can call this API operation up to 20 times per second per account. Time granularity
        The time granularity supported by Interval, the maximum time period within which historical data is available, and the data delay vary based on the time range to query, as described in the following table.
        |Time granularity|Maximum time range per query|Historical data available|Data delay|
        |---|---|---|---|
        |5 minutes|1 hour|93 days|15 minutes|
        
        @param request: DescribeVodRangeDataByLocateAndIspServiceRequest
        @return: DescribeVodRangeDataByLocateAndIspServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_range_data_by_locate_and_isp_service_with_options_async(request, runtime)

    def describe_vod_realtime_delivery_acc_with_options(
        self,
        request: vod_20170321_models.DescribeVodRealtimeDeliveryAccRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodRealtimeDeliveryAccResponse:
        """
        @summary Queries the number of real-time log deliveries.
        
        @param request: DescribeVodRealtimeDeliveryAccRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodRealtimeDeliveryAccResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.log_store):
            query['LogStore'] = request.log_store
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project):
            query['Project'] = request.project
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodRealtimeDeliveryAcc',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodRealtimeDeliveryAccResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_realtime_delivery_acc_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodRealtimeDeliveryAccRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodRealtimeDeliveryAccResponse:
        """
        @summary Queries the number of real-time log deliveries.
        
        @param request: DescribeVodRealtimeDeliveryAccRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodRealtimeDeliveryAccResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.log_store):
            query['LogStore'] = request.log_store
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project):
            query['Project'] = request.project
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodRealtimeDeliveryAcc',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodRealtimeDeliveryAccResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_realtime_delivery_acc(
        self,
        request: vod_20170321_models.DescribeVodRealtimeDeliveryAccRequest,
    ) -> vod_20170321_models.DescribeVodRealtimeDeliveryAccResponse:
        """
        @summary Queries the number of real-time log deliveries.
        
        @param request: DescribeVodRealtimeDeliveryAccRequest
        @return: DescribeVodRealtimeDeliveryAccResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_realtime_delivery_acc_with_options(request, runtime)

    async def describe_vod_realtime_delivery_acc_async(
        self,
        request: vod_20170321_models.DescribeVodRealtimeDeliveryAccRequest,
    ) -> vod_20170321_models.DescribeVodRealtimeDeliveryAccResponse:
        """
        @summary Queries the number of real-time log deliveries.
        
        @param request: DescribeVodRealtimeDeliveryAccRequest
        @return: DescribeVodRealtimeDeliveryAccResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_realtime_delivery_acc_with_options_async(request, runtime)

    def describe_vod_realtime_log_authorized_with_options(
        self,
        request: vod_20170321_models.DescribeVodRealtimeLogAuthorizedRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodRealtimeLogAuthorizedResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodRealtimeLogAuthorizedRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodRealtimeLogAuthorizedResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodRealtimeLogAuthorized',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodRealtimeLogAuthorizedResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_realtime_log_authorized_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodRealtimeLogAuthorizedRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodRealtimeLogAuthorizedResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodRealtimeLogAuthorizedRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodRealtimeLogAuthorizedResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodRealtimeLogAuthorized',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodRealtimeLogAuthorizedResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_realtime_log_authorized(
        self,
        request: vod_20170321_models.DescribeVodRealtimeLogAuthorizedRequest,
    ) -> vod_20170321_models.DescribeVodRealtimeLogAuthorizedResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodRealtimeLogAuthorizedRequest
        @return: DescribeVodRealtimeLogAuthorizedResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_realtime_log_authorized_with_options(request, runtime)

    async def describe_vod_realtime_log_authorized_async(
        self,
        request: vod_20170321_models.DescribeVodRealtimeLogAuthorizedRequest,
    ) -> vod_20170321_models.DescribeVodRealtimeLogAuthorizedResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodRealtimeLogAuthorizedRequest
        @return: DescribeVodRealtimeLogAuthorizedResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_realtime_log_authorized_with_options_async(request, runtime)

    def describe_vod_refresh_quota_with_options(
        self,
        request: vod_20170321_models.DescribeVodRefreshQuotaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodRefreshQuotaResponse:
        """
        @summary Queries the maximum number and remaining number of requests to refresh or prefetch files on the current day. You can prefetch files based on URLs and refresh files based on URLs or directories.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.html) operation to prefetch content.
        
        @param request: DescribeVodRefreshQuotaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodRefreshQuotaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodRefreshQuota',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodRefreshQuotaResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_refresh_quota_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodRefreshQuotaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodRefreshQuotaResponse:
        """
        @summary Queries the maximum number and remaining number of requests to refresh or prefetch files on the current day. You can prefetch files based on URLs and refresh files based on URLs or directories.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.html) operation to prefetch content.
        
        @param request: DescribeVodRefreshQuotaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodRefreshQuotaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodRefreshQuota',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodRefreshQuotaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_refresh_quota(
        self,
        request: vod_20170321_models.DescribeVodRefreshQuotaRequest,
    ) -> vod_20170321_models.DescribeVodRefreshQuotaResponse:
        """
        @summary Queries the maximum number and remaining number of requests to refresh or prefetch files on the current day. You can prefetch files based on URLs and refresh files based on URLs or directories.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.html) operation to prefetch content.
        
        @param request: DescribeVodRefreshQuotaRequest
        @return: DescribeVodRefreshQuotaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_refresh_quota_with_options(request, runtime)

    async def describe_vod_refresh_quota_async(
        self,
        request: vod_20170321_models.DescribeVodRefreshQuotaRequest,
    ) -> vod_20170321_models.DescribeVodRefreshQuotaResponse:
        """
        @summary Queries the maximum number and remaining number of requests to refresh or prefetch files on the current day. You can prefetch files based on URLs and refresh files based on URLs or directories.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.html) operation to prefetch content.
        
        @param request: DescribeVodRefreshQuotaRequest
        @return: DescribeVodRefreshQuotaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_refresh_quota_with_options_async(request, runtime)

    def describe_vod_refresh_tasks_with_options(
        self,
        request: vod_20170321_models.DescribeVodRefreshTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodRefreshTasksResponse:
        """
        @summary Queries the information about one or more refresh or prefetch tasks.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If you do not specify the TaskId or ObjectPath parameter, the data in the last three days is returned on the first page. By default, one page displays a maximum of 20 entries. You can specify the TaskId and ObjectPath parameters at the same time.
        
        @param request: DescribeVodRefreshTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodRefreshTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.object_type):
            query['ObjectType'] = request.object_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodRefreshTasks',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodRefreshTasksResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_refresh_tasks_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodRefreshTasksRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodRefreshTasksResponse:
        """
        @summary Queries the information about one or more refresh or prefetch tasks.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If you do not specify the TaskId or ObjectPath parameter, the data in the last three days is returned on the first page. By default, one page displays a maximum of 20 entries. You can specify the TaskId and ObjectPath parameters at the same time.
        
        @param request: DescribeVodRefreshTasksRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodRefreshTasksResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.object_type):
            query['ObjectType'] = request.object_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.task_id):
            query['TaskId'] = request.task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodRefreshTasks',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodRefreshTasksResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_refresh_tasks(
        self,
        request: vod_20170321_models.DescribeVodRefreshTasksRequest,
    ) -> vod_20170321_models.DescribeVodRefreshTasksResponse:
        """
        @summary Queries the information about one or more refresh or prefetch tasks.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If you do not specify the TaskId or ObjectPath parameter, the data in the last three days is returned on the first page. By default, one page displays a maximum of 20 entries. You can specify the TaskId and ObjectPath parameters at the same time.
        
        @param request: DescribeVodRefreshTasksRequest
        @return: DescribeVodRefreshTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_refresh_tasks_with_options(request, runtime)

    async def describe_vod_refresh_tasks_async(
        self,
        request: vod_20170321_models.DescribeVodRefreshTasksRequest,
    ) -> vod_20170321_models.DescribeVodRefreshTasksResponse:
        """
        @summary Queries the information about one or more refresh or prefetch tasks.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If you do not specify the TaskId or ObjectPath parameter, the data in the last three days is returned on the first page. By default, one page displays a maximum of 20 entries. You can specify the TaskId and ObjectPath parameters at the same time.
        
        @param request: DescribeVodRefreshTasksRequest
        @return: DescribeVodRefreshTasksResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_refresh_tasks_with_options_async(request, runtime)

    def describe_vod_sslcertificate_list_with_options(
        self,
        request: vod_20170321_models.DescribeVodSSLCertificateListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodSSLCertificateListResponse:
        """
        @summary Queries the certificates by domain name.
        
        @param request: DescribeVodSSLCertificateListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodSSLCertificateListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_keyword):
            query['SearchKeyword'] = request.search_keyword
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodSSLCertificateList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodSSLCertificateListResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_sslcertificate_list_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodSSLCertificateListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodSSLCertificateListResponse:
        """
        @summary Queries the certificates by domain name.
        
        @param request: DescribeVodSSLCertificateListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodSSLCertificateListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_keyword):
            query['SearchKeyword'] = request.search_keyword
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodSSLCertificateList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodSSLCertificateListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_sslcertificate_list(
        self,
        request: vod_20170321_models.DescribeVodSSLCertificateListRequest,
    ) -> vod_20170321_models.DescribeVodSSLCertificateListResponse:
        """
        @summary Queries the certificates by domain name.
        
        @param request: DescribeVodSSLCertificateListRequest
        @return: DescribeVodSSLCertificateListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_sslcertificate_list_with_options(request, runtime)

    async def describe_vod_sslcertificate_list_async(
        self,
        request: vod_20170321_models.DescribeVodSSLCertificateListRequest,
    ) -> vod_20170321_models.DescribeVodSSLCertificateListResponse:
        """
        @summary Queries the certificates by domain name.
        
        @param request: DescribeVodSSLCertificateListRequest
        @return: DescribeVodSSLCertificateListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_sslcertificate_list_with_options_async(request, runtime)

    def describe_vod_service_with_options(
        self,
        request: vod_20170321_models.DescribeVodServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodServiceResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodServiceResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_service_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodServiceResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodServiceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_service(
        self,
        request: vod_20170321_models.DescribeVodServiceRequest,
    ) -> vod_20170321_models.DescribeVodServiceResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodServiceRequest
        @return: DescribeVodServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_service_with_options(request, runtime)

    async def describe_vod_service_async(
        self,
        request: vod_20170321_models.DescribeVodServiceRequest,
    ) -> vod_20170321_models.DescribeVodServiceResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodServiceRequest
        @return: DescribeVodServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_service_with_options_async(request, runtime)

    def describe_vod_statis_with_options(
        self,
        request: vod_20170321_models.DescribeVodStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodStatisResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodStatisResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_statis_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodStatisResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodStatisResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_statis(
        self,
        request: vod_20170321_models.DescribeVodStatisRequest,
    ) -> vod_20170321_models.DescribeVodStatisResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodStatisRequest
        @return: DescribeVodStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_statis_with_options(request, runtime)

    async def describe_vod_statis_async(
        self,
        request: vod_20170321_models.DescribeVodStatisRequest,
    ) -> vod_20170321_models.DescribeVodStatisResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodStatisRequest
        @return: DescribeVodStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_statis_with_options_async(request, runtime)

    def describe_vod_storage_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodStorageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodStorageDataResponse:
        """
        @summary Queries the usage of storage-related resources, including the storage volume and outbound traffic.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
        
        @param request: DescribeVodStorageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodStorageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.storage):
            query['Storage'] = request.storage
        if not UtilClient.is_unset(request.storage_type):
            query['StorageType'] = request.storage_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodStorageData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodStorageDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_storage_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodStorageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodStorageDataResponse:
        """
        @summary Queries the usage of storage-related resources, including the storage volume and outbound traffic.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
        
        @param request: DescribeVodStorageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodStorageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.storage):
            query['Storage'] = request.storage
        if not UtilClient.is_unset(request.storage_type):
            query['StorageType'] = request.storage_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodStorageData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodStorageDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_storage_data(
        self,
        request: vod_20170321_models.DescribeVodStorageDataRequest,
    ) -> vod_20170321_models.DescribeVodStorageDataResponse:
        """
        @summary Queries the usage of storage-related resources, including the storage volume and outbound traffic.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
        
        @param request: DescribeVodStorageDataRequest
        @return: DescribeVodStorageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_storage_data_with_options(request, runtime)

    async def describe_vod_storage_data_async(
        self,
        request: vod_20170321_models.DescribeVodStorageDataRequest,
    ) -> vod_20170321_models.DescribeVodStorageDataResponse:
        """
        @summary Queries the usage of storage-related resources, including the storage volume and outbound traffic.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
        
        @param request: DescribeVodStorageDataRequest
        @return: DescribeVodStorageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_storage_data_with_options_async(request, runtime)

    def describe_vod_tag_resources_with_options(
        self,
        request: vod_20170321_models.DescribeVodTagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodTagResourcesResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodTagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodTagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodTagResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodTagResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_tag_resources_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodTagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodTagResourcesResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodTagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodTagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodTagResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodTagResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_tag_resources(
        self,
        request: vod_20170321_models.DescribeVodTagResourcesRequest,
    ) -> vod_20170321_models.DescribeVodTagResourcesResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodTagResourcesRequest
        @return: DescribeVodTagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_tag_resources_with_options(request, runtime)

    async def describe_vod_tag_resources_async(
        self,
        request: vod_20170321_models.DescribeVodTagResourcesRequest,
    ) -> vod_20170321_models.DescribeVodTagResourcesResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodTagResourcesRequest
        @return: DescribeVodTagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_tag_resources_with_options_async(request, runtime)

    def describe_vod_tiering_storage_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodTieringStorageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodTieringStorageDataResponse:
        """
        @summary Queries the usage of tiered storage for media assets.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If you specify a time range within 7 days, the request returns the data based on hours. If you specify a time range longer than 7 days, the request returns the data based on days. The maximum time range is 31 days.
        
        @param request: DescribeVodTieringStorageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodTieringStorageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.storage_class):
            query['StorageClass'] = request.storage_class
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodTieringStorageData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodTieringStorageDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_tiering_storage_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodTieringStorageDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodTieringStorageDataResponse:
        """
        @summary Queries the usage of tiered storage for media assets.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If you specify a time range within 7 days, the request returns the data based on hours. If you specify a time range longer than 7 days, the request returns the data based on days. The maximum time range is 31 days.
        
        @param request: DescribeVodTieringStorageDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodTieringStorageDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.storage_class):
            query['StorageClass'] = request.storage_class
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodTieringStorageData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodTieringStorageDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_tiering_storage_data(
        self,
        request: vod_20170321_models.DescribeVodTieringStorageDataRequest,
    ) -> vod_20170321_models.DescribeVodTieringStorageDataResponse:
        """
        @summary Queries the usage of tiered storage for media assets.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If you specify a time range within 7 days, the request returns the data based on hours. If you specify a time range longer than 7 days, the request returns the data based on days. The maximum time range is 31 days.
        
        @param request: DescribeVodTieringStorageDataRequest
        @return: DescribeVodTieringStorageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_tiering_storage_data_with_options(request, runtime)

    async def describe_vod_tiering_storage_data_async(
        self,
        request: vod_20170321_models.DescribeVodTieringStorageDataRequest,
    ) -> vod_20170321_models.DescribeVodTieringStorageDataResponse:
        """
        @summary Queries the usage of tiered storage for media assets.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If you specify a time range within 7 days, the request returns the data based on hours. If you specify a time range longer than 7 days, the request returns the data based on days. The maximum time range is 31 days.
        
        @param request: DescribeVodTieringStorageDataRequest
        @return: DescribeVodTieringStorageDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_tiering_storage_data_with_options_async(request, runtime)

    def describe_vod_tiering_storage_retrieval_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodTieringStorageRetrievalDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodTieringStorageRetrievalDataResponse:
        """
        @summary Queries the data retrieval from tiered storage.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If you specify a time range within 7 days, the request returns the data based on hours. If you specify a time range longer than 7 days, the request returns the data based on days. The maximum time range is 31 days.
        
        @param request: DescribeVodTieringStorageRetrievalDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodTieringStorageRetrievalDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.storage_class):
            query['StorageClass'] = request.storage_class
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodTieringStorageRetrievalData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodTieringStorageRetrievalDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_tiering_storage_retrieval_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodTieringStorageRetrievalDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodTieringStorageRetrievalDataResponse:
        """
        @summary Queries the data retrieval from tiered storage.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If you specify a time range within 7 days, the request returns the data based on hours. If you specify a time range longer than 7 days, the request returns the data based on days. The maximum time range is 31 days.
        
        @param request: DescribeVodTieringStorageRetrievalDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodTieringStorageRetrievalDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.storage_class):
            query['StorageClass'] = request.storage_class
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodTieringStorageRetrievalData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodTieringStorageRetrievalDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_tiering_storage_retrieval_data(
        self,
        request: vod_20170321_models.DescribeVodTieringStorageRetrievalDataRequest,
    ) -> vod_20170321_models.DescribeVodTieringStorageRetrievalDataResponse:
        """
        @summary Queries the data retrieval from tiered storage.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If you specify a time range within 7 days, the request returns the data based on hours. If you specify a time range longer than 7 days, the request returns the data based on days. The maximum time range is 31 days.
        
        @param request: DescribeVodTieringStorageRetrievalDataRequest
        @return: DescribeVodTieringStorageRetrievalDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_tiering_storage_retrieval_data_with_options(request, runtime)

    async def describe_vod_tiering_storage_retrieval_data_async(
        self,
        request: vod_20170321_models.DescribeVodTieringStorageRetrievalDataRequest,
    ) -> vod_20170321_models.DescribeVodTieringStorageRetrievalDataResponse:
        """
        @summary Queries the data retrieval from tiered storage.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If you specify a time range within 7 days, the request returns the data based on hours. If you specify a time range longer than 7 days, the request returns the data based on days. The maximum time range is 31 days.
        
        @param request: DescribeVodTieringStorageRetrievalDataRequest
        @return: DescribeVodTieringStorageRetrievalDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_tiering_storage_retrieval_data_with_options_async(request, runtime)

    def describe_vod_top_domains_by_flow_with_options(
        self,
        request: vod_20170321_models.DescribeVodTopDomainsByFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodTopDomainsByFlowResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodTopDomainsByFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodTopDomainsByFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.limit):
            query['Limit'] = request.limit
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.product):
            query['Product'] = request.product
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodTopDomainsByFlow',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodTopDomainsByFlowResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_top_domains_by_flow_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodTopDomainsByFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodTopDomainsByFlowResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodTopDomainsByFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodTopDomainsByFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.limit):
            query['Limit'] = request.limit
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.product):
            query['Product'] = request.product
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodTopDomainsByFlow',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodTopDomainsByFlowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_top_domains_by_flow(
        self,
        request: vod_20170321_models.DescribeVodTopDomainsByFlowRequest,
    ) -> vod_20170321_models.DescribeVodTopDomainsByFlowResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodTopDomainsByFlowRequest
        @return: DescribeVodTopDomainsByFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_top_domains_by_flow_with_options(request, runtime)

    async def describe_vod_top_domains_by_flow_async(
        self,
        request: vod_20170321_models.DescribeVodTopDomainsByFlowRequest,
    ) -> vod_20170321_models.DescribeVodTopDomainsByFlowResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodTopDomainsByFlowRequest
        @return: DescribeVodTopDomainsByFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_top_domains_by_flow_with_options_async(request, runtime)

    def describe_vod_transcode_data_with_options(
        self,
        request: vod_20170321_models.DescribeVodTranscodeDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodTranscodeDataResponse:
        """
        @summary Queries the transcoding statistics.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
        
        @param request: DescribeVodTranscodeDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodTranscodeDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.specification):
            query['Specification'] = request.specification
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.storage):
            query['Storage'] = request.storage
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodTranscodeData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodTranscodeDataResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_transcode_data_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodTranscodeDataRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodTranscodeDataResponse:
        """
        @summary Queries the transcoding statistics.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
        
        @param request: DescribeVodTranscodeDataRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodTranscodeDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.specification):
            query['Specification'] = request.specification
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.storage):
            query['Storage'] = request.storage
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodTranscodeData',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodTranscodeDataResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_transcode_data(
        self,
        request: vod_20170321_models.DescribeVodTranscodeDataRequest,
    ) -> vod_20170321_models.DescribeVodTranscodeDataResponse:
        """
        @summary Queries the transcoding statistics.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
        
        @param request: DescribeVodTranscodeDataRequest
        @return: DescribeVodTranscodeDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_transcode_data_with_options(request, runtime)

    async def describe_vod_transcode_data_async(
        self,
        request: vod_20170321_models.DescribeVodTranscodeDataRequest,
    ) -> vod_20170321_models.DescribeVodTranscodeDataResponse:
        """
        @summary Queries the transcoding statistics.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
        
        @param request: DescribeVodTranscodeDataRequest
        @return: DescribeVodTranscodeDataResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_transcode_data_with_options_async(request, runtime)

    def describe_vod_user_bill_prediction_with_options(
        self,
        request: vod_20170321_models.DescribeVodUserBillPredictionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodUserBillPredictionResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserBillPredictionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodUserBillPredictionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.area):
            query['Area'] = request.area
        if not UtilClient.is_unset(request.dimension):
            query['Dimension'] = request.dimension
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodUserBillPrediction',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodUserBillPredictionResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_user_bill_prediction_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodUserBillPredictionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodUserBillPredictionResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserBillPredictionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodUserBillPredictionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.area):
            query['Area'] = request.area
        if not UtilClient.is_unset(request.dimension):
            query['Dimension'] = request.dimension
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodUserBillPrediction',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodUserBillPredictionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_user_bill_prediction(
        self,
        request: vod_20170321_models.DescribeVodUserBillPredictionRequest,
    ) -> vod_20170321_models.DescribeVodUserBillPredictionResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserBillPredictionRequest
        @return: DescribeVodUserBillPredictionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_user_bill_prediction_with_options(request, runtime)

    async def describe_vod_user_bill_prediction_async(
        self,
        request: vod_20170321_models.DescribeVodUserBillPredictionRequest,
    ) -> vod_20170321_models.DescribeVodUserBillPredictionResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserBillPredictionRequest
        @return: DescribeVodUserBillPredictionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_user_bill_prediction_with_options_async(request, runtime)

    def describe_vod_user_domains_with_options(
        self,
        request: vod_20170321_models.DescribeVodUserDomainsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodUserDomainsResponse:
        """
        @summary Queries the domain names for CDN within your Alibaba Cloud account.
        
        @description    You can filter domain names by name and status. Fuzzy match is supported for domain name-based query.
        This operation is available only in the China (Shanghai) region.
        
        @param request: DescribeVodUserDomainsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodUserDomainsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_search_type):
            query['DomainSearchType'] = request.domain_search_type
        if not UtilClient.is_unset(request.domain_status):
            query['DomainStatus'] = request.domain_status
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodUserDomains',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodUserDomainsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_user_domains_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodUserDomainsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodUserDomainsResponse:
        """
        @summary Queries the domain names for CDN within your Alibaba Cloud account.
        
        @description    You can filter domain names by name and status. Fuzzy match is supported for domain name-based query.
        This operation is available only in the China (Shanghai) region.
        
        @param request: DescribeVodUserDomainsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodUserDomainsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.domain_search_type):
            query['DomainSearchType'] = request.domain_search_type
        if not UtilClient.is_unset(request.domain_status):
            query['DomainStatus'] = request.domain_status
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodUserDomains',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodUserDomainsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_user_domains(
        self,
        request: vod_20170321_models.DescribeVodUserDomainsRequest,
    ) -> vod_20170321_models.DescribeVodUserDomainsResponse:
        """
        @summary Queries the domain names for CDN within your Alibaba Cloud account.
        
        @description    You can filter domain names by name and status. Fuzzy match is supported for domain name-based query.
        This operation is available only in the China (Shanghai) region.
        
        @param request: DescribeVodUserDomainsRequest
        @return: DescribeVodUserDomainsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_user_domains_with_options(request, runtime)

    async def describe_vod_user_domains_async(
        self,
        request: vod_20170321_models.DescribeVodUserDomainsRequest,
    ) -> vod_20170321_models.DescribeVodUserDomainsResponse:
        """
        @summary Queries the domain names for CDN within your Alibaba Cloud account.
        
        @description    You can filter domain names by name and status. Fuzzy match is supported for domain name-based query.
        This operation is available only in the China (Shanghai) region.
        
        @param request: DescribeVodUserDomainsRequest
        @return: DescribeVodUserDomainsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_user_domains_with_options_async(request, runtime)

    def describe_vod_user_quota_with_options(
        self,
        request: vod_20170321_models.DescribeVodUserQuotaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodUserQuotaResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserQuotaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodUserQuotaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodUserQuota',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodUserQuotaResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_user_quota_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodUserQuotaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodUserQuotaResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserQuotaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodUserQuotaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodUserQuota',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodUserQuotaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_user_quota(
        self,
        request: vod_20170321_models.DescribeVodUserQuotaRequest,
    ) -> vod_20170321_models.DescribeVodUserQuotaResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserQuotaRequest
        @return: DescribeVodUserQuotaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_user_quota_with_options(request, runtime)

    async def describe_vod_user_quota_async(
        self,
        request: vod_20170321_models.DescribeVodUserQuotaRequest,
    ) -> vod_20170321_models.DescribeVodUserQuotaResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserQuotaRequest
        @return: DescribeVodUserQuotaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_user_quota_with_options_async(request, runtime)

    def describe_vod_user_resource_package_with_options(
        self,
        request: vod_20170321_models.DescribeVodUserResourcePackageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodUserResourcePackageResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserResourcePackageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodUserResourcePackageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodUserResourcePackage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodUserResourcePackageResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_user_resource_package_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodUserResourcePackageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodUserResourcePackageResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserResourcePackageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodUserResourcePackageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodUserResourcePackage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodUserResourcePackageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_user_resource_package(
        self,
        request: vod_20170321_models.DescribeVodUserResourcePackageRequest,
    ) -> vod_20170321_models.DescribeVodUserResourcePackageResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserResourcePackageRequest
        @return: DescribeVodUserResourcePackageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_user_resource_package_with_options(request, runtime)

    async def describe_vod_user_resource_package_async(
        self,
        request: vod_20170321_models.DescribeVodUserResourcePackageRequest,
    ) -> vod_20170321_models.DescribeVodUserResourcePackageResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserResourcePackageRequest
        @return: DescribeVodUserResourcePackageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_user_resource_package_with_options_async(request, runtime)

    def describe_vod_user_tags_with_options(
        self,
        request: vod_20170321_models.DescribeVodUserTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodUserTagsResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodUserTagsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodUserTags',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodUserTagsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_user_tags_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodUserTagsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodUserTagsResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserTagsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodUserTagsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodUserTags',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodUserTagsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_user_tags(
        self,
        request: vod_20170321_models.DescribeVodUserTagsRequest,
    ) -> vod_20170321_models.DescribeVodUserTagsResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserTagsRequest
        @return: DescribeVodUserTagsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_user_tags_with_options(request, runtime)

    async def describe_vod_user_tags_async(
        self,
        request: vod_20170321_models.DescribeVodUserTagsRequest,
    ) -> vod_20170321_models.DescribeVodUserTagsResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserTagsRequest
        @return: DescribeVodUserTagsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_user_tags_with_options_async(request, runtime)

    def describe_vod_user_usage_detail_data_export_task_with_options(
        self,
        request: vod_20170321_models.DescribeVodUserUsageDetailDataExportTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodUserUsageDetailDataExportTaskResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserUsageDetailDataExportTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodUserUsageDetailDataExportTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodUserUsageDetailDataExportTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodUserUsageDetailDataExportTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_user_usage_detail_data_export_task_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodUserUsageDetailDataExportTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodUserUsageDetailDataExportTaskResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserUsageDetailDataExportTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodUserUsageDetailDataExportTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodUserUsageDetailDataExportTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodUserUsageDetailDataExportTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_user_usage_detail_data_export_task(
        self,
        request: vod_20170321_models.DescribeVodUserUsageDetailDataExportTaskRequest,
    ) -> vod_20170321_models.DescribeVodUserUsageDetailDataExportTaskResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserUsageDetailDataExportTaskRequest
        @return: DescribeVodUserUsageDetailDataExportTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_user_usage_detail_data_export_task_with_options(request, runtime)

    async def describe_vod_user_usage_detail_data_export_task_async(
        self,
        request: vod_20170321_models.DescribeVodUserUsageDetailDataExportTaskRequest,
    ) -> vod_20170321_models.DescribeVodUserUsageDetailDataExportTaskResponse:
        """
        @summary 用量查询接口
        
        @param request: DescribeVodUserUsageDetailDataExportTaskRequest
        @return: DescribeVodUserUsageDetailDataExportTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_user_usage_detail_data_export_task_with_options_async(request, runtime)

    def describe_vod_verify_content_with_options(
        self,
        request: vod_20170321_models.DescribeVodVerifyContentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodVerifyContentResponse:
        """
        @summary Queries the ownership verification content.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        
        @param request: DescribeVodVerifyContentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodVerifyContentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodVerifyContent',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodVerifyContentResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_vod_verify_content_with_options_async(
        self,
        request: vod_20170321_models.DescribeVodVerifyContentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DescribeVodVerifyContentResponse:
        """
        @summary Queries the ownership verification content.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        
        @param request: DescribeVodVerifyContentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeVodVerifyContentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeVodVerifyContent',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DescribeVodVerifyContentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_vod_verify_content(
        self,
        request: vod_20170321_models.DescribeVodVerifyContentRequest,
    ) -> vod_20170321_models.DescribeVodVerifyContentResponse:
        """
        @summary Queries the ownership verification content.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        
        @param request: DescribeVodVerifyContentRequest
        @return: DescribeVodVerifyContentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_vod_verify_content_with_options(request, runtime)

    async def describe_vod_verify_content_async(
        self,
        request: vod_20170321_models.DescribeVodVerifyContentRequest,
    ) -> vod_20170321_models.DescribeVodVerifyContentResponse:
        """
        @summary Queries the ownership verification content.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        
        @param request: DescribeVodVerifyContentRequest
        @return: DescribeVodVerifyContentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_vod_verify_content_with_options_async(request, runtime)

    def detach_app_policy_from_identity_with_options(
        self,
        request: vod_20170321_models.DetachAppPolicyFromIdentityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DetachAppPolicyFromIdentityResponse:
        """
        @summary Revokes application permissions from the specified identity. The identity may a RAM user or RAM role.
        
        @description >  You can grant a maximum of 10 application permissions to a RAM user or RAM role.
        
        @param request: DetachAppPolicyFromIdentityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachAppPolicyFromIdentityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.identity_name):
            query['IdentityName'] = request.identity_name
        if not UtilClient.is_unset(request.identity_type):
            query['IdentityType'] = request.identity_type
        if not UtilClient.is_unset(request.policy_names):
            query['PolicyNames'] = request.policy_names
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachAppPolicyFromIdentity',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DetachAppPolicyFromIdentityResponse(),
            self.call_api(params, req, runtime)
        )

    async def detach_app_policy_from_identity_with_options_async(
        self,
        request: vod_20170321_models.DetachAppPolicyFromIdentityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DetachAppPolicyFromIdentityResponse:
        """
        @summary Revokes application permissions from the specified identity. The identity may a RAM user or RAM role.
        
        @description >  You can grant a maximum of 10 application permissions to a RAM user or RAM role.
        
        @param request: DetachAppPolicyFromIdentityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetachAppPolicyFromIdentityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.identity_name):
            query['IdentityName'] = request.identity_name
        if not UtilClient.is_unset(request.identity_type):
            query['IdentityType'] = request.identity_type
        if not UtilClient.is_unset(request.policy_names):
            query['PolicyNames'] = request.policy_names
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetachAppPolicyFromIdentity',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DetachAppPolicyFromIdentityResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def detach_app_policy_from_identity(
        self,
        request: vod_20170321_models.DetachAppPolicyFromIdentityRequest,
    ) -> vod_20170321_models.DetachAppPolicyFromIdentityResponse:
        """
        @summary Revokes application permissions from the specified identity. The identity may a RAM user or RAM role.
        
        @description >  You can grant a maximum of 10 application permissions to a RAM user or RAM role.
        
        @param request: DetachAppPolicyFromIdentityRequest
        @return: DetachAppPolicyFromIdentityResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.detach_app_policy_from_identity_with_options(request, runtime)

    async def detach_app_policy_from_identity_async(
        self,
        request: vod_20170321_models.DetachAppPolicyFromIdentityRequest,
    ) -> vod_20170321_models.DetachAppPolicyFromIdentityResponse:
        """
        @summary Revokes application permissions from the specified identity. The identity may a RAM user or RAM role.
        
        @description >  You can grant a maximum of 10 application permissions to a RAM user or RAM role.
        
        @param request: DetachAppPolicyFromIdentityRequest
        @return: DetachAppPolicyFromIdentityResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.detach_app_policy_from_identity_with_options_async(request, runtime)

    def disable_vod_realtime_log_delivery_with_options(
        self,
        request: vod_20170321_models.DisableVodRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DisableVodRealtimeLogDeliveryResponse:
        """
        @summary 停用实时日志
        
        @param request: DisableVodRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableVodRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableVodRealtimeLogDelivery',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DisableVodRealtimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def disable_vod_realtime_log_delivery_with_options_async(
        self,
        request: vod_20170321_models.DisableVodRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DisableVodRealtimeLogDeliveryResponse:
        """
        @summary 停用实时日志
        
        @param request: DisableVodRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableVodRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableVodRealtimeLogDelivery',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DisableVodRealtimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def disable_vod_realtime_log_delivery(
        self,
        request: vod_20170321_models.DisableVodRealtimeLogDeliveryRequest,
    ) -> vod_20170321_models.DisableVodRealtimeLogDeliveryResponse:
        """
        @summary 停用实时日志
        
        @param request: DisableVodRealtimeLogDeliveryRequest
        @return: DisableVodRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.disable_vod_realtime_log_delivery_with_options(request, runtime)

    async def disable_vod_realtime_log_delivery_async(
        self,
        request: vod_20170321_models.DisableVodRealtimeLogDeliveryRequest,
    ) -> vod_20170321_models.DisableVodRealtimeLogDeliveryResponse:
        """
        @summary 停用实时日志
        
        @param request: DisableVodRealtimeLogDeliveryRequest
        @return: DisableVodRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.disable_vod_realtime_log_delivery_with_options_async(request, runtime)

    def display_aiaudit_switch_with_options(
        self,
        request: vod_20170321_models.DisplayAIAuditSwitchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DisplayAIAuditSwitchResponse:
        """
        @summary 获取AI审核开关
        
        @param request: DisplayAIAuditSwitchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisplayAIAuditSwitchResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisplayAIAuditSwitch',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DisplayAIAuditSwitchResponse(),
            self.call_api(params, req, runtime)
        )

    async def display_aiaudit_switch_with_options_async(
        self,
        request: vod_20170321_models.DisplayAIAuditSwitchRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.DisplayAIAuditSwitchResponse:
        """
        @summary 获取AI审核开关
        
        @param request: DisplayAIAuditSwitchRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisplayAIAuditSwitchResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisplayAIAuditSwitch',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.DisplayAIAuditSwitchResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def display_aiaudit_switch(
        self,
        request: vod_20170321_models.DisplayAIAuditSwitchRequest,
    ) -> vod_20170321_models.DisplayAIAuditSwitchResponse:
        """
        @summary 获取AI审核开关
        
        @param request: DisplayAIAuditSwitchRequest
        @return: DisplayAIAuditSwitchResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.display_aiaudit_switch_with_options(request, runtime)

    async def display_aiaudit_switch_async(
        self,
        request: vod_20170321_models.DisplayAIAuditSwitchRequest,
    ) -> vod_20170321_models.DisplayAIAuditSwitchResponse:
        """
        @summary 获取AI审核开关
        
        @param request: DisplayAIAuditSwitchRequest
        @return: DisplayAIAuditSwitchResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.display_aiaudit_switch_with_options_async(request, runtime)

    def edit_app_info_with_options(
        self,
        tmp_req: vod_20170321_models.EditAppInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.EditAppInfoResponse:
        """
        @summary 编辑应用信息
        
        @param tmp_req: EditAppInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EditAppInfoResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vod_20170321_models.EditAppInfoShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.platforms):
            request.platforms_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.platforms, 'Platforms', 'json')
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.app_type):
            query['AppType'] = request.app_type
        if not UtilClient.is_unset(request.platforms_shrink):
            query['Platforms'] = request.platforms_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EditAppInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.EditAppInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def edit_app_info_with_options_async(
        self,
        tmp_req: vod_20170321_models.EditAppInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.EditAppInfoResponse:
        """
        @summary 编辑应用信息
        
        @param tmp_req: EditAppInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EditAppInfoResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vod_20170321_models.EditAppInfoShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.platforms):
            request.platforms_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.platforms, 'Platforms', 'json')
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.app_type):
            query['AppType'] = request.app_type
        if not UtilClient.is_unset(request.platforms_shrink):
            query['Platforms'] = request.platforms_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EditAppInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.EditAppInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def edit_app_info(
        self,
        request: vod_20170321_models.EditAppInfoRequest,
    ) -> vod_20170321_models.EditAppInfoResponse:
        """
        @summary 编辑应用信息
        
        @param request: EditAppInfoRequest
        @return: EditAppInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.edit_app_info_with_options(request, runtime)

    async def edit_app_info_async(
        self,
        request: vod_20170321_models.EditAppInfoRequest,
    ) -> vod_20170321_models.EditAppInfoResponse:
        """
        @summary 编辑应用信息
        
        @param request: EditAppInfoRequest
        @return: EditAppInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.edit_app_info_with_options_async(request, runtime)

    def edit_license_with_options(
        self,
        request: vod_20170321_models.EditLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.EditLicenseResponse:
        """
        @summary 编辑证书
        
        @param request: EditLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EditLicenseResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_item_id):
            body['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.app_name):
            body['AppName'] = request.app_name
        if not UtilClient.is_unset(request.app_platforms):
            body['AppPlatforms'] = request.app_platforms
        if not UtilClient.is_unset(request.contract_no):
            body['ContractNo'] = request.contract_no
        if not UtilClient.is_unset(request.instance_id):
            body['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.sdk_models):
            body['SdkModels'] = request.sdk_models
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='EditLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.EditLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def edit_license_with_options_async(
        self,
        request: vod_20170321_models.EditLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.EditLicenseResponse:
        """
        @summary 编辑证书
        
        @param request: EditLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EditLicenseResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_item_id):
            body['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.app_name):
            body['AppName'] = request.app_name
        if not UtilClient.is_unset(request.app_platforms):
            body['AppPlatforms'] = request.app_platforms
        if not UtilClient.is_unset(request.contract_no):
            body['ContractNo'] = request.contract_no
        if not UtilClient.is_unset(request.instance_id):
            body['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.sdk_models):
            body['SdkModels'] = request.sdk_models
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='EditLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.EditLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def edit_license(
        self,
        request: vod_20170321_models.EditLicenseRequest,
    ) -> vod_20170321_models.EditLicenseResponse:
        """
        @summary 编辑证书
        
        @param request: EditLicenseRequest
        @return: EditLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.edit_license_with_options(request, runtime)

    async def edit_license_async(
        self,
        request: vod_20170321_models.EditLicenseRequest,
    ) -> vod_20170321_models.EditLicenseResponse:
        """
        @summary 编辑证书
        
        @param request: EditLicenseRequest
        @return: EditLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.edit_license_with_options_async(request, runtime)

    def enable_vod_realtime_log_delivery_with_options(
        self,
        request: vod_20170321_models.EnableVodRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.EnableVodRealtimeLogDeliveryResponse:
        """
        @summary 启用实时日志
        
        @param request: EnableVodRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableVodRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableVodRealtimeLogDelivery',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.EnableVodRealtimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def enable_vod_realtime_log_delivery_with_options_async(
        self,
        request: vod_20170321_models.EnableVodRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.EnableVodRealtimeLogDeliveryResponse:
        """
        @summary 启用实时日志
        
        @param request: EnableVodRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableVodRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableVodRealtimeLogDelivery',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.EnableVodRealtimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def enable_vod_realtime_log_delivery(
        self,
        request: vod_20170321_models.EnableVodRealtimeLogDeliveryRequest,
    ) -> vod_20170321_models.EnableVodRealtimeLogDeliveryResponse:
        """
        @summary 启用实时日志
        
        @param request: EnableVodRealtimeLogDeliveryRequest
        @return: EnableVodRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.enable_vod_realtime_log_delivery_with_options(request, runtime)

    async def enable_vod_realtime_log_delivery_async(
        self,
        request: vod_20170321_models.EnableVodRealtimeLogDeliveryRequest,
    ) -> vod_20170321_models.EnableVodRealtimeLogDeliveryResponse:
        """
        @summary 启用实时日志
        
        @param request: EnableVodRealtimeLogDeliveryRequest
        @return: EnableVodRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.enable_vod_realtime_log_delivery_with_options_async(request, runtime)

    def face_registration_with_options(
        self,
        request: vod_20170321_models.FaceRegistrationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.FaceRegistrationResponse:
        """
        @summary 人脸注册
        
        @param request: FaceRegistrationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: FaceRegistrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.image_ids):
            query['ImageIds'] = request.image_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.person_id):
            query['PersonId'] = request.person_id
        if not UtilClient.is_unset(request.person_library):
            query['PersonLibrary'] = request.person_library
        if not UtilClient.is_unset(request.person_name):
            query['PersonName'] = request.person_name
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='FaceRegistration',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.FaceRegistrationResponse(),
            self.call_api(params, req, runtime)
        )

    async def face_registration_with_options_async(
        self,
        request: vod_20170321_models.FaceRegistrationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.FaceRegistrationResponse:
        """
        @summary 人脸注册
        
        @param request: FaceRegistrationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: FaceRegistrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category):
            query['Category'] = request.category
        if not UtilClient.is_unset(request.image_ids):
            query['ImageIds'] = request.image_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.person_id):
            query['PersonId'] = request.person_id
        if not UtilClient.is_unset(request.person_library):
            query['PersonLibrary'] = request.person_library
        if not UtilClient.is_unset(request.person_name):
            query['PersonName'] = request.person_name
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='FaceRegistration',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.FaceRegistrationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def face_registration(
        self,
        request: vod_20170321_models.FaceRegistrationRequest,
    ) -> vod_20170321_models.FaceRegistrationResponse:
        """
        @summary 人脸注册
        
        @param request: FaceRegistrationRequest
        @return: FaceRegistrationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.face_registration_with_options(request, runtime)

    async def face_registration_async(
        self,
        request: vod_20170321_models.FaceRegistrationRequest,
    ) -> vod_20170321_models.FaceRegistrationResponse:
        """
        @summary 人脸注册
        
        @param request: FaceRegistrationRequest
        @return: FaceRegistrationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.face_registration_with_options_async(request, runtime)

    def generate_download_secret_key_with_options(
        self,
        request: vod_20170321_models.GenerateDownloadSecretKeyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GenerateDownloadSecretKeyResponse:
        """
        @summary Generates a key for secure download. ApsaraVideo Player SDK provides the secure download feature. Videos that are downloaded to your local device in this mode are encrypted. You can play the encrypted videos only by using the key file generated from the app that you specified. Secure download protects your videos from malicious playback or distribution.
        
        @description    To use the secure download feature, you must enable the download feature in the ApsaraVideo VOD console and set the download method to secure download. For more information, see [Configure download settings](https://help.aliyun.com/document_detail/86107.html).
        After you generate a key for secure download, you must configure the key in ApsaraVideo Player SDK. For more information, see [Secure download](https://help.aliyun.com/document_detail/124735.html).
        
        @param request: GenerateDownloadSecretKeyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GenerateDownloadSecretKeyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_decrypt_key):
            query['AppDecryptKey'] = request.app_decrypt_key
        if not UtilClient.is_unset(request.app_identification):
            query['AppIdentification'] = request.app_identification
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GenerateDownloadSecretKey',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GenerateDownloadSecretKeyResponse(),
            self.call_api(params, req, runtime)
        )

    async def generate_download_secret_key_with_options_async(
        self,
        request: vod_20170321_models.GenerateDownloadSecretKeyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GenerateDownloadSecretKeyResponse:
        """
        @summary Generates a key for secure download. ApsaraVideo Player SDK provides the secure download feature. Videos that are downloaded to your local device in this mode are encrypted. You can play the encrypted videos only by using the key file generated from the app that you specified. Secure download protects your videos from malicious playback or distribution.
        
        @description    To use the secure download feature, you must enable the download feature in the ApsaraVideo VOD console and set the download method to secure download. For more information, see [Configure download settings](https://help.aliyun.com/document_detail/86107.html).
        After you generate a key for secure download, you must configure the key in ApsaraVideo Player SDK. For more information, see [Secure download](https://help.aliyun.com/document_detail/124735.html).
        
        @param request: GenerateDownloadSecretKeyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GenerateDownloadSecretKeyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_decrypt_key):
            query['AppDecryptKey'] = request.app_decrypt_key
        if not UtilClient.is_unset(request.app_identification):
            query['AppIdentification'] = request.app_identification
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GenerateDownloadSecretKey',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GenerateDownloadSecretKeyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def generate_download_secret_key(
        self,
        request: vod_20170321_models.GenerateDownloadSecretKeyRequest,
    ) -> vod_20170321_models.GenerateDownloadSecretKeyResponse:
        """
        @summary Generates a key for secure download. ApsaraVideo Player SDK provides the secure download feature. Videos that are downloaded to your local device in this mode are encrypted. You can play the encrypted videos only by using the key file generated from the app that you specified. Secure download protects your videos from malicious playback or distribution.
        
        @description    To use the secure download feature, you must enable the download feature in the ApsaraVideo VOD console and set the download method to secure download. For more information, see [Configure download settings](https://help.aliyun.com/document_detail/86107.html).
        After you generate a key for secure download, you must configure the key in ApsaraVideo Player SDK. For more information, see [Secure download](https://help.aliyun.com/document_detail/124735.html).
        
        @param request: GenerateDownloadSecretKeyRequest
        @return: GenerateDownloadSecretKeyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.generate_download_secret_key_with_options(request, runtime)

    async def generate_download_secret_key_async(
        self,
        request: vod_20170321_models.GenerateDownloadSecretKeyRequest,
    ) -> vod_20170321_models.GenerateDownloadSecretKeyResponse:
        """
        @summary Generates a key for secure download. ApsaraVideo Player SDK provides the secure download feature. Videos that are downloaded to your local device in this mode are encrypted. You can play the encrypted videos only by using the key file generated from the app that you specified. Secure download protects your videos from malicious playback or distribution.
        
        @description    To use the secure download feature, you must enable the download feature in the ApsaraVideo VOD console and set the download method to secure download. For more information, see [Configure download settings](https://help.aliyun.com/document_detail/86107.html).
        After you generate a key for secure download, you must configure the key in ApsaraVideo Player SDK. For more information, see [Secure download](https://help.aliyun.com/document_detail/124735.html).
        
        @param request: GenerateDownloadSecretKeyRequest
        @return: GenerateDownloadSecretKeyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.generate_download_secret_key_with_options_async(request, runtime)

    def generate_kmsdata_key_with_options(
        self,
        request: vod_20170321_models.GenerateKMSDataKeyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GenerateKMSDataKeyResponse:
        """
        @summary Generates a random Key Management Service (KMS) data key used for HLS encryption in ApsaraVideo VOD.
        
        @param request: GenerateKMSDataKeyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GenerateKMSDataKeyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GenerateKMSDataKey',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GenerateKMSDataKeyResponse(),
            self.call_api(params, req, runtime)
        )

    async def generate_kmsdata_key_with_options_async(
        self,
        request: vod_20170321_models.GenerateKMSDataKeyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GenerateKMSDataKeyResponse:
        """
        @summary Generates a random Key Management Service (KMS) data key used for HLS encryption in ApsaraVideo VOD.
        
        @param request: GenerateKMSDataKeyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GenerateKMSDataKeyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GenerateKMSDataKey',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GenerateKMSDataKeyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def generate_kmsdata_key(
        self,
        request: vod_20170321_models.GenerateKMSDataKeyRequest,
    ) -> vod_20170321_models.GenerateKMSDataKeyResponse:
        """
        @summary Generates a random Key Management Service (KMS) data key used for HLS encryption in ApsaraVideo VOD.
        
        @param request: GenerateKMSDataKeyRequest
        @return: GenerateKMSDataKeyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.generate_kmsdata_key_with_options(request, runtime)

    async def generate_kmsdata_key_async(
        self,
        request: vod_20170321_models.GenerateKMSDataKeyRequest,
    ) -> vod_20170321_models.GenerateKMSDataKeyResponse:
        """
        @summary Generates a random Key Management Service (KMS) data key used for HLS encryption in ApsaraVideo VOD.
        
        @param request: GenerateKMSDataKeyRequest
        @return: GenerateKMSDataKeyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.generate_kmsdata_key_with_options_async(request, runtime)

    def get_aicaption_extraction_jobs_with_options(
        self,
        request: vod_20170321_models.GetAICaptionExtractionJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAICaptionExtractionJobsResponse:
        """
        @summary 获取标题提取任务
        
        @param request: GetAICaptionExtractionJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAICaptionExtractionJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAICaptionExtractionJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAICaptionExtractionJobsResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_aicaption_extraction_jobs_with_options_async(
        self,
        request: vod_20170321_models.GetAICaptionExtractionJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAICaptionExtractionJobsResponse:
        """
        @summary 获取标题提取任务
        
        @param request: GetAICaptionExtractionJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAICaptionExtractionJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAICaptionExtractionJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAICaptionExtractionJobsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_aicaption_extraction_jobs(
        self,
        request: vod_20170321_models.GetAICaptionExtractionJobsRequest,
    ) -> vod_20170321_models.GetAICaptionExtractionJobsResponse:
        """
        @summary 获取标题提取任务
        
        @param request: GetAICaptionExtractionJobsRequest
        @return: GetAICaptionExtractionJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_aicaption_extraction_jobs_with_options(request, runtime)

    async def get_aicaption_extraction_jobs_async(
        self,
        request: vod_20170321_models.GetAICaptionExtractionJobsRequest,
    ) -> vod_20170321_models.GetAICaptionExtractionJobsResponse:
        """
        @summary 获取标题提取任务
        
        @param request: GetAICaptionExtractionJobsRequest
        @return: GetAICaptionExtractionJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_aicaption_extraction_jobs_with_options_async(request, runtime)

    def get_aiimage_jobs_with_options(
        self,
        request: vod_20170321_models.GetAIImageJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAIImageJobsResponse:
        """
        @summary Queries jobs of image AI processing.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        Call the [SubmitAIImageJob](~~SubmitAIImageJob~~) operation to submit image AI processing jobs before you call this operation to query image AI processing jobs.
        You can query a maximum of 10 jobs of image AI processing in one request.
        
        @param request: GetAIImageJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAIImageJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAIImageJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAIImageJobsResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_aiimage_jobs_with_options_async(
        self,
        request: vod_20170321_models.GetAIImageJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAIImageJobsResponse:
        """
        @summary Queries jobs of image AI processing.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        Call the [SubmitAIImageJob](~~SubmitAIImageJob~~) operation to submit image AI processing jobs before you call this operation to query image AI processing jobs.
        You can query a maximum of 10 jobs of image AI processing in one request.
        
        @param request: GetAIImageJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAIImageJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAIImageJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAIImageJobsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_aiimage_jobs(
        self,
        request: vod_20170321_models.GetAIImageJobsRequest,
    ) -> vod_20170321_models.GetAIImageJobsResponse:
        """
        @summary Queries jobs of image AI processing.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        Call the [SubmitAIImageJob](~~SubmitAIImageJob~~) operation to submit image AI processing jobs before you call this operation to query image AI processing jobs.
        You can query a maximum of 10 jobs of image AI processing in one request.
        
        @param request: GetAIImageJobsRequest
        @return: GetAIImageJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_aiimage_jobs_with_options(request, runtime)

    async def get_aiimage_jobs_async(
        self,
        request: vod_20170321_models.GetAIImageJobsRequest,
    ) -> vod_20170321_models.GetAIImageJobsResponse:
        """
        @summary Queries jobs of image AI processing.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        Call the [SubmitAIImageJob](~~SubmitAIImageJob~~) operation to submit image AI processing jobs before you call this operation to query image AI processing jobs.
        You can query a maximum of 10 jobs of image AI processing in one request.
        
        @param request: GetAIImageJobsRequest
        @return: GetAIImageJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_aiimage_jobs_with_options_async(request, runtime)

    def get_aimedia_audit_job_with_options(
        self,
        request: vod_20170321_models.GetAIMediaAuditJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAIMediaAuditJobResponse:
        """
        @summary Queries the information about an intelligent review job. After the job is submitted, it is processed asynchronously. You can call this operation to query the job information in real time.
        
        @description ApsaraVideo VOD stores the snapshots of the intelligent review results free of charge for two weeks. After this period, the snapshots are automatically deleted.
        
        @param request: GetAIMediaAuditJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAIMediaAuditJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAIMediaAuditJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAIMediaAuditJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_aimedia_audit_job_with_options_async(
        self,
        request: vod_20170321_models.GetAIMediaAuditJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAIMediaAuditJobResponse:
        """
        @summary Queries the information about an intelligent review job. After the job is submitted, it is processed asynchronously. You can call this operation to query the job information in real time.
        
        @description ApsaraVideo VOD stores the snapshots of the intelligent review results free of charge for two weeks. After this period, the snapshots are automatically deleted.
        
        @param request: GetAIMediaAuditJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAIMediaAuditJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAIMediaAuditJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAIMediaAuditJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_aimedia_audit_job(
        self,
        request: vod_20170321_models.GetAIMediaAuditJobRequest,
    ) -> vod_20170321_models.GetAIMediaAuditJobResponse:
        """
        @summary Queries the information about an intelligent review job. After the job is submitted, it is processed asynchronously. You can call this operation to query the job information in real time.
        
        @description ApsaraVideo VOD stores the snapshots of the intelligent review results free of charge for two weeks. After this period, the snapshots are automatically deleted.
        
        @param request: GetAIMediaAuditJobRequest
        @return: GetAIMediaAuditJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_aimedia_audit_job_with_options(request, runtime)

    async def get_aimedia_audit_job_async(
        self,
        request: vod_20170321_models.GetAIMediaAuditJobRequest,
    ) -> vod_20170321_models.GetAIMediaAuditJobResponse:
        """
        @summary Queries the information about an intelligent review job. After the job is submitted, it is processed asynchronously. You can call this operation to query the job information in real time.
        
        @description ApsaraVideo VOD stores the snapshots of the intelligent review results free of charge for two weeks. After this period, the snapshots are automatically deleted.
        
        @param request: GetAIMediaAuditJobRequest
        @return: GetAIMediaAuditJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_aimedia_audit_job_with_options_async(request, runtime)

    def get_aiservice_with_options(
        self,
        request: vod_20170321_models.GetAIServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAIServiceResponse:
        """
        @summary 获取AI服务状态
        
        @param request: GetAIServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAIServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.types):
            query['Types'] = request.types
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAIService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAIServiceResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_aiservice_with_options_async(
        self,
        request: vod_20170321_models.GetAIServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAIServiceResponse:
        """
        @summary 获取AI服务状态
        
        @param request: GetAIServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAIServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.types):
            query['Types'] = request.types
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAIService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAIServiceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_aiservice(
        self,
        request: vod_20170321_models.GetAIServiceRequest,
    ) -> vod_20170321_models.GetAIServiceResponse:
        """
        @summary 获取AI服务状态
        
        @param request: GetAIServiceRequest
        @return: GetAIServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_aiservice_with_options(request, runtime)

    async def get_aiservice_async(
        self,
        request: vod_20170321_models.GetAIServiceRequest,
    ) -> vod_20170321_models.GetAIServiceResponse:
        """
        @summary 获取AI服务状态
        
        @param request: GetAIServiceRequest
        @return: GetAIServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_aiservice_with_options_async(request, runtime)

    def get_aistatis_with_options(
        self,
        request: vod_20170321_models.GetAIStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAIStatisResponse:
        """
        @summary 获取AI统计信息
        
        @param request: GetAIStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAIStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.division):
            query['Division'] = request.division
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_utc):
            query['EndTimeUTC'] = request.end_time_utc
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.start_time_utc):
            query['StartTimeUTC'] = request.start_time_utc
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAIStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAIStatisResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_aistatis_with_options_async(
        self,
        request: vod_20170321_models.GetAIStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAIStatisResponse:
        """
        @summary 获取AI统计信息
        
        @param request: GetAIStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAIStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.division):
            query['Division'] = request.division
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_utc):
            query['EndTimeUTC'] = request.end_time_utc
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.start_time_utc):
            query['StartTimeUTC'] = request.start_time_utc
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAIStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAIStatisResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_aistatis(
        self,
        request: vod_20170321_models.GetAIStatisRequest,
    ) -> vod_20170321_models.GetAIStatisResponse:
        """
        @summary 获取AI统计信息
        
        @param request: GetAIStatisRequest
        @return: GetAIStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_aistatis_with_options(request, runtime)

    async def get_aistatis_async(
        self,
        request: vod_20170321_models.GetAIStatisRequest,
    ) -> vod_20170321_models.GetAIStatisResponse:
        """
        @summary 获取AI统计信息
        
        @param request: GetAIStatisRequest
        @return: GetAIStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_aistatis_with_options_async(request, runtime)

    def get_aitemplate_with_options(
        self,
        request: vod_20170321_models.GetAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAITemplateResponse:
        """
        @summary Queries the details of an AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        Before you call this operation to query details of an AI template, you must obtain the ID of the AI template.
        
        @param request: GetAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAITemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_aitemplate_with_options_async(
        self,
        request: vod_20170321_models.GetAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAITemplateResponse:
        """
        @summary Queries the details of an AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        Before you call this operation to query details of an AI template, you must obtain the ID of the AI template.
        
        @param request: GetAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAITemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_aitemplate(
        self,
        request: vod_20170321_models.GetAITemplateRequest,
    ) -> vod_20170321_models.GetAITemplateResponse:
        """
        @summary Queries the details of an AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        Before you call this operation to query details of an AI template, you must obtain the ID of the AI template.
        
        @param request: GetAITemplateRequest
        @return: GetAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_aitemplate_with_options(request, runtime)

    async def get_aitemplate_async(
        self,
        request: vod_20170321_models.GetAITemplateRequest,
    ) -> vod_20170321_models.GetAITemplateResponse:
        """
        @summary Queries the details of an AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        Before you call this operation to query details of an AI template, you must obtain the ID of the AI template.
        
        @param request: GetAITemplateRequest
        @return: GetAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_aitemplate_with_options_async(request, runtime)

    def get_aivideo_tag_result_with_options(
        self,
        request: vod_20170321_models.GetAIVideoTagResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAIVideoTagResultResponse:
        """
        @summary Queries the results of smart tagging jobs.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can obtain the smart tagging results by using the video ID.
        
        @param request: GetAIVideoTagResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAIVideoTagResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAIVideoTagResult',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAIVideoTagResultResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_aivideo_tag_result_with_options_async(
        self,
        request: vod_20170321_models.GetAIVideoTagResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAIVideoTagResultResponse:
        """
        @summary Queries the results of smart tagging jobs.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can obtain the smart tagging results by using the video ID.
        
        @param request: GetAIVideoTagResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAIVideoTagResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAIVideoTagResult',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAIVideoTagResultResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_aivideo_tag_result(
        self,
        request: vod_20170321_models.GetAIVideoTagResultRequest,
    ) -> vod_20170321_models.GetAIVideoTagResultResponse:
        """
        @summary Queries the results of smart tagging jobs.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can obtain the smart tagging results by using the video ID.
        
        @param request: GetAIVideoTagResultRequest
        @return: GetAIVideoTagResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_aivideo_tag_result_with_options(request, runtime)

    async def get_aivideo_tag_result_async(
        self,
        request: vod_20170321_models.GetAIVideoTagResultRequest,
    ) -> vod_20170321_models.GetAIVideoTagResultResponse:
        """
        @summary Queries the results of smart tagging jobs.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can obtain the smart tagging results by using the video ID.
        
        @param request: GetAIVideoTagResultRequest
        @return: GetAIVideoTagResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_aivideo_tag_result_with_options_async(request, runtime)

    def get_app_infos_with_options(
        self,
        request: vod_20170321_models.GetAppInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAppInfosResponse:
        """
        @summary Queries the information about one or more applications based on application IDs.
        
        @description You can specify multiple accelerated domain names in a request.
        
        @param request: GetAppInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAppInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_ids):
            query['AppIds'] = request.app_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAppInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAppInfosResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_app_infos_with_options_async(
        self,
        request: vod_20170321_models.GetAppInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAppInfosResponse:
        """
        @summary Queries the information about one or more applications based on application IDs.
        
        @description You can specify multiple accelerated domain names in a request.
        
        @param request: GetAppInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAppInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_ids):
            query['AppIds'] = request.app_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAppInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAppInfosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_app_infos(
        self,
        request: vod_20170321_models.GetAppInfosRequest,
    ) -> vod_20170321_models.GetAppInfosResponse:
        """
        @summary Queries the information about one or more applications based on application IDs.
        
        @description You can specify multiple accelerated domain names in a request.
        
        @param request: GetAppInfosRequest
        @return: GetAppInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_app_infos_with_options(request, runtime)

    async def get_app_infos_async(
        self,
        request: vod_20170321_models.GetAppInfosRequest,
    ) -> vod_20170321_models.GetAppInfosResponse:
        """
        @summary Queries the information about one or more applications based on application IDs.
        
        @description You can specify multiple accelerated domain names in a request.
        
        @param request: GetAppInfosRequest
        @return: GetAppInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_app_infos_with_options_async(request, runtime)

    def get_app_policies_with_options(
        self,
        request: vod_20170321_models.GetAppPoliciesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAppPoliciesResponse:
        """
        @summary 获取App策略
        
        @param request: GetAppPoliciesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAppPoliciesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy_names):
            query['PolicyNames'] = request.policy_names
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAppPolicies',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAppPoliciesResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_app_policies_with_options_async(
        self,
        request: vod_20170321_models.GetAppPoliciesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAppPoliciesResponse:
        """
        @summary 获取App策略
        
        @param request: GetAppPoliciesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAppPoliciesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy_names):
            query['PolicyNames'] = request.policy_names
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAppPolicies',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAppPoliciesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_app_policies(
        self,
        request: vod_20170321_models.GetAppPoliciesRequest,
    ) -> vod_20170321_models.GetAppPoliciesResponse:
        """
        @summary 获取App策略
        
        @param request: GetAppPoliciesRequest
        @return: GetAppPoliciesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_app_policies_with_options(request, runtime)

    async def get_app_policies_async(
        self,
        request: vod_20170321_models.GetAppPoliciesRequest,
    ) -> vod_20170321_models.GetAppPoliciesResponse:
        """
        @summary 获取App策略
        
        @param request: GetAppPoliciesRequest
        @return: GetAppPoliciesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_app_policies_with_options_async(request, runtime)

    def get_attached_media_info_with_options(
        self,
        request: vod_20170321_models.GetAttachedMediaInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAttachedMediaInfoResponse:
        """
        @summary Queries the URL and basic information about one or more auxiliary media assets such as watermark images, subtitle files, and materials based on IDs.
        
        @description You can query information about up to 20 auxiliary media assets in a request.
        
        @param request: GetAttachedMediaInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAttachedMediaInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_timeout):
            query['AuthTimeout'] = request.auth_timeout
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        if not UtilClient.is_unset(request.output_type):
            query['OutputType'] = request.output_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAttachedMediaInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAttachedMediaInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_attached_media_info_with_options_async(
        self,
        request: vod_20170321_models.GetAttachedMediaInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAttachedMediaInfoResponse:
        """
        @summary Queries the URL and basic information about one or more auxiliary media assets such as watermark images, subtitle files, and materials based on IDs.
        
        @description You can query information about up to 20 auxiliary media assets in a request.
        
        @param request: GetAttachedMediaInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAttachedMediaInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_timeout):
            query['AuthTimeout'] = request.auth_timeout
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        if not UtilClient.is_unset(request.output_type):
            query['OutputType'] = request.output_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAttachedMediaInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAttachedMediaInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_attached_media_info(
        self,
        request: vod_20170321_models.GetAttachedMediaInfoRequest,
    ) -> vod_20170321_models.GetAttachedMediaInfoResponse:
        """
        @summary Queries the URL and basic information about one or more auxiliary media assets such as watermark images, subtitle files, and materials based on IDs.
        
        @description You can query information about up to 20 auxiliary media assets in a request.
        
        @param request: GetAttachedMediaInfoRequest
        @return: GetAttachedMediaInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_attached_media_info_with_options(request, runtime)

    async def get_attached_media_info_async(
        self,
        request: vod_20170321_models.GetAttachedMediaInfoRequest,
    ) -> vod_20170321_models.GetAttachedMediaInfoResponse:
        """
        @summary Queries the URL and basic information about one or more auxiliary media assets such as watermark images, subtitle files, and materials based on IDs.
        
        @description You can query information about up to 20 auxiliary media assets in a request.
        
        @param request: GetAttachedMediaInfoRequest
        @return: GetAttachedMediaInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_attached_media_info_with_options_async(request, runtime)

    def get_audit_history_with_options(
        self,
        request: vod_20170321_models.GetAuditHistoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAuditHistoryResponse:
        """
        @summary Queries the manual review history.
        
        @param request: GetAuditHistoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAuditHistoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAuditHistory',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAuditHistoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_audit_history_with_options_async(
        self,
        request: vod_20170321_models.GetAuditHistoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAuditHistoryResponse:
        """
        @summary Queries the manual review history.
        
        @param request: GetAuditHistoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAuditHistoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAuditHistory',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAuditHistoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_audit_history(
        self,
        request: vod_20170321_models.GetAuditHistoryRequest,
    ) -> vod_20170321_models.GetAuditHistoryResponse:
        """
        @summary Queries the manual review history.
        
        @param request: GetAuditHistoryRequest
        @return: GetAuditHistoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_audit_history_with_options(request, runtime)

    async def get_audit_history_async(
        self,
        request: vod_20170321_models.GetAuditHistoryRequest,
    ) -> vod_20170321_models.GetAuditHistoryResponse:
        """
        @summary Queries the manual review history.
        
        @param request: GetAuditHistoryRequest
        @return: GetAuditHistoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_audit_history_with_options_async(request, runtime)

    def get_audit_result_with_options(
        self,
        request: vod_20170321_models.GetAuditResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAuditResultResponse:
        """
        @summary 获取审核结果
        
        @param request: GetAuditResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAuditResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAuditResult',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAuditResultResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_audit_result_with_options_async(
        self,
        request: vod_20170321_models.GetAuditResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAuditResultResponse:
        """
        @summary 获取审核结果
        
        @param request: GetAuditResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAuditResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAuditResult',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAuditResultResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_audit_result(
        self,
        request: vod_20170321_models.GetAuditResultRequest,
    ) -> vod_20170321_models.GetAuditResultResponse:
        """
        @summary 获取审核结果
        
        @param request: GetAuditResultRequest
        @return: GetAuditResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_audit_result_with_options(request, runtime)

    async def get_audit_result_async(
        self,
        request: vod_20170321_models.GetAuditResultRequest,
    ) -> vod_20170321_models.GetAuditResultResponse:
        """
        @summary 获取审核结果
        
        @param request: GetAuditResultRequest
        @return: GetAuditResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_audit_result_with_options_async(request, runtime)

    def get_audit_result_detail_with_options(
        self,
        request: vod_20170321_models.GetAuditResultDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAuditResultDetailResponse:
        """
        @summary 获取审核结果详情
        
        @param request: GetAuditResultDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAuditResultDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAuditResultDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAuditResultDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_audit_result_detail_with_options_async(
        self,
        request: vod_20170321_models.GetAuditResultDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetAuditResultDetailResponse:
        """
        @summary 获取审核结果详情
        
        @param request: GetAuditResultDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAuditResultDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAuditResultDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetAuditResultDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_audit_result_detail(
        self,
        request: vod_20170321_models.GetAuditResultDetailRequest,
    ) -> vod_20170321_models.GetAuditResultDetailResponse:
        """
        @summary 获取审核结果详情
        
        @param request: GetAuditResultDetailRequest
        @return: GetAuditResultDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_audit_result_detail_with_options(request, runtime)

    async def get_audit_result_detail_async(
        self,
        request: vod_20170321_models.GetAuditResultDetailRequest,
    ) -> vod_20170321_models.GetAuditResultDetailResponse:
        """
        @summary 获取审核结果详情
        
        @param request: GetAuditResultDetailRequest
        @return: GetAuditResultDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_audit_result_detail_with_options_async(request, runtime)

    def get_bucket_delete_task_with_options(
        self,
        request: vod_20170321_models.GetBucketDeleteTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetBucketDeleteTaskResponse:
        """
        @summary 查询bucket删除任务信息
        
        @param request: GetBucketDeleteTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetBucketDeleteTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetBucketDeleteTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetBucketDeleteTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_bucket_delete_task_with_options_async(
        self,
        request: vod_20170321_models.GetBucketDeleteTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetBucketDeleteTaskResponse:
        """
        @summary 查询bucket删除任务信息
        
        @param request: GetBucketDeleteTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetBucketDeleteTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetBucketDeleteTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetBucketDeleteTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_bucket_delete_task(
        self,
        request: vod_20170321_models.GetBucketDeleteTaskRequest,
    ) -> vod_20170321_models.GetBucketDeleteTaskResponse:
        """
        @summary 查询bucket删除任务信息
        
        @param request: GetBucketDeleteTaskRequest
        @return: GetBucketDeleteTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_bucket_delete_task_with_options(request, runtime)

    async def get_bucket_delete_task_async(
        self,
        request: vod_20170321_models.GetBucketDeleteTaskRequest,
    ) -> vod_20170321_models.GetBucketDeleteTaskResponse:
        """
        @summary 查询bucket删除任务信息
        
        @param request: GetBucketDeleteTaskRequest
        @return: GetBucketDeleteTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_bucket_delete_task_with_options_async(request, runtime)

    def get_cdnstatis_with_options(
        self,
        request: vod_20170321_models.GetCDNStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetCDNStatisResponse:
        """
        @summary 获取CDN统计数据
        
        @param request: GetCDNStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCDNStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCDNStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetCDNStatisResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_cdnstatis_with_options_async(
        self,
        request: vod_20170321_models.GetCDNStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetCDNStatisResponse:
        """
        @summary 获取CDN统计数据
        
        @param request: GetCDNStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCDNStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCDNStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetCDNStatisResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_cdnstatis(
        self,
        request: vod_20170321_models.GetCDNStatisRequest,
    ) -> vod_20170321_models.GetCDNStatisResponse:
        """
        @summary 获取CDN统计数据
        
        @param request: GetCDNStatisRequest
        @return: GetCDNStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_cdnstatis_with_options(request, runtime)

    async def get_cdnstatis_async(
        self,
        request: vod_20170321_models.GetCDNStatisRequest,
    ) -> vod_20170321_models.GetCDNStatisResponse:
        """
        @summary 获取CDN统计数据
        
        @param request: GetCDNStatisRequest
        @return: GetCDNStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_cdnstatis_with_options_async(request, runtime)

    def get_cdnstatis_sum_with_options(
        self,
        request: vod_20170321_models.GetCDNStatisSumRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetCDNStatisSumResponse:
        """
        @summary 获取CDN统计和
        
        @param request: GetCDNStatisSumRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCDNStatisSumResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_statis_time):
            query['EndStatisTime'] = request.end_statis_time
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_statis_time):
            query['StartStatisTime'] = request.start_statis_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCDNStatisSum',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetCDNStatisSumResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_cdnstatis_sum_with_options_async(
        self,
        request: vod_20170321_models.GetCDNStatisSumRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetCDNStatisSumResponse:
        """
        @summary 获取CDN统计和
        
        @param request: GetCDNStatisSumRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCDNStatisSumResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_statis_time):
            query['EndStatisTime'] = request.end_statis_time
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_statis_time):
            query['StartStatisTime'] = request.start_statis_time
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCDNStatisSum',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetCDNStatisSumResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_cdnstatis_sum(
        self,
        request: vod_20170321_models.GetCDNStatisSumRequest,
    ) -> vod_20170321_models.GetCDNStatisSumResponse:
        """
        @summary 获取CDN统计和
        
        @param request: GetCDNStatisSumRequest
        @return: GetCDNStatisSumResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_cdnstatis_sum_with_options(request, runtime)

    async def get_cdnstatis_sum_async(
        self,
        request: vod_20170321_models.GetCDNStatisSumRequest,
    ) -> vod_20170321_models.GetCDNStatisSumResponse:
        """
        @summary 获取CDN统计和
        
        @param request: GetCDNStatisSumRequest
        @return: GetCDNStatisSumResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_cdnstatis_sum_with_options_async(request, runtime)

    def get_categories_with_options(
        self,
        request: vod_20170321_models.GetCategoriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetCategoriesResponse:
        """
        @summary Queries the information about a specific category and its subcategories based on the ID or type of the category.
        
        @param request: GetCategoriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCategoriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCategories',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetCategoriesResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_categories_with_options_async(
        self,
        request: vod_20170321_models.GetCategoriesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetCategoriesResponse:
        """
        @summary Queries the information about a specific category and its subcategories based on the ID or type of the category.
        
        @param request: GetCategoriesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCategoriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCategories',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetCategoriesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_categories(
        self,
        request: vod_20170321_models.GetCategoriesRequest,
    ) -> vod_20170321_models.GetCategoriesResponse:
        """
        @summary Queries the information about a specific category and its subcategories based on the ID or type of the category.
        
        @param request: GetCategoriesRequest
        @return: GetCategoriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_categories_with_options(request, runtime)

    async def get_categories_async(
        self,
        request: vod_20170321_models.GetCategoriesRequest,
    ) -> vod_20170321_models.GetCategoriesResponse:
        """
        @summary Queries the information about a specific category and its subcategories based on the ID or type of the category.
        
        @param request: GetCategoriesRequest
        @return: GetCategoriesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_categories_with_options_async(request, runtime)

    def get_check_channel_with_options(
        self,
        request: vod_20170321_models.GetCheckChannelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetCheckChannelResponse:
        """
        @summary 获取通道
        
        @param request: GetCheckChannelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCheckChannelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCheckChannel',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetCheckChannelResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_check_channel_with_options_async(
        self,
        request: vod_20170321_models.GetCheckChannelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetCheckChannelResponse:
        """
        @summary 获取通道
        
        @param request: GetCheckChannelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCheckChannelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCheckChannel',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetCheckChannelResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_check_channel(
        self,
        request: vod_20170321_models.GetCheckChannelRequest,
    ) -> vod_20170321_models.GetCheckChannelResponse:
        """
        @summary 获取通道
        
        @param request: GetCheckChannelRequest
        @return: GetCheckChannelResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_check_channel_with_options(request, runtime)

    async def get_check_channel_async(
        self,
        request: vod_20170321_models.GetCheckChannelRequest,
    ) -> vod_20170321_models.GetCheckChannelResponse:
        """
        @summary 获取通道
        
        @param request: GetCheckChannelRequest
        @return: GetCheckChannelResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_check_channel_with_options_async(request, runtime)

    def get_client_config_with_options(
        self,
        request: vod_20170321_models.GetClientConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetClientConfigResponse:
        """
        @param request: GetClientConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetClientConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.brand):
            query['Brand'] = request.brand
        if not UtilClient.is_unset(request.device_name):
            query['DeviceName'] = request.device_name
        if not UtilClient.is_unset(request.os_name):
            query['OsName'] = request.os_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetClientConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetClientConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_client_config_with_options_async(
        self,
        request: vod_20170321_models.GetClientConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetClientConfigResponse:
        """
        @param request: GetClientConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetClientConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.brand):
            query['Brand'] = request.brand
        if not UtilClient.is_unset(request.device_name):
            query['DeviceName'] = request.device_name
        if not UtilClient.is_unset(request.os_name):
            query['OsName'] = request.os_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetClientConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetClientConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_client_config(
        self,
        request: vod_20170321_models.GetClientConfigRequest,
    ) -> vod_20170321_models.GetClientConfigResponse:
        """
        @param request: GetClientConfigRequest
        @return: GetClientConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_client_config_with_options(request, runtime)

    async def get_client_config_async(
        self,
        request: vod_20170321_models.GetClientConfigRequest,
    ) -> vod_20170321_models.GetClientConfigResponse:
        """
        @param request: GetClientConfigRequest
        @return: GetClientConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_client_config_with_options_async(request, runtime)

    def get_customer_config_with_options(
        self,
        request: vod_20170321_models.GetCustomerConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetCustomerConfigResponse:
        """
        @summary 获取用户配置
        
        @param request: GetCustomerConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCustomerConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCustomerConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetCustomerConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_customer_config_with_options_async(
        self,
        request: vod_20170321_models.GetCustomerConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetCustomerConfigResponse:
        """
        @summary 获取用户配置
        
        @param request: GetCustomerConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCustomerConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCustomerConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetCustomerConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_customer_config(
        self,
        request: vod_20170321_models.GetCustomerConfigRequest,
    ) -> vod_20170321_models.GetCustomerConfigResponse:
        """
        @summary 获取用户配置
        
        @param request: GetCustomerConfigRequest
        @return: GetCustomerConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_customer_config_with_options(request, runtime)

    async def get_customer_config_async(
        self,
        request: vod_20170321_models.GetCustomerConfigRequest,
    ) -> vod_20170321_models.GetCustomerConfigResponse:
        """
        @summary 获取用户配置
        
        @param request: GetCustomerConfigRequest
        @return: GetCustomerConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_customer_config_with_options_async(request, runtime)

    def get_dnadbwith_options(
        self,
        request: vod_20170321_models.GetDNADBRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDNADBResponse:
        """
        @summary 获取DNADB
        
        @param request: GetDNADBRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDNADBResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dbid):
            query['DBId'] = request.dbid
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDNADB',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDNADBResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_dnadbwith_options_async(
        self,
        request: vod_20170321_models.GetDNADBRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDNADBResponse:
        """
        @summary 获取DNADB
        
        @param request: GetDNADBRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDNADBResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dbid):
            query['DBId'] = request.dbid
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDNADB',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDNADBResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_dnadb(
        self,
        request: vod_20170321_models.GetDNADBRequest,
    ) -> vod_20170321_models.GetDNADBResponse:
        """
        @summary 获取DNADB
        
        @param request: GetDNADBRequest
        @return: GetDNADBResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_dnadbwith_options(request, runtime)

    async def get_dnadb_async(
        self,
        request: vod_20170321_models.GetDNADBRequest,
    ) -> vod_20170321_models.GetDNADBResponse:
        """
        @summary 获取DNADB
        
        @param request: GetDNADBRequest
        @return: GetDNADBResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_dnadbwith_options_async(request, runtime)

    def get_drmcert_info_with_options(
        self,
        request: vod_20170321_models.GetDRMCertInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDRMCertInfoResponse:
        """
        @summary 获取DRM证书信息
        
        @param request: GetDRMCertInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDRMCertInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_id):
            query['CertId'] = request.cert_id
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDRMCertInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDRMCertInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_drmcert_info_with_options_async(
        self,
        request: vod_20170321_models.GetDRMCertInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDRMCertInfoResponse:
        """
        @summary 获取DRM证书信息
        
        @param request: GetDRMCertInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDRMCertInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_id):
            query['CertId'] = request.cert_id
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDRMCertInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDRMCertInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_drmcert_info(
        self,
        request: vod_20170321_models.GetDRMCertInfoRequest,
    ) -> vod_20170321_models.GetDRMCertInfoResponse:
        """
        @summary 获取DRM证书信息
        
        @param request: GetDRMCertInfoRequest
        @return: GetDRMCertInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_drmcert_info_with_options(request, runtime)

    async def get_drmcert_info_async(
        self,
        request: vod_20170321_models.GetDRMCertInfoRequest,
    ) -> vod_20170321_models.GetDRMCertInfoResponse:
        """
        @summary 获取DRM证书信息
        
        @param request: GetDRMCertInfoRequest
        @return: GetDRMCertInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_drmcert_info_with_options_async(request, runtime)

    def get_drmlicense_with_options(
        self,
        request: vod_20170321_models.GetDRMLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDRMLicenseResponse:
        """
        @summary 获取DRM证书
        
        @param request: GetDRMLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDRMLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cdmdata):
            query['CDMData'] = request.cdmdata
        if not UtilClient.is_unset(request.cert_id):
            query['CertId'] = request.cert_id
        if not UtilClient.is_unset(request.drmtype):
            query['DRMType'] = request.drmtype
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDRMLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDRMLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_drmlicense_with_options_async(
        self,
        request: vod_20170321_models.GetDRMLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDRMLicenseResponse:
        """
        @summary 获取DRM证书
        
        @param request: GetDRMLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDRMLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cdmdata):
            query['CDMData'] = request.cdmdata
        if not UtilClient.is_unset(request.cert_id):
            query['CertId'] = request.cert_id
        if not UtilClient.is_unset(request.drmtype):
            query['DRMType'] = request.drmtype
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDRMLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDRMLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_drmlicense(
        self,
        request: vod_20170321_models.GetDRMLicenseRequest,
    ) -> vod_20170321_models.GetDRMLicenseResponse:
        """
        @summary 获取DRM证书
        
        @param request: GetDRMLicenseRequest
        @return: GetDRMLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_drmlicense_with_options(request, runtime)

    async def get_drmlicense_async(
        self,
        request: vod_20170321_models.GetDRMLicenseRequest,
    ) -> vod_20170321_models.GetDRMLicenseResponse:
        """
        @summary 获取DRM证书
        
        @param request: GetDRMLicenseRequest
        @return: GetDRMLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_drmlicense_with_options_async(request, runtime)

    def get_daily_play_region_statis_with_options(
        self,
        request: vod_20170321_models.GetDailyPlayRegionStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDailyPlayRegionStatisResponse:
        """
        @summary 支持区域化媒资ID级别播放数据查询
        
        @param request: GetDailyPlayRegionStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDailyPlayRegionStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.date):
            query['Date'] = request.date
        if not UtilClient.is_unset(request.media_region):
            query['MediaRegion'] = request.media_region
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDailyPlayRegionStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDailyPlayRegionStatisResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_daily_play_region_statis_with_options_async(
        self,
        request: vod_20170321_models.GetDailyPlayRegionStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDailyPlayRegionStatisResponse:
        """
        @summary 支持区域化媒资ID级别播放数据查询
        
        @param request: GetDailyPlayRegionStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDailyPlayRegionStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.date):
            query['Date'] = request.date
        if not UtilClient.is_unset(request.media_region):
            query['MediaRegion'] = request.media_region
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDailyPlayRegionStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDailyPlayRegionStatisResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_daily_play_region_statis(
        self,
        request: vod_20170321_models.GetDailyPlayRegionStatisRequest,
    ) -> vod_20170321_models.GetDailyPlayRegionStatisResponse:
        """
        @summary 支持区域化媒资ID级别播放数据查询
        
        @param request: GetDailyPlayRegionStatisRequest
        @return: GetDailyPlayRegionStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_daily_play_region_statis_with_options(request, runtime)

    async def get_daily_play_region_statis_async(
        self,
        request: vod_20170321_models.GetDailyPlayRegionStatisRequest,
    ) -> vod_20170321_models.GetDailyPlayRegionStatisResponse:
        """
        @summary 支持区域化媒资ID级别播放数据查询
        
        @param request: GetDailyPlayRegionStatisRequest
        @return: GetDailyPlayRegionStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_daily_play_region_statis_with_options_async(request, runtime)

    def get_daily_play_statis_with_options(
        self,
        request: vod_20170321_models.GetDailyPlayStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDailyPlayStatisResponse:
        """
        @summary 支持媒资ID级别播放数据查询
        
        @param request: GetDailyPlayStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDailyPlayStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_date):
            query['EndDate'] = request.end_date
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.media_region):
            query['MediaRegion'] = request.media_region
        if not UtilClient.is_unset(request.start_date):
            query['StartDate'] = request.start_date
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDailyPlayStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDailyPlayStatisResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_daily_play_statis_with_options_async(
        self,
        request: vod_20170321_models.GetDailyPlayStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDailyPlayStatisResponse:
        """
        @summary 支持媒资ID级别播放数据查询
        
        @param request: GetDailyPlayStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDailyPlayStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_date):
            query['EndDate'] = request.end_date
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.media_region):
            query['MediaRegion'] = request.media_region
        if not UtilClient.is_unset(request.start_date):
            query['StartDate'] = request.start_date
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDailyPlayStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDailyPlayStatisResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_daily_play_statis(
        self,
        request: vod_20170321_models.GetDailyPlayStatisRequest,
    ) -> vod_20170321_models.GetDailyPlayStatisResponse:
        """
        @summary 支持媒资ID级别播放数据查询
        
        @param request: GetDailyPlayStatisRequest
        @return: GetDailyPlayStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_daily_play_statis_with_options(request, runtime)

    async def get_daily_play_statis_async(
        self,
        request: vod_20170321_models.GetDailyPlayStatisRequest,
    ) -> vod_20170321_models.GetDailyPlayStatisResponse:
        """
        @summary 支持媒资ID级别播放数据查询
        
        @param request: GetDailyPlayStatisRequest
        @return: GetDailyPlayStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_daily_play_statis_with_options_async(request, runtime)

    def get_default_aitemplate_with_options(
        self,
        request: vod_20170321_models.GetDefaultAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDefaultAITemplateResponse:
        """
        @summary Queries information about the default AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can query information only about the default AI template for automated review.
        
        @param request: GetDefaultAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDefaultAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDefaultAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDefaultAITemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_default_aitemplate_with_options_async(
        self,
        request: vod_20170321_models.GetDefaultAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDefaultAITemplateResponse:
        """
        @summary Queries information about the default AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can query information only about the default AI template for automated review.
        
        @param request: GetDefaultAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDefaultAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDefaultAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDefaultAITemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_default_aitemplate(
        self,
        request: vod_20170321_models.GetDefaultAITemplateRequest,
    ) -> vod_20170321_models.GetDefaultAITemplateResponse:
        """
        @summary Queries information about the default AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can query information only about the default AI template for automated review.
        
        @param request: GetDefaultAITemplateRequest
        @return: GetDefaultAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_default_aitemplate_with_options(request, runtime)

    async def get_default_aitemplate_async(
        self,
        request: vod_20170321_models.GetDefaultAITemplateRequest,
    ) -> vod_20170321_models.GetDefaultAITemplateResponse:
        """
        @summary Queries information about the default AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can query information only about the default AI template for automated review.
        
        @param request: GetDefaultAITemplateRequest
        @return: GetDefaultAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_default_aitemplate_with_options_async(request, runtime)

    def get_digital_watermark_extract_result_with_options(
        self,
        request: vod_20170321_models.GetDigitalWatermarkExtractResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDigitalWatermarkExtractResultResponse:
        """
        @summary Queries the results of a digital watermark extraction job. You can call this operation to obtain information such as the job status and the content of the copyright or user-tracing watermark.
        
        @description    This operation is supported only in the China (Shanghai) and China (Beijing) regions.
        You can call this operation to query the watermark content after you call the [SubmitDigitalWatermarkExtractJob](~~SubmitDigitalWatermarkExtractJob~~) operation to extract the copyright or user-tracing watermark in a video.
        You can query watermark content extracted only from watermark extraction jobs that are submitted in the last 2 years.
        
        @param request: GetDigitalWatermarkExtractResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDigitalWatermarkExtractResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.extract_type):
            query['ExtractType'] = request.extract_type
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDigitalWatermarkExtractResult',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDigitalWatermarkExtractResultResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_digital_watermark_extract_result_with_options_async(
        self,
        request: vod_20170321_models.GetDigitalWatermarkExtractResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetDigitalWatermarkExtractResultResponse:
        """
        @summary Queries the results of a digital watermark extraction job. You can call this operation to obtain information such as the job status and the content of the copyright or user-tracing watermark.
        
        @description    This operation is supported only in the China (Shanghai) and China (Beijing) regions.
        You can call this operation to query the watermark content after you call the [SubmitDigitalWatermarkExtractJob](~~SubmitDigitalWatermarkExtractJob~~) operation to extract the copyright or user-tracing watermark in a video.
        You can query watermark content extracted only from watermark extraction jobs that are submitted in the last 2 years.
        
        @param request: GetDigitalWatermarkExtractResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDigitalWatermarkExtractResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.extract_type):
            query['ExtractType'] = request.extract_type
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDigitalWatermarkExtractResult',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetDigitalWatermarkExtractResultResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_digital_watermark_extract_result(
        self,
        request: vod_20170321_models.GetDigitalWatermarkExtractResultRequest,
    ) -> vod_20170321_models.GetDigitalWatermarkExtractResultResponse:
        """
        @summary Queries the results of a digital watermark extraction job. You can call this operation to obtain information such as the job status and the content of the copyright or user-tracing watermark.
        
        @description    This operation is supported only in the China (Shanghai) and China (Beijing) regions.
        You can call this operation to query the watermark content after you call the [SubmitDigitalWatermarkExtractJob](~~SubmitDigitalWatermarkExtractJob~~) operation to extract the copyright or user-tracing watermark in a video.
        You can query watermark content extracted only from watermark extraction jobs that are submitted in the last 2 years.
        
        @param request: GetDigitalWatermarkExtractResultRequest
        @return: GetDigitalWatermarkExtractResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_digital_watermark_extract_result_with_options(request, runtime)

    async def get_digital_watermark_extract_result_async(
        self,
        request: vod_20170321_models.GetDigitalWatermarkExtractResultRequest,
    ) -> vod_20170321_models.GetDigitalWatermarkExtractResultResponse:
        """
        @summary Queries the results of a digital watermark extraction job. You can call this operation to obtain information such as the job status and the content of the copyright or user-tracing watermark.
        
        @description    This operation is supported only in the China (Shanghai) and China (Beijing) regions.
        You can call this operation to query the watermark content after you call the [SubmitDigitalWatermarkExtractJob](~~SubmitDigitalWatermarkExtractJob~~) operation to extract the copyright or user-tracing watermark in a video.
        You can query watermark content extracted only from watermark extraction jobs that are submitted in the last 2 years.
        
        @param request: GetDigitalWatermarkExtractResultRequest
        @return: GetDigitalWatermarkExtractResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_digital_watermark_extract_result_with_options_async(request, runtime)

    def get_editing_project_with_options(
        self,
        request: vod_20170321_models.GetEditingProjectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetEditingProjectResponse:
        """
        @summary 获取剪辑工程
        
        @param request: GetEditingProjectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEditingProjectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEditingProject',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetEditingProjectResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_editing_project_with_options_async(
        self,
        request: vod_20170321_models.GetEditingProjectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetEditingProjectResponse:
        """
        @summary 获取剪辑工程
        
        @param request: GetEditingProjectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEditingProjectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEditingProject',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetEditingProjectResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_editing_project(
        self,
        request: vod_20170321_models.GetEditingProjectRequest,
    ) -> vod_20170321_models.GetEditingProjectResponse:
        """
        @summary 获取剪辑工程
        
        @param request: GetEditingProjectRequest
        @return: GetEditingProjectResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_editing_project_with_options(request, runtime)

    async def get_editing_project_async(
        self,
        request: vod_20170321_models.GetEditingProjectRequest,
    ) -> vod_20170321_models.GetEditingProjectResponse:
        """
        @summary 获取剪辑工程
        
        @param request: GetEditingProjectRequest
        @return: GetEditingProjectResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_editing_project_with_options_async(request, runtime)

    def get_editing_project_materials_with_options(
        self,
        request: vod_20170321_models.GetEditingProjectMaterialsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetEditingProjectMaterialsResponse:
        """
        @summary Queries materials to be edited for an online editing project.
        
        @description During editing, you can add materials to the timeline, but some of them may not be used.
        
        @param request: GetEditingProjectMaterialsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEditingProjectMaterialsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.material_type):
            query['MaterialType'] = request.material_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEditingProjectMaterials',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetEditingProjectMaterialsResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_editing_project_materials_with_options_async(
        self,
        request: vod_20170321_models.GetEditingProjectMaterialsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetEditingProjectMaterialsResponse:
        """
        @summary Queries materials to be edited for an online editing project.
        
        @description During editing, you can add materials to the timeline, but some of them may not be used.
        
        @param request: GetEditingProjectMaterialsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEditingProjectMaterialsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.material_type):
            query['MaterialType'] = request.material_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEditingProjectMaterials',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetEditingProjectMaterialsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_editing_project_materials(
        self,
        request: vod_20170321_models.GetEditingProjectMaterialsRequest,
    ) -> vod_20170321_models.GetEditingProjectMaterialsResponse:
        """
        @summary Queries materials to be edited for an online editing project.
        
        @description During editing, you can add materials to the timeline, but some of them may not be used.
        
        @param request: GetEditingProjectMaterialsRequest
        @return: GetEditingProjectMaterialsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_editing_project_materials_with_options(request, runtime)

    async def get_editing_project_materials_async(
        self,
        request: vod_20170321_models.GetEditingProjectMaterialsRequest,
    ) -> vod_20170321_models.GetEditingProjectMaterialsResponse:
        """
        @summary Queries materials to be edited for an online editing project.
        
        @description During editing, you can add materials to the timeline, but some of them may not be used.
        
        @param request: GetEditingProjectMaterialsRequest
        @return: GetEditingProjectMaterialsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_editing_project_materials_with_options_async(request, runtime)

    def get_image_info_with_options(
        self,
        request: vod_20170321_models.GetImageInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetImageInfoResponse:
        """
        @summary Queries the basic information and access URL of an image based on the image ID.
        
        @param request: GetImageInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetImageInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_timeout):
            query['AuthTimeout'] = request.auth_timeout
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.output_type):
            query['OutputType'] = request.output_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetImageInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetImageInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_image_info_with_options_async(
        self,
        request: vod_20170321_models.GetImageInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetImageInfoResponse:
        """
        @summary Queries the basic information and access URL of an image based on the image ID.
        
        @param request: GetImageInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetImageInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_timeout):
            query['AuthTimeout'] = request.auth_timeout
        if not UtilClient.is_unset(request.image_id):
            query['ImageId'] = request.image_id
        if not UtilClient.is_unset(request.output_type):
            query['OutputType'] = request.output_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetImageInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetImageInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_image_info(
        self,
        request: vod_20170321_models.GetImageInfoRequest,
    ) -> vod_20170321_models.GetImageInfoResponse:
        """
        @summary Queries the basic information and access URL of an image based on the image ID.
        
        @param request: GetImageInfoRequest
        @return: GetImageInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_image_info_with_options(request, runtime)

    async def get_image_info_async(
        self,
        request: vod_20170321_models.GetImageInfoRequest,
    ) -> vod_20170321_models.GetImageInfoResponse:
        """
        @summary Queries the basic information and access URL of an image based on the image ID.
        
        @param request: GetImageInfoRequest
        @return: GetImageInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_image_info_with_options_async(request, runtime)

    def get_image_infos_with_options(
        self,
        request: vod_20170321_models.GetImageInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetImageInfosResponse:
        """
        @summary Queries the basic information about multiple images at a time.
        
        @description    You can call the [CreateUploadImage](~~CreateUploadImage~~) operation to upload images to ApsaraVideo VOD and call this operation to query the basic information about multiple images at a time.
        To query information about video snapshots, call the [ListSnapshots](~~ListSnapshots~~) operation.
        You can specify up to 20 image IDs in one call.
        
        @param request: GetImageInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetImageInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_timeout):
            query['AuthTimeout'] = request.auth_timeout
        if not UtilClient.is_unset(request.image_ids):
            query['ImageIds'] = request.image_ids
        if not UtilClient.is_unset(request.output_type):
            query['OutputType'] = request.output_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetImageInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetImageInfosResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_image_infos_with_options_async(
        self,
        request: vod_20170321_models.GetImageInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetImageInfosResponse:
        """
        @summary Queries the basic information about multiple images at a time.
        
        @description    You can call the [CreateUploadImage](~~CreateUploadImage~~) operation to upload images to ApsaraVideo VOD and call this operation to query the basic information about multiple images at a time.
        To query information about video snapshots, call the [ListSnapshots](~~ListSnapshots~~) operation.
        You can specify up to 20 image IDs in one call.
        
        @param request: GetImageInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetImageInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_timeout):
            query['AuthTimeout'] = request.auth_timeout
        if not UtilClient.is_unset(request.image_ids):
            query['ImageIds'] = request.image_ids
        if not UtilClient.is_unset(request.output_type):
            query['OutputType'] = request.output_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetImageInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetImageInfosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_image_infos(
        self,
        request: vod_20170321_models.GetImageInfosRequest,
    ) -> vod_20170321_models.GetImageInfosResponse:
        """
        @summary Queries the basic information about multiple images at a time.
        
        @description    You can call the [CreateUploadImage](~~CreateUploadImage~~) operation to upload images to ApsaraVideo VOD and call this operation to query the basic information about multiple images at a time.
        To query information about video snapshots, call the [ListSnapshots](~~ListSnapshots~~) operation.
        You can specify up to 20 image IDs in one call.
        
        @param request: GetImageInfosRequest
        @return: GetImageInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_image_infos_with_options(request, runtime)

    async def get_image_infos_async(
        self,
        request: vod_20170321_models.GetImageInfosRequest,
    ) -> vod_20170321_models.GetImageInfosResponse:
        """
        @summary Queries the basic information about multiple images at a time.
        
        @description    You can call the [CreateUploadImage](~~CreateUploadImage~~) operation to upload images to ApsaraVideo VOD and call this operation to query the basic information about multiple images at a time.
        To query information about video snapshots, call the [ListSnapshots](~~ListSnapshots~~) operation.
        You can specify up to 20 image IDs in one call.
        
        @param request: GetImageInfosRequest
        @return: GetImageInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_image_infos_with_options_async(request, runtime)

    def get_intelligent_strategy_with_options(
        self,
        request: vod_20170321_models.GetIntelligentStrategyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetIntelligentStrategyResponse:
        """
        @summary 获取单个智能策略信息
        
        @param request: GetIntelligentStrategyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIntelligentStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.strategy_id):
            query['StrategyId'] = request.strategy_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIntelligentStrategy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetIntelligentStrategyResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_intelligent_strategy_with_options_async(
        self,
        request: vod_20170321_models.GetIntelligentStrategyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetIntelligentStrategyResponse:
        """
        @summary 获取单个智能策略信息
        
        @param request: GetIntelligentStrategyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIntelligentStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.strategy_id):
            query['StrategyId'] = request.strategy_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIntelligentStrategy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetIntelligentStrategyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_intelligent_strategy(
        self,
        request: vod_20170321_models.GetIntelligentStrategyRequest,
    ) -> vod_20170321_models.GetIntelligentStrategyResponse:
        """
        @summary 获取单个智能策略信息
        
        @param request: GetIntelligentStrategyRequest
        @return: GetIntelligentStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_intelligent_strategy_with_options(request, runtime)

    async def get_intelligent_strategy_async(
        self,
        request: vod_20170321_models.GetIntelligentStrategyRequest,
    ) -> vod_20170321_models.GetIntelligentStrategyResponse:
        """
        @summary 获取单个智能策略信息
        
        @param request: GetIntelligentStrategyRequest
        @return: GetIntelligentStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_intelligent_strategy_with_options_async(request, runtime)

    def get_job_detail_with_options(
        self,
        request: vod_20170321_models.GetJobDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetJobDetailResponse:
        """
        @summary Queries the details of an asynchronous task based on jobId.
        
        @description ***\
        You can call this operation to query only asynchronous tasks of the last six months. The types of tasks that you can query include transcoding tasks, snapshot tasks, and AI tasks.
        *QPS limit**\
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: GetJobDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetJobDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.job_type):
            query['JobType'] = request.job_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetJobDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetJobDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_job_detail_with_options_async(
        self,
        request: vod_20170321_models.GetJobDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetJobDetailResponse:
        """
        @summary Queries the details of an asynchronous task based on jobId.
        
        @description ***\
        You can call this operation to query only asynchronous tasks of the last six months. The types of tasks that you can query include transcoding tasks, snapshot tasks, and AI tasks.
        *QPS limit**\
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: GetJobDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetJobDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.job_type):
            query['JobType'] = request.job_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetJobDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetJobDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_job_detail(
        self,
        request: vod_20170321_models.GetJobDetailRequest,
    ) -> vod_20170321_models.GetJobDetailResponse:
        """
        @summary Queries the details of an asynchronous task based on jobId.
        
        @description ***\
        You can call this operation to query only asynchronous tasks of the last six months. The types of tasks that you can query include transcoding tasks, snapshot tasks, and AI tasks.
        *QPS limit**\
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: GetJobDetailRequest
        @return: GetJobDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_job_detail_with_options(request, runtime)

    async def get_job_detail_async(
        self,
        request: vod_20170321_models.GetJobDetailRequest,
    ) -> vod_20170321_models.GetJobDetailResponse:
        """
        @summary Queries the details of an asynchronous task based on jobId.
        
        @description ***\
        You can call this operation to query only asynchronous tasks of the last six months. The types of tasks that you can query include transcoding tasks, snapshot tasks, and AI tasks.
        *QPS limit**\
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: GetJobDetailRequest
        @return: GetJobDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_job_detail_with_options_async(request, runtime)

    def get_kmsservice_key_with_options(
        self,
        request: vod_20170321_models.GetKMSServiceKeyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetKMSServiceKeyResponse:
        """
        @summary GetKMSServiceKey
        
        @param request: GetKMSServiceKeyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetKMSServiceKeyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.kms_region_id):
            query['KmsRegionId'] = request.kms_region_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetKMSServiceKey',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetKMSServiceKeyResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_kmsservice_key_with_options_async(
        self,
        request: vod_20170321_models.GetKMSServiceKeyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetKMSServiceKeyResponse:
        """
        @summary GetKMSServiceKey
        
        @param request: GetKMSServiceKeyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetKMSServiceKeyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.kms_region_id):
            query['KmsRegionId'] = request.kms_region_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetKMSServiceKey',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetKMSServiceKeyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_kmsservice_key(
        self,
        request: vod_20170321_models.GetKMSServiceKeyRequest,
    ) -> vod_20170321_models.GetKMSServiceKeyResponse:
        """
        @summary GetKMSServiceKey
        
        @param request: GetKMSServiceKeyRequest
        @return: GetKMSServiceKeyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_kmsservice_key_with_options(request, runtime)

    async def get_kmsservice_key_async(
        self,
        request: vod_20170321_models.GetKMSServiceKeyRequest,
    ) -> vod_20170321_models.GetKMSServiceKeyResponse:
        """
        @summary GetKMSServiceKey
        
        @param request: GetKMSServiceKeyRequest
        @return: GetKMSServiceKeyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_kmsservice_key_with_options_async(request, runtime)

    def get_license_info_with_options(
        self,
        request: vod_20170321_models.GetLicenseInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetLicenseInfoResponse:
        """
        @summary 获取License证书信息
        
        @param request: GetLicenseInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetLicenseInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.license_id):
            query['LicenseId'] = request.license_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetLicenseInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetLicenseInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_license_info_with_options_async(
        self,
        request: vod_20170321_models.GetLicenseInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetLicenseInfoResponse:
        """
        @summary 获取License证书信息
        
        @param request: GetLicenseInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetLicenseInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.license_id):
            query['LicenseId'] = request.license_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetLicenseInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetLicenseInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_license_info(
        self,
        request: vod_20170321_models.GetLicenseInfoRequest,
    ) -> vod_20170321_models.GetLicenseInfoResponse:
        """
        @summary 获取License证书信息
        
        @param request: GetLicenseInfoRequest
        @return: GetLicenseInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_license_info_with_options(request, runtime)

    async def get_license_info_async(
        self,
        request: vod_20170321_models.GetLicenseInfoRequest,
    ) -> vod_20170321_models.GetLicenseInfoResponse:
        """
        @summary 获取License证书信息
        
        @param request: GetLicenseInfoRequest
        @return: GetLicenseInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_license_info_with_options_async(request, runtime)

    def get_license_key_with_options(
        self,
        request: vod_20170321_models.GetLicenseKeyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetLicenseKeyResponse:
        """
        @summary 获取LicenseKey
        
        @param request: GetLicenseKeyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetLicenseKeyResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.user_id):
            body['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetLicenseKey',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetLicenseKeyResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_license_key_with_options_async(
        self,
        request: vod_20170321_models.GetLicenseKeyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetLicenseKeyResponse:
        """
        @summary 获取LicenseKey
        
        @param request: GetLicenseKeyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetLicenseKeyResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.user_id):
            body['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetLicenseKey',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetLicenseKeyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_license_key(
        self,
        request: vod_20170321_models.GetLicenseKeyRequest,
    ) -> vod_20170321_models.GetLicenseKeyResponse:
        """
        @summary 获取LicenseKey
        
        @param request: GetLicenseKeyRequest
        @return: GetLicenseKeyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_license_key_with_options(request, runtime)

    async def get_license_key_async(
        self,
        request: vod_20170321_models.GetLicenseKeyRequest,
    ) -> vod_20170321_models.GetLicenseKeyResponse:
        """
        @summary 获取LicenseKey
        
        @param request: GetLicenseKeyRequest
        @return: GetLicenseKeyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_license_key_with_options_async(request, runtime)

    def get_license_purchase_status_with_options(
        self,
        request: vod_20170321_models.GetLicensePurchaseStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetLicensePurchaseStatusResponse:
        """
        @summary 获取License支付状态
        
        @param request: GetLicensePurchaseStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetLicensePurchaseStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.license_item_ids):
            query['LicenseItemIds'] = request.license_item_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetLicensePurchaseStatus',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetLicensePurchaseStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_license_purchase_status_with_options_async(
        self,
        request: vod_20170321_models.GetLicensePurchaseStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetLicensePurchaseStatusResponse:
        """
        @summary 获取License支付状态
        
        @param request: GetLicensePurchaseStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetLicensePurchaseStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.license_item_ids):
            query['LicenseItemIds'] = request.license_item_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetLicensePurchaseStatus',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetLicensePurchaseStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_license_purchase_status(
        self,
        request: vod_20170321_models.GetLicensePurchaseStatusRequest,
    ) -> vod_20170321_models.GetLicensePurchaseStatusResponse:
        """
        @summary 获取License支付状态
        
        @param request: GetLicensePurchaseStatusRequest
        @return: GetLicensePurchaseStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_license_purchase_status_with_options(request, runtime)

    async def get_license_purchase_status_async(
        self,
        request: vod_20170321_models.GetLicensePurchaseStatusRequest,
    ) -> vod_20170321_models.GetLicensePurchaseStatusResponse:
        """
        @summary 获取License支付状态
        
        @param request: GetLicensePurchaseStatusRequest
        @return: GetLicensePurchaseStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_license_purchase_status_with_options_async(request, runtime)

    def get_licenses_with_options(
        self,
        request: vod_20170321_models.GetLicensesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetLicensesResponse:
        """
        @summary 查询license列表
        
        @param request: GetLicensesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetLicensesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        body = {}
        if not UtilClient.is_unset(request.app_name):
            body['AppName'] = request.app_name
        if not UtilClient.is_unset(request.business_type):
            body['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.need_total_count):
            body['NeedTotalCount'] = request.need_total_count
        if not UtilClient.is_unset(request.offset):
            body['Offset'] = request.offset
        if not UtilClient.is_unset(request.page_no):
            body['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.pkg_name):
            body['PkgName'] = request.pkg_name
        if not UtilClient.is_unset(request.platform_type):
            body['PlatformType'] = request.platform_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetLicenses',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetLicensesResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_licenses_with_options_async(
        self,
        request: vod_20170321_models.GetLicensesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetLicensesResponse:
        """
        @summary 查询license列表
        
        @param request: GetLicensesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetLicensesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        body = {}
        if not UtilClient.is_unset(request.app_name):
            body['AppName'] = request.app_name
        if not UtilClient.is_unset(request.business_type):
            body['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.need_total_count):
            body['NeedTotalCount'] = request.need_total_count
        if not UtilClient.is_unset(request.offset):
            body['Offset'] = request.offset
        if not UtilClient.is_unset(request.page_no):
            body['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.pkg_name):
            body['PkgName'] = request.pkg_name
        if not UtilClient.is_unset(request.platform_type):
            body['PlatformType'] = request.platform_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetLicenses',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetLicensesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_licenses(
        self,
        request: vod_20170321_models.GetLicensesRequest,
    ) -> vod_20170321_models.GetLicensesResponse:
        """
        @summary 查询license列表
        
        @param request: GetLicensesRequest
        @return: GetLicensesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_licenses_with_options(request, runtime)

    async def get_licenses_async(
        self,
        request: vod_20170321_models.GetLicensesRequest,
    ) -> vod_20170321_models.GetLicensesResponse:
        """
        @summary 查询license列表
        
        @param request: GetLicensesRequest
        @return: GetLicensesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_licenses_with_options_async(request, runtime)

    def get_mtsstatis_with_options(
        self,
        request: vod_20170321_models.GetMTSStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMTSStatisResponse:
        """
        @summary 获取MTS统计数据
        
        @param request: GetMTSStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMTSStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.division):
            query['Division'] = request.division
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_utc):
            query['EndTimeUTC'] = request.end_time_utc
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.start_time_utc):
            query['StartTimeUTC'] = request.start_time_utc
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMTSStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMTSStatisResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_mtsstatis_with_options_async(
        self,
        request: vod_20170321_models.GetMTSStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMTSStatisResponse:
        """
        @summary 获取MTS统计数据
        
        @param request: GetMTSStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMTSStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.division):
            query['Division'] = request.division
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_utc):
            query['EndTimeUTC'] = request.end_time_utc
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.start_time_utc):
            query['StartTimeUTC'] = request.start_time_utc
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMTSStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMTSStatisResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_mtsstatis(
        self,
        request: vod_20170321_models.GetMTSStatisRequest,
    ) -> vod_20170321_models.GetMTSStatisResponse:
        """
        @summary 获取MTS统计数据
        
        @param request: GetMTSStatisRequest
        @return: GetMTSStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_mtsstatis_with_options(request, runtime)

    async def get_mtsstatis_async(
        self,
        request: vod_20170321_models.GetMTSStatisRequest,
    ) -> vod_20170321_models.GetMTSStatisResponse:
        """
        @summary 获取MTS统计数据
        
        @param request: GetMTSStatisRequest
        @return: GetMTSStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_mtsstatis_with_options_async(request, runtime)

    def get_media_audit_audio_result_detail_with_options(
        self,
        request: vod_20170321_models.GetMediaAuditAudioResultDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaAuditAudioResultDetailResponse:
        """
        @summary Queries the details of audio review results.
        
        @description If notifications for the [CreateAuditComplete](https://help.aliyun.com/document_detail/89576.html) event are configured, event notifications are sent to the callback URL after automated review is complete. You can call this operation to query the details of audio review results.
        
        @param request: GetMediaAuditAudioResultDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaAuditAudioResultDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaAuditAudioResultDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaAuditAudioResultDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_media_audit_audio_result_detail_with_options_async(
        self,
        request: vod_20170321_models.GetMediaAuditAudioResultDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaAuditAudioResultDetailResponse:
        """
        @summary Queries the details of audio review results.
        
        @description If notifications for the [CreateAuditComplete](https://help.aliyun.com/document_detail/89576.html) event are configured, event notifications are sent to the callback URL after automated review is complete. You can call this operation to query the details of audio review results.
        
        @param request: GetMediaAuditAudioResultDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaAuditAudioResultDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaAuditAudioResultDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaAuditAudioResultDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_media_audit_audio_result_detail(
        self,
        request: vod_20170321_models.GetMediaAuditAudioResultDetailRequest,
    ) -> vod_20170321_models.GetMediaAuditAudioResultDetailResponse:
        """
        @summary Queries the details of audio review results.
        
        @description If notifications for the [CreateAuditComplete](https://help.aliyun.com/document_detail/89576.html) event are configured, event notifications are sent to the callback URL after automated review is complete. You can call this operation to query the details of audio review results.
        
        @param request: GetMediaAuditAudioResultDetailRequest
        @return: GetMediaAuditAudioResultDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_media_audit_audio_result_detail_with_options(request, runtime)

    async def get_media_audit_audio_result_detail_async(
        self,
        request: vod_20170321_models.GetMediaAuditAudioResultDetailRequest,
    ) -> vod_20170321_models.GetMediaAuditAudioResultDetailResponse:
        """
        @summary Queries the details of audio review results.
        
        @description If notifications for the [CreateAuditComplete](https://help.aliyun.com/document_detail/89576.html) event are configured, event notifications are sent to the callback URL after automated review is complete. You can call this operation to query the details of audio review results.
        
        @param request: GetMediaAuditAudioResultDetailRequest
        @return: GetMediaAuditAudioResultDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_media_audit_audio_result_detail_with_options_async(request, runtime)

    def get_media_audit_result_with_options(
        self,
        request: vod_20170321_models.GetMediaAuditResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaAuditResultResponse:
        """
        @summary Queries the summary of automated review results.
        
        @param request: GetMediaAuditResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaAuditResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaAuditResult',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaAuditResultResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_media_audit_result_with_options_async(
        self,
        request: vod_20170321_models.GetMediaAuditResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaAuditResultResponse:
        """
        @summary Queries the summary of automated review results.
        
        @param request: GetMediaAuditResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaAuditResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaAuditResult',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaAuditResultResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_media_audit_result(
        self,
        request: vod_20170321_models.GetMediaAuditResultRequest,
    ) -> vod_20170321_models.GetMediaAuditResultResponse:
        """
        @summary Queries the summary of automated review results.
        
        @param request: GetMediaAuditResultRequest
        @return: GetMediaAuditResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_media_audit_result_with_options(request, runtime)

    async def get_media_audit_result_async(
        self,
        request: vod_20170321_models.GetMediaAuditResultRequest,
    ) -> vod_20170321_models.GetMediaAuditResultResponse:
        """
        @summary Queries the summary of automated review results.
        
        @param request: GetMediaAuditResultRequest
        @return: GetMediaAuditResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_media_audit_result_with_options_async(request, runtime)

    def get_media_audit_result_detail_with_options(
        self,
        request: vod_20170321_models.GetMediaAuditResultDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaAuditResultDetailResponse:
        """
        @summary Queries the details of automated review results. You can call this operation to query the details of review results in real time.
        
        @description    By default, only details of snapshots that violate content regulations and potentially violate content regulations are returned.
        ApsaraVideo VOD stores the snapshots in the automated review results free of charge for two weeks. After this period, the snapshots are automatically deleted.
        This operation is available only in the Singapore region.
        
        @param request: GetMediaAuditResultDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaAuditResultDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaAuditResultDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaAuditResultDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_media_audit_result_detail_with_options_async(
        self,
        request: vod_20170321_models.GetMediaAuditResultDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaAuditResultDetailResponse:
        """
        @summary Queries the details of automated review results. You can call this operation to query the details of review results in real time.
        
        @description    By default, only details of snapshots that violate content regulations and potentially violate content regulations are returned.
        ApsaraVideo VOD stores the snapshots in the automated review results free of charge for two weeks. After this period, the snapshots are automatically deleted.
        This operation is available only in the Singapore region.
        
        @param request: GetMediaAuditResultDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaAuditResultDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaAuditResultDetail',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaAuditResultDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_media_audit_result_detail(
        self,
        request: vod_20170321_models.GetMediaAuditResultDetailRequest,
    ) -> vod_20170321_models.GetMediaAuditResultDetailResponse:
        """
        @summary Queries the details of automated review results. You can call this operation to query the details of review results in real time.
        
        @description    By default, only details of snapshots that violate content regulations and potentially violate content regulations are returned.
        ApsaraVideo VOD stores the snapshots in the automated review results free of charge for two weeks. After this period, the snapshots are automatically deleted.
        This operation is available only in the Singapore region.
        
        @param request: GetMediaAuditResultDetailRequest
        @return: GetMediaAuditResultDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_media_audit_result_detail_with_options(request, runtime)

    async def get_media_audit_result_detail_async(
        self,
        request: vod_20170321_models.GetMediaAuditResultDetailRequest,
    ) -> vod_20170321_models.GetMediaAuditResultDetailResponse:
        """
        @summary Queries the details of automated review results. You can call this operation to query the details of review results in real time.
        
        @description    By default, only details of snapshots that violate content regulations and potentially violate content regulations are returned.
        ApsaraVideo VOD stores the snapshots in the automated review results free of charge for two weeks. After this period, the snapshots are automatically deleted.
        This operation is available only in the Singapore region.
        
        @param request: GetMediaAuditResultDetailRequest
        @return: GetMediaAuditResultDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_media_audit_result_detail_with_options_async(request, runtime)

    def get_media_audit_result_timeline_with_options(
        self,
        request: vod_20170321_models.GetMediaAuditResultTimelineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaAuditResultTimelineResponse:
        """
        @summary Queries the timelines of all snapshots that violate content regulations.
        
        @description >  By default, only details of snapshots that violate content regulations and potentially violate content regulations are returned.
        This operation is available only in the Singapore region.
        
        @param request: GetMediaAuditResultTimelineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaAuditResultTimelineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaAuditResultTimeline',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaAuditResultTimelineResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_media_audit_result_timeline_with_options_async(
        self,
        request: vod_20170321_models.GetMediaAuditResultTimelineRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaAuditResultTimelineResponse:
        """
        @summary Queries the timelines of all snapshots that violate content regulations.
        
        @description >  By default, only details of snapshots that violate content regulations and potentially violate content regulations are returned.
        This operation is available only in the Singapore region.
        
        @param request: GetMediaAuditResultTimelineRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaAuditResultTimelineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaAuditResultTimeline',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaAuditResultTimelineResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_media_audit_result_timeline(
        self,
        request: vod_20170321_models.GetMediaAuditResultTimelineRequest,
    ) -> vod_20170321_models.GetMediaAuditResultTimelineResponse:
        """
        @summary Queries the timelines of all snapshots that violate content regulations.
        
        @description >  By default, only details of snapshots that violate content regulations and potentially violate content regulations are returned.
        This operation is available only in the Singapore region.
        
        @param request: GetMediaAuditResultTimelineRequest
        @return: GetMediaAuditResultTimelineResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_media_audit_result_timeline_with_options(request, runtime)

    async def get_media_audit_result_timeline_async(
        self,
        request: vod_20170321_models.GetMediaAuditResultTimelineRequest,
    ) -> vod_20170321_models.GetMediaAuditResultTimelineResponse:
        """
        @summary Queries the timelines of all snapshots that violate content regulations.
        
        @description >  By default, only details of snapshots that violate content regulations and potentially violate content regulations are returned.
        This operation is available only in the Singapore region.
        
        @param request: GetMediaAuditResultTimelineRequest
        @return: GetMediaAuditResultTimelineResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_media_audit_result_timeline_with_options_async(request, runtime)

    def get_media_dnaresult_with_options(
        self,
        request: vod_20170321_models.GetMediaDNAResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaDNAResultResponse:
        """
        @summary Queries a media fingerprinting result. After a media fingerprinting job is complete, you can call this operation to query the media fingerprinting result.
        
        @description Regions that support this operation: *China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        
        @param request: GetMediaDNAResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaDNAResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaDNAResult',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaDNAResultResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_media_dnaresult_with_options_async(
        self,
        request: vod_20170321_models.GetMediaDNAResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaDNAResultResponse:
        """
        @summary Queries a media fingerprinting result. After a media fingerprinting job is complete, you can call this operation to query the media fingerprinting result.
        
        @description Regions that support this operation: *China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        
        @param request: GetMediaDNAResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaDNAResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaDNAResult',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaDNAResultResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_media_dnaresult(
        self,
        request: vod_20170321_models.GetMediaDNAResultRequest,
    ) -> vod_20170321_models.GetMediaDNAResultResponse:
        """
        @summary Queries a media fingerprinting result. After a media fingerprinting job is complete, you can call this operation to query the media fingerprinting result.
        
        @description Regions that support this operation: *China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        
        @param request: GetMediaDNAResultRequest
        @return: GetMediaDNAResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_media_dnaresult_with_options(request, runtime)

    async def get_media_dnaresult_async(
        self,
        request: vod_20170321_models.GetMediaDNAResultRequest,
    ) -> vod_20170321_models.GetMediaDNAResultResponse:
        """
        @summary Queries a media fingerprinting result. After a media fingerprinting job is complete, you can call this operation to query the media fingerprinting result.
        
        @description Regions that support this operation: *China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        
        @param request: GetMediaDNAResultRequest
        @return: GetMediaDNAResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_media_dnaresult_with_options_async(request, runtime)

    def get_media_export_jobs_with_options(
        self,
        request: vod_20170321_models.GetMediaExportJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaExportJobsResponse:
        """
        @summary 获取媒资导出任务
        
        @param request: GetMediaExportJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaExportJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaExportJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaExportJobsResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_media_export_jobs_with_options_async(
        self,
        request: vod_20170321_models.GetMediaExportJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaExportJobsResponse:
        """
        @summary 获取媒资导出任务
        
        @param request: GetMediaExportJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaExportJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaExportJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaExportJobsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_media_export_jobs(
        self,
        request: vod_20170321_models.GetMediaExportJobsRequest,
    ) -> vod_20170321_models.GetMediaExportJobsResponse:
        """
        @summary 获取媒资导出任务
        
        @param request: GetMediaExportJobsRequest
        @return: GetMediaExportJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_media_export_jobs_with_options(request, runtime)

    async def get_media_export_jobs_async(
        self,
        request: vod_20170321_models.GetMediaExportJobsRequest,
    ) -> vod_20170321_models.GetMediaExportJobsResponse:
        """
        @summary 获取媒资导出任务
        
        @param request: GetMediaExportJobsRequest
        @return: GetMediaExportJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_media_export_jobs_with_options_async(request, runtime)

    def get_media_lifecycle_rule_with_options(
        self,
        request: vod_20170321_models.GetMediaLifecycleRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaLifecycleRuleResponse:
        """
        @summary 获取生命周期规则
        
        @param request: GetMediaLifecycleRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaLifecycleRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.rule_ids):
            query['RuleIds'] = request.rule_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaLifecycleRule',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaLifecycleRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_media_lifecycle_rule_with_options_async(
        self,
        request: vod_20170321_models.GetMediaLifecycleRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaLifecycleRuleResponse:
        """
        @summary 获取生命周期规则
        
        @param request: GetMediaLifecycleRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaLifecycleRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.rule_ids):
            query['RuleIds'] = request.rule_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaLifecycleRule',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaLifecycleRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_media_lifecycle_rule(
        self,
        request: vod_20170321_models.GetMediaLifecycleRuleRequest,
    ) -> vod_20170321_models.GetMediaLifecycleRuleResponse:
        """
        @summary 获取生命周期规则
        
        @param request: GetMediaLifecycleRuleRequest
        @return: GetMediaLifecycleRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_media_lifecycle_rule_with_options(request, runtime)

    async def get_media_lifecycle_rule_async(
        self,
        request: vod_20170321_models.GetMediaLifecycleRuleRequest,
    ) -> vod_20170321_models.GetMediaLifecycleRuleResponse:
        """
        @summary 获取生命周期规则
        
        @param request: GetMediaLifecycleRuleRequest
        @return: GetMediaLifecycleRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_media_lifecycle_rule_with_options_async(request, runtime)

    def get_media_refresh_jobs_with_options(
        self,
        request: vod_20170321_models.GetMediaRefreshJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaRefreshJobsResponse:
        """
        @summary Queries the information about media refresh or prefetch jobs, such as the job status and filtering conditions.
        
        @description You can query the information about all media files or a specific media file in a refresh or prefetch job.
        ### QPS limits
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: GetMediaRefreshJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaRefreshJobsResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaRefreshJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaRefreshJobsResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_media_refresh_jobs_with_options_async(
        self,
        request: vod_20170321_models.GetMediaRefreshJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMediaRefreshJobsResponse:
        """
        @summary Queries the information about media refresh or prefetch jobs, such as the job status and filtering conditions.
        
        @description You can query the information about all media files or a specific media file in a refresh or prefetch job.
        ### QPS limits
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: GetMediaRefreshJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMediaRefreshJobsResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMediaRefreshJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMediaRefreshJobsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_media_refresh_jobs(
        self,
        request: vod_20170321_models.GetMediaRefreshJobsRequest,
    ) -> vod_20170321_models.GetMediaRefreshJobsResponse:
        """
        @summary Queries the information about media refresh or prefetch jobs, such as the job status and filtering conditions.
        
        @description You can query the information about all media files or a specific media file in a refresh or prefetch job.
        ### QPS limits
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: GetMediaRefreshJobsRequest
        @return: GetMediaRefreshJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_media_refresh_jobs_with_options(request, runtime)

    async def get_media_refresh_jobs_async(
        self,
        request: vod_20170321_models.GetMediaRefreshJobsRequest,
    ) -> vod_20170321_models.GetMediaRefreshJobsResponse:
        """
        @summary Queries the information about media refresh or prefetch jobs, such as the job status and filtering conditions.
        
        @description You can query the information about all media files or a specific media file in a refresh or prefetch job.
        ### QPS limits
        You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: GetMediaRefreshJobsRequest
        @return: GetMediaRefreshJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_media_refresh_jobs_with_options_async(request, runtime)

    def get_message_callback_with_options(
        self,
        request: vod_20170321_models.GetMessageCallbackRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMessageCallbackResponse:
        """
        @summary Queries the callback method, callback URL, and event type for event notifications.
        
        @description > For more information, see [Event notification](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: GetMessageCallbackRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageCallbackResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMessageCallback',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMessageCallbackResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_message_callback_with_options_async(
        self,
        request: vod_20170321_models.GetMessageCallbackRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMessageCallbackResponse:
        """
        @summary Queries the callback method, callback URL, and event type for event notifications.
        
        @description > For more information, see [Event notification](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: GetMessageCallbackRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageCallbackResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMessageCallback',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMessageCallbackResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_message_callback(
        self,
        request: vod_20170321_models.GetMessageCallbackRequest,
    ) -> vod_20170321_models.GetMessageCallbackResponse:
        """
        @summary Queries the callback method, callback URL, and event type for event notifications.
        
        @description > For more information, see [Event notification](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: GetMessageCallbackRequest
        @return: GetMessageCallbackResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_message_callback_with_options(request, runtime)

    async def get_message_callback_async(
        self,
        request: vod_20170321_models.GetMessageCallbackRequest,
    ) -> vod_20170321_models.GetMessageCallbackResponse:
        """
        @summary Queries the callback method, callback URL, and event type for event notifications.
        
        @description > For more information, see [Event notification](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: GetMessageCallbackRequest
        @return: GetMessageCallbackResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_message_callback_with_options_async(request, runtime)

    def get_message_callback_event_list_with_options(
        self,
        request: vod_20170321_models.GetMessageCallbackEventListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMessageCallbackEventListResponse:
        """
        @summary 获取回调事件列表
        
        @param request: GetMessageCallbackEventListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageCallbackEventListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMessageCallbackEventList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMessageCallbackEventListResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_message_callback_event_list_with_options_async(
        self,
        request: vod_20170321_models.GetMessageCallbackEventListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMessageCallbackEventListResponse:
        """
        @summary 获取回调事件列表
        
        @param request: GetMessageCallbackEventListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageCallbackEventListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMessageCallbackEventList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMessageCallbackEventListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_message_callback_event_list(
        self,
        request: vod_20170321_models.GetMessageCallbackEventListRequest,
    ) -> vod_20170321_models.GetMessageCallbackEventListResponse:
        """
        @summary 获取回调事件列表
        
        @param request: GetMessageCallbackEventListRequest
        @return: GetMessageCallbackEventListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_message_callback_event_list_with_options(request, runtime)

    async def get_message_callback_event_list_async(
        self,
        request: vod_20170321_models.GetMessageCallbackEventListRequest,
    ) -> vod_20170321_models.GetMessageCallbackEventListResponse:
        """
        @summary 获取回调事件列表
        
        @param request: GetMessageCallbackEventListRequest
        @return: GetMessageCallbackEventListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_message_callback_event_list_with_options_async(request, runtime)

    def get_message_cloud_monitor_config_with_options(
        self,
        request: vod_20170321_models.GetMessageCloudMonitorConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMessageCloudMonitorConfigResponse:
        """
        @summary 获取云监控配置
        
        @param request: GetMessageCloudMonitorConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageCloudMonitorConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMessageCloudMonitorConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMessageCloudMonitorConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_message_cloud_monitor_config_with_options_async(
        self,
        request: vod_20170321_models.GetMessageCloudMonitorConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMessageCloudMonitorConfigResponse:
        """
        @summary 获取云监控配置
        
        @param request: GetMessageCloudMonitorConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageCloudMonitorConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMessageCloudMonitorConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMessageCloudMonitorConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_message_cloud_monitor_config(
        self,
        request: vod_20170321_models.GetMessageCloudMonitorConfigRequest,
    ) -> vod_20170321_models.GetMessageCloudMonitorConfigResponse:
        """
        @summary 获取云监控配置
        
        @param request: GetMessageCloudMonitorConfigRequest
        @return: GetMessageCloudMonitorConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_message_cloud_monitor_config_with_options(request, runtime)

    async def get_message_cloud_monitor_config_async(
        self,
        request: vod_20170321_models.GetMessageCloudMonitorConfigRequest,
    ) -> vod_20170321_models.GetMessageCloudMonitorConfigResponse:
        """
        @summary 获取云监控配置
        
        @param request: GetMessageCloudMonitorConfigRequest
        @return: GetMessageCloudMonitorConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_message_cloud_monitor_config_with_options_async(request, runtime)

    def get_message_cloud_monitor_event_list_with_options(
        self,
        request: vod_20170321_models.GetMessageCloudMonitorEventListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMessageCloudMonitorEventListResponse:
        """
        @summary 获取云监控事件列表
        
        @param request: GetMessageCloudMonitorEventListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageCloudMonitorEventListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMessageCloudMonitorEventList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMessageCloudMonitorEventListResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_message_cloud_monitor_event_list_with_options_async(
        self,
        request: vod_20170321_models.GetMessageCloudMonitorEventListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMessageCloudMonitorEventListResponse:
        """
        @summary 获取云监控事件列表
        
        @param request: GetMessageCloudMonitorEventListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMessageCloudMonitorEventListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMessageCloudMonitorEventList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMessageCloudMonitorEventListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_message_cloud_monitor_event_list(
        self,
        request: vod_20170321_models.GetMessageCloudMonitorEventListRequest,
    ) -> vod_20170321_models.GetMessageCloudMonitorEventListResponse:
        """
        @summary 获取云监控事件列表
        
        @param request: GetMessageCloudMonitorEventListRequest
        @return: GetMessageCloudMonitorEventListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_message_cloud_monitor_event_list_with_options(request, runtime)

    async def get_message_cloud_monitor_event_list_async(
        self,
        request: vod_20170321_models.GetMessageCloudMonitorEventListRequest,
    ) -> vod_20170321_models.GetMessageCloudMonitorEventListResponse:
        """
        @summary 获取云监控事件列表
        
        @param request: GetMessageCloudMonitorEventListRequest
        @return: GetMessageCloudMonitorEventListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_message_cloud_monitor_event_list_with_options_async(request, runtime)

    def get_mezzanine_info_with_options(
        self,
        request: vod_20170321_models.GetMezzanineInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMezzanineInfoResponse:
        """
        @summary Queries the information about the mezzanine file of an audio or video. The information includes the mezzanine file URL, resolution, and bitrate of the audio or video.
        
        @description You can obtain complete information about the source file only after a stream is transcoded.
        
        @param request: GetMezzanineInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMezzanineInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addition_type):
            query['AdditionType'] = request.addition_type
        if not UtilClient.is_unset(request.auth_timeout):
            query['AuthTimeout'] = request.auth_timeout
        if not UtilClient.is_unset(request.output_type):
            query['OutputType'] = request.output_type
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMezzanineInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMezzanineInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_mezzanine_info_with_options_async(
        self,
        request: vod_20170321_models.GetMezzanineInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetMezzanineInfoResponse:
        """
        @summary Queries the information about the mezzanine file of an audio or video. The information includes the mezzanine file URL, resolution, and bitrate of the audio or video.
        
        @description You can obtain complete information about the source file only after a stream is transcoded.
        
        @param request: GetMezzanineInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMezzanineInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addition_type):
            query['AdditionType'] = request.addition_type
        if not UtilClient.is_unset(request.auth_timeout):
            query['AuthTimeout'] = request.auth_timeout
        if not UtilClient.is_unset(request.output_type):
            query['OutputType'] = request.output_type
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMezzanineInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetMezzanineInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_mezzanine_info(
        self,
        request: vod_20170321_models.GetMezzanineInfoRequest,
    ) -> vod_20170321_models.GetMezzanineInfoResponse:
        """
        @summary Queries the information about the mezzanine file of an audio or video. The information includes the mezzanine file URL, resolution, and bitrate of the audio or video.
        
        @description You can obtain complete information about the source file only after a stream is transcoded.
        
        @param request: GetMezzanineInfoRequest
        @return: GetMezzanineInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_mezzanine_info_with_options(request, runtime)

    async def get_mezzanine_info_async(
        self,
        request: vod_20170321_models.GetMezzanineInfoRequest,
    ) -> vod_20170321_models.GetMezzanineInfoResponse:
        """
        @summary Queries the information about the mezzanine file of an audio or video. The information includes the mezzanine file URL, resolution, and bitrate of the audio or video.
        
        @description You can obtain complete information about the source file only after a stream is transcoded.
        
        @param request: GetMezzanineInfoRequest
        @return: GetMezzanineInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_mezzanine_info_with_options_async(request, runtime)

    def get_ossflow_statis_with_options(
        self,
        request: vod_20170321_models.GetOSSFlowStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetOSSFlowStatisResponse:
        """
        @summary 获取OSS流量统计
        
        @param request: GetOSSFlowStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOSSFlowStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.division):
            query['Division'] = request.division
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_utc):
            query['EndTimeUTC'] = request.end_time_utc
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.start_time_utc):
            query['StartTimeUTC'] = request.start_time_utc
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOSSFlowStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetOSSFlowStatisResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_ossflow_statis_with_options_async(
        self,
        request: vod_20170321_models.GetOSSFlowStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetOSSFlowStatisResponse:
        """
        @summary 获取OSS流量统计
        
        @param request: GetOSSFlowStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOSSFlowStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.division):
            query['Division'] = request.division
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_utc):
            query['EndTimeUTC'] = request.end_time_utc
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.start_time_utc):
            query['StartTimeUTC'] = request.start_time_utc
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOSSFlowStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetOSSFlowStatisResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_ossflow_statis(
        self,
        request: vod_20170321_models.GetOSSFlowStatisRequest,
    ) -> vod_20170321_models.GetOSSFlowStatisResponse:
        """
        @summary 获取OSS流量统计
        
        @param request: GetOSSFlowStatisRequest
        @return: GetOSSFlowStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_ossflow_statis_with_options(request, runtime)

    async def get_ossflow_statis_async(
        self,
        request: vod_20170321_models.GetOSSFlowStatisRequest,
    ) -> vod_20170321_models.GetOSSFlowStatisResponse:
        """
        @summary 获取OSS流量统计
        
        @param request: GetOSSFlowStatisRequest
        @return: GetOSSFlowStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_ossflow_statis_with_options_async(request, runtime)

    def get_ossstatis_with_options(
        self,
        request: vod_20170321_models.GetOSSStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetOSSStatisResponse:
        """
        @summary 获取OSS统计
        
        @param request: GetOSSStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOSSStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.division):
            query['Division'] = request.division
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_utc):
            query['EndTimeUTC'] = request.end_time_utc
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.start_time_utc):
            query['StartTimeUTC'] = request.start_time_utc
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOSSStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetOSSStatisResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_ossstatis_with_options_async(
        self,
        request: vod_20170321_models.GetOSSStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetOSSStatisResponse:
        """
        @summary 获取OSS统计
        
        @param request: GetOSSStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOSSStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.division):
            query['Division'] = request.division
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.end_time_utc):
            query['EndTimeUTC'] = request.end_time_utc
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.start_time_utc):
            query['StartTimeUTC'] = request.start_time_utc
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOSSStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetOSSStatisResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_ossstatis(
        self,
        request: vod_20170321_models.GetOSSStatisRequest,
    ) -> vod_20170321_models.GetOSSStatisResponse:
        """
        @summary 获取OSS统计
        
        @param request: GetOSSStatisRequest
        @return: GetOSSStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_ossstatis_with_options(request, runtime)

    async def get_ossstatis_async(
        self,
        request: vod_20170321_models.GetOSSStatisRequest,
    ) -> vod_20170321_models.GetOSSStatisResponse:
        """
        @summary 获取OSS统计
        
        @param request: GetOSSStatisRequest
        @return: GetOSSStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_ossstatis_with_options_async(request, runtime)

    def get_page_by_cond_app_info_with_options(
        self,
        request: vod_20170321_models.GetPageByCondAppInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPageByCondAppInfoResponse:
        """
        @summary 分页获取应用信息列表
        
        @param request: GetPageByCondAppInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPageByCondAppInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.app_type):
            query['AppType'] = request.app_type
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.need_total_count):
            query['NeedTotalCount'] = request.need_total_count
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.pkg_name):
            query['PkgName'] = request.pkg_name
        if not UtilClient.is_unset(request.pkg_signature):
            query['PkgSignature'] = request.pkg_signature
        if not UtilClient.is_unset(request.platform_type):
            query['PlatformType'] = request.platform_type
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPageByCondAppInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPageByCondAppInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_page_by_cond_app_info_with_options_async(
        self,
        request: vod_20170321_models.GetPageByCondAppInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPageByCondAppInfoResponse:
        """
        @summary 分页获取应用信息列表
        
        @param request: GetPageByCondAppInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPageByCondAppInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.app_type):
            query['AppType'] = request.app_type
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.need_total_count):
            query['NeedTotalCount'] = request.need_total_count
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.pkg_name):
            query['PkgName'] = request.pkg_name
        if not UtilClient.is_unset(request.pkg_signature):
            query['PkgSignature'] = request.pkg_signature
        if not UtilClient.is_unset(request.platform_type):
            query['PlatformType'] = request.platform_type
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPageByCondAppInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPageByCondAppInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_page_by_cond_app_info(
        self,
        request: vod_20170321_models.GetPageByCondAppInfoRequest,
    ) -> vod_20170321_models.GetPageByCondAppInfoResponse:
        """
        @summary 分页获取应用信息列表
        
        @param request: GetPageByCondAppInfoRequest
        @return: GetPageByCondAppInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_page_by_cond_app_info_with_options(request, runtime)

    async def get_page_by_cond_app_info_async(
        self,
        request: vod_20170321_models.GetPageByCondAppInfoRequest,
    ) -> vod_20170321_models.GetPageByCondAppInfoResponse:
        """
        @summary 分页获取应用信息列表
        
        @param request: GetPageByCondAppInfoRequest
        @return: GetPageByCondAppInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_page_by_cond_app_info_with_options_async(request, runtime)

    def get_page_by_cond_license_instance_with_options(
        self,
        request: vod_20170321_models.GetPageByCondLicenseInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPageByCondLicenseInstanceResponse:
        """
        @summary 分页获取实例信息列表
        
        @param request: GetPageByCondLicenseInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPageByCondLicenseInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.contract_no):
            query['ContractNo'] = request.contract_no
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.need_total_count):
            query['NeedTotalCount'] = request.need_total_count
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPageByCondLicenseInstance',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPageByCondLicenseInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_page_by_cond_license_instance_with_options_async(
        self,
        request: vod_20170321_models.GetPageByCondLicenseInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPageByCondLicenseInstanceResponse:
        """
        @summary 分页获取实例信息列表
        
        @param request: GetPageByCondLicenseInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPageByCondLicenseInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.contract_no):
            query['ContractNo'] = request.contract_no
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.need_total_count):
            query['NeedTotalCount'] = request.need_total_count
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPageByCondLicenseInstance',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPageByCondLicenseInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_page_by_cond_license_instance(
        self,
        request: vod_20170321_models.GetPageByCondLicenseInstanceRequest,
    ) -> vod_20170321_models.GetPageByCondLicenseInstanceResponse:
        """
        @summary 分页获取实例信息列表
        
        @param request: GetPageByCondLicenseInstanceRequest
        @return: GetPageByCondLicenseInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_page_by_cond_license_instance_with_options(request, runtime)

    async def get_page_by_cond_license_instance_async(
        self,
        request: vod_20170321_models.GetPageByCondLicenseInstanceRequest,
    ) -> vod_20170321_models.GetPageByCondLicenseInstanceResponse:
        """
        @summary 分页获取实例信息列表
        
        @param request: GetPageByCondLicenseInstanceRequest
        @return: GetPageByCondLicenseInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_page_by_cond_license_instance_with_options_async(request, runtime)

    def get_personal_storage_list_with_options(
        self,
        request: vod_20170321_models.GetPersonalStorageListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPersonalStorageListResponse:
        """
        @summary 获取自有存储列表
        
        @param request: GetPersonalStorageListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPersonalStorageListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_keys):
            query['MaxKeys'] = request.max_keys
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix):
            query['Prefix'] = request.prefix
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_region):
            query['StorageRegion'] = request.storage_region
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPersonalStorageList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPersonalStorageListResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_personal_storage_list_with_options_async(
        self,
        request: vod_20170321_models.GetPersonalStorageListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPersonalStorageListResponse:
        """
        @summary 获取自有存储列表
        
        @param request: GetPersonalStorageListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPersonalStorageListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_keys):
            query['MaxKeys'] = request.max_keys
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.prefix):
            query['Prefix'] = request.prefix
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_region):
            query['StorageRegion'] = request.storage_region
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPersonalStorageList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPersonalStorageListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_personal_storage_list(
        self,
        request: vod_20170321_models.GetPersonalStorageListRequest,
    ) -> vod_20170321_models.GetPersonalStorageListResponse:
        """
        @summary 获取自有存储列表
        
        @param request: GetPersonalStorageListRequest
        @return: GetPersonalStorageListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_personal_storage_list_with_options(request, runtime)

    async def get_personal_storage_list_async(
        self,
        request: vod_20170321_models.GetPersonalStorageListRequest,
    ) -> vod_20170321_models.GetPersonalStorageListResponse:
        """
        @summary 获取自有存储列表
        
        @param request: GetPersonalStorageListRequest
        @return: GetPersonalStorageListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_personal_storage_list_with_options_async(request, runtime)

    def get_plan_specification_for_license_with_options(
        self,
        request: vod_20170321_models.GetPlanSpecificationForLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPlanSpecificationForLicenseResponse:
        """
        @summary 查询套餐规格
        
        @param request: GetPlanSpecificationForLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPlanSpecificationForLicenseResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPlanSpecificationForLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPlanSpecificationForLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_plan_specification_for_license_with_options_async(
        self,
        request: vod_20170321_models.GetPlanSpecificationForLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPlanSpecificationForLicenseResponse:
        """
        @summary 查询套餐规格
        
        @param request: GetPlanSpecificationForLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPlanSpecificationForLicenseResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPlanSpecificationForLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPlanSpecificationForLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_plan_specification_for_license(
        self,
        request: vod_20170321_models.GetPlanSpecificationForLicenseRequest,
    ) -> vod_20170321_models.GetPlanSpecificationForLicenseResponse:
        """
        @summary 查询套餐规格
        
        @param request: GetPlanSpecificationForLicenseRequest
        @return: GetPlanSpecificationForLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_plan_specification_for_license_with_options(request, runtime)

    async def get_plan_specification_for_license_async(
        self,
        request: vod_20170321_models.GetPlanSpecificationForLicenseRequest,
    ) -> vod_20170321_models.GetPlanSpecificationForLicenseResponse:
        """
        @summary 查询套餐规格
        
        @param request: GetPlanSpecificationForLicenseRequest
        @return: GetPlanSpecificationForLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_plan_specification_for_license_with_options_async(request, runtime)

    def get_play_config_with_options(
        self,
        request: vod_20170321_models.GetPlayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPlayConfigResponse:
        """
        @summary 获取播放配置信息
        
        @param request: GetPlayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPlayConfigResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPlayConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPlayConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_play_config_with_options_async(
        self,
        request: vod_20170321_models.GetPlayConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPlayConfigResponse:
        """
        @summary 获取播放配置信息
        
        @param request: GetPlayConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPlayConfigResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPlayConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPlayConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_play_config(
        self,
        request: vod_20170321_models.GetPlayConfigRequest,
    ) -> vod_20170321_models.GetPlayConfigResponse:
        """
        @summary 获取播放配置信息
        
        @param request: GetPlayConfigRequest
        @return: GetPlayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_play_config_with_options(request, runtime)

    async def get_play_config_async(
        self,
        request: vod_20170321_models.GetPlayConfigRequest,
    ) -> vod_20170321_models.GetPlayConfigResponse:
        """
        @summary 获取播放配置信息
        
        @param request: GetPlayConfigRequest
        @return: GetPlayConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_play_config_with_options_async(request, runtime)

    def get_play_info_with_options(
        self,
        request: vod_20170321_models.GetPlayInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPlayInfoResponse:
        """
        @summary Obtains the playback URL by the audio or video ID. Then, you can use ApsaraVideo Player or a third-party player, such as a system player, open source player, orself-developed player, to play the audio or video.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for outbound traffic when you download or play videos based on URLs in ApsaraVideo VOD. For more information about billing of outbound traffic, see [Billing of outbound traffic](~~188308#section-rwh-e88-f7j~~). If you have configured an accelerated domain name, see [Billing of the acceleration service](~~188308#section-c5t-oq9-15e~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        Only videos whose Status is Normal can be played. For more information, see [Overview](https://help.aliyun.com/document_detail/57290.html).
        If video playback fails, you can call the [GetMezzanineInfo](~~GetMezzanineInfo~~) operation to check whether the video source information is correct.
        
        @param request: GetPlayInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPlayInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addition_type):
            query['AdditionType'] = request.addition_type
        if not UtilClient.is_unset(request.auth_timeout):
            query['AuthTimeout'] = request.auth_timeout
        if not UtilClient.is_unset(request.definition):
            query['Definition'] = request.definition
        if not UtilClient.is_unset(request.digital_watermark_type):
            query['DigitalWatermarkType'] = request.digital_watermark_type
        if not UtilClient.is_unset(request.formats):
            query['Formats'] = request.formats
        if not UtilClient.is_unset(request.output_type):
            query['OutputType'] = request.output_type
        if not UtilClient.is_unset(request.play_config):
            query['PlayConfig'] = request.play_config
        if not UtilClient.is_unset(request.re_auth_info):
            query['ReAuthInfo'] = request.re_auth_info
        if not UtilClient.is_unset(request.result_type):
            query['ResultType'] = request.result_type
        if not UtilClient.is_unset(request.stream_type):
            query['StreamType'] = request.stream_type
        if not UtilClient.is_unset(request.trace):
            query['Trace'] = request.trace
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPlayInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPlayInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_play_info_with_options_async(
        self,
        request: vod_20170321_models.GetPlayInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPlayInfoResponse:
        """
        @summary Obtains the playback URL by the audio or video ID. Then, you can use ApsaraVideo Player or a third-party player, such as a system player, open source player, orself-developed player, to play the audio or video.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for outbound traffic when you download or play videos based on URLs in ApsaraVideo VOD. For more information about billing of outbound traffic, see [Billing of outbound traffic](~~188308#section-rwh-e88-f7j~~). If you have configured an accelerated domain name, see [Billing of the acceleration service](~~188308#section-c5t-oq9-15e~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        Only videos whose Status is Normal can be played. For more information, see [Overview](https://help.aliyun.com/document_detail/57290.html).
        If video playback fails, you can call the [GetMezzanineInfo](~~GetMezzanineInfo~~) operation to check whether the video source information is correct.
        
        @param request: GetPlayInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPlayInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addition_type):
            query['AdditionType'] = request.addition_type
        if not UtilClient.is_unset(request.auth_timeout):
            query['AuthTimeout'] = request.auth_timeout
        if not UtilClient.is_unset(request.definition):
            query['Definition'] = request.definition
        if not UtilClient.is_unset(request.digital_watermark_type):
            query['DigitalWatermarkType'] = request.digital_watermark_type
        if not UtilClient.is_unset(request.formats):
            query['Formats'] = request.formats
        if not UtilClient.is_unset(request.output_type):
            query['OutputType'] = request.output_type
        if not UtilClient.is_unset(request.play_config):
            query['PlayConfig'] = request.play_config
        if not UtilClient.is_unset(request.re_auth_info):
            query['ReAuthInfo'] = request.re_auth_info
        if not UtilClient.is_unset(request.result_type):
            query['ResultType'] = request.result_type
        if not UtilClient.is_unset(request.stream_type):
            query['StreamType'] = request.stream_type
        if not UtilClient.is_unset(request.trace):
            query['Trace'] = request.trace
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPlayInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPlayInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_play_info(
        self,
        request: vod_20170321_models.GetPlayInfoRequest,
    ) -> vod_20170321_models.GetPlayInfoResponse:
        """
        @summary Obtains the playback URL by the audio or video ID. Then, you can use ApsaraVideo Player or a third-party player, such as a system player, open source player, orself-developed player, to play the audio or video.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for outbound traffic when you download or play videos based on URLs in ApsaraVideo VOD. For more information about billing of outbound traffic, see [Billing of outbound traffic](~~188308#section-rwh-e88-f7j~~). If you have configured an accelerated domain name, see [Billing of the acceleration service](~~188308#section-c5t-oq9-15e~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        Only videos whose Status is Normal can be played. For more information, see [Overview](https://help.aliyun.com/document_detail/57290.html).
        If video playback fails, you can call the [GetMezzanineInfo](~~GetMezzanineInfo~~) operation to check whether the video source information is correct.
        
        @param request: GetPlayInfoRequest
        @return: GetPlayInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_play_info_with_options(request, runtime)

    async def get_play_info_async(
        self,
        request: vod_20170321_models.GetPlayInfoRequest,
    ) -> vod_20170321_models.GetPlayInfoResponse:
        """
        @summary Obtains the playback URL by the audio or video ID. Then, you can use ApsaraVideo Player or a third-party player, such as a system player, open source player, orself-developed player, to play the audio or video.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for outbound traffic when you download or play videos based on URLs in ApsaraVideo VOD. For more information about billing of outbound traffic, see [Billing of outbound traffic](~~188308#section-rwh-e88-f7j~~). If you have configured an accelerated domain name, see [Billing of the acceleration service](~~188308#section-c5t-oq9-15e~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        Only videos whose Status is Normal can be played. For more information, see [Overview](https://help.aliyun.com/document_detail/57290.html).
        If video playback fails, you can call the [GetMezzanineInfo](~~GetMezzanineInfo~~) operation to check whether the video source information is correct.
        
        @param request: GetPlayInfoRequest
        @return: GetPlayInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_play_info_with_options_async(request, runtime)

    def get_player_config_with_options(
        self,
        request: vod_20170321_models.GetPlayerConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPlayerConfigResponse:
        """
        @summary 获取播放配置
        
        @param request: GetPlayerConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPlayerConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.api_version):
            query['ApiVersion'] = request.api_version
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.auth_timestamp):
            query['AuthTimestamp'] = request.auth_timestamp
        if not UtilClient.is_unset(request.device_brand):
            query['DeviceBrand'] = request.device_brand
        if not UtilClient.is_unset(request.device_model):
            query['DeviceModel'] = request.device_model
        if not UtilClient.is_unset(request.os_name):
            query['OsName'] = request.os_name
        if not UtilClient.is_unset(request.reserved):
            query['Reserved'] = request.reserved
        if not UtilClient.is_unset(request.rule):
            query['Rule'] = request.rule
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPlayerConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPlayerConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_player_config_with_options_async(
        self,
        request: vod_20170321_models.GetPlayerConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetPlayerConfigResponse:
        """
        @summary 获取播放配置
        
        @param request: GetPlayerConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPlayerConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.api_version):
            query['ApiVersion'] = request.api_version
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.auth_timestamp):
            query['AuthTimestamp'] = request.auth_timestamp
        if not UtilClient.is_unset(request.device_brand):
            query['DeviceBrand'] = request.device_brand
        if not UtilClient.is_unset(request.device_model):
            query['DeviceModel'] = request.device_model
        if not UtilClient.is_unset(request.os_name):
            query['OsName'] = request.os_name
        if not UtilClient.is_unset(request.reserved):
            query['Reserved'] = request.reserved
        if not UtilClient.is_unset(request.rule):
            query['Rule'] = request.rule
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPlayerConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetPlayerConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_player_config(
        self,
        request: vod_20170321_models.GetPlayerConfigRequest,
    ) -> vod_20170321_models.GetPlayerConfigResponse:
        """
        @summary 获取播放配置
        
        @param request: GetPlayerConfigRequest
        @return: GetPlayerConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_player_config_with_options(request, runtime)

    async def get_player_config_async(
        self,
        request: vod_20170321_models.GetPlayerConfigRequest,
    ) -> vod_20170321_models.GetPlayerConfigResponse:
        """
        @summary 获取播放配置
        
        @param request: GetPlayerConfigRequest
        @return: GetPlayerConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_player_config_with_options_async(request, runtime)

    def get_sdk_integration_with_options(
        self,
        request: vod_20170321_models.GetSdkIntegrationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetSdkIntegrationResponse:
        """
        @summary 获取SDK接入
        
        @param request: GetSdkIntegrationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSdkIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.integration_type):
            query['IntegrationType'] = request.integration_type
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.product):
            query['Product'] = request.product
        if not UtilClient.is_unset(request.sdk_code_id):
            query['SdkCodeId'] = request.sdk_code_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSdkIntegration',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetSdkIntegrationResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_sdk_integration_with_options_async(
        self,
        request: vod_20170321_models.GetSdkIntegrationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetSdkIntegrationResponse:
        """
        @summary 获取SDK接入
        
        @param request: GetSdkIntegrationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSdkIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.integration_type):
            query['IntegrationType'] = request.integration_type
        if not UtilClient.is_unset(request.platform):
            query['Platform'] = request.platform
        if not UtilClient.is_unset(request.product):
            query['Product'] = request.product
        if not UtilClient.is_unset(request.sdk_code_id):
            query['SdkCodeId'] = request.sdk_code_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSdkIntegration',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetSdkIntegrationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_sdk_integration(
        self,
        request: vod_20170321_models.GetSdkIntegrationRequest,
    ) -> vod_20170321_models.GetSdkIntegrationResponse:
        """
        @summary 获取SDK接入
        
        @param request: GetSdkIntegrationRequest
        @return: GetSdkIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_sdk_integration_with_options(request, runtime)

    async def get_sdk_integration_async(
        self,
        request: vod_20170321_models.GetSdkIntegrationRequest,
    ) -> vod_20170321_models.GetSdkIntegrationResponse:
        """
        @summary 获取SDK接入
        
        @param request: GetSdkIntegrationRequest
        @return: GetSdkIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_sdk_integration_with_options_async(request, runtime)

    def get_sdk_list_with_options(
        self,
        request: vod_20170321_models.GetSdkListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetSdkListResponse:
        """
        @summary 获取sdk列表
        
        @param request: GetSdkListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSdkListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group):
            query['Group'] = request.group
        if not UtilClient.is_unset(request.product):
            query['Product'] = request.product
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSdkList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetSdkListResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_sdk_list_with_options_async(
        self,
        request: vod_20170321_models.GetSdkListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetSdkListResponse:
        """
        @summary 获取sdk列表
        
        @param request: GetSdkListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSdkListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group):
            query['Group'] = request.group
        if not UtilClient.is_unset(request.product):
            query['Product'] = request.product
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSdkList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetSdkListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_sdk_list(
        self,
        request: vod_20170321_models.GetSdkListRequest,
    ) -> vod_20170321_models.GetSdkListResponse:
        """
        @summary 获取sdk列表
        
        @param request: GetSdkListRequest
        @return: GetSdkListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_sdk_list_with_options(request, runtime)

    async def get_sdk_list_async(
        self,
        request: vod_20170321_models.GetSdkListRequest,
    ) -> vod_20170321_models.GetSdkListResponse:
        """
        @summary 获取sdk列表
        
        @param request: GetSdkListRequest
        @return: GetSdkListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_sdk_list_with_options_async(request, runtime)

    def get_specifications_for_license_with_options(
        self,
        request: vod_20170321_models.GetSpecificationsForLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetSpecificationsForLicenseResponse:
        """
        @summary 获取商品完整的规格对象
        
        @param request: GetSpecificationsForLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSpecificationsForLicenseResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSpecificationsForLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetSpecificationsForLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_specifications_for_license_with_options_async(
        self,
        request: vod_20170321_models.GetSpecificationsForLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetSpecificationsForLicenseResponse:
        """
        @summary 获取商品完整的规格对象
        
        @param request: GetSpecificationsForLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSpecificationsForLicenseResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSpecificationsForLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetSpecificationsForLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_specifications_for_license(
        self,
        request: vod_20170321_models.GetSpecificationsForLicenseRequest,
    ) -> vod_20170321_models.GetSpecificationsForLicenseResponse:
        """
        @summary 获取商品完整的规格对象
        
        @param request: GetSpecificationsForLicenseRequest
        @return: GetSpecificationsForLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_specifications_for_license_with_options(request, runtime)

    async def get_specifications_for_license_async(
        self,
        request: vod_20170321_models.GetSpecificationsForLicenseRequest,
    ) -> vod_20170321_models.GetSpecificationsForLicenseResponse:
        """
        @summary 获取商品完整的规格对象
        
        @param request: GetSpecificationsForLicenseRequest
        @return: GetSpecificationsForLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_specifications_for_license_with_options_async(request, runtime)

    def get_storage_info_with_options(
        self,
        request: vod_20170321_models.GetStorageInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetStorageInfoResponse:
        """
        @summary 获取客户的存储信息
        
        @param request: GetStorageInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStorageInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStorageInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetStorageInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_storage_info_with_options_async(
        self,
        request: vod_20170321_models.GetStorageInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetStorageInfoResponse:
        """
        @summary 获取客户的存储信息
        
        @param request: GetStorageInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStorageInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStorageInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetStorageInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_storage_info(
        self,
        request: vod_20170321_models.GetStorageInfoRequest,
    ) -> vod_20170321_models.GetStorageInfoResponse:
        """
        @summary 获取客户的存储信息
        
        @param request: GetStorageInfoRequest
        @return: GetStorageInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_storage_info_with_options(request, runtime)

    async def get_storage_info_async(
        self,
        request: vod_20170321_models.GetStorageInfoRequest,
    ) -> vod_20170321_models.GetStorageInfoResponse:
        """
        @summary 获取客户的存储信息
        
        @param request: GetStorageInfoRequest
        @return: GetStorageInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_storage_info_with_options_async(request, runtime)

    def get_storage_list_with_options(
        self,
        request: vod_20170321_models.GetStorageListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetStorageListResponse:
        """
        @summary 获取存储列表
        
        @param request: GetStorageListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStorageListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.division):
            query['Division'] = request.division
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_region):
            query['StorageRegion'] = request.storage_region
        if not UtilClient.is_unset(request.storage_status):
            query['StorageStatus'] = request.storage_status
        if not UtilClient.is_unset(request.storage_type):
            query['StorageType'] = request.storage_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStorageList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetStorageListResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_storage_list_with_options_async(
        self,
        request: vod_20170321_models.GetStorageListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetStorageListResponse:
        """
        @summary 获取存储列表
        
        @param request: GetStorageListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStorageListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.division):
            query['Division'] = request.division
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_region):
            query['StorageRegion'] = request.storage_region
        if not UtilClient.is_unset(request.storage_status):
            query['StorageStatus'] = request.storage_status
        if not UtilClient.is_unset(request.storage_type):
            query['StorageType'] = request.storage_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStorageList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetStorageListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_storage_list(
        self,
        request: vod_20170321_models.GetStorageListRequest,
    ) -> vod_20170321_models.GetStorageListResponse:
        """
        @summary 获取存储列表
        
        @param request: GetStorageListRequest
        @return: GetStorageListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_storage_list_with_options(request, runtime)

    async def get_storage_list_async(
        self,
        request: vod_20170321_models.GetStorageListRequest,
    ) -> vod_20170321_models.GetStorageListResponse:
        """
        @summary 获取存储列表
        
        @param request: GetStorageListRequest
        @return: GetStorageListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_storage_list_with_options_async(request, runtime)

    def get_storage_notify_config_with_options(
        self,
        request: vod_20170321_models.GetStorageNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetStorageNotifyConfigResponse:
        """
        @summary 获取存储通知配置
        
        @param request: GetStorageNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStorageNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStorageNotifyConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetStorageNotifyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_storage_notify_config_with_options_async(
        self,
        request: vod_20170321_models.GetStorageNotifyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetStorageNotifyConfigResponse:
        """
        @summary 获取存储通知配置
        
        @param request: GetStorageNotifyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStorageNotifyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStorageNotifyConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetStorageNotifyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_storage_notify_config(
        self,
        request: vod_20170321_models.GetStorageNotifyConfigRequest,
    ) -> vod_20170321_models.GetStorageNotifyConfigResponse:
        """
        @summary 获取存储通知配置
        
        @param request: GetStorageNotifyConfigRequest
        @return: GetStorageNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_storage_notify_config_with_options(request, runtime)

    async def get_storage_notify_config_async(
        self,
        request: vod_20170321_models.GetStorageNotifyConfigRequest,
    ) -> vod_20170321_models.GetStorageNotifyConfigResponse:
        """
        @summary 获取存储通知配置
        
        @param request: GetStorageNotifyConfigRequest
        @return: GetStorageNotifyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_storage_notify_config_with_options_async(request, runtime)

    def get_storage_region_list_with_options(
        self,
        request: vod_20170321_models.GetStorageRegionListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetStorageRegionListResponse:
        """
        @summary 获取存储区域列表
        
        @param request: GetStorageRegionListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStorageRegionListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStorageRegionList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetStorageRegionListResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_storage_region_list_with_options_async(
        self,
        request: vod_20170321_models.GetStorageRegionListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetStorageRegionListResponse:
        """
        @summary 获取存储区域列表
        
        @param request: GetStorageRegionListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStorageRegionListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStorageRegionList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetStorageRegionListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_storage_region_list(
        self,
        request: vod_20170321_models.GetStorageRegionListRequest,
    ) -> vod_20170321_models.GetStorageRegionListResponse:
        """
        @summary 获取存储区域列表
        
        @param request: GetStorageRegionListRequest
        @return: GetStorageRegionListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_storage_region_list_with_options(request, runtime)

    async def get_storage_region_list_async(
        self,
        request: vod_20170321_models.GetStorageRegionListRequest,
    ) -> vod_20170321_models.GetStorageRegionListResponse:
        """
        @summary 获取存储区域列表
        
        @param request: GetStorageRegionListRequest
        @return: GetStorageRegionListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_storage_region_list_with_options_async(request, runtime)

    def get_template_group_console_with_options(
        self,
        request: vod_20170321_models.GetTemplateGroupConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetTemplateGroupConsoleResponse:
        """
        @summary 获取模版组
        
        @param request: GetTemplateGroupConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTemplateGroupConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTemplateGroupConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetTemplateGroupConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_template_group_console_with_options_async(
        self,
        request: vod_20170321_models.GetTemplateGroupConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetTemplateGroupConsoleResponse:
        """
        @summary 获取模版组
        
        @param request: GetTemplateGroupConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTemplateGroupConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTemplateGroupConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetTemplateGroupConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_template_group_console(
        self,
        request: vod_20170321_models.GetTemplateGroupConsoleRequest,
    ) -> vod_20170321_models.GetTemplateGroupConsoleResponse:
        """
        @summary 获取模版组
        
        @param request: GetTemplateGroupConsoleRequest
        @return: GetTemplateGroupConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_template_group_console_with_options(request, runtime)

    async def get_template_group_console_async(
        self,
        request: vod_20170321_models.GetTemplateGroupConsoleRequest,
    ) -> vod_20170321_models.GetTemplateGroupConsoleResponse:
        """
        @summary 获取模版组
        
        @param request: GetTemplateGroupConsoleRequest
        @return: GetTemplateGroupConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_template_group_console_with_options_async(request, runtime)

    def get_total_statis_with_options(
        self,
        request: vod_20170321_models.GetTotalStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetTotalStatisResponse:
        """
        @summary 获取全部统计数据
        
        @param request: GetTotalStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTotalStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTotalStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetTotalStatisResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_total_statis_with_options_async(
        self,
        request: vod_20170321_models.GetTotalStatisRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetTotalStatisResponse:
        """
        @summary 获取全部统计数据
        
        @param request: GetTotalStatisRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTotalStatisResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTotalStatis',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetTotalStatisResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_total_statis(
        self,
        request: vod_20170321_models.GetTotalStatisRequest,
    ) -> vod_20170321_models.GetTotalStatisResponse:
        """
        @summary 获取全部统计数据
        
        @param request: GetTotalStatisRequest
        @return: GetTotalStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_total_statis_with_options(request, runtime)

    async def get_total_statis_async(
        self,
        request: vod_20170321_models.GetTotalStatisRequest,
    ) -> vod_20170321_models.GetTotalStatisResponse:
        """
        @summary 获取全部统计数据
        
        @param request: GetTotalStatisRequest
        @return: GetTotalStatisResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_total_statis_with_options_async(request, runtime)

    def get_transcode_summary_with_options(
        self,
        request: vod_20170321_models.GetTranscodeSummaryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetTranscodeSummaryResponse:
        """
        @summary Queries transcoding summaries of audio and video files based on the file ID. A transcoding summary includes the status and progress of transcoding.
        
        @description    An audio or video file may be transcoded multiple times. This operation returns only the latest transcoding summary.
        You can query transcoding summaries for a maximum of 10 audio and video files in one request.
        You can call the [ListTranscodeTask](https://help.aliyun.com/document_detail/109120.html) operation to query historical transcoding tasks.
        **You can call this operation to query information only about transcoding tasks created within the past year.
        
        @param request: GetTranscodeSummaryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTranscodeSummaryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.video_ids):
            query['VideoIds'] = request.video_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTranscodeSummary',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetTranscodeSummaryResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_transcode_summary_with_options_async(
        self,
        request: vod_20170321_models.GetTranscodeSummaryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetTranscodeSummaryResponse:
        """
        @summary Queries transcoding summaries of audio and video files based on the file ID. A transcoding summary includes the status and progress of transcoding.
        
        @description    An audio or video file may be transcoded multiple times. This operation returns only the latest transcoding summary.
        You can query transcoding summaries for a maximum of 10 audio and video files in one request.
        You can call the [ListTranscodeTask](https://help.aliyun.com/document_detail/109120.html) operation to query historical transcoding tasks.
        **You can call this operation to query information only about transcoding tasks created within the past year.
        
        @param request: GetTranscodeSummaryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTranscodeSummaryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.video_ids):
            query['VideoIds'] = request.video_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTranscodeSummary',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetTranscodeSummaryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_transcode_summary(
        self,
        request: vod_20170321_models.GetTranscodeSummaryRequest,
    ) -> vod_20170321_models.GetTranscodeSummaryResponse:
        """
        @summary Queries transcoding summaries of audio and video files based on the file ID. A transcoding summary includes the status and progress of transcoding.
        
        @description    An audio or video file may be transcoded multiple times. This operation returns only the latest transcoding summary.
        You can query transcoding summaries for a maximum of 10 audio and video files in one request.
        You can call the [ListTranscodeTask](https://help.aliyun.com/document_detail/109120.html) operation to query historical transcoding tasks.
        **You can call this operation to query information only about transcoding tasks created within the past year.
        
        @param request: GetTranscodeSummaryRequest
        @return: GetTranscodeSummaryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_transcode_summary_with_options(request, runtime)

    async def get_transcode_summary_async(
        self,
        request: vod_20170321_models.GetTranscodeSummaryRequest,
    ) -> vod_20170321_models.GetTranscodeSummaryResponse:
        """
        @summary Queries transcoding summaries of audio and video files based on the file ID. A transcoding summary includes the status and progress of transcoding.
        
        @description    An audio or video file may be transcoded multiple times. This operation returns only the latest transcoding summary.
        You can query transcoding summaries for a maximum of 10 audio and video files in one request.
        You can call the [ListTranscodeTask](https://help.aliyun.com/document_detail/109120.html) operation to query historical transcoding tasks.
        **You can call this operation to query information only about transcoding tasks created within the past year.
        
        @param request: GetTranscodeSummaryRequest
        @return: GetTranscodeSummaryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_transcode_summary_with_options_async(request, runtime)

    def get_transcode_task_with_options(
        self,
        request: vod_20170321_models.GetTranscodeTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetTranscodeTaskResponse:
        """
        @summary Queries details about transcoding jobs based on the transcoding task ID.
        
        @description You can call this operation to query only transcoding tasks created within the past year.
        
        @param request: GetTranscodeTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTranscodeTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.transcode_task_id):
            query['TranscodeTaskId'] = request.transcode_task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTranscodeTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetTranscodeTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_transcode_task_with_options_async(
        self,
        request: vod_20170321_models.GetTranscodeTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetTranscodeTaskResponse:
        """
        @summary Queries details about transcoding jobs based on the transcoding task ID.
        
        @description You can call this operation to query only transcoding tasks created within the past year.
        
        @param request: GetTranscodeTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTranscodeTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.transcode_task_id):
            query['TranscodeTaskId'] = request.transcode_task_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTranscodeTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetTranscodeTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_transcode_task(
        self,
        request: vod_20170321_models.GetTranscodeTaskRequest,
    ) -> vod_20170321_models.GetTranscodeTaskResponse:
        """
        @summary Queries details about transcoding jobs based on the transcoding task ID.
        
        @description You can call this operation to query only transcoding tasks created within the past year.
        
        @param request: GetTranscodeTaskRequest
        @return: GetTranscodeTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_transcode_task_with_options(request, runtime)

    async def get_transcode_task_async(
        self,
        request: vod_20170321_models.GetTranscodeTaskRequest,
    ) -> vod_20170321_models.GetTranscodeTaskResponse:
        """
        @summary Queries details about transcoding jobs based on the transcoding task ID.
        
        @description You can call this operation to query only transcoding tasks created within the past year.
        
        @param request: GetTranscodeTaskRequest
        @return: GetTranscodeTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_transcode_task_with_options_async(request, runtime)

    def get_transcode_template_group_with_options(
        self,
        request: vod_20170321_models.GetTranscodeTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetTranscodeTemplateGroupResponse:
        """
        @summary Queries the details of a transcoding template group based on the template group ID.
        
        @description This operation returns information about the specified transcoding template group and the configurations of all the transcoding templates in the group.
        
        @param request: GetTranscodeTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTranscodeTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.transcode_template_group_id):
            query['TranscodeTemplateGroupId'] = request.transcode_template_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTranscodeTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetTranscodeTemplateGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_transcode_template_group_with_options_async(
        self,
        request: vod_20170321_models.GetTranscodeTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetTranscodeTemplateGroupResponse:
        """
        @summary Queries the details of a transcoding template group based on the template group ID.
        
        @description This operation returns information about the specified transcoding template group and the configurations of all the transcoding templates in the group.
        
        @param request: GetTranscodeTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTranscodeTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.transcode_template_group_id):
            query['TranscodeTemplateGroupId'] = request.transcode_template_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTranscodeTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetTranscodeTemplateGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_transcode_template_group(
        self,
        request: vod_20170321_models.GetTranscodeTemplateGroupRequest,
    ) -> vod_20170321_models.GetTranscodeTemplateGroupResponse:
        """
        @summary Queries the details of a transcoding template group based on the template group ID.
        
        @description This operation returns information about the specified transcoding template group and the configurations of all the transcoding templates in the group.
        
        @param request: GetTranscodeTemplateGroupRequest
        @return: GetTranscodeTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_transcode_template_group_with_options(request, runtime)

    async def get_transcode_template_group_async(
        self,
        request: vod_20170321_models.GetTranscodeTemplateGroupRequest,
    ) -> vod_20170321_models.GetTranscodeTemplateGroupResponse:
        """
        @summary Queries the details of a transcoding template group based on the template group ID.
        
        @description This operation returns information about the specified transcoding template group and the configurations of all the transcoding templates in the group.
        
        @param request: GetTranscodeTemplateGroupRequest
        @return: GetTranscodeTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_transcode_template_group_with_options_async(request, runtime)

    def get_urlupload_infos_with_options(
        self,
        request: vod_20170321_models.GetURLUploadInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetURLUploadInfosResponse:
        """
        @summary Queries the information about URL-based upload jobs.
        
        @description You can query the information about a URL-based upload job by specifying the upload URL or using the job ID returned when you upload media files. The information includes the status of the upload job, custom configurations, the time when the job was created, and the time when the job was complete.
        If the upload fails, you can view the error code and error message. If the upload is successful, you can obtain the video ID.
        
        @param request: GetURLUploadInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetURLUploadInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.upload_urls):
            query['UploadURLs'] = request.upload_urls
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetURLUploadInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetURLUploadInfosResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_urlupload_infos_with_options_async(
        self,
        request: vod_20170321_models.GetURLUploadInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetURLUploadInfosResponse:
        """
        @summary Queries the information about URL-based upload jobs.
        
        @description You can query the information about a URL-based upload job by specifying the upload URL or using the job ID returned when you upload media files. The information includes the status of the upload job, custom configurations, the time when the job was created, and the time when the job was complete.
        If the upload fails, you can view the error code and error message. If the upload is successful, you can obtain the video ID.
        
        @param request: GetURLUploadInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetURLUploadInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.upload_urls):
            query['UploadURLs'] = request.upload_urls
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetURLUploadInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetURLUploadInfosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_urlupload_infos(
        self,
        request: vod_20170321_models.GetURLUploadInfosRequest,
    ) -> vod_20170321_models.GetURLUploadInfosResponse:
        """
        @summary Queries the information about URL-based upload jobs.
        
        @description You can query the information about a URL-based upload job by specifying the upload URL or using the job ID returned when you upload media files. The information includes the status of the upload job, custom configurations, the time when the job was created, and the time when the job was complete.
        If the upload fails, you can view the error code and error message. If the upload is successful, you can obtain the video ID.
        
        @param request: GetURLUploadInfosRequest
        @return: GetURLUploadInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_urlupload_infos_with_options(request, runtime)

    async def get_urlupload_infos_async(
        self,
        request: vod_20170321_models.GetURLUploadInfosRequest,
    ) -> vod_20170321_models.GetURLUploadInfosResponse:
        """
        @summary Queries the information about URL-based upload jobs.
        
        @description You can query the information about a URL-based upload job by specifying the upload URL or using the job ID returned when you upload media files. The information includes the status of the upload job, custom configurations, the time when the job was created, and the time when the job was complete.
        If the upload fails, you can view the error code and error message. If the upload is successful, you can obtain the video ID.
        
        @param request: GetURLUploadInfosRequest
        @return: GetURLUploadInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_urlupload_infos_with_options_async(request, runtime)

    def get_unactivated_license_order_with_options(
        self,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetUnactivatedLicenseOrderResponse:
        """
        @summary 查询未核销license订单信息
        
        @param request: GetUnactivatedLicenseOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUnactivatedLicenseOrderResponse
        """
        req = open_api_models.OpenApiRequest()
        params = open_api_models.Params(
            action='GetUnactivatedLicenseOrder',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetUnactivatedLicenseOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_unactivated_license_order_with_options_async(
        self,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetUnactivatedLicenseOrderResponse:
        """
        @summary 查询未核销license订单信息
        
        @param request: GetUnactivatedLicenseOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUnactivatedLicenseOrderResponse
        """
        req = open_api_models.OpenApiRequest()
        params = open_api_models.Params(
            action='GetUnactivatedLicenseOrder',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetUnactivatedLicenseOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_unactivated_license_order(self) -> vod_20170321_models.GetUnactivatedLicenseOrderResponse:
        """
        @summary 查询未核销license订单信息
        
        @return: GetUnactivatedLicenseOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_unactivated_license_order_with_options(runtime)

    async def get_unactivated_license_order_async(self) -> vod_20170321_models.GetUnactivatedLicenseOrderResponse:
        """
        @summary 查询未核销license订单信息
        
        @return: GetUnactivatedLicenseOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_unactivated_license_order_with_options_async(runtime)

    def get_upload_details_with_options(
        self,
        request: vod_20170321_models.GetUploadDetailsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetUploadDetailsResponse:
        """
        @summary Queries the upload details, such as the upload time, upload ratio, and upload source, about one or more media files based on the media IDs.
        
        @description    You can call this operation to obtain the upload details only about audio and video files.
        If you use the ApsaraVideo VOD console to upload audio and video files, you can call this operation to query information such as the upload ratio. If you use an upload SDK to upload audio and video files, make sure that the version of the [upload SDK](https://help.aliyun.com/document_detail/52200.html) meets one of the following requirements:
        The version of the upload SDK for Java is 1.4.4 or later.
        The version of the upload SDK for C++ is 1.0.0 or later.
        The version of the upload SDK for PHP is 1.0.2 or later.
        The version of the upload SDK for Python is 1.3.0 or later.
        The version of the upload SDK for JavaScript is 1.4.0 or later.
        The version of the upload SDK for Android is 1.5.0 or later.
        The version of the upload SDK for iOS is 1.5.0 or later.
        
        @param request: GetUploadDetailsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUploadDetailsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetUploadDetails',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetUploadDetailsResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_upload_details_with_options_async(
        self,
        request: vod_20170321_models.GetUploadDetailsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetUploadDetailsResponse:
        """
        @summary Queries the upload details, such as the upload time, upload ratio, and upload source, about one or more media files based on the media IDs.
        
        @description    You can call this operation to obtain the upload details only about audio and video files.
        If you use the ApsaraVideo VOD console to upload audio and video files, you can call this operation to query information such as the upload ratio. If you use an upload SDK to upload audio and video files, make sure that the version of the [upload SDK](https://help.aliyun.com/document_detail/52200.html) meets one of the following requirements:
        The version of the upload SDK for Java is 1.4.4 or later.
        The version of the upload SDK for C++ is 1.0.0 or later.
        The version of the upload SDK for PHP is 1.0.2 or later.
        The version of the upload SDK for Python is 1.3.0 or later.
        The version of the upload SDK for JavaScript is 1.4.0 or later.
        The version of the upload SDK for Android is 1.5.0 or later.
        The version of the upload SDK for iOS is 1.5.0 or later.
        
        @param request: GetUploadDetailsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUploadDetailsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetUploadDetails',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetUploadDetailsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_upload_details(
        self,
        request: vod_20170321_models.GetUploadDetailsRequest,
    ) -> vod_20170321_models.GetUploadDetailsResponse:
        """
        @summary Queries the upload details, such as the upload time, upload ratio, and upload source, about one or more media files based on the media IDs.
        
        @description    You can call this operation to obtain the upload details only about audio and video files.
        If you use the ApsaraVideo VOD console to upload audio and video files, you can call this operation to query information such as the upload ratio. If you use an upload SDK to upload audio and video files, make sure that the version of the [upload SDK](https://help.aliyun.com/document_detail/52200.html) meets one of the following requirements:
        The version of the upload SDK for Java is 1.4.4 or later.
        The version of the upload SDK for C++ is 1.0.0 or later.
        The version of the upload SDK for PHP is 1.0.2 or later.
        The version of the upload SDK for Python is 1.3.0 or later.
        The version of the upload SDK for JavaScript is 1.4.0 or later.
        The version of the upload SDK for Android is 1.5.0 or later.
        The version of the upload SDK for iOS is 1.5.0 or later.
        
        @param request: GetUploadDetailsRequest
        @return: GetUploadDetailsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_upload_details_with_options(request, runtime)

    async def get_upload_details_async(
        self,
        request: vod_20170321_models.GetUploadDetailsRequest,
    ) -> vod_20170321_models.GetUploadDetailsResponse:
        """
        @summary Queries the upload details, such as the upload time, upload ratio, and upload source, about one or more media files based on the media IDs.
        
        @description    You can call this operation to obtain the upload details only about audio and video files.
        If you use the ApsaraVideo VOD console to upload audio and video files, you can call this operation to query information such as the upload ratio. If you use an upload SDK to upload audio and video files, make sure that the version of the [upload SDK](https://help.aliyun.com/document_detail/52200.html) meets one of the following requirements:
        The version of the upload SDK for Java is 1.4.4 or later.
        The version of the upload SDK for C++ is 1.0.0 or later.
        The version of the upload SDK for PHP is 1.0.2 or later.
        The version of the upload SDK for Python is 1.3.0 or later.
        The version of the upload SDK for JavaScript is 1.4.0 or later.
        The version of the upload SDK for Android is 1.5.0 or later.
        The version of the upload SDK for iOS is 1.5.0 or later.
        
        @param request: GetUploadDetailsRequest
        @return: GetUploadDetailsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_upload_details_with_options_async(request, runtime)

    def get_upload_progress_with_options(
        self,
        request: vod_20170321_models.GetUploadProgressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetUploadProgressResponse:
        """
        @summary 获取上传进度
        
        @param request: GetUploadProgressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUploadProgressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_version):
            query['AppVersion'] = request.app_version
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.auth_timestamp):
            query['AuthTimestamp'] = request.auth_timestamp
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.client_id):
            query['ClientId'] = request.client_id
        if not UtilClient.is_unset(request.device_model):
            query['DeviceModel'] = request.device_model
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.source):
            query['Source'] = request.source
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        if not UtilClient.is_unset(request.upload_address):
            query['UploadAddress'] = request.upload_address
        if not UtilClient.is_unset(request.upload_info_list):
            query['UploadInfoList'] = request.upload_info_list
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetUploadProgress',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetUploadProgressResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_upload_progress_with_options_async(
        self,
        request: vod_20170321_models.GetUploadProgressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetUploadProgressResponse:
        """
        @summary 获取上传进度
        
        @param request: GetUploadProgressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUploadProgressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_version):
            query['AppVersion'] = request.app_version
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.auth_timestamp):
            query['AuthTimestamp'] = request.auth_timestamp
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.client_id):
            query['ClientId'] = request.client_id
        if not UtilClient.is_unset(request.device_model):
            query['DeviceModel'] = request.device_model
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.source):
            query['Source'] = request.source
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        if not UtilClient.is_unset(request.upload_address):
            query['UploadAddress'] = request.upload_address
        if not UtilClient.is_unset(request.upload_info_list):
            query['UploadInfoList'] = request.upload_info_list
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetUploadProgress',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetUploadProgressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_upload_progress(
        self,
        request: vod_20170321_models.GetUploadProgressRequest,
    ) -> vod_20170321_models.GetUploadProgressResponse:
        """
        @summary 获取上传进度
        
        @param request: GetUploadProgressRequest
        @return: GetUploadProgressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_upload_progress_with_options(request, runtime)

    async def get_upload_progress_async(
        self,
        request: vod_20170321_models.GetUploadProgressRequest,
    ) -> vod_20170321_models.GetUploadProgressResponse:
        """
        @summary 获取上传进度
        
        @param request: GetUploadProgressRequest
        @return: GetUploadProgressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_upload_progress_with_options_async(request, runtime)

    def get_video_config_with_options(
        self,
        request: vod_20170321_models.GetVideoConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoConfigResponse:
        """
        @summary 获取视频配置
        
        @param request: GetVideoConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_video_config_with_options_async(
        self,
        request: vod_20170321_models.GetVideoConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoConfigResponse:
        """
        @summary 获取视频配置
        
        @param request: GetVideoConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_video_config(
        self,
        request: vod_20170321_models.GetVideoConfigRequest,
    ) -> vod_20170321_models.GetVideoConfigResponse:
        """
        @summary 获取视频配置
        
        @param request: GetVideoConfigRequest
        @return: GetVideoConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_video_config_with_options(request, runtime)

    async def get_video_config_async(
        self,
        request: vod_20170321_models.GetVideoConfigRequest,
    ) -> vod_20170321_models.GetVideoConfigResponse:
        """
        @summary 获取视频配置
        
        @param request: GetVideoConfigRequest
        @return: GetVideoConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_video_config_with_options_async(request, runtime)

    def get_video_dnaresult_with_options(
        self,
        request: vod_20170321_models.GetVideoDNAResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoDNAResultResponse:
        """
        @summary 获取视频DNA结果
        
        @param request: GetVideoDNAResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoDNAResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoDNAResult',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoDNAResultResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_video_dnaresult_with_options_async(
        self,
        request: vod_20170321_models.GetVideoDNAResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoDNAResultResponse:
        """
        @summary 获取视频DNA结果
        
        @param request: GetVideoDNAResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoDNAResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoDNAResult',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoDNAResultResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_video_dnaresult(
        self,
        request: vod_20170321_models.GetVideoDNAResultRequest,
    ) -> vod_20170321_models.GetVideoDNAResultResponse:
        """
        @summary 获取视频DNA结果
        
        @param request: GetVideoDNAResultRequest
        @return: GetVideoDNAResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_video_dnaresult_with_options(request, runtime)

    async def get_video_dnaresult_async(
        self,
        request: vod_20170321_models.GetVideoDNAResultRequest,
    ) -> vod_20170321_models.GetVideoDNAResultResponse:
        """
        @summary 获取视频DNA结果
        
        @param request: GetVideoDNAResultRequest
        @return: GetVideoDNAResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_video_dnaresult_with_options_async(request, runtime)

    def get_video_info_with_options(
        self,
        request: vod_20170321_models.GetVideoInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoInfoResponse:
        """
        @summary Obtains the title, description, duration, thumbnail URL, status, creation time, size, snapshots, category, and tags of a media file based on the file ID.
        
        @description After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: GetVideoInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_video_info_with_options_async(
        self,
        request: vod_20170321_models.GetVideoInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoInfoResponse:
        """
        @summary Obtains the title, description, duration, thumbnail URL, status, creation time, size, snapshots, category, and tags of a media file based on the file ID.
        
        @description After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: GetVideoInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_video_info(
        self,
        request: vod_20170321_models.GetVideoInfoRequest,
    ) -> vod_20170321_models.GetVideoInfoResponse:
        """
        @summary Obtains the title, description, duration, thumbnail URL, status, creation time, size, snapshots, category, and tags of a media file based on the file ID.
        
        @description After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: GetVideoInfoRequest
        @return: GetVideoInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_video_info_with_options(request, runtime)

    async def get_video_info_async(
        self,
        request: vod_20170321_models.GetVideoInfoRequest,
    ) -> vod_20170321_models.GetVideoInfoResponse:
        """
        @summary Obtains the title, description, duration, thumbnail URL, status, creation time, size, snapshots, category, and tags of a media file based on the file ID.
        
        @description After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: GetVideoInfoRequest
        @return: GetVideoInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_video_info_with_options_async(request, runtime)

    def get_video_infos_with_options(
        self,
        request: vod_20170321_models.GetVideoInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoInfosResponse:
        """
        @summary Queries information such as the title, description, duration, thumbnail URL, status, creation time, size, snapshots, category, and tags about multiple audio or video files based on IDs.
        
        @description    You can specify up to 20 audio or video file IDs in each request.
        After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: GetVideoInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.video_ids):
            query['VideoIds'] = request.video_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoInfosResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_video_infos_with_options_async(
        self,
        request: vod_20170321_models.GetVideoInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoInfosResponse:
        """
        @summary Queries information such as the title, description, duration, thumbnail URL, status, creation time, size, snapshots, category, and tags about multiple audio or video files based on IDs.
        
        @description    You can specify up to 20 audio or video file IDs in each request.
        After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: GetVideoInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.video_ids):
            query['VideoIds'] = request.video_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoInfosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_video_infos(
        self,
        request: vod_20170321_models.GetVideoInfosRequest,
    ) -> vod_20170321_models.GetVideoInfosResponse:
        """
        @summary Queries information such as the title, description, duration, thumbnail URL, status, creation time, size, snapshots, category, and tags about multiple audio or video files based on IDs.
        
        @description    You can specify up to 20 audio or video file IDs in each request.
        After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: GetVideoInfosRequest
        @return: GetVideoInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_video_infos_with_options(request, runtime)

    async def get_video_infos_async(
        self,
        request: vod_20170321_models.GetVideoInfosRequest,
    ) -> vod_20170321_models.GetVideoInfosResponse:
        """
        @summary Queries information such as the title, description, duration, thumbnail URL, status, creation time, size, snapshots, category, and tags about multiple audio or video files based on IDs.
        
        @description    You can specify up to 20 audio or video file IDs in each request.
        After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: GetVideoInfosRequest
        @return: GetVideoInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_video_infos_with_options_async(request, runtime)

    def get_video_list_with_options(
        self,
        request: vod_20170321_models.GetVideoListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoListResponse:
        """
        @summary Queries information about media files.
        
        @description You can call this operation to query information about media files based on the filter conditions that you specify, such as video status and category ID. Information about a maximum of *5,000** media files can be returned for each request. We recommend that you set the StartTime and EndTime parameters to specify a time range for each request. For more information about how to query information about more media files or even all media files, see [SearchMedia](https://help.aliyun.com/document_detail/86044.html).
        
        @param request: GetVideoListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoListResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_video_list_with_options_async(
        self,
        request: vod_20170321_models.GetVideoListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoListResponse:
        """
        @summary Queries information about media files.
        
        @description You can call this operation to query information about media files based on the filter conditions that you specify, such as video status and category ID. Information about a maximum of *5,000** media files can be returned for each request. We recommend that you set the StartTime and EndTime parameters to specify a time range for each request. For more information about how to query information about more media files or even all media files, see [SearchMedia](https://help.aliyun.com/document_detail/86044.html).
        
        @param request: GetVideoListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoList',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_video_list(
        self,
        request: vod_20170321_models.GetVideoListRequest,
    ) -> vod_20170321_models.GetVideoListResponse:
        """
        @summary Queries information about media files.
        
        @description You can call this operation to query information about media files based on the filter conditions that you specify, such as video status and category ID. Information about a maximum of *5,000** media files can be returned for each request. We recommend that you set the StartTime and EndTime parameters to specify a time range for each request. For more information about how to query information about more media files or even all media files, see [SearchMedia](https://help.aliyun.com/document_detail/86044.html).
        
        @param request: GetVideoListRequest
        @return: GetVideoListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_video_list_with_options(request, runtime)

    async def get_video_list_async(
        self,
        request: vod_20170321_models.GetVideoListRequest,
    ) -> vod_20170321_models.GetVideoListResponse:
        """
        @summary Queries information about media files.
        
        @description You can call this operation to query information about media files based on the filter conditions that you specify, such as video status and category ID. Information about a maximum of *5,000** media files can be returned for each request. We recommend that you set the StartTime and EndTime parameters to specify a time range for each request. For more information about how to query information about more media files or even all media files, see [SearchMedia](https://help.aliyun.com/document_detail/86044.html).
        
        @param request: GetVideoListRequest
        @return: GetVideoListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_video_list_with_options_async(request, runtime)

    def get_video_play_auth_with_options(
        self,
        request: vod_20170321_models.GetVideoPlayAuthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoPlayAuthResponse:
        """
        @summary Queries the credential required for media playback. ApsaraVideo Player SDK automatically obtains the playback URL based on the playback credential. Each playback credential can be used to obtain the playback URL only for a specific video in a specific period of time. You cannot obtain the playback URL if the credential expires or is incorrect. You can use PlayAuth-based playback when you require high security for audio and video playback.
        
        @description    You can call this operation to obtain a playback credential when you use ApsaraVideo Player SDK to play a media file based on PlayAuth. The credential is used to obtain the playback URL. For more information, see [ApsaraVideo Player SDK](https://help.aliyun.com/document_detail/125579.html).
        You cannot obtain the playback URL of a video by using a credential that has expired. A new credential is required.
        
        @param request: GetVideoPlayAuthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoPlayAuthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.api_version):
            query['ApiVersion'] = request.api_version
        if not UtilClient.is_unset(request.auth_info_timeout):
            query['AuthInfoTimeout'] = request.auth_info_timeout
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoPlayAuth',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoPlayAuthResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_video_play_auth_with_options_async(
        self,
        request: vod_20170321_models.GetVideoPlayAuthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoPlayAuthResponse:
        """
        @summary Queries the credential required for media playback. ApsaraVideo Player SDK automatically obtains the playback URL based on the playback credential. Each playback credential can be used to obtain the playback URL only for a specific video in a specific period of time. You cannot obtain the playback URL if the credential expires or is incorrect. You can use PlayAuth-based playback when you require high security for audio and video playback.
        
        @description    You can call this operation to obtain a playback credential when you use ApsaraVideo Player SDK to play a media file based on PlayAuth. The credential is used to obtain the playback URL. For more information, see [ApsaraVideo Player SDK](https://help.aliyun.com/document_detail/125579.html).
        You cannot obtain the playback URL of a video by using a credential that has expired. A new credential is required.
        
        @param request: GetVideoPlayAuthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoPlayAuthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.api_version):
            query['ApiVersion'] = request.api_version
        if not UtilClient.is_unset(request.auth_info_timeout):
            query['AuthInfoTimeout'] = request.auth_info_timeout
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoPlayAuth',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoPlayAuthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_video_play_auth(
        self,
        request: vod_20170321_models.GetVideoPlayAuthRequest,
    ) -> vod_20170321_models.GetVideoPlayAuthResponse:
        """
        @summary Queries the credential required for media playback. ApsaraVideo Player SDK automatically obtains the playback URL based on the playback credential. Each playback credential can be used to obtain the playback URL only for a specific video in a specific period of time. You cannot obtain the playback URL if the credential expires or is incorrect. You can use PlayAuth-based playback when you require high security for audio and video playback.
        
        @description    You can call this operation to obtain a playback credential when you use ApsaraVideo Player SDK to play a media file based on PlayAuth. The credential is used to obtain the playback URL. For more information, see [ApsaraVideo Player SDK](https://help.aliyun.com/document_detail/125579.html).
        You cannot obtain the playback URL of a video by using a credential that has expired. A new credential is required.
        
        @param request: GetVideoPlayAuthRequest
        @return: GetVideoPlayAuthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_video_play_auth_with_options(request, runtime)

    async def get_video_play_auth_async(
        self,
        request: vod_20170321_models.GetVideoPlayAuthRequest,
    ) -> vod_20170321_models.GetVideoPlayAuthResponse:
        """
        @summary Queries the credential required for media playback. ApsaraVideo Player SDK automatically obtains the playback URL based on the playback credential. Each playback credential can be used to obtain the playback URL only for a specific video in a specific period of time. You cannot obtain the playback URL if the credential expires or is incorrect. You can use PlayAuth-based playback when you require high security for audio and video playback.
        
        @description    You can call this operation to obtain a playback credential when you use ApsaraVideo Player SDK to play a media file based on PlayAuth. The credential is used to obtain the playback URL. For more information, see [ApsaraVideo Player SDK](https://help.aliyun.com/document_detail/125579.html).
        You cannot obtain the playback URL of a video by using a credential that has expired. A new credential is required.
        
        @param request: GetVideoPlayAuthRequest
        @return: GetVideoPlayAuthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_video_play_auth_with_options_async(request, runtime)

    def get_video_play_info_with_options(
        self,
        request: vod_20170321_models.GetVideoPlayInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoPlayInfoResponse:
        """
        @summary 获取视频播放信息
        
        @param request: GetVideoPlayInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoPlayInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.channel):
            query['Channel'] = request.channel
        if not UtilClient.is_unset(request.client_ts):
            query['ClientTS'] = request.client_ts
        if not UtilClient.is_unset(request.client_version):
            query['ClientVersion'] = request.client_version
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.play_sign):
            query['PlaySign'] = request.play_sign
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.sign_version):
            query['SignVersion'] = request.sign_version
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoPlayInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoPlayInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_video_play_info_with_options_async(
        self,
        request: vod_20170321_models.GetVideoPlayInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVideoPlayInfoResponse:
        """
        @summary 获取视频播放信息
        
        @param request: GetVideoPlayInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVideoPlayInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.channel):
            query['Channel'] = request.channel
        if not UtilClient.is_unset(request.client_ts):
            query['ClientTS'] = request.client_ts
        if not UtilClient.is_unset(request.client_version):
            query['ClientVersion'] = request.client_version
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.play_sign):
            query['PlaySign'] = request.play_sign
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.sign_version):
            query['SignVersion'] = request.sign_version
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVideoPlayInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVideoPlayInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_video_play_info(
        self,
        request: vod_20170321_models.GetVideoPlayInfoRequest,
    ) -> vod_20170321_models.GetVideoPlayInfoResponse:
        """
        @summary 获取视频播放信息
        
        @param request: GetVideoPlayInfoRequest
        @return: GetVideoPlayInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_video_play_info_with_options(request, runtime)

    async def get_video_play_info_async(
        self,
        request: vod_20170321_models.GetVideoPlayInfoRequest,
    ) -> vod_20170321_models.GetVideoPlayInfoResponse:
        """
        @summary 获取视频播放信息
        
        @param request: GetVideoPlayInfoRequest
        @return: GetVideoPlayInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_video_play_info_with_options_async(request, runtime)

    def get_vod_service_region_with_options(
        self,
        request: vod_20170321_models.GetVodServiceRegionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVodServiceRegionResponse:
        """
        @summary 获取点播服务区域
        
        @param request: GetVodServiceRegionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVodServiceRegionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVodServiceRegion',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVodServiceRegionResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_vod_service_region_with_options_async(
        self,
        request: vod_20170321_models.GetVodServiceRegionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVodServiceRegionResponse:
        """
        @summary 获取点播服务区域
        
        @param request: GetVodServiceRegionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVodServiceRegionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVodServiceRegion',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVodServiceRegionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_vod_service_region(
        self,
        request: vod_20170321_models.GetVodServiceRegionRequest,
    ) -> vod_20170321_models.GetVodServiceRegionResponse:
        """
        @summary 获取点播服务区域
        
        @param request: GetVodServiceRegionRequest
        @return: GetVodServiceRegionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_vod_service_region_with_options(request, runtime)

    async def get_vod_service_region_async(
        self,
        request: vod_20170321_models.GetVodServiceRegionRequest,
    ) -> vod_20170321_models.GetVodServiceRegionResponse:
        """
        @summary 获取点播服务区域
        
        @param request: GetVodServiceRegionRequest
        @return: GetVodServiceRegionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_vod_service_region_with_options_async(request, runtime)

    def get_vod_template_with_options(
        self,
        request: vod_20170321_models.GetVodTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVodTemplateResponse:
        """
        @summary Queries a single snapshot template.
        
        @param request: GetVodTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVodTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.vod_template_id):
            query['VodTemplateId'] = request.vod_template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVodTemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVodTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_vod_template_with_options_async(
        self,
        request: vod_20170321_models.GetVodTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetVodTemplateResponse:
        """
        @summary Queries a single snapshot template.
        
        @param request: GetVodTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetVodTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.vod_template_id):
            query['VodTemplateId'] = request.vod_template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetVodTemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetVodTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_vod_template(
        self,
        request: vod_20170321_models.GetVodTemplateRequest,
    ) -> vod_20170321_models.GetVodTemplateResponse:
        """
        @summary Queries a single snapshot template.
        
        @param request: GetVodTemplateRequest
        @return: GetVodTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_vod_template_with_options(request, runtime)

    async def get_vod_template_async(
        self,
        request: vod_20170321_models.GetVodTemplateRequest,
    ) -> vod_20170321_models.GetVodTemplateResponse:
        """
        @summary Queries a single snapshot template.
        
        @param request: GetVodTemplateRequest
        @return: GetVodTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_vod_template_with_options_async(request, runtime)

    def get_watermark_with_options(
        self,
        request: vod_20170321_models.GetWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetWatermarkResponse:
        """
        @summary Queries the information about an image or text watermark based on the watermark template ID. You can call this operation to obtain information such as the position, size, and display time of an image watermark or the content, position, font, and font color of a text watermark.
        
        @param request: GetWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetWatermark',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetWatermarkResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_watermark_with_options_async(
        self,
        request: vod_20170321_models.GetWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetWatermarkResponse:
        """
        @summary Queries the information about an image or text watermark based on the watermark template ID. You can call this operation to obtain information such as the position, size, and display time of an image watermark or the content, position, font, and font color of a text watermark.
        
        @param request: GetWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetWatermark',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetWatermarkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_watermark(
        self,
        request: vod_20170321_models.GetWatermarkRequest,
    ) -> vod_20170321_models.GetWatermarkResponse:
        """
        @summary Queries the information about an image or text watermark based on the watermark template ID. You can call this operation to obtain information such as the position, size, and display time of an image watermark or the content, position, font, and font color of a text watermark.
        
        @param request: GetWatermarkRequest
        @return: GetWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_watermark_with_options(request, runtime)

    async def get_watermark_async(
        self,
        request: vod_20170321_models.GetWatermarkRequest,
    ) -> vod_20170321_models.GetWatermarkResponse:
        """
        @summary Queries the information about an image or text watermark based on the watermark template ID. You can call this operation to obtain information such as the position, size, and display time of an image watermark or the content, position, font, and font color of a text watermark.
        
        @param request: GetWatermarkRequest
        @return: GetWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_watermark_with_options_async(request, runtime)

    def get_watermark_console_with_options(
        self,
        request: vod_20170321_models.GetWatermarkConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetWatermarkConsoleResponse:
        """
        @summary 获取水印
        
        @param request: GetWatermarkConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetWatermarkConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetWatermarkConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetWatermarkConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_watermark_console_with_options_async(
        self,
        request: vod_20170321_models.GetWatermarkConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetWatermarkConsoleResponse:
        """
        @summary 获取水印
        
        @param request: GetWatermarkConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetWatermarkConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetWatermarkConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetWatermarkConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_watermark_console(
        self,
        request: vod_20170321_models.GetWatermarkConsoleRequest,
    ) -> vod_20170321_models.GetWatermarkConsoleResponse:
        """
        @summary 获取水印
        
        @param request: GetWatermarkConsoleRequest
        @return: GetWatermarkConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_watermark_console_with_options(request, runtime)

    async def get_watermark_console_async(
        self,
        request: vod_20170321_models.GetWatermarkConsoleRequest,
    ) -> vod_20170321_models.GetWatermarkConsoleResponse:
        """
        @summary 获取水印
        
        @param request: GetWatermarkConsoleRequest
        @return: GetWatermarkConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_watermark_console_with_options_async(request, runtime)

    def get_watermarks_console_with_options(
        self,
        request: vod_20170321_models.GetWatermarksConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetWatermarksConsoleResponse:
        """
        @summary 获取水印
        
        @param request: GetWatermarksConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetWatermarksConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetWatermarksConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetWatermarksConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_watermarks_console_with_options_async(
        self,
        request: vod_20170321_models.GetWatermarksConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetWatermarksConsoleResponse:
        """
        @summary 获取水印
        
        @param request: GetWatermarksConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetWatermarksConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetWatermarksConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetWatermarksConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_watermarks_console(
        self,
        request: vod_20170321_models.GetWatermarksConsoleRequest,
    ) -> vod_20170321_models.GetWatermarksConsoleResponse:
        """
        @summary 获取水印
        
        @param request: GetWatermarksConsoleRequest
        @return: GetWatermarksConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_watermarks_console_with_options(request, runtime)

    async def get_watermarks_console_async(
        self,
        request: vod_20170321_models.GetWatermarksConsoleRequest,
    ) -> vod_20170321_models.GetWatermarksConsoleResponse:
        """
        @summary 获取水印
        
        @param request: GetWatermarksConsoleRequest
        @return: GetWatermarksConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_watermarks_console_with_options_async(request, runtime)

    def get_workflow_with_options(
        self,
        request: vod_20170321_models.GetWorkflowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetWorkflowResponse:
        """
        @summary 获取工作流信息
        
        @param request: GetWorkflowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetWorkflowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetWorkflow',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetWorkflowResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_workflow_with_options_async(
        self,
        request: vod_20170321_models.GetWorkflowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.GetWorkflowResponse:
        """
        @summary 获取工作流信息
        
        @param request: GetWorkflowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetWorkflowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetWorkflow',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.GetWorkflowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_workflow(
        self,
        request: vod_20170321_models.GetWorkflowRequest,
    ) -> vod_20170321_models.GetWorkflowResponse:
        """
        @summary 获取工作流信息
        
        @param request: GetWorkflowRequest
        @return: GetWorkflowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_workflow_with_options(request, runtime)

    async def get_workflow_async(
        self,
        request: vod_20170321_models.GetWorkflowRequest,
    ) -> vod_20170321_models.GetWorkflowResponse:
        """
        @summary 获取工作流信息
        
        @param request: GetWorkflowRequest
        @return: GetWorkflowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_workflow_with_options_async(request, runtime)

    def http_request_vod_test_tool_with_options(
        self,
        tmp_req: vod_20170321_models.HttpRequestVodTestToolRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.HttpRequestVodTestToolResponse:
        """
        @summary 测试HTTP请求
        
        @param tmp_req: HttpRequestVodTestToolRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: HttpRequestVodTestToolResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vod_20170321_models.HttpRequestVodTestToolShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.header):
            request.header_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.header, 'Header', 'json')
        query = {}
        if not UtilClient.is_unset(request.args):
            query['Args'] = request.args
        if not UtilClient.is_unset(request.body):
            query['Body'] = request.body
        if not UtilClient.is_unset(request.header_shrink):
            query['Header'] = request.header_shrink
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.method):
            query['Method'] = request.method
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.proxy_ip):
            query['ProxyIp'] = request.proxy_ip
        if not UtilClient.is_unset(request.scheme):
            query['Scheme'] = request.scheme
        if not UtilClient.is_unset(request.uri):
            query['Uri'] = request.uri
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='HttpRequestVodTestTool',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.HttpRequestVodTestToolResponse(),
            self.call_api(params, req, runtime)
        )

    async def http_request_vod_test_tool_with_options_async(
        self,
        tmp_req: vod_20170321_models.HttpRequestVodTestToolRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.HttpRequestVodTestToolResponse:
        """
        @summary 测试HTTP请求
        
        @param tmp_req: HttpRequestVodTestToolRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: HttpRequestVodTestToolResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vod_20170321_models.HttpRequestVodTestToolShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.header):
            request.header_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.header, 'Header', 'json')
        query = {}
        if not UtilClient.is_unset(request.args):
            query['Args'] = request.args
        if not UtilClient.is_unset(request.body):
            query['Body'] = request.body
        if not UtilClient.is_unset(request.header_shrink):
            query['Header'] = request.header_shrink
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.method):
            query['Method'] = request.method
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.proxy_ip):
            query['ProxyIp'] = request.proxy_ip
        if not UtilClient.is_unset(request.scheme):
            query['Scheme'] = request.scheme
        if not UtilClient.is_unset(request.uri):
            query['Uri'] = request.uri
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='HttpRequestVodTestTool',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.HttpRequestVodTestToolResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def http_request_vod_test_tool(
        self,
        request: vod_20170321_models.HttpRequestVodTestToolRequest,
    ) -> vod_20170321_models.HttpRequestVodTestToolResponse:
        """
        @summary 测试HTTP请求
        
        @param request: HttpRequestVodTestToolRequest
        @return: HttpRequestVodTestToolResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.http_request_vod_test_tool_with_options(request, runtime)

    async def http_request_vod_test_tool_async(
        self,
        request: vod_20170321_models.HttpRequestVodTestToolRequest,
    ) -> vod_20170321_models.HttpRequestVodTestToolResponse:
        """
        @summary 测试HTTP请求
        
        @param request: HttpRequestVodTestToolRequest
        @return: HttpRequestVodTestToolResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.http_request_vod_test_tool_with_options_async(request, runtime)

    def initial_transcode_config_with_options(
        self,
        request: vod_20170321_models.InitialTranscodeConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.InitialTranscodeConfigResponse:
        """
        @summary 初始化转码配置
        
        @param request: InitialTranscodeConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: InitialTranscodeConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InitialTranscodeConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.InitialTranscodeConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def initial_transcode_config_with_options_async(
        self,
        request: vod_20170321_models.InitialTranscodeConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.InitialTranscodeConfigResponse:
        """
        @summary 初始化转码配置
        
        @param request: InitialTranscodeConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: InitialTranscodeConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InitialTranscodeConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.InitialTranscodeConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def initial_transcode_config(
        self,
        request: vod_20170321_models.InitialTranscodeConfigRequest,
    ) -> vod_20170321_models.InitialTranscodeConfigResponse:
        """
        @summary 初始化转码配置
        
        @param request: InitialTranscodeConfigRequest
        @return: InitialTranscodeConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.initial_transcode_config_with_options(request, runtime)

    async def initial_transcode_config_async(
        self,
        request: vod_20170321_models.InitialTranscodeConfigRequest,
    ) -> vod_20170321_models.InitialTranscodeConfigResponse:
        """
        @summary 初始化转码配置
        
        @param request: InitialTranscodeConfigRequest
        @return: InitialTranscodeConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.initial_transcode_config_with_options_async(request, runtime)

    def list_aiasrjob_with_options(
        self,
        request: vod_20170321_models.ListAIASRJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIASRJobResponse:
        """
        @summary 列举AIASR任务
        
        @param request: ListAIASRJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIASRJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aiasrjob_ids):
            query['AIASRJobIds'] = request.aiasrjob_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIASRJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIASRJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aiasrjob_with_options_async(
        self,
        request: vod_20170321_models.ListAIASRJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIASRJobResponse:
        """
        @summary 列举AIASR任务
        
        @param request: ListAIASRJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIASRJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aiasrjob_ids):
            query['AIASRJobIds'] = request.aiasrjob_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIASRJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIASRJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aiasrjob(
        self,
        request: vod_20170321_models.ListAIASRJobRequest,
    ) -> vod_20170321_models.ListAIASRJobResponse:
        """
        @summary 列举AIASR任务
        
        @param request: ListAIASRJobRequest
        @return: ListAIASRJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aiasrjob_with_options(request, runtime)

    async def list_aiasrjob_async(
        self,
        request: vod_20170321_models.ListAIASRJobRequest,
    ) -> vod_20170321_models.ListAIASRJobResponse:
        """
        @summary 列举AIASR任务
        
        @param request: ListAIASRJobRequest
        @return: ListAIASRJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aiasrjob_with_options_async(request, runtime)

    def list_aiimage_info_with_options(
        self,
        request: vod_20170321_models.ListAIImageInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIImageInfoResponse:
        """
        @summary Queries the AI processing results about the images of a specified video.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        You can call this operation to query AI processing results about images of a specified video. Images of different videos cannot be queried in one request.
        
        @param request: ListAIImageInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIImageInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIImageInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIImageInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aiimage_info_with_options_async(
        self,
        request: vod_20170321_models.ListAIImageInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIImageInfoResponse:
        """
        @summary Queries the AI processing results about the images of a specified video.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        You can call this operation to query AI processing results about images of a specified video. Images of different videos cannot be queried in one request.
        
        @param request: ListAIImageInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIImageInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIImageInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIImageInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aiimage_info(
        self,
        request: vod_20170321_models.ListAIImageInfoRequest,
    ) -> vod_20170321_models.ListAIImageInfoResponse:
        """
        @summary Queries the AI processing results about the images of a specified video.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        You can call this operation to query AI processing results about images of a specified video. Images of different videos cannot be queried in one request.
        
        @param request: ListAIImageInfoRequest
        @return: ListAIImageInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aiimage_info_with_options(request, runtime)

    async def list_aiimage_info_async(
        self,
        request: vod_20170321_models.ListAIImageInfoRequest,
    ) -> vod_20170321_models.ListAIImageInfoResponse:
        """
        @summary Queries the AI processing results about the images of a specified video.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        You can call this operation to query AI processing results about images of a specified video. Images of different videos cannot be queried in one request.
        
        @param request: ListAIImageInfoRequest
        @return: ListAIImageInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aiimage_info_with_options_async(request, runtime)

    def list_aijob_with_options(
        self,
        request: vod_20170321_models.ListAIJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIJobResponse:
        """
        @summary Queries AI jobs. After a job is submitted, ApsaraVideo VOD asynchronously processes the job. You can call this operation to query the job information in real time.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can call this operation to query video fingerprinting jobs and smart tagging jobs.
        
        @param request: ListAIJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aijob_with_options_async(
        self,
        request: vod_20170321_models.ListAIJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIJobResponse:
        """
        @summary Queries AI jobs. After a job is submitted, ApsaraVideo VOD asynchronously processes the job. You can call this operation to query the job information in real time.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can call this operation to query video fingerprinting jobs and smart tagging jobs.
        
        @param request: ListAIJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aijob(
        self,
        request: vod_20170321_models.ListAIJobRequest,
    ) -> vod_20170321_models.ListAIJobResponse:
        """
        @summary Queries AI jobs. After a job is submitted, ApsaraVideo VOD asynchronously processes the job. You can call this operation to query the job information in real time.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can call this operation to query video fingerprinting jobs and smart tagging jobs.
        
        @param request: ListAIJobRequest
        @return: ListAIJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aijob_with_options(request, runtime)

    async def list_aijob_async(
        self,
        request: vod_20170321_models.ListAIJobRequest,
    ) -> vod_20170321_models.ListAIJobResponse:
        """
        @summary Queries AI jobs. After a job is submitted, ApsaraVideo VOD asynchronously processes the job. You can call this operation to query the job information in real time.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can call this operation to query video fingerprinting jobs and smart tagging jobs.
        
        @param request: ListAIJobRequest
        @return: ListAIJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aijob_with_options_async(request, runtime)

    def list_aistatis_type_with_options(
        self,
        request: vod_20170321_models.ListAIStatisTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIStatisTypeResponse:
        """
        @summary 列举AI统计类型
        
        @param request: ListAIStatisTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIStatisTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIStatisType',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIStatisTypeResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aistatis_type_with_options_async(
        self,
        request: vod_20170321_models.ListAIStatisTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIStatisTypeResponse:
        """
        @summary 列举AI统计类型
        
        @param request: ListAIStatisTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIStatisTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIStatisType',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIStatisTypeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aistatis_type(
        self,
        request: vod_20170321_models.ListAIStatisTypeRequest,
    ) -> vod_20170321_models.ListAIStatisTypeResponse:
        """
        @summary 列举AI统计类型
        
        @param request: ListAIStatisTypeRequest
        @return: ListAIStatisTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aistatis_type_with_options(request, runtime)

    async def list_aistatis_type_async(
        self,
        request: vod_20170321_models.ListAIStatisTypeRequest,
    ) -> vod_20170321_models.ListAIStatisTypeResponse:
        """
        @summary 列举AI统计类型
        
        @param request: ListAIStatisTypeRequest
        @return: ListAIStatisTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aistatis_type_with_options_async(request, runtime)

    def list_aitemplate_with_options(
        self,
        request: vod_20170321_models.ListAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAITemplateResponse:
        """
        @summary Queries AI templates.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can call this operation to query AI templates of a specified type.
        
        @param request: ListAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAITemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aitemplate_with_options_async(
        self,
        request: vod_20170321_models.ListAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAITemplateResponse:
        """
        @summary Queries AI templates.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can call this operation to query AI templates of a specified type.
        
        @param request: ListAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAITemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aitemplate(
        self,
        request: vod_20170321_models.ListAITemplateRequest,
    ) -> vod_20170321_models.ListAITemplateResponse:
        """
        @summary Queries AI templates.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can call this operation to query AI templates of a specified type.
        
        @param request: ListAITemplateRequest
        @return: ListAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aitemplate_with_options(request, runtime)

    async def list_aitemplate_async(
        self,
        request: vod_20170321_models.ListAITemplateRequest,
    ) -> vod_20170321_models.ListAITemplateResponse:
        """
        @summary Queries AI templates.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        You can call this operation to query AI templates of a specified type.
        
        @param request: ListAITemplateRequest
        @return: ListAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aitemplate_with_options_async(request, runtime)

    def list_aivideo_category_job_with_options(
        self,
        request: vod_20170321_models.ListAIVideoCategoryJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoCategoryJobResponse:
        """
        @summary 列举AI智能分类任务
        
        @param request: ListAIVideoCategoryJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoCategoryJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_category_job_ids):
            query['AIVideoCategoryJobIds'] = request.aivideo_category_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoCategoryJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoCategoryJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aivideo_category_job_with_options_async(
        self,
        request: vod_20170321_models.ListAIVideoCategoryJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoCategoryJobResponse:
        """
        @summary 列举AI智能分类任务
        
        @param request: ListAIVideoCategoryJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoCategoryJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_category_job_ids):
            query['AIVideoCategoryJobIds'] = request.aivideo_category_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoCategoryJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoCategoryJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aivideo_category_job(
        self,
        request: vod_20170321_models.ListAIVideoCategoryJobRequest,
    ) -> vod_20170321_models.ListAIVideoCategoryJobResponse:
        """
        @summary 列举AI智能分类任务
        
        @param request: ListAIVideoCategoryJobRequest
        @return: ListAIVideoCategoryJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aivideo_category_job_with_options(request, runtime)

    async def list_aivideo_category_job_async(
        self,
        request: vod_20170321_models.ListAIVideoCategoryJobRequest,
    ) -> vod_20170321_models.ListAIVideoCategoryJobResponse:
        """
        @summary 列举AI智能分类任务
        
        @param request: ListAIVideoCategoryJobRequest
        @return: ListAIVideoCategoryJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aivideo_category_job_with_options_async(request, runtime)

    def list_aivideo_censor_job_with_options(
        self,
        request: vod_20170321_models.ListAIVideoCensorJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoCensorJobResponse:
        """
        @summary 列举视频审核任务
        
        @param request: ListAIVideoCensorJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoCensorJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_censor_job_ids):
            query['AIVideoCensorJobIds'] = request.aivideo_censor_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoCensorJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoCensorJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aivideo_censor_job_with_options_async(
        self,
        request: vod_20170321_models.ListAIVideoCensorJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoCensorJobResponse:
        """
        @summary 列举视频审核任务
        
        @param request: ListAIVideoCensorJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoCensorJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_censor_job_ids):
            query['AIVideoCensorJobIds'] = request.aivideo_censor_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoCensorJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoCensorJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aivideo_censor_job(
        self,
        request: vod_20170321_models.ListAIVideoCensorJobRequest,
    ) -> vod_20170321_models.ListAIVideoCensorJobResponse:
        """
        @summary 列举视频审核任务
        
        @param request: ListAIVideoCensorJobRequest
        @return: ListAIVideoCensorJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aivideo_censor_job_with_options(request, runtime)

    async def list_aivideo_censor_job_async(
        self,
        request: vod_20170321_models.ListAIVideoCensorJobRequest,
    ) -> vod_20170321_models.ListAIVideoCensorJobResponse:
        """
        @summary 列举视频审核任务
        
        @param request: ListAIVideoCensorJobRequest
        @return: ListAIVideoCensorJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aivideo_censor_job_with_options_async(request, runtime)

    def list_aivideo_cover_job_with_options(
        self,
        request: vod_20170321_models.ListAIVideoCoverJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoCoverJobResponse:
        """
        @summary 列举AI封面任务
        
        @param request: ListAIVideoCoverJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoCoverJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_cover_job_ids):
            query['AIVideoCoverJobIds'] = request.aivideo_cover_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoCoverJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoCoverJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aivideo_cover_job_with_options_async(
        self,
        request: vod_20170321_models.ListAIVideoCoverJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoCoverJobResponse:
        """
        @summary 列举AI封面任务
        
        @param request: ListAIVideoCoverJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoCoverJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_cover_job_ids):
            query['AIVideoCoverJobIds'] = request.aivideo_cover_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoCoverJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoCoverJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aivideo_cover_job(
        self,
        request: vod_20170321_models.ListAIVideoCoverJobRequest,
    ) -> vod_20170321_models.ListAIVideoCoverJobResponse:
        """
        @summary 列举AI封面任务
        
        @param request: ListAIVideoCoverJobRequest
        @return: ListAIVideoCoverJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aivideo_cover_job_with_options(request, runtime)

    async def list_aivideo_cover_job_async(
        self,
        request: vod_20170321_models.ListAIVideoCoverJobRequest,
    ) -> vod_20170321_models.ListAIVideoCoverJobResponse:
        """
        @summary 列举AI封面任务
        
        @param request: ListAIVideoCoverJobRequest
        @return: ListAIVideoCoverJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aivideo_cover_job_with_options_async(request, runtime)

    def list_aivideo_face_recog_job_with_options(
        self,
        request: vod_20170321_models.ListAIVideoFaceRecogJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoFaceRecogJobResponse:
        """
        @summary 列举AI人脸识别任务
        
        @param request: ListAIVideoFaceRecogJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoFaceRecogJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_face_recog_job_ids):
            query['AIVideoFaceRecogJobIds'] = request.aivideo_face_recog_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoFaceRecogJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoFaceRecogJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aivideo_face_recog_job_with_options_async(
        self,
        request: vod_20170321_models.ListAIVideoFaceRecogJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoFaceRecogJobResponse:
        """
        @summary 列举AI人脸识别任务
        
        @param request: ListAIVideoFaceRecogJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoFaceRecogJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_face_recog_job_ids):
            query['AIVideoFaceRecogJobIds'] = request.aivideo_face_recog_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoFaceRecogJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoFaceRecogJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aivideo_face_recog_job(
        self,
        request: vod_20170321_models.ListAIVideoFaceRecogJobRequest,
    ) -> vod_20170321_models.ListAIVideoFaceRecogJobResponse:
        """
        @summary 列举AI人脸识别任务
        
        @param request: ListAIVideoFaceRecogJobRequest
        @return: ListAIVideoFaceRecogJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aivideo_face_recog_job_with_options(request, runtime)

    async def list_aivideo_face_recog_job_async(
        self,
        request: vod_20170321_models.ListAIVideoFaceRecogJobRequest,
    ) -> vod_20170321_models.ListAIVideoFaceRecogJobResponse:
        """
        @summary 列举AI人脸识别任务
        
        @param request: ListAIVideoFaceRecogJobRequest
        @return: ListAIVideoFaceRecogJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aivideo_face_recog_job_with_options_async(request, runtime)

    def list_aivideo_porn_recog_job_with_options(
        self,
        request: vod_20170321_models.ListAIVideoPornRecogJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoPornRecogJobResponse:
        """
        @summary 列举AI审核任务
        
        @param request: ListAIVideoPornRecogJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoPornRecogJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_porn_recog_job_ids):
            query['AIVideoPornRecogJobIds'] = request.aivideo_porn_recog_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoPornRecogJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoPornRecogJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aivideo_porn_recog_job_with_options_async(
        self,
        request: vod_20170321_models.ListAIVideoPornRecogJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoPornRecogJobResponse:
        """
        @summary 列举AI审核任务
        
        @param request: ListAIVideoPornRecogJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoPornRecogJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_porn_recog_job_ids):
            query['AIVideoPornRecogJobIds'] = request.aivideo_porn_recog_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoPornRecogJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoPornRecogJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aivideo_porn_recog_job(
        self,
        request: vod_20170321_models.ListAIVideoPornRecogJobRequest,
    ) -> vod_20170321_models.ListAIVideoPornRecogJobResponse:
        """
        @summary 列举AI审核任务
        
        @param request: ListAIVideoPornRecogJobRequest
        @return: ListAIVideoPornRecogJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aivideo_porn_recog_job_with_options(request, runtime)

    async def list_aivideo_porn_recog_job_async(
        self,
        request: vod_20170321_models.ListAIVideoPornRecogJobRequest,
    ) -> vod_20170321_models.ListAIVideoPornRecogJobResponse:
        """
        @summary 列举AI审核任务
        
        @param request: ListAIVideoPornRecogJobRequest
        @return: ListAIVideoPornRecogJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aivideo_porn_recog_job_with_options_async(request, runtime)

    def list_aivideo_summary_job_with_options(
        self,
        request: vod_20170321_models.ListAIVideoSummaryJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoSummaryJobResponse:
        """
        @summary 列举AI智能摘要任务
        
        @param request: ListAIVideoSummaryJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoSummaryJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_summary_job_ids):
            query['AIVideoSummaryJobIds'] = request.aivideo_summary_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoSummaryJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoSummaryJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aivideo_summary_job_with_options_async(
        self,
        request: vod_20170321_models.ListAIVideoSummaryJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoSummaryJobResponse:
        """
        @summary 列举AI智能摘要任务
        
        @param request: ListAIVideoSummaryJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoSummaryJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_summary_job_ids):
            query['AIVideoSummaryJobIds'] = request.aivideo_summary_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoSummaryJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoSummaryJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aivideo_summary_job(
        self,
        request: vod_20170321_models.ListAIVideoSummaryJobRequest,
    ) -> vod_20170321_models.ListAIVideoSummaryJobResponse:
        """
        @summary 列举AI智能摘要任务
        
        @param request: ListAIVideoSummaryJobRequest
        @return: ListAIVideoSummaryJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aivideo_summary_job_with_options(request, runtime)

    async def list_aivideo_summary_job_async(
        self,
        request: vod_20170321_models.ListAIVideoSummaryJobRequest,
    ) -> vod_20170321_models.ListAIVideoSummaryJobResponse:
        """
        @summary 列举AI智能摘要任务
        
        @param request: ListAIVideoSummaryJobRequest
        @return: ListAIVideoSummaryJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aivideo_summary_job_with_options_async(request, runtime)

    def list_aivideo_tag_job_with_options(
        self,
        request: vod_20170321_models.ListAIVideoTagJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoTagJobResponse:
        """
        @summary 列举AI智能标签任务
        
        @param request: ListAIVideoTagJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoTagJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_tag_job_ids):
            query['AIVideoTagJobIds'] = request.aivideo_tag_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoTagJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoTagJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aivideo_tag_job_with_options_async(
        self,
        request: vod_20170321_models.ListAIVideoTagJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoTagJobResponse:
        """
        @summary 列举AI智能标签任务
        
        @param request: ListAIVideoTagJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoTagJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_tag_job_ids):
            query['AIVideoTagJobIds'] = request.aivideo_tag_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoTagJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoTagJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aivideo_tag_job(
        self,
        request: vod_20170321_models.ListAIVideoTagJobRequest,
    ) -> vod_20170321_models.ListAIVideoTagJobResponse:
        """
        @summary 列举AI智能标签任务
        
        @param request: ListAIVideoTagJobRequest
        @return: ListAIVideoTagJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aivideo_tag_job_with_options(request, runtime)

    async def list_aivideo_tag_job_async(
        self,
        request: vod_20170321_models.ListAIVideoTagJobRequest,
    ) -> vod_20170321_models.ListAIVideoTagJobResponse:
        """
        @summary 列举AI智能标签任务
        
        @param request: ListAIVideoTagJobRequest
        @return: ListAIVideoTagJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aivideo_tag_job_with_options_async(request, runtime)

    def list_aivideo_terrorism_recog_job_with_options(
        self,
        request: vod_20170321_models.ListAIVideoTerrorismRecogJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoTerrorismRecogJobResponse:
        """
        @summary 列举AI暴力审核任务
        
        @param request: ListAIVideoTerrorismRecogJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoTerrorismRecogJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_terrorism_recog_job_ids):
            query['AIVideoTerrorismRecogJobIds'] = request.aivideo_terrorism_recog_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoTerrorismRecogJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoTerrorismRecogJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_aivideo_terrorism_recog_job_with_options_async(
        self,
        request: vod_20170321_models.ListAIVideoTerrorismRecogJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAIVideoTerrorismRecogJobResponse:
        """
        @summary 列举AI暴力审核任务
        
        @param request: ListAIVideoTerrorismRecogJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAIVideoTerrorismRecogJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_terrorism_recog_job_ids):
            query['AIVideoTerrorismRecogJobIds'] = request.aivideo_terrorism_recog_job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAIVideoTerrorismRecogJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAIVideoTerrorismRecogJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_aivideo_terrorism_recog_job(
        self,
        request: vod_20170321_models.ListAIVideoTerrorismRecogJobRequest,
    ) -> vod_20170321_models.ListAIVideoTerrorismRecogJobResponse:
        """
        @summary 列举AI暴力审核任务
        
        @param request: ListAIVideoTerrorismRecogJobRequest
        @return: ListAIVideoTerrorismRecogJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_aivideo_terrorism_recog_job_with_options(request, runtime)

    async def list_aivideo_terrorism_recog_job_async(
        self,
        request: vod_20170321_models.ListAIVideoTerrorismRecogJobRequest,
    ) -> vod_20170321_models.ListAIVideoTerrorismRecogJobResponse:
        """
        @summary 列举AI暴力审核任务
        
        @param request: ListAIVideoTerrorismRecogJobRequest
        @return: ListAIVideoTerrorismRecogJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_aivideo_terrorism_recog_job_with_options_async(request, runtime)

    def list_app_info_with_options(
        self,
        request: vod_20170321_models.ListAppInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAppInfoResponse:
        """
        @summary Queries the applications that you are authorized to manage based on query conditions.
        
        @description ### [](#)Usage notes
        You can query applications based on states.
        ### [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: ListAppInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAppInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAppInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAppInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_app_info_with_options_async(
        self,
        request: vod_20170321_models.ListAppInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAppInfoResponse:
        """
        @summary Queries the applications that you are authorized to manage based on query conditions.
        
        @description ### [](#)Usage notes
        You can query applications based on states.
        ### [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: ListAppInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAppInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAppInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAppInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_app_info(
        self,
        request: vod_20170321_models.ListAppInfoRequest,
    ) -> vod_20170321_models.ListAppInfoResponse:
        """
        @summary Queries the applications that you are authorized to manage based on query conditions.
        
        @description ### [](#)Usage notes
        You can query applications based on states.
        ### [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: ListAppInfoRequest
        @return: ListAppInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_app_info_with_options(request, runtime)

    async def list_app_info_async(
        self,
        request: vod_20170321_models.ListAppInfoRequest,
    ) -> vod_20170321_models.ListAppInfoResponse:
        """
        @summary Queries the applications that you are authorized to manage based on query conditions.
        
        @description ### [](#)Usage notes
        You can query applications based on states.
        ### [](#qps-)QPS limit
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: ListAppInfoRequest
        @return: ListAppInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_app_info_with_options_async(request, runtime)

    def list_app_policies_for_identity_with_options(
        self,
        request: vod_20170321_models.ListAppPoliciesForIdentityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAppPoliciesForIdentityResponse:
        """
        @summary Queries the application policies that are attached to the specified identity. The identity may be a RAM user or RAM role.
        
        @description > The IdentityType and IdentityName parameters take effect only when an identity assumes the application administrator role to call this operation. Otherwise, only application policies that are attached to the current identity are returned.
        
        @param request: ListAppPoliciesForIdentityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAppPoliciesForIdentityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.identity_name):
            query['IdentityName'] = request.identity_name
        if not UtilClient.is_unset(request.identity_type):
            query['IdentityType'] = request.identity_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAppPoliciesForIdentity',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAppPoliciesForIdentityResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_app_policies_for_identity_with_options_async(
        self,
        request: vod_20170321_models.ListAppPoliciesForIdentityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAppPoliciesForIdentityResponse:
        """
        @summary Queries the application policies that are attached to the specified identity. The identity may be a RAM user or RAM role.
        
        @description > The IdentityType and IdentityName parameters take effect only when an identity assumes the application administrator role to call this operation. Otherwise, only application policies that are attached to the current identity are returned.
        
        @param request: ListAppPoliciesForIdentityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAppPoliciesForIdentityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.identity_name):
            query['IdentityName'] = request.identity_name
        if not UtilClient.is_unset(request.identity_type):
            query['IdentityType'] = request.identity_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAppPoliciesForIdentity',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAppPoliciesForIdentityResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_app_policies_for_identity(
        self,
        request: vod_20170321_models.ListAppPoliciesForIdentityRequest,
    ) -> vod_20170321_models.ListAppPoliciesForIdentityResponse:
        """
        @summary Queries the application policies that are attached to the specified identity. The identity may be a RAM user or RAM role.
        
        @description > The IdentityType and IdentityName parameters take effect only when an identity assumes the application administrator role to call this operation. Otherwise, only application policies that are attached to the current identity are returned.
        
        @param request: ListAppPoliciesForIdentityRequest
        @return: ListAppPoliciesForIdentityResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_app_policies_for_identity_with_options(request, runtime)

    async def list_app_policies_for_identity_async(
        self,
        request: vod_20170321_models.ListAppPoliciesForIdentityRequest,
    ) -> vod_20170321_models.ListAppPoliciesForIdentityResponse:
        """
        @summary Queries the application policies that are attached to the specified identity. The identity may be a RAM user or RAM role.
        
        @description > The IdentityType and IdentityName parameters take effect only when an identity assumes the application administrator role to call this operation. Otherwise, only application policies that are attached to the current identity are returned.
        
        @param request: ListAppPoliciesForIdentityRequest
        @return: ListAppPoliciesForIdentityResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_app_policies_for_identity_with_options_async(request, runtime)

    def list_app_policy_with_options(
        self,
        request: vod_20170321_models.ListAppPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAppPolicyResponse:
        """
        @summary 列举应用策略
        
        @param request: ListAppPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAppPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.policy_type):
            query['PolicyType'] = request.policy_type
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAppPolicy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAppPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_app_policy_with_options_async(
        self,
        request: vod_20170321_models.ListAppPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAppPolicyResponse:
        """
        @summary 列举应用策略
        
        @param request: ListAppPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAppPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.policy_type):
            query['PolicyType'] = request.policy_type
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAppPolicy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAppPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_app_policy(
        self,
        request: vod_20170321_models.ListAppPolicyRequest,
    ) -> vod_20170321_models.ListAppPolicyResponse:
        """
        @summary 列举应用策略
        
        @param request: ListAppPolicyRequest
        @return: ListAppPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_app_policy_with_options(request, runtime)

    async def list_app_policy_async(
        self,
        request: vod_20170321_models.ListAppPolicyRequest,
    ) -> vod_20170321_models.ListAppPolicyResponse:
        """
        @summary 列举应用策略
        
        @param request: ListAppPolicyRequest
        @return: ListAppPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_app_policy_with_options_async(request, runtime)

    def list_audit_security_ip_with_options(
        self,
        request: vod_20170321_models.ListAuditSecurityIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAuditSecurityIpResponse:
        """
        @summary Queries the IP addresses in a review security group.
        
        @param request: ListAuditSecurityIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAuditSecurityIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.security_group_name):
            query['SecurityGroupName'] = request.security_group_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAuditSecurityIp',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAuditSecurityIpResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_audit_security_ip_with_options_async(
        self,
        request: vod_20170321_models.ListAuditSecurityIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListAuditSecurityIpResponse:
        """
        @summary Queries the IP addresses in a review security group.
        
        @param request: ListAuditSecurityIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAuditSecurityIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.security_group_name):
            query['SecurityGroupName'] = request.security_group_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAuditSecurityIp',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListAuditSecurityIpResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_audit_security_ip(
        self,
        request: vod_20170321_models.ListAuditSecurityIpRequest,
    ) -> vod_20170321_models.ListAuditSecurityIpResponse:
        """
        @summary Queries the IP addresses in a review security group.
        
        @param request: ListAuditSecurityIpRequest
        @return: ListAuditSecurityIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_audit_security_ip_with_options(request, runtime)

    async def list_audit_security_ip_async(
        self,
        request: vod_20170321_models.ListAuditSecurityIpRequest,
    ) -> vod_20170321_models.ListAuditSecurityIpResponse:
        """
        @summary Queries the IP addresses in a review security group.
        
        @param request: ListAuditSecurityIpRequest
        @return: ListAuditSecurityIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_audit_security_ip_with_options_async(request, runtime)

    def list_bucket_redundancy_transition_with_options(
        self,
        request: vod_20170321_models.ListBucketRedundancyTransitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListBucketRedundancyTransitionResponse:
        """
        @summary 查询系统存储冗余类型转换任务
        
        @param request: ListBucketRedundancyTransitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListBucketRedundancyTransitionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListBucketRedundancyTransition',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListBucketRedundancyTransitionResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_bucket_redundancy_transition_with_options_async(
        self,
        request: vod_20170321_models.ListBucketRedundancyTransitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListBucketRedundancyTransitionResponse:
        """
        @summary 查询系统存储冗余类型转换任务
        
        @param request: ListBucketRedundancyTransitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListBucketRedundancyTransitionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListBucketRedundancyTransition',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListBucketRedundancyTransitionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_bucket_redundancy_transition(
        self,
        request: vod_20170321_models.ListBucketRedundancyTransitionRequest,
    ) -> vod_20170321_models.ListBucketRedundancyTransitionResponse:
        """
        @summary 查询系统存储冗余类型转换任务
        
        @param request: ListBucketRedundancyTransitionRequest
        @return: ListBucketRedundancyTransitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_bucket_redundancy_transition_with_options(request, runtime)

    async def list_bucket_redundancy_transition_async(
        self,
        request: vod_20170321_models.ListBucketRedundancyTransitionRequest,
    ) -> vod_20170321_models.ListBucketRedundancyTransitionResponse:
        """
        @summary 查询系统存储冗余类型转换任务
        
        @param request: ListBucketRedundancyTransitionRequest
        @return: ListBucketRedundancyTransitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_bucket_redundancy_transition_with_options_async(request, runtime)

    def list_dnadbwith_options(
        self,
        request: vod_20170321_models.ListDNADBRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListDNADBResponse:
        """
        @summary 列举DNADB
        
        @param request: ListDNADBRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDNADBResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDNADB',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListDNADBResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_dnadbwith_options_async(
        self,
        request: vod_20170321_models.ListDNADBRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListDNADBResponse:
        """
        @summary 列举DNADB
        
        @param request: ListDNADBRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDNADBResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDNADB',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListDNADBResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_dnadb(
        self,
        request: vod_20170321_models.ListDNADBRequest,
    ) -> vod_20170321_models.ListDNADBResponse:
        """
        @summary 列举DNADB
        
        @param request: ListDNADBRequest
        @return: ListDNADBResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_dnadbwith_options(request, runtime)

    async def list_dnadb_async(
        self,
        request: vod_20170321_models.ListDNADBRequest,
    ) -> vod_20170321_models.ListDNADBResponse:
        """
        @summary 列举DNADB
        
        @param request: ListDNADBRequest
        @return: ListDNADBResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_dnadbwith_options_async(request, runtime)

    def list_drmcert_info_with_options(
        self,
        request: vod_20170321_models.ListDRMCertInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListDRMCertInfoResponse:
        """
        @summary 列举DRM证书信息
        
        @param request: ListDRMCertInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDRMCertInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDRMCertInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListDRMCertInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_drmcert_info_with_options_async(
        self,
        request: vod_20170321_models.ListDRMCertInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListDRMCertInfoResponse:
        """
        @summary 列举DRM证书信息
        
        @param request: ListDRMCertInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDRMCertInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDRMCertInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListDRMCertInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_drmcert_info(
        self,
        request: vod_20170321_models.ListDRMCertInfoRequest,
    ) -> vod_20170321_models.ListDRMCertInfoResponse:
        """
        @summary 列举DRM证书信息
        
        @param request: ListDRMCertInfoRequest
        @return: ListDRMCertInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_drmcert_info_with_options(request, runtime)

    async def list_drmcert_info_async(
        self,
        request: vod_20170321_models.ListDRMCertInfoRequest,
    ) -> vod_20170321_models.ListDRMCertInfoResponse:
        """
        @summary 列举DRM证书信息
        
        @param request: ListDRMCertInfoRequest
        @return: ListDRMCertInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_drmcert_info_with_options_async(request, runtime)

    def list_dynamic_image_with_options(
        self,
        request: vod_20170321_models.ListDynamicImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListDynamicImageResponse:
        """
        @summary Queries the information about animated stickers of a video based on the video ID.
        
        @param request: ListDynamicImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDynamicImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDynamicImage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListDynamicImageResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_dynamic_image_with_options_async(
        self,
        request: vod_20170321_models.ListDynamicImageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListDynamicImageResponse:
        """
        @summary Queries the information about animated stickers of a video based on the video ID.
        
        @param request: ListDynamicImageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDynamicImageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDynamicImage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListDynamicImageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_dynamic_image(
        self,
        request: vod_20170321_models.ListDynamicImageRequest,
    ) -> vod_20170321_models.ListDynamicImageResponse:
        """
        @summary Queries the information about animated stickers of a video based on the video ID.
        
        @param request: ListDynamicImageRequest
        @return: ListDynamicImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_dynamic_image_with_options(request, runtime)

    async def list_dynamic_image_async(
        self,
        request: vod_20170321_models.ListDynamicImageRequest,
    ) -> vod_20170321_models.ListDynamicImageResponse:
        """
        @summary Queries the information about animated stickers of a video based on the video ID.
        
        @param request: ListDynamicImageRequest
        @return: ListDynamicImageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_dynamic_image_with_options_async(request, runtime)

    def list_intelligent_strategy_with_options(
        self,
        request: vod_20170321_models.ListIntelligentStrategyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListIntelligentStrategyResponse:
        """
        @summary 获取智能策略信息列表
        
        @param request: ListIntelligentStrategyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntelligentStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.state):
            query['State'] = request.state
        if not UtilClient.is_unset(request.strategy_ids):
            query['StrategyIds'] = request.strategy_ids
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntelligentStrategy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListIntelligentStrategyResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_intelligent_strategy_with_options_async(
        self,
        request: vod_20170321_models.ListIntelligentStrategyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListIntelligentStrategyResponse:
        """
        @summary 获取智能策略信息列表
        
        @param request: ListIntelligentStrategyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntelligentStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.state):
            query['State'] = request.state
        if not UtilClient.is_unset(request.strategy_ids):
            query['StrategyIds'] = request.strategy_ids
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntelligentStrategy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListIntelligentStrategyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_intelligent_strategy(
        self,
        request: vod_20170321_models.ListIntelligentStrategyRequest,
    ) -> vod_20170321_models.ListIntelligentStrategyResponse:
        """
        @summary 获取智能策略信息列表
        
        @param request: ListIntelligentStrategyRequest
        @return: ListIntelligentStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_intelligent_strategy_with_options(request, runtime)

    async def list_intelligent_strategy_async(
        self,
        request: vod_20170321_models.ListIntelligentStrategyRequest,
    ) -> vod_20170321_models.ListIntelligentStrategyResponse:
        """
        @summary 获取智能策略信息列表
        
        @param request: ListIntelligentStrategyRequest
        @return: ListIntelligentStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_intelligent_strategy_with_options_async(request, runtime)

    def list_job_info_with_options(
        self,
        request: vod_20170321_models.ListJobInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListJobInfoResponse:
        """
        @summary Queries historical tasks based on the media asset ID.
        
        @description ***\
        You can call the [GetJobDetail](https://apiworkbench.aliyun-inc.com/document/vod/2017-03-21/GetJobDetail?spm=openapi-amp.newDocPublishment.0.0.616a281fSegn0e) operation to query detailed information about the tasks.
        You can call this operation to query only asynchronous tasks of the last six months. The types of tasks that you can query include transcoding tasks, snapshot tasks, and AI tasks.
        *QPS limits**\
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: ListJobInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListJobInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_type):
            query['JobType'] = request.job_type
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListJobInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListJobInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_job_info_with_options_async(
        self,
        request: vod_20170321_models.ListJobInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListJobInfoResponse:
        """
        @summary Queries historical tasks based on the media asset ID.
        
        @description ***\
        You can call the [GetJobDetail](https://apiworkbench.aliyun-inc.com/document/vod/2017-03-21/GetJobDetail?spm=openapi-amp.newDocPublishment.0.0.616a281fSegn0e) operation to query detailed information about the tasks.
        You can call this operation to query only asynchronous tasks of the last six months. The types of tasks that you can query include transcoding tasks, snapshot tasks, and AI tasks.
        *QPS limits**\
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: ListJobInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListJobInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_type):
            query['JobType'] = request.job_type
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListJobInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListJobInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_job_info(
        self,
        request: vod_20170321_models.ListJobInfoRequest,
    ) -> vod_20170321_models.ListJobInfoResponse:
        """
        @summary Queries historical tasks based on the media asset ID.
        
        @description ***\
        You can call the [GetJobDetail](https://apiworkbench.aliyun-inc.com/document/vod/2017-03-21/GetJobDetail?spm=openapi-amp.newDocPublishment.0.0.616a281fSegn0e) operation to query detailed information about the tasks.
        You can call this operation to query only asynchronous tasks of the last six months. The types of tasks that you can query include transcoding tasks, snapshot tasks, and AI tasks.
        *QPS limits**\
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: ListJobInfoRequest
        @return: ListJobInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_job_info_with_options(request, runtime)

    async def list_job_info_async(
        self,
        request: vod_20170321_models.ListJobInfoRequest,
    ) -> vod_20170321_models.ListJobInfoResponse:
        """
        @summary Queries historical tasks based on the media asset ID.
        
        @description ***\
        You can call the [GetJobDetail](https://apiworkbench.aliyun-inc.com/document/vod/2017-03-21/GetJobDetail?spm=openapi-amp.newDocPublishment.0.0.616a281fSegn0e) operation to query detailed information about the tasks.
        You can call this operation to query only asynchronous tasks of the last six months. The types of tasks that you can query include transcoding tasks, snapshot tasks, and AI tasks.
        *QPS limits**\
        You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: ListJobInfoRequest
        @return: ListJobInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_job_info_with_options_async(request, runtime)

    def list_license_infos_with_options(
        self,
        request: vod_20170321_models.ListLicenseInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListLicenseInfosResponse:
        """
        @summary 列举证书信息
        
        @param request: ListLicenseInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLicenseInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.account_id):
            query['AccountId'] = request.account_id
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.contract_no):
            query['ContractNo'] = request.contract_no
        if not UtilClient.is_unset(request.customer_id):
            query['CustomerId'] = request.customer_id
        if not UtilClient.is_unset(request.end_begin_time):
            query['EndBeginTime'] = request.end_begin_time
        if not UtilClient.is_unset(request.end_expired_on):
            query['EndExpiredOn'] = request.end_expired_on
        if not UtilClient.is_unset(request.extra_info):
            query['ExtraInfo'] = request.extra_info
        if not UtilClient.is_unset(request.license_id):
            query['LicenseId'] = request.license_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.start_begin_time):
            query['StartBeginTime'] = request.start_begin_time
        if not UtilClient.is_unset(request.start_expired_on):
            query['StartExpiredOn'] = request.start_expired_on
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLicenseInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListLicenseInfosResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_license_infos_with_options_async(
        self,
        request: vod_20170321_models.ListLicenseInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListLicenseInfosResponse:
        """
        @summary 列举证书信息
        
        @param request: ListLicenseInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLicenseInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.account_id):
            query['AccountId'] = request.account_id
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.contract_no):
            query['ContractNo'] = request.contract_no
        if not UtilClient.is_unset(request.customer_id):
            query['CustomerId'] = request.customer_id
        if not UtilClient.is_unset(request.end_begin_time):
            query['EndBeginTime'] = request.end_begin_time
        if not UtilClient.is_unset(request.end_expired_on):
            query['EndExpiredOn'] = request.end_expired_on
        if not UtilClient.is_unset(request.extra_info):
            query['ExtraInfo'] = request.extra_info
        if not UtilClient.is_unset(request.license_id):
            query['LicenseId'] = request.license_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.start_begin_time):
            query['StartBeginTime'] = request.start_begin_time
        if not UtilClient.is_unset(request.start_expired_on):
            query['StartExpiredOn'] = request.start_expired_on
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLicenseInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListLicenseInfosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_license_infos(
        self,
        request: vod_20170321_models.ListLicenseInfosRequest,
    ) -> vod_20170321_models.ListLicenseInfosResponse:
        """
        @summary 列举证书信息
        
        @param request: ListLicenseInfosRequest
        @return: ListLicenseInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_license_infos_with_options(request, runtime)

    async def list_license_infos_async(
        self,
        request: vod_20170321_models.ListLicenseInfosRequest,
    ) -> vod_20170321_models.ListLicenseInfosResponse:
        """
        @summary 列举证书信息
        
        @param request: ListLicenseInfosRequest
        @return: ListLicenseInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_license_infos_with_options_async(request, runtime)

    def list_licenses_with_options(
        self,
        request: vod_20170321_models.ListLicensesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListLicensesResponse:
        """
        @summary 列举证书
        
        @param request: ListLicensesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLicensesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.product):
            query['Product'] = request.product
        body = {}
        if not UtilClient.is_unset(request.app_name):
            body['AppName'] = request.app_name
        if not UtilClient.is_unset(request.app_type):
            body['AppType'] = request.app_type
        if not UtilClient.is_unset(request.business_type):
            body['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.need_total_count):
            body['NeedTotalCount'] = request.need_total_count
        if not UtilClient.is_unset(request.offset):
            body['Offset'] = request.offset
        if not UtilClient.is_unset(request.orders):
            body['Orders'] = request.orders
        if not UtilClient.is_unset(request.page_no):
            body['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.pkg_name):
            body['PkgName'] = request.pkg_name
        if not UtilClient.is_unset(request.platform_type):
            body['PlatformType'] = request.platform_type
        if not UtilClient.is_unset(request.user_id):
            body['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListLicenses',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListLicensesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_licenses_with_options_async(
        self,
        request: vod_20170321_models.ListLicensesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListLicensesResponse:
        """
        @summary 列举证书
        
        @param request: ListLicensesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLicensesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.product):
            query['Product'] = request.product
        body = {}
        if not UtilClient.is_unset(request.app_name):
            body['AppName'] = request.app_name
        if not UtilClient.is_unset(request.app_type):
            body['AppType'] = request.app_type
        if not UtilClient.is_unset(request.business_type):
            body['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.need_total_count):
            body['NeedTotalCount'] = request.need_total_count
        if not UtilClient.is_unset(request.offset):
            body['Offset'] = request.offset
        if not UtilClient.is_unset(request.orders):
            body['Orders'] = request.orders
        if not UtilClient.is_unset(request.page_no):
            body['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            body['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.pkg_name):
            body['PkgName'] = request.pkg_name
        if not UtilClient.is_unset(request.platform_type):
            body['PlatformType'] = request.platform_type
        if not UtilClient.is_unset(request.user_id):
            body['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListLicenses',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListLicensesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_licenses(
        self,
        request: vod_20170321_models.ListLicensesRequest,
    ) -> vod_20170321_models.ListLicensesResponse:
        """
        @summary 列举证书
        
        @param request: ListLicensesRequest
        @return: ListLicensesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_licenses_with_options(request, runtime)

    async def list_licenses_async(
        self,
        request: vod_20170321_models.ListLicensesRequest,
    ) -> vod_20170321_models.ListLicensesResponse:
        """
        @summary 列举证书
        
        @param request: ListLicensesRequest
        @return: ListLicensesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_licenses_with_options_async(request, runtime)

    def list_live_record_video_with_options(
        self,
        request: vod_20170321_models.ListLiveRecordVideoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListLiveRecordVideoResponse:
        """
        @summary Queries live-to-VOD videos.
        
        @description You can query up to 5,000 videos based on the specified filter condition.
        
        @param request: ListLiveRecordVideoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveRecordVideoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveRecordVideo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListLiveRecordVideoResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_live_record_video_with_options_async(
        self,
        request: vod_20170321_models.ListLiveRecordVideoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListLiveRecordVideoResponse:
        """
        @summary Queries live-to-VOD videos.
        
        @description You can query up to 5,000 videos based on the specified filter condition.
        
        @param request: ListLiveRecordVideoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLiveRecordVideoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLiveRecordVideo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListLiveRecordVideoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_live_record_video(
        self,
        request: vod_20170321_models.ListLiveRecordVideoRequest,
    ) -> vod_20170321_models.ListLiveRecordVideoResponse:
        """
        @summary Queries live-to-VOD videos.
        
        @description You can query up to 5,000 videos based on the specified filter condition.
        
        @param request: ListLiveRecordVideoRequest
        @return: ListLiveRecordVideoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_live_record_video_with_options(request, runtime)

    async def list_live_record_video_async(
        self,
        request: vod_20170321_models.ListLiveRecordVideoRequest,
    ) -> vod_20170321_models.ListLiveRecordVideoResponse:
        """
        @summary Queries live-to-VOD videos.
        
        @description You can query up to 5,000 videos based on the specified filter condition.
        
        @param request: ListLiveRecordVideoRequest
        @return: ListLiveRecordVideoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_live_record_video_with_options_async(request, runtime)

    def list_media_dnadelete_job_with_options(
        self,
        request: vod_20170321_models.ListMediaDNADeleteJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListMediaDNADeleteJobResponse:
        """
        @summary 列举媒资DNA删除任务
        
        @param request: ListMediaDNADeleteJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMediaDNADeleteJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMediaDNADeleteJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListMediaDNADeleteJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_media_dnadelete_job_with_options_async(
        self,
        request: vod_20170321_models.ListMediaDNADeleteJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListMediaDNADeleteJobResponse:
        """
        @summary 列举媒资DNA删除任务
        
        @param request: ListMediaDNADeleteJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMediaDNADeleteJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_ids):
            query['JobIds'] = request.job_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMediaDNADeleteJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListMediaDNADeleteJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_media_dnadelete_job(
        self,
        request: vod_20170321_models.ListMediaDNADeleteJobRequest,
    ) -> vod_20170321_models.ListMediaDNADeleteJobResponse:
        """
        @summary 列举媒资DNA删除任务
        
        @param request: ListMediaDNADeleteJobRequest
        @return: ListMediaDNADeleteJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_media_dnadelete_job_with_options(request, runtime)

    async def list_media_dnadelete_job_async(
        self,
        request: vod_20170321_models.ListMediaDNADeleteJobRequest,
    ) -> vod_20170321_models.ListMediaDNADeleteJobResponse:
        """
        @summary 列举媒资DNA删除任务
        
        @param request: ListMediaDNADeleteJobRequest
        @return: ListMediaDNADeleteJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_media_dnadelete_job_with_options_async(request, runtime)

    def list_media_dnalibs_with_options(
        self,
        request: vod_20170321_models.ListMediaDNALibsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListMediaDNALibsResponse:
        """
        @summary 列举媒资DNALibs
        
        @param request: ListMediaDNALibsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMediaDNALibsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.lib_region):
            query['LibRegion'] = request.lib_region
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMediaDNALibs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListMediaDNALibsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_media_dnalibs_with_options_async(
        self,
        request: vod_20170321_models.ListMediaDNALibsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListMediaDNALibsResponse:
        """
        @summary 列举媒资DNALibs
        
        @param request: ListMediaDNALibsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMediaDNALibsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.lib_region):
            query['LibRegion'] = request.lib_region
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMediaDNALibs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListMediaDNALibsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_media_dnalibs(
        self,
        request: vod_20170321_models.ListMediaDNALibsRequest,
    ) -> vod_20170321_models.ListMediaDNALibsResponse:
        """
        @summary 列举媒资DNALibs
        
        @param request: ListMediaDNALibsRequest
        @return: ListMediaDNALibsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_media_dnalibs_with_options(request, runtime)

    async def list_media_dnalibs_async(
        self,
        request: vod_20170321_models.ListMediaDNALibsRequest,
    ) -> vod_20170321_models.ListMediaDNALibsResponse:
        """
        @summary 列举媒资DNALibs
        
        @param request: ListMediaDNALibsRequest
        @return: ListMediaDNALibsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_media_dnalibs_with_options_async(request, runtime)

    def list_media_export_jobs_with_options(
        self,
        request: vod_20170321_models.ListMediaExportJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListMediaExportJobsResponse:
        """
        @summary 列举媒资导出任务
        
        @param request: ListMediaExportJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMediaExportJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMediaExportJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListMediaExportJobsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_media_export_jobs_with_options_async(
        self,
        request: vod_20170321_models.ListMediaExportJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListMediaExportJobsResponse:
        """
        @summary 列举媒资导出任务
        
        @param request: ListMediaExportJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMediaExportJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMediaExportJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListMediaExportJobsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_media_export_jobs(
        self,
        request: vod_20170321_models.ListMediaExportJobsRequest,
    ) -> vod_20170321_models.ListMediaExportJobsResponse:
        """
        @summary 列举媒资导出任务
        
        @param request: ListMediaExportJobsRequest
        @return: ListMediaExportJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_media_export_jobs_with_options(request, runtime)

    async def list_media_export_jobs_async(
        self,
        request: vod_20170321_models.ListMediaExportJobsRequest,
    ) -> vod_20170321_models.ListMediaExportJobsResponse:
        """
        @summary 列举媒资导出任务
        
        @param request: ListMediaExportJobsRequest
        @return: ListMediaExportJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_media_export_jobs_with_options_async(request, runtime)

    def list_media_lifecycle_rule_with_options(
        self,
        request: vod_20170321_models.ListMediaLifecycleRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListMediaLifecycleRuleResponse:
        """
        @summary 列举媒资生命周期规则
        
        @param request: ListMediaLifecycleRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMediaLifecycleRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.rule_type):
            query['RuleType'] = request.rule_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMediaLifecycleRule',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListMediaLifecycleRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_media_lifecycle_rule_with_options_async(
        self,
        request: vod_20170321_models.ListMediaLifecycleRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListMediaLifecycleRuleResponse:
        """
        @summary 列举媒资生命周期规则
        
        @param request: ListMediaLifecycleRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMediaLifecycleRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.rule_type):
            query['RuleType'] = request.rule_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMediaLifecycleRule',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListMediaLifecycleRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_media_lifecycle_rule(
        self,
        request: vod_20170321_models.ListMediaLifecycleRuleRequest,
    ) -> vod_20170321_models.ListMediaLifecycleRuleResponse:
        """
        @summary 列举媒资生命周期规则
        
        @param request: ListMediaLifecycleRuleRequest
        @return: ListMediaLifecycleRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_media_lifecycle_rule_with_options(request, runtime)

    async def list_media_lifecycle_rule_async(
        self,
        request: vod_20170321_models.ListMediaLifecycleRuleRequest,
    ) -> vod_20170321_models.ListMediaLifecycleRuleResponse:
        """
        @summary 列举媒资生命周期规则
        
        @param request: ListMediaLifecycleRuleRequest
        @return: ListMediaLifecycleRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_media_lifecycle_rule_with_options_async(request, runtime)

    def list_snapshots_with_options(
        self,
        request: vod_20170321_models.ListSnapshotsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListSnapshotsResponse:
        """
        @summary Queries the snapshots that are captured by submitting snapshot jobs or snapshots that are generated by the system when you upload the video.
        
        @description If multiple snapshots exist for a video, you can call this operation to query information about the latest snapshot.
        
        @param request: ListSnapshotsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSnapshotsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_timeout):
            query['AuthTimeout'] = request.auth_timeout
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.snapshot_type):
            query['SnapshotType'] = request.snapshot_type
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSnapshots',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListSnapshotsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_snapshots_with_options_async(
        self,
        request: vod_20170321_models.ListSnapshotsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListSnapshotsResponse:
        """
        @summary Queries the snapshots that are captured by submitting snapshot jobs or snapshots that are generated by the system when you upload the video.
        
        @description If multiple snapshots exist for a video, you can call this operation to query information about the latest snapshot.
        
        @param request: ListSnapshotsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSnapshotsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auth_timeout):
            query['AuthTimeout'] = request.auth_timeout
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.snapshot_type):
            query['SnapshotType'] = request.snapshot_type
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSnapshots',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListSnapshotsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_snapshots(
        self,
        request: vod_20170321_models.ListSnapshotsRequest,
    ) -> vod_20170321_models.ListSnapshotsResponse:
        """
        @summary Queries the snapshots that are captured by submitting snapshot jobs or snapshots that are generated by the system when you upload the video.
        
        @description If multiple snapshots exist for a video, you can call this operation to query information about the latest snapshot.
        
        @param request: ListSnapshotsRequest
        @return: ListSnapshotsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_snapshots_with_options(request, runtime)

    async def list_snapshots_async(
        self,
        request: vod_20170321_models.ListSnapshotsRequest,
    ) -> vod_20170321_models.ListSnapshotsResponse:
        """
        @summary Queries the snapshots that are captured by submitting snapshot jobs or snapshots that are generated by the system when you upload the video.
        
        @description If multiple snapshots exist for a video, you can call this operation to query information about the latest snapshot.
        
        @param request: ListSnapshotsRequest
        @return: ListSnapshotsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_snapshots_with_options_async(request, runtime)

    def list_strategy_execution_record_with_options(
        self,
        request: vod_20170321_models.ListStrategyExecutionRecordRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListStrategyExecutionRecordResponse:
        """
        @summary 获取智能策略执行记录列表
        
        @param request: ListStrategyExecutionRecordRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListStrategyExecutionRecordResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.strategy_id):
            query['StrategyId'] = request.strategy_id
        if not UtilClient.is_unset(request.strategy_type):
            query['StrategyType'] = request.strategy_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListStrategyExecutionRecord',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListStrategyExecutionRecordResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_strategy_execution_record_with_options_async(
        self,
        request: vod_20170321_models.ListStrategyExecutionRecordRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListStrategyExecutionRecordResponse:
        """
        @summary 获取智能策略执行记录列表
        
        @param request: ListStrategyExecutionRecordRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListStrategyExecutionRecordResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.strategy_id):
            query['StrategyId'] = request.strategy_id
        if not UtilClient.is_unset(request.strategy_type):
            query['StrategyType'] = request.strategy_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListStrategyExecutionRecord',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListStrategyExecutionRecordResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_strategy_execution_record(
        self,
        request: vod_20170321_models.ListStrategyExecutionRecordRequest,
    ) -> vod_20170321_models.ListStrategyExecutionRecordResponse:
        """
        @summary 获取智能策略执行记录列表
        
        @param request: ListStrategyExecutionRecordRequest
        @return: ListStrategyExecutionRecordResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_strategy_execution_record_with_options(request, runtime)

    async def list_strategy_execution_record_async(
        self,
        request: vod_20170321_models.ListStrategyExecutionRecordRequest,
    ) -> vod_20170321_models.ListStrategyExecutionRecordResponse:
        """
        @summary 获取智能策略执行记录列表
        
        @param request: ListStrategyExecutionRecordRequest
        @return: ListStrategyExecutionRecordResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_strategy_execution_record_with_options_async(request, runtime)

    def list_tag_resources_with_options(
        self,
        request: vod_20170321_models.ListTagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListTagResourcesResponse:
        """
        @summary 查询资源标签
        
        @param request: ListTagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTagResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListTagResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_tag_resources_with_options_async(
        self,
        request: vod_20170321_models.ListTagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListTagResourcesResponse:
        """
        @summary 查询资源标签
        
        @param request: ListTagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTagResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListTagResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_tag_resources(
        self,
        request: vod_20170321_models.ListTagResourcesRequest,
    ) -> vod_20170321_models.ListTagResourcesResponse:
        """
        @summary 查询资源标签
        
        @param request: ListTagResourcesRequest
        @return: ListTagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_tag_resources_with_options(request, runtime)

    async def list_tag_resources_async(
        self,
        request: vod_20170321_models.ListTagResourcesRequest,
    ) -> vod_20170321_models.ListTagResourcesResponse:
        """
        @summary 查询资源标签
        
        @param request: ListTagResourcesRequest
        @return: ListTagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_tag_resources_with_options_async(request, runtime)

    def list_template_group_with_options(
        self,
        request: vod_20170321_models.ListTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListTemplateGroupResponse:
        """
        @summary 列举模版组
        
        @param request: ListTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.is_contains_templates):
            query['IsContainsTemplates'] = request.is_contains_templates
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListTemplateGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_template_group_with_options_async(
        self,
        request: vod_20170321_models.ListTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListTemplateGroupResponse:
        """
        @summary 列举模版组
        
        @param request: ListTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.is_contains_templates):
            query['IsContainsTemplates'] = request.is_contains_templates
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListTemplateGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_template_group(
        self,
        request: vod_20170321_models.ListTemplateGroupRequest,
    ) -> vod_20170321_models.ListTemplateGroupResponse:
        """
        @summary 列举模版组
        
        @param request: ListTemplateGroupRequest
        @return: ListTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_template_group_with_options(request, runtime)

    async def list_template_group_async(
        self,
        request: vod_20170321_models.ListTemplateGroupRequest,
    ) -> vod_20170321_models.ListTemplateGroupResponse:
        """
        @summary 列举模版组
        
        @param request: ListTemplateGroupRequest
        @return: ListTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_template_group_with_options_async(request, runtime)

    def list_template_group_console_with_options(
        self,
        request: vod_20170321_models.ListTemplateGroupConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListTemplateGroupConsoleResponse:
        """
        @summary 列举模版组
        
        @param request: ListTemplateGroupConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTemplateGroupConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.is_contains_templates):
            query['IsContainsTemplates'] = request.is_contains_templates
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTemplateGroupConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListTemplateGroupConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_template_group_console_with_options_async(
        self,
        request: vod_20170321_models.ListTemplateGroupConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListTemplateGroupConsoleResponse:
        """
        @summary 列举模版组
        
        @param request: ListTemplateGroupConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTemplateGroupConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.is_contains_templates):
            query['IsContainsTemplates'] = request.is_contains_templates
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTemplateGroupConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListTemplateGroupConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_template_group_console(
        self,
        request: vod_20170321_models.ListTemplateGroupConsoleRequest,
    ) -> vod_20170321_models.ListTemplateGroupConsoleResponse:
        """
        @summary 列举模版组
        
        @param request: ListTemplateGroupConsoleRequest
        @return: ListTemplateGroupConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_template_group_console_with_options(request, runtime)

    async def list_template_group_console_async(
        self,
        request: vod_20170321_models.ListTemplateGroupConsoleRequest,
    ) -> vod_20170321_models.ListTemplateGroupConsoleResponse:
        """
        @summary 列举模版组
        
        @param request: ListTemplateGroupConsoleRequest
        @return: ListTemplateGroupConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_template_group_console_with_options_async(request, runtime)

    def list_transcode_task_with_options(
        self,
        request: vod_20170321_models.ListTranscodeTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListTranscodeTaskResponse:
        """
        @summary Queries transcoding tasks based on the media ID. This operation does not return specific job information.
        
        @description    You can call the [GetTranscodeTask](https://help.aliyun.com/document_detail/109121.html) operation to query details about transcoding jobs.
        **You can call this operation to query only transcoding tasks created within the past year.**\
        
        @param request: ListTranscodeTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTranscodeTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTranscodeTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListTranscodeTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_transcode_task_with_options_async(
        self,
        request: vod_20170321_models.ListTranscodeTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListTranscodeTaskResponse:
        """
        @summary Queries transcoding tasks based on the media ID. This operation does not return specific job information.
        
        @description    You can call the [GetTranscodeTask](https://help.aliyun.com/document_detail/109121.html) operation to query details about transcoding jobs.
        **You can call this operation to query only transcoding tasks created within the past year.**\
        
        @param request: ListTranscodeTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTranscodeTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTranscodeTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListTranscodeTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_transcode_task(
        self,
        request: vod_20170321_models.ListTranscodeTaskRequest,
    ) -> vod_20170321_models.ListTranscodeTaskResponse:
        """
        @summary Queries transcoding tasks based on the media ID. This operation does not return specific job information.
        
        @description    You can call the [GetTranscodeTask](https://help.aliyun.com/document_detail/109121.html) operation to query details about transcoding jobs.
        **You can call this operation to query only transcoding tasks created within the past year.**\
        
        @param request: ListTranscodeTaskRequest
        @return: ListTranscodeTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_transcode_task_with_options(request, runtime)

    async def list_transcode_task_async(
        self,
        request: vod_20170321_models.ListTranscodeTaskRequest,
    ) -> vod_20170321_models.ListTranscodeTaskResponse:
        """
        @summary Queries transcoding tasks based on the media ID. This operation does not return specific job information.
        
        @description    You can call the [GetTranscodeTask](https://help.aliyun.com/document_detail/109121.html) operation to query details about transcoding jobs.
        **You can call this operation to query only transcoding tasks created within the past year.**\
        
        @param request: ListTranscodeTaskRequest
        @return: ListTranscodeTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_transcode_task_with_options_async(request, runtime)

    def list_transcode_template_group_with_options(
        self,
        request: vod_20170321_models.ListTranscodeTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListTranscodeTemplateGroupResponse:
        """
        @summary Queries transcoding template groups.
        
        @description > This operation does not return the configurations of transcoding templates in each transcoding template group. To query the configurations of transcoding templates in a specific transcoding template group, call the [GetTranscodeTemplateGroup](https://help.aliyun.com/document_detail/102670.html) operation.
        
        @param request: ListTranscodeTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTranscodeTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTranscodeTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListTranscodeTemplateGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_transcode_template_group_with_options_async(
        self,
        request: vod_20170321_models.ListTranscodeTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListTranscodeTemplateGroupResponse:
        """
        @summary Queries transcoding template groups.
        
        @description > This operation does not return the configurations of transcoding templates in each transcoding template group. To query the configurations of transcoding templates in a specific transcoding template group, call the [GetTranscodeTemplateGroup](https://help.aliyun.com/document_detail/102670.html) operation.
        
        @param request: ListTranscodeTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTranscodeTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTranscodeTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListTranscodeTemplateGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_transcode_template_group(
        self,
        request: vod_20170321_models.ListTranscodeTemplateGroupRequest,
    ) -> vod_20170321_models.ListTranscodeTemplateGroupResponse:
        """
        @summary Queries transcoding template groups.
        
        @description > This operation does not return the configurations of transcoding templates in each transcoding template group. To query the configurations of transcoding templates in a specific transcoding template group, call the [GetTranscodeTemplateGroup](https://help.aliyun.com/document_detail/102670.html) operation.
        
        @param request: ListTranscodeTemplateGroupRequest
        @return: ListTranscodeTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_transcode_template_group_with_options(request, runtime)

    async def list_transcode_template_group_async(
        self,
        request: vod_20170321_models.ListTranscodeTemplateGroupRequest,
    ) -> vod_20170321_models.ListTranscodeTemplateGroupResponse:
        """
        @summary Queries transcoding template groups.
        
        @description > This operation does not return the configurations of transcoding templates in each transcoding template group. To query the configurations of transcoding templates in a specific transcoding template group, call the [GetTranscodeTemplateGroup](https://help.aliyun.com/document_detail/102670.html) operation.
        
        @param request: ListTranscodeTemplateGroupRequest
        @return: ListTranscodeTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_transcode_template_group_with_options_async(request, runtime)

    def list_vod_es_template_info_with_options(
        self,
        request: vod_20170321_models.ListVodEsTemplateInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListVodEsTemplateInfoResponse:
        """
        @summary 列举ES模版
        
        @param request: ListVodEsTemplateInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVodEsTemplateInfoResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVodEsTemplateInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListVodEsTemplateInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_vod_es_template_info_with_options_async(
        self,
        request: vod_20170321_models.ListVodEsTemplateInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListVodEsTemplateInfoResponse:
        """
        @summary 列举ES模版
        
        @param request: ListVodEsTemplateInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVodEsTemplateInfoResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVodEsTemplateInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListVodEsTemplateInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_vod_es_template_info(
        self,
        request: vod_20170321_models.ListVodEsTemplateInfoRequest,
    ) -> vod_20170321_models.ListVodEsTemplateInfoResponse:
        """
        @summary 列举ES模版
        
        @param request: ListVodEsTemplateInfoRequest
        @return: ListVodEsTemplateInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_vod_es_template_info_with_options(request, runtime)

    async def list_vod_es_template_info_async(
        self,
        request: vod_20170321_models.ListVodEsTemplateInfoRequest,
    ) -> vod_20170321_models.ListVodEsTemplateInfoResponse:
        """
        @summary 列举ES模版
        
        @param request: ListVodEsTemplateInfoRequest
        @return: ListVodEsTemplateInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_vod_es_template_info_with_options_async(request, runtime)

    def list_vod_realtime_log_delivery_with_options(
        self,
        request: vod_20170321_models.ListVodRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListVodRealtimeLogDeliveryResponse:
        """
        @summary 列举实时日志
        
        @param request: ListVodRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVodRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVodRealtimeLogDelivery',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListVodRealtimeLogDeliveryResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_vod_realtime_log_delivery_with_options_async(
        self,
        request: vod_20170321_models.ListVodRealtimeLogDeliveryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListVodRealtimeLogDeliveryResponse:
        """
        @summary 列举实时日志
        
        @param request: ListVodRealtimeLogDeliveryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVodRealtimeLogDeliveryResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVodRealtimeLogDelivery',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListVodRealtimeLogDeliveryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_vod_realtime_log_delivery(
        self,
        request: vod_20170321_models.ListVodRealtimeLogDeliveryRequest,
    ) -> vod_20170321_models.ListVodRealtimeLogDeliveryResponse:
        """
        @summary 列举实时日志
        
        @param request: ListVodRealtimeLogDeliveryRequest
        @return: ListVodRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_vod_realtime_log_delivery_with_options(request, runtime)

    async def list_vod_realtime_log_delivery_async(
        self,
        request: vod_20170321_models.ListVodRealtimeLogDeliveryRequest,
    ) -> vod_20170321_models.ListVodRealtimeLogDeliveryResponse:
        """
        @summary 列举实时日志
        
        @param request: ListVodRealtimeLogDeliveryRequest
        @return: ListVodRealtimeLogDeliveryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_vod_realtime_log_delivery_with_options_async(request, runtime)

    def list_vod_realtime_log_delivery_domains_with_options(
        self,
        request: vod_20170321_models.ListVodRealtimeLogDeliveryDomainsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListVodRealtimeLogDeliveryDomainsResponse:
        """
        @summary 列举实时日志域名
        
        @param request: ListVodRealtimeLogDeliveryDomainsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVodRealtimeLogDeliveryDomainsResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVodRealtimeLogDeliveryDomains',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListVodRealtimeLogDeliveryDomainsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_vod_realtime_log_delivery_domains_with_options_async(
        self,
        request: vod_20170321_models.ListVodRealtimeLogDeliveryDomainsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListVodRealtimeLogDeliveryDomainsResponse:
        """
        @summary 列举实时日志域名
        
        @param request: ListVodRealtimeLogDeliveryDomainsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVodRealtimeLogDeliveryDomainsResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVodRealtimeLogDeliveryDomains',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListVodRealtimeLogDeliveryDomainsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_vod_realtime_log_delivery_domains(
        self,
        request: vod_20170321_models.ListVodRealtimeLogDeliveryDomainsRequest,
    ) -> vod_20170321_models.ListVodRealtimeLogDeliveryDomainsResponse:
        """
        @summary 列举实时日志域名
        
        @param request: ListVodRealtimeLogDeliveryDomainsRequest
        @return: ListVodRealtimeLogDeliveryDomainsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_vod_realtime_log_delivery_domains_with_options(request, runtime)

    async def list_vod_realtime_log_delivery_domains_async(
        self,
        request: vod_20170321_models.ListVodRealtimeLogDeliveryDomainsRequest,
    ) -> vod_20170321_models.ListVodRealtimeLogDeliveryDomainsResponse:
        """
        @summary 列举实时日志域名
        
        @param request: ListVodRealtimeLogDeliveryDomainsRequest
        @return: ListVodRealtimeLogDeliveryDomainsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_vod_realtime_log_delivery_domains_with_options_async(request, runtime)

    def list_vod_realtime_log_delivery_infos_with_options(
        self,
        request: vod_20170321_models.ListVodRealtimeLogDeliveryInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListVodRealtimeLogDeliveryInfosResponse:
        """
        @summary 列举实时日志转存信息
        
        @param request: ListVodRealtimeLogDeliveryInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVodRealtimeLogDeliveryInfosResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVodRealtimeLogDeliveryInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListVodRealtimeLogDeliveryInfosResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_vod_realtime_log_delivery_infos_with_options_async(
        self,
        request: vod_20170321_models.ListVodRealtimeLogDeliveryInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListVodRealtimeLogDeliveryInfosResponse:
        """
        @summary 列举实时日志转存信息
        
        @param request: ListVodRealtimeLogDeliveryInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVodRealtimeLogDeliveryInfosResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVodRealtimeLogDeliveryInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListVodRealtimeLogDeliveryInfosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_vod_realtime_log_delivery_infos(
        self,
        request: vod_20170321_models.ListVodRealtimeLogDeliveryInfosRequest,
    ) -> vod_20170321_models.ListVodRealtimeLogDeliveryInfosResponse:
        """
        @summary 列举实时日志转存信息
        
        @param request: ListVodRealtimeLogDeliveryInfosRequest
        @return: ListVodRealtimeLogDeliveryInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_vod_realtime_log_delivery_infos_with_options(request, runtime)

    async def list_vod_realtime_log_delivery_infos_async(
        self,
        request: vod_20170321_models.ListVodRealtimeLogDeliveryInfosRequest,
    ) -> vod_20170321_models.ListVodRealtimeLogDeliveryInfosResponse:
        """
        @summary 列举实时日志转存信息
        
        @param request: ListVodRealtimeLogDeliveryInfosRequest
        @return: ListVodRealtimeLogDeliveryInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_vod_realtime_log_delivery_infos_with_options_async(request, runtime)

    def list_vod_tag_resources_with_options(
        self,
        request: vod_20170321_models.ListVodTagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListVodTagResourcesResponse:
        """
        @summary 列举VOD域名标签
        
        @param request: ListVodTagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVodTagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.tag_owner_bid):
            query['TagOwnerBid'] = request.tag_owner_bid
        if not UtilClient.is_unset(request.tag_owner_uid):
            query['TagOwnerUid'] = request.tag_owner_uid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVodTagResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListVodTagResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_vod_tag_resources_with_options_async(
        self,
        request: vod_20170321_models.ListVodTagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListVodTagResourcesResponse:
        """
        @summary 列举VOD域名标签
        
        @param request: ListVodTagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVodTagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        if not UtilClient.is_unset(request.tag_owner_bid):
            query['TagOwnerBid'] = request.tag_owner_bid
        if not UtilClient.is_unset(request.tag_owner_uid):
            query['TagOwnerUid'] = request.tag_owner_uid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVodTagResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListVodTagResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_vod_tag_resources(
        self,
        request: vod_20170321_models.ListVodTagResourcesRequest,
    ) -> vod_20170321_models.ListVodTagResourcesResponse:
        """
        @summary 列举VOD域名标签
        
        @param request: ListVodTagResourcesRequest
        @return: ListVodTagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_vod_tag_resources_with_options(request, runtime)

    async def list_vod_tag_resources_async(
        self,
        request: vod_20170321_models.ListVodTagResourcesRequest,
    ) -> vod_20170321_models.ListVodTagResourcesResponse:
        """
        @summary 列举VOD域名标签
        
        @param request: ListVodTagResourcesRequest
        @return: ListVodTagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_vod_tag_resources_with_options_async(request, runtime)

    def list_vod_template_with_options(
        self,
        request: vod_20170321_models.ListVodTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListVodTemplateResponse:
        """
        @summary Queries snapshot templates.
        
        @param request: ListVodTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVodTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVodTemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListVodTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_vod_template_with_options_async(
        self,
        request: vod_20170321_models.ListVodTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListVodTemplateResponse:
        """
        @summary Queries snapshot templates.
        
        @param request: ListVodTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListVodTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListVodTemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListVodTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_vod_template(
        self,
        request: vod_20170321_models.ListVodTemplateRequest,
    ) -> vod_20170321_models.ListVodTemplateResponse:
        """
        @summary Queries snapshot templates.
        
        @param request: ListVodTemplateRequest
        @return: ListVodTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_vod_template_with_options(request, runtime)

    async def list_vod_template_async(
        self,
        request: vod_20170321_models.ListVodTemplateRequest,
    ) -> vod_20170321_models.ListVodTemplateResponse:
        """
        @summary Queries snapshot templates.
        
        @param request: ListVodTemplateRequest
        @return: ListVodTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_vod_template_with_options_async(request, runtime)

    def list_watermark_with_options(
        self,
        request: vod_20170321_models.ListWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListWatermarkResponse:
        """
        @summary Queries the configuration information about all image and text watermark templates in a region. You can call this operation to obtain information such as the position, size, and display time of image watermarks or the content, position, font, and font color of text watermarks.
        
        @param request: ListWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListWatermark',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListWatermarkResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_watermark_with_options_async(
        self,
        request: vod_20170321_models.ListWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListWatermarkResponse:
        """
        @summary Queries the configuration information about all image and text watermark templates in a region. You can call this operation to obtain information such as the position, size, and display time of image watermarks or the content, position, font, and font color of text watermarks.
        
        @param request: ListWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListWatermark',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListWatermarkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_watermark(
        self,
        request: vod_20170321_models.ListWatermarkRequest,
    ) -> vod_20170321_models.ListWatermarkResponse:
        """
        @summary Queries the configuration information about all image and text watermark templates in a region. You can call this operation to obtain information such as the position, size, and display time of image watermarks or the content, position, font, and font color of text watermarks.
        
        @param request: ListWatermarkRequest
        @return: ListWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_watermark_with_options(request, runtime)

    async def list_watermark_async(
        self,
        request: vod_20170321_models.ListWatermarkRequest,
    ) -> vod_20170321_models.ListWatermarkResponse:
        """
        @summary Queries the configuration information about all image and text watermark templates in a region. You can call this operation to obtain information such as the position, size, and display time of image watermarks or the content, position, font, and font color of text watermarks.
        
        @param request: ListWatermarkRequest
        @return: ListWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_watermark_with_options_async(request, runtime)

    def list_workflow_with_options(
        self,
        request: vod_20170321_models.ListWorkflowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListWorkflowResponse:
        """
        @summary 列举工作流
        
        @param request: ListWorkflowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListWorkflowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.biz_version):
            query['BizVersion'] = request.biz_version
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.state):
            query['State'] = request.state
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListWorkflow',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListWorkflowResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_workflow_with_options_async(
        self,
        request: vod_20170321_models.ListWorkflowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ListWorkflowResponse:
        """
        @summary 列举工作流
        
        @param request: ListWorkflowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListWorkflowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.biz_version):
            query['BizVersion'] = request.biz_version
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.state):
            query['State'] = request.state
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListWorkflow',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ListWorkflowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_workflow(
        self,
        request: vod_20170321_models.ListWorkflowRequest,
    ) -> vod_20170321_models.ListWorkflowResponse:
        """
        @summary 列举工作流
        
        @param request: ListWorkflowRequest
        @return: ListWorkflowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_workflow_with_options(request, runtime)

    async def list_workflow_async(
        self,
        request: vod_20170321_models.ListWorkflowRequest,
    ) -> vod_20170321_models.ListWorkflowResponse:
        """
        @summary 列举工作流
        
        @param request: ListWorkflowRequest
        @return: ListWorkflowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_workflow_with_options_async(request, runtime)

    def modify_license_info_with_options(
        self,
        request: vod_20170321_models.ModifyLicenseInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ModifyLicenseInfoResponse:
        """
        @summary 修改license
        
        @param request: ModifyLicenseInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLicenseInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.account_id):
            query['AccountId'] = request.account_id
        if not UtilClient.is_unset(request.begin_time):
            query['BeginTime'] = request.begin_time
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.contract_no):
            query['ContractNo'] = request.contract_no
        if not UtilClient.is_unset(request.customer_id):
            query['CustomerId'] = request.customer_id
        if not UtilClient.is_unset(request.expired_on):
            query['ExpiredOn'] = request.expired_on
        if not UtilClient.is_unset(request.extra_info):
            query['ExtraInfo'] = request.extra_info
        if not UtilClient.is_unset(request.license_id):
            query['LicenseId'] = request.license_id
        if not UtilClient.is_unset(request.operator):
            query['Operator'] = request.operator
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLicenseInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ModifyLicenseInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_license_info_with_options_async(
        self,
        request: vod_20170321_models.ModifyLicenseInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ModifyLicenseInfoResponse:
        """
        @summary 修改license
        
        @param request: ModifyLicenseInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyLicenseInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.account_id):
            query['AccountId'] = request.account_id
        if not UtilClient.is_unset(request.begin_time):
            query['BeginTime'] = request.begin_time
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.contract_no):
            query['ContractNo'] = request.contract_no
        if not UtilClient.is_unset(request.customer_id):
            query['CustomerId'] = request.customer_id
        if not UtilClient.is_unset(request.expired_on):
            query['ExpiredOn'] = request.expired_on
        if not UtilClient.is_unset(request.extra_info):
            query['ExtraInfo'] = request.extra_info
        if not UtilClient.is_unset(request.license_id):
            query['LicenseId'] = request.license_id
        if not UtilClient.is_unset(request.operator):
            query['Operator'] = request.operator
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyLicenseInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ModifyLicenseInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_license_info(
        self,
        request: vod_20170321_models.ModifyLicenseInfoRequest,
    ) -> vod_20170321_models.ModifyLicenseInfoResponse:
        """
        @summary 修改license
        
        @param request: ModifyLicenseInfoRequest
        @return: ModifyLicenseInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_license_info_with_options(request, runtime)

    async def modify_license_info_async(
        self,
        request: vod_20170321_models.ModifyLicenseInfoRequest,
    ) -> vod_20170321_models.ModifyLicenseInfoResponse:
        """
        @summary 修改license
        
        @param request: ModifyLicenseInfoRequest
        @return: ModifyLicenseInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_license_info_with_options_async(request, runtime)

    def modify_vod_domain_schdm_by_property_with_options(
        self,
        request: vod_20170321_models.ModifyVodDomainSchdmByPropertyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ModifyVodDomainSchdmByPropertyResponse:
        """
        @summary 修改域名配置
        
        @param request: ModifyVodDomainSchdmByPropertyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVodDomainSchdmByPropertyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.property):
            query['Property'] = request.property
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVodDomainSchdmByProperty',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ModifyVodDomainSchdmByPropertyResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vod_domain_schdm_by_property_with_options_async(
        self,
        request: vod_20170321_models.ModifyVodDomainSchdmByPropertyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ModifyVodDomainSchdmByPropertyResponse:
        """
        @summary 修改域名配置
        
        @param request: ModifyVodDomainSchdmByPropertyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVodDomainSchdmByPropertyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.property):
            query['Property'] = request.property
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVodDomainSchdmByProperty',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ModifyVodDomainSchdmByPropertyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vod_domain_schdm_by_property(
        self,
        request: vod_20170321_models.ModifyVodDomainSchdmByPropertyRequest,
    ) -> vod_20170321_models.ModifyVodDomainSchdmByPropertyResponse:
        """
        @summary 修改域名配置
        
        @param request: ModifyVodDomainSchdmByPropertyRequest
        @return: ModifyVodDomainSchdmByPropertyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vod_domain_schdm_by_property_with_options(request, runtime)

    async def modify_vod_domain_schdm_by_property_async(
        self,
        request: vod_20170321_models.ModifyVodDomainSchdmByPropertyRequest,
    ) -> vod_20170321_models.ModifyVodDomainSchdmByPropertyResponse:
        """
        @summary 修改域名配置
        
        @param request: ModifyVodDomainSchdmByPropertyRequest
        @return: ModifyVodDomainSchdmByPropertyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vod_domain_schdm_by_property_with_options_async(request, runtime)

    def modify_vod_service_with_options(
        self,
        request: vod_20170321_models.ModifyVodServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ModifyVodServiceResponse:
        """
        @summary 修改Vod服务配置
        
        @param request: ModifyVodServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVodServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVodService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ModifyVodServiceResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_vod_service_with_options_async(
        self,
        request: vod_20170321_models.ModifyVodServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ModifyVodServiceResponse:
        """
        @summary 修改Vod服务配置
        
        @param request: ModifyVodServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyVodServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.internet_charge_type):
            query['InternetChargeType'] = request.internet_charge_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyVodService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ModifyVodServiceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_vod_service(
        self,
        request: vod_20170321_models.ModifyVodServiceRequest,
    ) -> vod_20170321_models.ModifyVodServiceResponse:
        """
        @summary 修改Vod服务配置
        
        @param request: ModifyVodServiceRequest
        @return: ModifyVodServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_vod_service_with_options(request, runtime)

    async def modify_vod_service_async(
        self,
        request: vod_20170321_models.ModifyVodServiceRequest,
    ) -> vod_20170321_models.ModifyVodServiceResponse:
        """
        @summary 修改Vod服务配置
        
        @param request: ModifyVodServiceRequest
        @return: ModifyVodServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_vod_service_with_options_async(request, runtime)

    def move_app_resource_with_options(
        self,
        request: vod_20170321_models.MoveAppResourceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.MoveAppResourceResponse:
        """
        @summary Migrates resources between applications. The application administrator can directly migrate resources between applications. Resource Access Management (RAM) users or RAM roles must obtain the write permissions on the source and destination applications before they migrate resources between applications. Multiple resources can be migrated at a time.
        
        @param request: MoveAppResourceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MoveAppResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.resource_ids):
            query['ResourceIds'] = request.resource_ids
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.target_app_id):
            query['TargetAppId'] = request.target_app_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MoveAppResource',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.MoveAppResourceResponse(),
            self.call_api(params, req, runtime)
        )

    async def move_app_resource_with_options_async(
        self,
        request: vod_20170321_models.MoveAppResourceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.MoveAppResourceResponse:
        """
        @summary Migrates resources between applications. The application administrator can directly migrate resources between applications. Resource Access Management (RAM) users or RAM roles must obtain the write permissions on the source and destination applications before they migrate resources between applications. Multiple resources can be migrated at a time.
        
        @param request: MoveAppResourceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MoveAppResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.resource_ids):
            query['ResourceIds'] = request.resource_ids
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.target_app_id):
            query['TargetAppId'] = request.target_app_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MoveAppResource',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.MoveAppResourceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def move_app_resource(
        self,
        request: vod_20170321_models.MoveAppResourceRequest,
    ) -> vod_20170321_models.MoveAppResourceResponse:
        """
        @summary Migrates resources between applications. The application administrator can directly migrate resources between applications. Resource Access Management (RAM) users or RAM roles must obtain the write permissions on the source and destination applications before they migrate resources between applications. Multiple resources can be migrated at a time.
        
        @param request: MoveAppResourceRequest
        @return: MoveAppResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.move_app_resource_with_options(request, runtime)

    async def move_app_resource_async(
        self,
        request: vod_20170321_models.MoveAppResourceRequest,
    ) -> vod_20170321_models.MoveAppResourceResponse:
        """
        @summary Migrates resources between applications. The application administrator can directly migrate resources between applications. Resource Access Management (RAM) users or RAM roles must obtain the write permissions on the source and destination applications before they migrate resources between applications. Multiple resources can be migrated at a time.
        
        @param request: MoveAppResourceRequest
        @return: MoveAppResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.move_app_resource_with_options_async(request, runtime)

    def open_vod_service_with_options(
        self,
        request: vod_20170321_models.OpenVodServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.OpenVodServiceResponse:
        """
        @summary 开通Vod服务
        
        @param request: OpenVodServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenVodServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OpenVodService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.OpenVodServiceResponse(),
            self.call_api(params, req, runtime)
        )

    async def open_vod_service_with_options_async(
        self,
        request: vod_20170321_models.OpenVodServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.OpenVodServiceResponse:
        """
        @summary 开通Vod服务
        
        @param request: OpenVodServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenVodServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OpenVodService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.OpenVodServiceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def open_vod_service(
        self,
        request: vod_20170321_models.OpenVodServiceRequest,
    ) -> vod_20170321_models.OpenVodServiceResponse:
        """
        @summary 开通Vod服务
        
        @param request: OpenVodServiceRequest
        @return: OpenVodServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.open_vod_service_with_options(request, runtime)

    async def open_vod_service_async(
        self,
        request: vod_20170321_models.OpenVodServiceRequest,
    ) -> vod_20170321_models.OpenVodServiceResponse:
        """
        @summary 开通Vod服务
        
        @param request: OpenVodServiceRequest
        @return: OpenVodServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.open_vod_service_with_options_async(request, runtime)

    def preload_play_device_ability_with_options(
        self,
        request: vod_20170321_models.PreloadPlayDeviceAbilityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.PreloadPlayDeviceAbilityResponse:
        """
        @summary 预加载播放设备能力数据到缓存
        
        @param request: PreloadPlayDeviceAbilityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PreloadPlayDeviceAbilityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.brand):
            query['Brand'] = request.brand
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PreloadPlayDeviceAbility',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.PreloadPlayDeviceAbilityResponse(),
            self.call_api(params, req, runtime)
        )

    async def preload_play_device_ability_with_options_async(
        self,
        request: vod_20170321_models.PreloadPlayDeviceAbilityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.PreloadPlayDeviceAbilityResponse:
        """
        @summary 预加载播放设备能力数据到缓存
        
        @param request: PreloadPlayDeviceAbilityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PreloadPlayDeviceAbilityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.brand):
            query['Brand'] = request.brand
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PreloadPlayDeviceAbility',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.PreloadPlayDeviceAbilityResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def preload_play_device_ability(
        self,
        request: vod_20170321_models.PreloadPlayDeviceAbilityRequest,
    ) -> vod_20170321_models.PreloadPlayDeviceAbilityResponse:
        """
        @summary 预加载播放设备能力数据到缓存
        
        @param request: PreloadPlayDeviceAbilityRequest
        @return: PreloadPlayDeviceAbilityResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.preload_play_device_ability_with_options(request, runtime)

    async def preload_play_device_ability_async(
        self,
        request: vod_20170321_models.PreloadPlayDeviceAbilityRequest,
    ) -> vod_20170321_models.PreloadPlayDeviceAbilityResponse:
        """
        @summary 预加载播放设备能力数据到缓存
        
        @param request: PreloadPlayDeviceAbilityRequest
        @return: PreloadPlayDeviceAbilityResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.preload_play_device_ability_with_options_async(request, runtime)

    def preload_vod_object_caches_with_options(
        self,
        request: vod_20170321_models.PreloadVodObjectCachesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.PreloadVodObjectCachesResponse:
        """
        @summary Prefetches resources from an origin server to L2 nodes. Users can directly hit the cache upon their first visits. This way, workloads on the origin server can be reduced.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    You can submit a maximum of 500 requests to prefetch resources based on URLs each day by using an Alibaba Cloud account. You cannot prefetch resources based on directories.
        >    You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.htmll) operation to prefetch content.
        
        @param request: PreloadVodObjectCachesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PreloadVodObjectCachesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.area):
            query['Area'] = request.area
        if not UtilClient.is_unset(request.l_2preload):
            query['L2Preload'] = request.l_2preload
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.with_header):
            query['WithHeader'] = request.with_header
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PreloadVodObjectCaches',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.PreloadVodObjectCachesResponse(),
            self.call_api(params, req, runtime)
        )

    async def preload_vod_object_caches_with_options_async(
        self,
        request: vod_20170321_models.PreloadVodObjectCachesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.PreloadVodObjectCachesResponse:
        """
        @summary Prefetches resources from an origin server to L2 nodes. Users can directly hit the cache upon their first visits. This way, workloads on the origin server can be reduced.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    You can submit a maximum of 500 requests to prefetch resources based on URLs each day by using an Alibaba Cloud account. You cannot prefetch resources based on directories.
        >    You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.htmll) operation to prefetch content.
        
        @param request: PreloadVodObjectCachesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PreloadVodObjectCachesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.area):
            query['Area'] = request.area
        if not UtilClient.is_unset(request.l_2preload):
            query['L2Preload'] = request.l_2preload
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.with_header):
            query['WithHeader'] = request.with_header
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PreloadVodObjectCaches',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.PreloadVodObjectCachesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def preload_vod_object_caches(
        self,
        request: vod_20170321_models.PreloadVodObjectCachesRequest,
    ) -> vod_20170321_models.PreloadVodObjectCachesResponse:
        """
        @summary Prefetches resources from an origin server to L2 nodes. Users can directly hit the cache upon their first visits. This way, workloads on the origin server can be reduced.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    You can submit a maximum of 500 requests to prefetch resources based on URLs each day by using an Alibaba Cloud account. You cannot prefetch resources based on directories.
        >    You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.htmll) operation to prefetch content.
        
        @param request: PreloadVodObjectCachesRequest
        @return: PreloadVodObjectCachesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.preload_vod_object_caches_with_options(request, runtime)

    async def preload_vod_object_caches_async(
        self,
        request: vod_20170321_models.PreloadVodObjectCachesRequest,
    ) -> vod_20170321_models.PreloadVodObjectCachesResponse:
        """
        @summary Prefetches resources from an origin server to L2 nodes. Users can directly hit the cache upon their first visits. This way, workloads on the origin server can be reduced.
        
        @description >    This operation is available only in the **China (Shanghai)** region.
        >    You can submit a maximum of 500 requests to prefetch resources based on URLs each day by using an Alibaba Cloud account. You cannot prefetch resources based on directories.
        >    You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.htmll) operation to prefetch content.
        
        @param request: PreloadVodObjectCachesRequest
        @return: PreloadVodObjectCachesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.preload_vod_object_caches_with_options_async(request, runtime)

    def produce_editing_project_video_with_options(
        self,
        request: vod_20170321_models.ProduceEditingProjectVideoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ProduceEditingProjectVideoResponse:
        """
        @summary Produces a video from one or more source files. You can directly specify source files by configuring the Timeline parameter. Alternatively, you can specify source files after you create an online editing project.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for using the online editing feature. For more information, see [Billing](~~188310#section-pyv-b8h-bo7~~).**\
        This operation returns only the submission result of a video production task. When the submission result is returned, video production may still be in progress. After a video production task is submitted, the task is queued in the background for asynchronous processing.
        The source files that are used in the timeline of an online editing project can be materials directly uploaded to the online project or selected from the media asset library. Only media assets that are in the Normal state can be used in the project.
        Videos are produced based on ProjectId and Timeline. The following content describes the parameter configurations:
        You must specify ProjectId or Timeline. If you leave both parameters empty, the video cannot be produced.
        If you specify Timeline and leave ProjectId empty, the system automatically creates an online editing project based on Timeline and adds the materials specified in the Timeline to the project to produce videos.
        If you specify ProjectId and leave Timeline empty, the system automatically uses the latest timeline information of the project to produce videos.
        If you specify both ProjectId and Timeline, the system automatically uses the timeline information that you specified to produce videos and updates the project timeline and materials. You can also specify other parameters to update the corresponding information about the online editing project.
        You can create up to 100 video tracks, 100 image tracks, and 100 subtitle tracks in a project.
        The total size of material files cannot exceed 1 TB.
        The buckets in which the materials reside and where the exported videos are stored must be in the same region as the region where ApsaraVideo VOD is activated.
        The exported videos must meet the following requirements:
        The width and height of the video image cannot be less than 128 pixels.
        The width and height of the video image cannot exceed 4,096 pixels.
        The width cannot exceed 2,160 pixels.
        After a video is produced, the video is automatically uploaded to ApsaraVideo VOD. Then, the **ProduceMediaComplete** and **FileUploadComplete** event notifications are sent to you. After the produced video is transcoded, the **StreamTranscodeComplete** and **TranscodeComplete** event notifications are sent to you.
        You can add special effects to the video. For more information, see [Special effects](https://help.aliyun.com/document_detail/69082.html).
        
        @param request: ProduceEditingProjectVideoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ProduceEditingProjectVideoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.cover_url):
            query['CoverURL'] = request.cover_url
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.media_metadata):
            query['MediaMetadata'] = request.media_metadata
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.produce_config):
            query['ProduceConfig'] = request.produce_config
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.timeline):
            query['Timeline'] = request.timeline
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ProduceEditingProjectVideo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ProduceEditingProjectVideoResponse(),
            self.call_api(params, req, runtime)
        )

    async def produce_editing_project_video_with_options_async(
        self,
        request: vod_20170321_models.ProduceEditingProjectVideoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ProduceEditingProjectVideoResponse:
        """
        @summary Produces a video from one or more source files. You can directly specify source files by configuring the Timeline parameter. Alternatively, you can specify source files after you create an online editing project.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for using the online editing feature. For more information, see [Billing](~~188310#section-pyv-b8h-bo7~~).**\
        This operation returns only the submission result of a video production task. When the submission result is returned, video production may still be in progress. After a video production task is submitted, the task is queued in the background for asynchronous processing.
        The source files that are used in the timeline of an online editing project can be materials directly uploaded to the online project or selected from the media asset library. Only media assets that are in the Normal state can be used in the project.
        Videos are produced based on ProjectId and Timeline. The following content describes the parameter configurations:
        You must specify ProjectId or Timeline. If you leave both parameters empty, the video cannot be produced.
        If you specify Timeline and leave ProjectId empty, the system automatically creates an online editing project based on Timeline and adds the materials specified in the Timeline to the project to produce videos.
        If you specify ProjectId and leave Timeline empty, the system automatically uses the latest timeline information of the project to produce videos.
        If you specify both ProjectId and Timeline, the system automatically uses the timeline information that you specified to produce videos and updates the project timeline and materials. You can also specify other parameters to update the corresponding information about the online editing project.
        You can create up to 100 video tracks, 100 image tracks, and 100 subtitle tracks in a project.
        The total size of material files cannot exceed 1 TB.
        The buckets in which the materials reside and where the exported videos are stored must be in the same region as the region where ApsaraVideo VOD is activated.
        The exported videos must meet the following requirements:
        The width and height of the video image cannot be less than 128 pixels.
        The width and height of the video image cannot exceed 4,096 pixels.
        The width cannot exceed 2,160 pixels.
        After a video is produced, the video is automatically uploaded to ApsaraVideo VOD. Then, the **ProduceMediaComplete** and **FileUploadComplete** event notifications are sent to you. After the produced video is transcoded, the **StreamTranscodeComplete** and **TranscodeComplete** event notifications are sent to you.
        You can add special effects to the video. For more information, see [Special effects](https://help.aliyun.com/document_detail/69082.html).
        
        @param request: ProduceEditingProjectVideoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ProduceEditingProjectVideoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.cover_url):
            query['CoverURL'] = request.cover_url
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.media_metadata):
            query['MediaMetadata'] = request.media_metadata
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.produce_config):
            query['ProduceConfig'] = request.produce_config
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.timeline):
            query['Timeline'] = request.timeline
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ProduceEditingProjectVideo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ProduceEditingProjectVideoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def produce_editing_project_video(
        self,
        request: vod_20170321_models.ProduceEditingProjectVideoRequest,
    ) -> vod_20170321_models.ProduceEditingProjectVideoResponse:
        """
        @summary Produces a video from one or more source files. You can directly specify source files by configuring the Timeline parameter. Alternatively, you can specify source files after you create an online editing project.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for using the online editing feature. For more information, see [Billing](~~188310#section-pyv-b8h-bo7~~).**\
        This operation returns only the submission result of a video production task. When the submission result is returned, video production may still be in progress. After a video production task is submitted, the task is queued in the background for asynchronous processing.
        The source files that are used in the timeline of an online editing project can be materials directly uploaded to the online project or selected from the media asset library. Only media assets that are in the Normal state can be used in the project.
        Videos are produced based on ProjectId and Timeline. The following content describes the parameter configurations:
        You must specify ProjectId or Timeline. If you leave both parameters empty, the video cannot be produced.
        If you specify Timeline and leave ProjectId empty, the system automatically creates an online editing project based on Timeline and adds the materials specified in the Timeline to the project to produce videos.
        If you specify ProjectId and leave Timeline empty, the system automatically uses the latest timeline information of the project to produce videos.
        If you specify both ProjectId and Timeline, the system automatically uses the timeline information that you specified to produce videos and updates the project timeline and materials. You can also specify other parameters to update the corresponding information about the online editing project.
        You can create up to 100 video tracks, 100 image tracks, and 100 subtitle tracks in a project.
        The total size of material files cannot exceed 1 TB.
        The buckets in which the materials reside and where the exported videos are stored must be in the same region as the region where ApsaraVideo VOD is activated.
        The exported videos must meet the following requirements:
        The width and height of the video image cannot be less than 128 pixels.
        The width and height of the video image cannot exceed 4,096 pixels.
        The width cannot exceed 2,160 pixels.
        After a video is produced, the video is automatically uploaded to ApsaraVideo VOD. Then, the **ProduceMediaComplete** and **FileUploadComplete** event notifications are sent to you. After the produced video is transcoded, the **StreamTranscodeComplete** and **TranscodeComplete** event notifications are sent to you.
        You can add special effects to the video. For more information, see [Special effects](https://help.aliyun.com/document_detail/69082.html).
        
        @param request: ProduceEditingProjectVideoRequest
        @return: ProduceEditingProjectVideoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.produce_editing_project_video_with_options(request, runtime)

    async def produce_editing_project_video_async(
        self,
        request: vod_20170321_models.ProduceEditingProjectVideoRequest,
    ) -> vod_20170321_models.ProduceEditingProjectVideoResponse:
        """
        @summary Produces a video from one or more source files. You can directly specify source files by configuring the Timeline parameter. Alternatively, you can specify source files after you create an online editing project.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for using the online editing feature. For more information, see [Billing](~~188310#section-pyv-b8h-bo7~~).**\
        This operation returns only the submission result of a video production task. When the submission result is returned, video production may still be in progress. After a video production task is submitted, the task is queued in the background for asynchronous processing.
        The source files that are used in the timeline of an online editing project can be materials directly uploaded to the online project or selected from the media asset library. Only media assets that are in the Normal state can be used in the project.
        Videos are produced based on ProjectId and Timeline. The following content describes the parameter configurations:
        You must specify ProjectId or Timeline. If you leave both parameters empty, the video cannot be produced.
        If you specify Timeline and leave ProjectId empty, the system automatically creates an online editing project based on Timeline and adds the materials specified in the Timeline to the project to produce videos.
        If you specify ProjectId and leave Timeline empty, the system automatically uses the latest timeline information of the project to produce videos.
        If you specify both ProjectId and Timeline, the system automatically uses the timeline information that you specified to produce videos and updates the project timeline and materials. You can also specify other parameters to update the corresponding information about the online editing project.
        You can create up to 100 video tracks, 100 image tracks, and 100 subtitle tracks in a project.
        The total size of material files cannot exceed 1 TB.
        The buckets in which the materials reside and where the exported videos are stored must be in the same region as the region where ApsaraVideo VOD is activated.
        The exported videos must meet the following requirements:
        The width and height of the video image cannot be less than 128 pixels.
        The width and height of the video image cannot exceed 4,096 pixels.
        The width cannot exceed 2,160 pixels.
        After a video is produced, the video is automatically uploaded to ApsaraVideo VOD. Then, the **ProduceMediaComplete** and **FileUploadComplete** event notifications are sent to you. After the produced video is transcoded, the **StreamTranscodeComplete** and **TranscodeComplete** event notifications are sent to you.
        You can add special effects to the video. For more information, see [Special effects](https://help.aliyun.com/document_detail/69082.html).
        
        @param request: ProduceEditingProjectVideoRequest
        @return: ProduceEditingProjectVideoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.produce_editing_project_video_with_options_async(request, runtime)

    def publish_vod_staging_config_to_production_with_options(
        self,
        request: vod_20170321_models.PublishVodStagingConfigToProductionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.PublishVodStagingConfigToProductionResponse:
        """
        @summary 发布灰度配置到生产
        
        @param request: PublishVodStagingConfigToProductionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PublishVodStagingConfigToProductionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PublishVodStagingConfigToProduction',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.PublishVodStagingConfigToProductionResponse(),
            self.call_api(params, req, runtime)
        )

    async def publish_vod_staging_config_to_production_with_options_async(
        self,
        request: vod_20170321_models.PublishVodStagingConfigToProductionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.PublishVodStagingConfigToProductionResponse:
        """
        @summary 发布灰度配置到生产
        
        @param request: PublishVodStagingConfigToProductionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PublishVodStagingConfigToProductionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PublishVodStagingConfigToProduction',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.PublishVodStagingConfigToProductionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def publish_vod_staging_config_to_production(
        self,
        request: vod_20170321_models.PublishVodStagingConfigToProductionRequest,
    ) -> vod_20170321_models.PublishVodStagingConfigToProductionResponse:
        """
        @summary 发布灰度配置到生产
        
        @param request: PublishVodStagingConfigToProductionRequest
        @return: PublishVodStagingConfigToProductionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.publish_vod_staging_config_to_production_with_options(request, runtime)

    async def publish_vod_staging_config_to_production_async(
        self,
        request: vod_20170321_models.PublishVodStagingConfigToProductionRequest,
    ) -> vod_20170321_models.PublishVodStagingConfigToProductionResponse:
        """
        @summary 发布灰度配置到生产
        
        @param request: PublishVodStagingConfigToProductionRequest
        @return: PublishVodStagingConfigToProductionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.publish_vod_staging_config_to_production_with_options_async(request, runtime)

    def push_object_cache_with_options(
        self,
        request: vod_20170321_models.PushObjectCacheRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.PushObjectCacheResponse:
        """
        @summary 推送缓存
        
        @param request: PushObjectCacheRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PushObjectCacheResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PushObjectCache',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.PushObjectCacheResponse(),
            self.call_api(params, req, runtime)
        )

    async def push_object_cache_with_options_async(
        self,
        request: vod_20170321_models.PushObjectCacheRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.PushObjectCacheResponse:
        """
        @summary 推送缓存
        
        @param request: PushObjectCacheRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PushObjectCacheResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PushObjectCache',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.PushObjectCacheResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def push_object_cache(
        self,
        request: vod_20170321_models.PushObjectCacheRequest,
    ) -> vod_20170321_models.PushObjectCacheResponse:
        """
        @summary 推送缓存
        
        @param request: PushObjectCacheRequest
        @return: PushObjectCacheResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.push_object_cache_with_options(request, runtime)

    async def push_object_cache_async(
        self,
        request: vod_20170321_models.PushObjectCacheRequest,
    ) -> vod_20170321_models.PushObjectCacheResponse:
        """
        @summary 推送缓存
        
        @param request: PushObjectCacheRequest
        @return: PushObjectCacheResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.push_object_cache_with_options_async(request, runtime)

    def query_css_order_for_license_with_options(
        self,
        request: vod_20170321_models.QueryCssOrderForLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.QueryCssOrderForLicenseResponse:
        """
        @summary 下单询价流量询价
        
        @param request: QueryCssOrderForLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: QueryCssOrderForLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.param_str):
            query['ParamStr'] = request.param_str
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='QueryCssOrderForLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.QueryCssOrderForLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def query_css_order_for_license_with_options_async(
        self,
        request: vod_20170321_models.QueryCssOrderForLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.QueryCssOrderForLicenseResponse:
        """
        @summary 下单询价流量询价
        
        @param request: QueryCssOrderForLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: QueryCssOrderForLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.param_str):
            query['ParamStr'] = request.param_str
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='QueryCssOrderForLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.QueryCssOrderForLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def query_css_order_for_license(
        self,
        request: vod_20170321_models.QueryCssOrderForLicenseRequest,
    ) -> vod_20170321_models.QueryCssOrderForLicenseResponse:
        """
        @summary 下单询价流量询价
        
        @param request: QueryCssOrderForLicenseRequest
        @return: QueryCssOrderForLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.query_css_order_for_license_with_options(request, runtime)

    async def query_css_order_for_license_async(
        self,
        request: vod_20170321_models.QueryCssOrderForLicenseRequest,
    ) -> vod_20170321_models.QueryCssOrderForLicenseResponse:
        """
        @summary 下单询价流量询价
        
        @param request: QueryCssOrderForLicenseRequest
        @return: QueryCssOrderForLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.query_css_order_for_license_with_options_async(request, runtime)

    def refresh_media_play_urls_with_options(
        self,
        request: vod_20170321_models.RefreshMediaPlayUrlsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RefreshMediaPlayUrlsResponse:
        """
        @summary Submits media refresh or prefetch tasks based on the media IDs.
        
        @description    ApsaraVideo VOD allows you to purge and prefetch resources. The purge feature forces the point of presence (POP) to clear cached resources and retrieve the latest resources from origin servers. The prefetch feature allows the POP to retrieve frequently accessed resources from origin servers during off-peak hours. This increases the cache hit ratio.
        You can call this operation to submit purge or prefetch tasks based on the media ID. You can also specify the format and resolution of the media streams to purge or prefetch based on your business requirements.
        You can submit a maximum of 20 purge or prefetch tasks at a time.
        
        @param request: RefreshMediaPlayUrlsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RefreshMediaPlayUrlsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.definitions):
            query['Definitions'] = request.definitions
        if not UtilClient.is_unset(request.formats):
            query['Formats'] = request.formats
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        if not UtilClient.is_unset(request.result_type):
            query['ResultType'] = request.result_type
        if not UtilClient.is_unset(request.slice_count):
            query['SliceCount'] = request.slice_count
        if not UtilClient.is_unset(request.slice_flag):
            query['SliceFlag'] = request.slice_flag
        if not UtilClient.is_unset(request.stream_type):
            query['StreamType'] = request.stream_type
        if not UtilClient.is_unset(request.task_type):
            query['TaskType'] = request.task_type
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RefreshMediaPlayUrls',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RefreshMediaPlayUrlsResponse(),
            self.call_api(params, req, runtime)
        )

    async def refresh_media_play_urls_with_options_async(
        self,
        request: vod_20170321_models.RefreshMediaPlayUrlsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RefreshMediaPlayUrlsResponse:
        """
        @summary Submits media refresh or prefetch tasks based on the media IDs.
        
        @description    ApsaraVideo VOD allows you to purge and prefetch resources. The purge feature forces the point of presence (POP) to clear cached resources and retrieve the latest resources from origin servers. The prefetch feature allows the POP to retrieve frequently accessed resources from origin servers during off-peak hours. This increases the cache hit ratio.
        You can call this operation to submit purge or prefetch tasks based on the media ID. You can also specify the format and resolution of the media streams to purge or prefetch based on your business requirements.
        You can submit a maximum of 20 purge or prefetch tasks at a time.
        
        @param request: RefreshMediaPlayUrlsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RefreshMediaPlayUrlsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.definitions):
            query['Definitions'] = request.definitions
        if not UtilClient.is_unset(request.formats):
            query['Formats'] = request.formats
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        if not UtilClient.is_unset(request.result_type):
            query['ResultType'] = request.result_type
        if not UtilClient.is_unset(request.slice_count):
            query['SliceCount'] = request.slice_count
        if not UtilClient.is_unset(request.slice_flag):
            query['SliceFlag'] = request.slice_flag
        if not UtilClient.is_unset(request.stream_type):
            query['StreamType'] = request.stream_type
        if not UtilClient.is_unset(request.task_type):
            query['TaskType'] = request.task_type
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RefreshMediaPlayUrls',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RefreshMediaPlayUrlsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def refresh_media_play_urls(
        self,
        request: vod_20170321_models.RefreshMediaPlayUrlsRequest,
    ) -> vod_20170321_models.RefreshMediaPlayUrlsResponse:
        """
        @summary Submits media refresh or prefetch tasks based on the media IDs.
        
        @description    ApsaraVideo VOD allows you to purge and prefetch resources. The purge feature forces the point of presence (POP) to clear cached resources and retrieve the latest resources from origin servers. The prefetch feature allows the POP to retrieve frequently accessed resources from origin servers during off-peak hours. This increases the cache hit ratio.
        You can call this operation to submit purge or prefetch tasks based on the media ID. You can also specify the format and resolution of the media streams to purge or prefetch based on your business requirements.
        You can submit a maximum of 20 purge or prefetch tasks at a time.
        
        @param request: RefreshMediaPlayUrlsRequest
        @return: RefreshMediaPlayUrlsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.refresh_media_play_urls_with_options(request, runtime)

    async def refresh_media_play_urls_async(
        self,
        request: vod_20170321_models.RefreshMediaPlayUrlsRequest,
    ) -> vod_20170321_models.RefreshMediaPlayUrlsResponse:
        """
        @summary Submits media refresh or prefetch tasks based on the media IDs.
        
        @description    ApsaraVideo VOD allows you to purge and prefetch resources. The purge feature forces the point of presence (POP) to clear cached resources and retrieve the latest resources from origin servers. The prefetch feature allows the POP to retrieve frequently accessed resources from origin servers during off-peak hours. This increases the cache hit ratio.
        You can call this operation to submit purge or prefetch tasks based on the media ID. You can also specify the format and resolution of the media streams to purge or prefetch based on your business requirements.
        You can submit a maximum of 20 purge or prefetch tasks at a time.
        
        @param request: RefreshMediaPlayUrlsRequest
        @return: RefreshMediaPlayUrlsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.refresh_media_play_urls_with_options_async(request, runtime)

    def refresh_object_caches_with_options(
        self,
        request: vod_20170321_models.RefreshObjectCachesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RefreshObjectCachesResponse:
        """
        @summary 刷新缓存
        
        @param request: RefreshObjectCachesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RefreshObjectCachesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.object_type):
            query['ObjectType'] = request.object_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RefreshObjectCaches',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RefreshObjectCachesResponse(),
            self.call_api(params, req, runtime)
        )

    async def refresh_object_caches_with_options_async(
        self,
        request: vod_20170321_models.RefreshObjectCachesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RefreshObjectCachesResponse:
        """
        @summary 刷新缓存
        
        @param request: RefreshObjectCachesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RefreshObjectCachesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.object_type):
            query['ObjectType'] = request.object_type
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RefreshObjectCaches',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RefreshObjectCachesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def refresh_object_caches(
        self,
        request: vod_20170321_models.RefreshObjectCachesRequest,
    ) -> vod_20170321_models.RefreshObjectCachesResponse:
        """
        @summary 刷新缓存
        
        @param request: RefreshObjectCachesRequest
        @return: RefreshObjectCachesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.refresh_object_caches_with_options(request, runtime)

    async def refresh_object_caches_async(
        self,
        request: vod_20170321_models.RefreshObjectCachesRequest,
    ) -> vod_20170321_models.RefreshObjectCachesResponse:
        """
        @summary 刷新缓存
        
        @param request: RefreshObjectCachesRequest
        @return: RefreshObjectCachesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.refresh_object_caches_with_options_async(request, runtime)

    def refresh_upload_video_with_options(
        self,
        request: vod_20170321_models.RefreshUploadVideoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RefreshUploadVideoResponse:
        """
        @summary Obtains a new upload credential after a file failed to be uploaded.
        
        @description You can also call this operation to overwrite the source file of an audio or video file. After you call this operation, the system obtains the upload URL and uploads a new source file without changing the ID of the audio or video file. If you have configured transcoding or snapshot capture for the upload, the transcoding or snapshot capture job is automatically triggered. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        
        @param request: RefreshUploadVideoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RefreshUploadVideoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RefreshUploadVideo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RefreshUploadVideoResponse(),
            self.call_api(params, req, runtime)
        )

    async def refresh_upload_video_with_options_async(
        self,
        request: vod_20170321_models.RefreshUploadVideoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RefreshUploadVideoResponse:
        """
        @summary Obtains a new upload credential after a file failed to be uploaded.
        
        @description You can also call this operation to overwrite the source file of an audio or video file. After you call this operation, the system obtains the upload URL and uploads a new source file without changing the ID of the audio or video file. If you have configured transcoding or snapshot capture for the upload, the transcoding or snapshot capture job is automatically triggered. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        
        @param request: RefreshUploadVideoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RefreshUploadVideoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RefreshUploadVideo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RefreshUploadVideoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def refresh_upload_video(
        self,
        request: vod_20170321_models.RefreshUploadVideoRequest,
    ) -> vod_20170321_models.RefreshUploadVideoResponse:
        """
        @summary Obtains a new upload credential after a file failed to be uploaded.
        
        @description You can also call this operation to overwrite the source file of an audio or video file. After you call this operation, the system obtains the upload URL and uploads a new source file without changing the ID of the audio or video file. If you have configured transcoding or snapshot capture for the upload, the transcoding or snapshot capture job is automatically triggered. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        
        @param request: RefreshUploadVideoRequest
        @return: RefreshUploadVideoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.refresh_upload_video_with_options(request, runtime)

    async def refresh_upload_video_async(
        self,
        request: vod_20170321_models.RefreshUploadVideoRequest,
    ) -> vod_20170321_models.RefreshUploadVideoResponse:
        """
        @summary Obtains a new upload credential after a file failed to be uploaded.
        
        @description You can also call this operation to overwrite the source file of an audio or video file. After you call this operation, the system obtains the upload URL and uploads a new source file without changing the ID of the audio or video file. If you have configured transcoding or snapshot capture for the upload, the transcoding or snapshot capture job is automatically triggered. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
        
        @param request: RefreshUploadVideoRequest
        @return: RefreshUploadVideoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.refresh_upload_video_with_options_async(request, runtime)

    def refresh_vod_object_caches_with_options(
        self,
        request: vod_20170321_models.RefreshVodObjectCachesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RefreshVodObjectCachesResponse:
        """
        @summary Refreshes files on Alibaba Cloud CDN nodes. You can refresh multiple files at a time based on URLs.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can submit a maximum of 2,000 requests to refresh resources based on URLs and 100 requests to refresh resources based on directories each day by using an Alibaba Cloud account.
        You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.html) operation to prefetch content.
        
        @param request: RefreshVodObjectCachesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RefreshVodObjectCachesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.object_type):
            query['ObjectType'] = request.object_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RefreshVodObjectCaches',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RefreshVodObjectCachesResponse(),
            self.call_api(params, req, runtime)
        )

    async def refresh_vod_object_caches_with_options_async(
        self,
        request: vod_20170321_models.RefreshVodObjectCachesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RefreshVodObjectCachesResponse:
        """
        @summary Refreshes files on Alibaba Cloud CDN nodes. You can refresh multiple files at a time based on URLs.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can submit a maximum of 2,000 requests to refresh resources based on URLs and 100 requests to refresh resources based on directories each day by using an Alibaba Cloud account.
        You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.html) operation to prefetch content.
        
        @param request: RefreshVodObjectCachesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RefreshVodObjectCachesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['Force'] = request.force
        if not UtilClient.is_unset(request.object_path):
            query['ObjectPath'] = request.object_path
        if not UtilClient.is_unset(request.object_type):
            query['ObjectType'] = request.object_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RefreshVodObjectCaches',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RefreshVodObjectCachesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def refresh_vod_object_caches(
        self,
        request: vod_20170321_models.RefreshVodObjectCachesRequest,
    ) -> vod_20170321_models.RefreshVodObjectCachesResponse:
        """
        @summary Refreshes files on Alibaba Cloud CDN nodes. You can refresh multiple files at a time based on URLs.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can submit a maximum of 2,000 requests to refresh resources based on URLs and 100 requests to refresh resources based on directories each day by using an Alibaba Cloud account.
        You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.html) operation to prefetch content.
        
        @param request: RefreshVodObjectCachesRequest
        @return: RefreshVodObjectCachesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.refresh_vod_object_caches_with_options(request, runtime)

    async def refresh_vod_object_caches_async(
        self,
        request: vod_20170321_models.RefreshVodObjectCachesRequest,
    ) -> vod_20170321_models.RefreshVodObjectCachesResponse:
        """
        @summary Refreshes files on Alibaba Cloud CDN nodes. You can refresh multiple files at a time based on URLs.
        
        @description    This operation is available only in the **China (Shanghai)** region.
        You can submit a maximum of 2,000 requests to refresh resources based on URLs and 100 requests to refresh resources based on directories each day by using an Alibaba Cloud account.
        You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.html) operation to prefetch content.
        
        @param request: RefreshVodObjectCachesRequest
        @return: RefreshVodObjectCachesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.refresh_vod_object_caches_with_options_async(request, runtime)

    def regist_drmcert_info_with_options(
        self,
        request: vod_20170321_models.RegistDRMCertInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RegistDRMCertInfoResponse:
        """
        @summary 注册DRM证书
        
        @param request: RegistDRMCertInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RegistDRMCertInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ask):
            query['Ask'] = request.ask
        if not UtilClient.is_unset(request.cert_name):
            query['CertName'] = request.cert_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pass_phrase):
            query['PassPhrase'] = request.pass_phrase
        if not UtilClient.is_unset(request.private_key):
            query['PrivateKey'] = request.private_key
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.serv_cert):
            query['ServCert'] = request.serv_cert
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RegistDRMCertInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RegistDRMCertInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def regist_drmcert_info_with_options_async(
        self,
        request: vod_20170321_models.RegistDRMCertInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RegistDRMCertInfoResponse:
        """
        @summary 注册DRM证书
        
        @param request: RegistDRMCertInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RegistDRMCertInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ask):
            query['Ask'] = request.ask
        if not UtilClient.is_unset(request.cert_name):
            query['CertName'] = request.cert_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.pass_phrase):
            query['PassPhrase'] = request.pass_phrase
        if not UtilClient.is_unset(request.private_key):
            query['PrivateKey'] = request.private_key
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.serv_cert):
            query['ServCert'] = request.serv_cert
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RegistDRMCertInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RegistDRMCertInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def regist_drmcert_info(
        self,
        request: vod_20170321_models.RegistDRMCertInfoRequest,
    ) -> vod_20170321_models.RegistDRMCertInfoResponse:
        """
        @summary 注册DRM证书
        
        @param request: RegistDRMCertInfoRequest
        @return: RegistDRMCertInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.regist_drmcert_info_with_options(request, runtime)

    async def regist_drmcert_info_async(
        self,
        request: vod_20170321_models.RegistDRMCertInfoRequest,
    ) -> vod_20170321_models.RegistDRMCertInfoResponse:
        """
        @summary 注册DRM证书
        
        @param request: RegistDRMCertInfoRequest
        @return: RegistDRMCertInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.regist_drmcert_info_with_options_async(request, runtime)

    def register_media_with_options(
        self,
        request: vod_20170321_models.RegisterMediaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RegisterMediaResponse:
        """
        @summary Registers media files. After you add an Object Storage Service (OSS) bucket to ApsaraVideo VOD, you must register the media files in the bucket to generate the required information before you use features such as transcoding and snapshot capture on the media files.
        
        @description    After you add an OSS bucket to ApsaraVideo VOD, you must register media files in the OSS bucket to generate the required information. Then, you can use media IDs for features such as transcoding, snapshot capture, and AI processing.use features such as xxx on media files by specifying their IDs?
        You can register up to 10 media files in an OSS bucket in a request. The media files must be stored in the same bucket.
        If you do not specify a transcoding template group ID when you upload a media file to ApsaraVideo VOD, the media file is automatically transcoded based on the default template group. If you do not specify a transcoding template group ID after you register a media file, the media file is not automatically transcoded. The registered media files are automatically transcoded only if you specify a transcoding template group ID.
        If the media file that you want to register has been registered, this operation returns only the unique media ID that is associated with the media file. No further operation is performed.
        Make sure that the media file that you want to register has a valid suffix. Otherwise, the registration fails.
        
        @param request: RegisterMediaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RegisterMediaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.register_metadatas):
            query['RegisterMetadatas'] = request.register_metadatas
        if not UtilClient.is_unset(request.template_group_id):
            query['TemplateGroupId'] = request.template_group_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RegisterMedia',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RegisterMediaResponse(),
            self.call_api(params, req, runtime)
        )

    async def register_media_with_options_async(
        self,
        request: vod_20170321_models.RegisterMediaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RegisterMediaResponse:
        """
        @summary Registers media files. After you add an Object Storage Service (OSS) bucket to ApsaraVideo VOD, you must register the media files in the bucket to generate the required information before you use features such as transcoding and snapshot capture on the media files.
        
        @description    After you add an OSS bucket to ApsaraVideo VOD, you must register media files in the OSS bucket to generate the required information. Then, you can use media IDs for features such as transcoding, snapshot capture, and AI processing.use features such as xxx on media files by specifying their IDs?
        You can register up to 10 media files in an OSS bucket in a request. The media files must be stored in the same bucket.
        If you do not specify a transcoding template group ID when you upload a media file to ApsaraVideo VOD, the media file is automatically transcoded based on the default template group. If you do not specify a transcoding template group ID after you register a media file, the media file is not automatically transcoded. The registered media files are automatically transcoded only if you specify a transcoding template group ID.
        If the media file that you want to register has been registered, this operation returns only the unique media ID that is associated with the media file. No further operation is performed.
        Make sure that the media file that you want to register has a valid suffix. Otherwise, the registration fails.
        
        @param request: RegisterMediaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RegisterMediaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.register_metadatas):
            query['RegisterMetadatas'] = request.register_metadatas
        if not UtilClient.is_unset(request.template_group_id):
            query['TemplateGroupId'] = request.template_group_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RegisterMedia',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RegisterMediaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def register_media(
        self,
        request: vod_20170321_models.RegisterMediaRequest,
    ) -> vod_20170321_models.RegisterMediaResponse:
        """
        @summary Registers media files. After you add an Object Storage Service (OSS) bucket to ApsaraVideo VOD, you must register the media files in the bucket to generate the required information before you use features such as transcoding and snapshot capture on the media files.
        
        @description    After you add an OSS bucket to ApsaraVideo VOD, you must register media files in the OSS bucket to generate the required information. Then, you can use media IDs for features such as transcoding, snapshot capture, and AI processing.use features such as xxx on media files by specifying their IDs?
        You can register up to 10 media files in an OSS bucket in a request. The media files must be stored in the same bucket.
        If you do not specify a transcoding template group ID when you upload a media file to ApsaraVideo VOD, the media file is automatically transcoded based on the default template group. If you do not specify a transcoding template group ID after you register a media file, the media file is not automatically transcoded. The registered media files are automatically transcoded only if you specify a transcoding template group ID.
        If the media file that you want to register has been registered, this operation returns only the unique media ID that is associated with the media file. No further operation is performed.
        Make sure that the media file that you want to register has a valid suffix. Otherwise, the registration fails.
        
        @param request: RegisterMediaRequest
        @return: RegisterMediaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.register_media_with_options(request, runtime)

    async def register_media_async(
        self,
        request: vod_20170321_models.RegisterMediaRequest,
    ) -> vod_20170321_models.RegisterMediaResponse:
        """
        @summary Registers media files. After you add an Object Storage Service (OSS) bucket to ApsaraVideo VOD, you must register the media files in the bucket to generate the required information before you use features such as transcoding and snapshot capture on the media files.
        
        @description    After you add an OSS bucket to ApsaraVideo VOD, you must register media files in the OSS bucket to generate the required information. Then, you can use media IDs for features such as transcoding, snapshot capture, and AI processing.use features such as xxx on media files by specifying their IDs?
        You can register up to 10 media files in an OSS bucket in a request. The media files must be stored in the same bucket.
        If you do not specify a transcoding template group ID when you upload a media file to ApsaraVideo VOD, the media file is automatically transcoded based on the default template group. If you do not specify a transcoding template group ID after you register a media file, the media file is not automatically transcoded. The registered media files are automatically transcoded only if you specify a transcoding template group ID.
        If the media file that you want to register has been registered, this operation returns only the unique media ID that is associated with the media file. No further operation is performed.
        Make sure that the media file that you want to register has a valid suffix. Otherwise, the registration fails.
        
        @param request: RegisterMediaRequest
        @return: RegisterMediaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.register_media_with_options_async(request, runtime)

    def renew_app_license_with_options(
        self,
        request: vod_20170321_models.RenewAppLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RenewAppLicenseResponse:
        """
        @summary 更新AppLicense
        
        @param request: RenewAppLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenewAppLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_ids):
            query['OrderIds'] = request.order_ids
        if not UtilClient.is_unset(request.purchase_method):
            query['PurchaseMethod'] = request.purchase_method
        body = {}
        if not UtilClient.is_unset(request.license_item_ids):
            body['LicenseItemIds'] = request.license_item_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='RenewAppLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RenewAppLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def renew_app_license_with_options_async(
        self,
        request: vod_20170321_models.RenewAppLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RenewAppLicenseResponse:
        """
        @summary 更新AppLicense
        
        @param request: RenewAppLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenewAppLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_ids):
            query['OrderIds'] = request.order_ids
        if not UtilClient.is_unset(request.purchase_method):
            query['PurchaseMethod'] = request.purchase_method
        body = {}
        if not UtilClient.is_unset(request.license_item_ids):
            body['LicenseItemIds'] = request.license_item_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='RenewAppLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RenewAppLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def renew_app_license(
        self,
        request: vod_20170321_models.RenewAppLicenseRequest,
    ) -> vod_20170321_models.RenewAppLicenseResponse:
        """
        @summary 更新AppLicense
        
        @param request: RenewAppLicenseRequest
        @return: RenewAppLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.renew_app_license_with_options(request, runtime)

    async def renew_app_license_async(
        self,
        request: vod_20170321_models.RenewAppLicenseRequest,
    ) -> vod_20170321_models.RenewAppLicenseResponse:
        """
        @summary 更新AppLicense
        
        @param request: RenewAppLicenseRequest
        @return: RenewAppLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.renew_app_license_with_options_async(request, runtime)

    def renew_free_license_with_options(
        self,
        request: vod_20170321_models.RenewFreeLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RenewFreeLicenseResponse:
        """
        @summary 续费免费license
        
        @param request: RenewFreeLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenewFreeLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.license_item_id):
            query['LicenseItemId'] = request.license_item_id
        if not UtilClient.is_unset(request.valid_period):
            query['ValidPeriod'] = request.valid_period
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RenewFreeLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RenewFreeLicenseResponse(),
            self.call_api(params, req, runtime)
        )

    async def renew_free_license_with_options_async(
        self,
        request: vod_20170321_models.RenewFreeLicenseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RenewFreeLicenseResponse:
        """
        @summary 续费免费license
        
        @param request: RenewFreeLicenseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenewFreeLicenseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_item_id):
            query['AppItemId'] = request.app_item_id
        if not UtilClient.is_unset(request.license_item_id):
            query['LicenseItemId'] = request.license_item_id
        if not UtilClient.is_unset(request.valid_period):
            query['ValidPeriod'] = request.valid_period
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RenewFreeLicense',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RenewFreeLicenseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def renew_free_license(
        self,
        request: vod_20170321_models.RenewFreeLicenseRequest,
    ) -> vod_20170321_models.RenewFreeLicenseResponse:
        """
        @summary 续费免费license
        
        @param request: RenewFreeLicenseRequest
        @return: RenewFreeLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.renew_free_license_with_options(request, runtime)

    async def renew_free_license_async(
        self,
        request: vod_20170321_models.RenewFreeLicenseRequest,
    ) -> vod_20170321_models.RenewFreeLicenseResponse:
        """
        @summary 续费免费license
        
        @param request: RenewFreeLicenseRequest
        @return: RenewFreeLicenseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.renew_free_license_with_options_async(request, runtime)

    def report_upload_progress_with_options(
        self,
        request: vod_20170321_models.ReportUploadProgressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ReportUploadProgressResponse:
        """
        @summary 报告上传进度
        
        @param request: ReportUploadProgressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReportUploadProgressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_version):
            query['AppVersion'] = request.app_version
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.auth_timestamp):
            query['AuthTimestamp'] = request.auth_timestamp
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.client_id):
            query['ClientId'] = request.client_id
        if not UtilClient.is_unset(request.device_model):
            query['DeviceModel'] = request.device_model
        if not UtilClient.is_unset(request.done_parts_count):
            query['DonePartsCount'] = request.done_parts_count
        if not UtilClient.is_unset(request.file_create_time):
            query['FileCreateTime'] = request.file_create_time
        if not UtilClient.is_unset(request.file_hash):
            query['FileHash'] = request.file_hash
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.file_size):
            query['FileSize'] = request.file_size
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.part_size):
            query['PartSize'] = request.part_size
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.source):
            query['Source'] = request.source
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        if not UtilClient.is_unset(request.total_part):
            query['TotalPart'] = request.total_part
        if not UtilClient.is_unset(request.upload_address):
            query['UploadAddress'] = request.upload_address
        if not UtilClient.is_unset(request.upload_id):
            query['UploadId'] = request.upload_id
        if not UtilClient.is_unset(request.upload_point):
            query['UploadPoint'] = request.upload_point
        if not UtilClient.is_unset(request.upload_ratio):
            query['UploadRatio'] = request.upload_ratio
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReportUploadProgress',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ReportUploadProgressResponse(),
            self.call_api(params, req, runtime)
        )

    async def report_upload_progress_with_options_async(
        self,
        request: vod_20170321_models.ReportUploadProgressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ReportUploadProgressResponse:
        """
        @summary 报告上传进度
        
        @param request: ReportUploadProgressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReportUploadProgressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_version):
            query['AppVersion'] = request.app_version
        if not UtilClient.is_unset(request.auth_info):
            query['AuthInfo'] = request.auth_info
        if not UtilClient.is_unset(request.auth_timestamp):
            query['AuthTimestamp'] = request.auth_timestamp
        if not UtilClient.is_unset(request.business_type):
            query['BusinessType'] = request.business_type
        if not UtilClient.is_unset(request.client_id):
            query['ClientId'] = request.client_id
        if not UtilClient.is_unset(request.device_model):
            query['DeviceModel'] = request.device_model
        if not UtilClient.is_unset(request.done_parts_count):
            query['DonePartsCount'] = request.done_parts_count
        if not UtilClient.is_unset(request.file_create_time):
            query['FileCreateTime'] = request.file_create_time
        if not UtilClient.is_unset(request.file_hash):
            query['FileHash'] = request.file_hash
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.file_size):
            query['FileSize'] = request.file_size
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.part_size):
            query['PartSize'] = request.part_size
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.source):
            query['Source'] = request.source
        if not UtilClient.is_unset(request.terminal_type):
            query['TerminalType'] = request.terminal_type
        if not UtilClient.is_unset(request.total_part):
            query['TotalPart'] = request.total_part
        if not UtilClient.is_unset(request.upload_address):
            query['UploadAddress'] = request.upload_address
        if not UtilClient.is_unset(request.upload_id):
            query['UploadId'] = request.upload_id
        if not UtilClient.is_unset(request.upload_point):
            query['UploadPoint'] = request.upload_point
        if not UtilClient.is_unset(request.upload_ratio):
            query['UploadRatio'] = request.upload_ratio
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReportUploadProgress',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='Anonymous',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ReportUploadProgressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def report_upload_progress(
        self,
        request: vod_20170321_models.ReportUploadProgressRequest,
    ) -> vod_20170321_models.ReportUploadProgressResponse:
        """
        @summary 报告上传进度
        
        @param request: ReportUploadProgressRequest
        @return: ReportUploadProgressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.report_upload_progress_with_options(request, runtime)

    async def report_upload_progress_async(
        self,
        request: vod_20170321_models.ReportUploadProgressRequest,
    ) -> vod_20170321_models.ReportUploadProgressResponse:
        """
        @summary 报告上传进度
        
        @param request: ReportUploadProgressRequest
        @return: ReportUploadProgressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.report_upload_progress_with_options_async(request, runtime)

    def restore_media_with_options(
        self,
        request: vod_20170321_models.RestoreMediaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RestoreMediaResponse:
        """
        @summary Restores media assets.
        
        @description You can call this operation to restore only Archive and Cold Archive audio and video files. You can access the audio and video files after the files are restored. You cannot change the storage class of an audio or video file that is being restored. You are charged for the retrieval traffic generated during restoration. After a Cold Archive audio or video file is restored, a Standard replica of the file is generated for access. You are charged for the storage of the replica before the file returns to the frozen state.
        
        @param request: RestoreMediaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RestoreMediaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        if not UtilClient.is_unset(request.restore_days):
            query['RestoreDays'] = request.restore_days
        if not UtilClient.is_unset(request.restore_tier):
            query['RestoreTier'] = request.restore_tier
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RestoreMedia',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RestoreMediaResponse(),
            self.call_api(params, req, runtime)
        )

    async def restore_media_with_options_async(
        self,
        request: vod_20170321_models.RestoreMediaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RestoreMediaResponse:
        """
        @summary Restores media assets.
        
        @description You can call this operation to restore only Archive and Cold Archive audio and video files. You can access the audio and video files after the files are restored. You cannot change the storage class of an audio or video file that is being restored. You are charged for the retrieval traffic generated during restoration. After a Cold Archive audio or video file is restored, a Standard replica of the file is generated for access. You are charged for the storage of the replica before the file returns to the frozen state.
        
        @param request: RestoreMediaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RestoreMediaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        if not UtilClient.is_unset(request.restore_days):
            query['RestoreDays'] = request.restore_days
        if not UtilClient.is_unset(request.restore_tier):
            query['RestoreTier'] = request.restore_tier
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RestoreMedia',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RestoreMediaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def restore_media(
        self,
        request: vod_20170321_models.RestoreMediaRequest,
    ) -> vod_20170321_models.RestoreMediaResponse:
        """
        @summary Restores media assets.
        
        @description You can call this operation to restore only Archive and Cold Archive audio and video files. You can access the audio and video files after the files are restored. You cannot change the storage class of an audio or video file that is being restored. You are charged for the retrieval traffic generated during restoration. After a Cold Archive audio or video file is restored, a Standard replica of the file is generated for access. You are charged for the storage of the replica before the file returns to the frozen state.
        
        @param request: RestoreMediaRequest
        @return: RestoreMediaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.restore_media_with_options(request, runtime)

    async def restore_media_async(
        self,
        request: vod_20170321_models.RestoreMediaRequest,
    ) -> vod_20170321_models.RestoreMediaResponse:
        """
        @summary Restores media assets.
        
        @description You can call this operation to restore only Archive and Cold Archive audio and video files. You can access the audio and video files after the files are restored. You cannot change the storage class of an audio or video file that is being restored. You are charged for the retrieval traffic generated during restoration. After a Cold Archive audio or video file is restored, a Standard replica of the file is generated for access. You are charged for the storage of the replica before the file returns to the frozen state.
        
        @param request: RestoreMediaRequest
        @return: RestoreMediaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.restore_media_with_options_async(request, runtime)

    def rollback_vod_staging_config_with_options(
        self,
        request: vod_20170321_models.RollbackVodStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RollbackVodStagingConfigResponse:
        """
        @summary 回滚灰度配置
        
        @param request: RollbackVodStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RollbackVodStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RollbackVodStagingConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RollbackVodStagingConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def rollback_vod_staging_config_with_options_async(
        self,
        request: vod_20170321_models.RollbackVodStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.RollbackVodStagingConfigResponse:
        """
        @summary 回滚灰度配置
        
        @param request: RollbackVodStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RollbackVodStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RollbackVodStagingConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.RollbackVodStagingConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def rollback_vod_staging_config(
        self,
        request: vod_20170321_models.RollbackVodStagingConfigRequest,
    ) -> vod_20170321_models.RollbackVodStagingConfigResponse:
        """
        @summary 回滚灰度配置
        
        @param request: RollbackVodStagingConfigRequest
        @return: RollbackVodStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.rollback_vod_staging_config_with_options(request, runtime)

    async def rollback_vod_staging_config_async(
        self,
        request: vod_20170321_models.RollbackVodStagingConfigRequest,
    ) -> vod_20170321_models.RollbackVodStagingConfigResponse:
        """
        @summary 回滚灰度配置
        
        @param request: RollbackVodStagingConfigRequest
        @return: RollbackVodStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.rollback_vod_staging_config_with_options_async(request, runtime)

    def search_editing_project_with_options(
        self,
        request: vod_20170321_models.SearchEditingProjectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SearchEditingProjectResponse:
        """
        @summary Queries online editing projects.
        
        @param request: SearchEditingProjectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SearchEditingProjectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SearchEditingProject',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SearchEditingProjectResponse(),
            self.call_api(params, req, runtime)
        )

    async def search_editing_project_with_options_async(
        self,
        request: vod_20170321_models.SearchEditingProjectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SearchEditingProjectResponse:
        """
        @summary Queries online editing projects.
        
        @param request: SearchEditingProjectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SearchEditingProjectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SearchEditingProject',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SearchEditingProjectResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def search_editing_project(
        self,
        request: vod_20170321_models.SearchEditingProjectRequest,
    ) -> vod_20170321_models.SearchEditingProjectResponse:
        """
        @summary Queries online editing projects.
        
        @param request: SearchEditingProjectRequest
        @return: SearchEditingProjectResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.search_editing_project_with_options(request, runtime)

    async def search_editing_project_async(
        self,
        request: vod_20170321_models.SearchEditingProjectRequest,
    ) -> vod_20170321_models.SearchEditingProjectResponse:
        """
        @summary Queries online editing projects.
        
        @param request: SearchEditingProjectRequest
        @return: SearchEditingProjectResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.search_editing_project_with_options_async(request, runtime)

    def search_media_with_options(
        self,
        request: vod_20170321_models.SearchMediaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SearchMediaResponse:
        """
        @summary Queries information about videos, audio, images, and auxiliary media assets. You can call this operation and specify the search protocol to query media assets based on the return fields, fields used for exact match, fields used for fuzzy match, fields used for a multi-value query, fields used for a range query, and sort fields.
        
        @description The maximum number of data records that you can query varies based on the method used to query the data. You can use the following methods to query data:
        Method 1: Traverse data by page
        You can use the PageNo and PageSize parameters to traverse up to 5,000 data records that meet the specified filter condition. PageNo specifies the page number and PageSize specifies the number of data records displayed on a page. If the number of data records that meet the specified filter condition exceeds 5,000, change the filter conditions to narrow down the results. You cannot use this method to traverse all data records. If you want to traverse more data records, use Method 2.
        Method 2: Traverse all data (available only for audio and video files)
        You can use this method to traverse up to 2 million data records related to audio and video files. If the number of data records that meet the specified filter condition exceeds 2 million, change the filter conditions to narrow down the results. To traverse data page by page, you must set the PageNo, PageSize, and ScrollToken parameters. The total number of data records from the current page to the target page cannot exceed 100. For example, you set PageSize to 20. The following content describes the traverse logic:
        When the PageNo parameter is set to 1, you can traverse data records from page 1 to page 5.
        When the PageNo parameter is set to 2, you can traverse data records from page 2 to page 6.
        Make sure that you set the appropriate page number and page size, and use a traverse method based on the number of results that meet your filter condition.
        
        @param request: SearchMediaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SearchMediaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.fields):
            query['Fields'] = request.fields
        if not UtilClient.is_unset(request.match):
            query['Match'] = request.match
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.scroll_token):
            query['ScrollToken'] = request.scroll_token
        if not UtilClient.is_unset(request.search_type):
            query['SearchType'] = request.search_type
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SearchMedia',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SearchMediaResponse(),
            self.call_api(params, req, runtime)
        )

    async def search_media_with_options_async(
        self,
        request: vod_20170321_models.SearchMediaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SearchMediaResponse:
        """
        @summary Queries information about videos, audio, images, and auxiliary media assets. You can call this operation and specify the search protocol to query media assets based on the return fields, fields used for exact match, fields used for fuzzy match, fields used for a multi-value query, fields used for a range query, and sort fields.
        
        @description The maximum number of data records that you can query varies based on the method used to query the data. You can use the following methods to query data:
        Method 1: Traverse data by page
        You can use the PageNo and PageSize parameters to traverse up to 5,000 data records that meet the specified filter condition. PageNo specifies the page number and PageSize specifies the number of data records displayed on a page. If the number of data records that meet the specified filter condition exceeds 5,000, change the filter conditions to narrow down the results. You cannot use this method to traverse all data records. If you want to traverse more data records, use Method 2.
        Method 2: Traverse all data (available only for audio and video files)
        You can use this method to traverse up to 2 million data records related to audio and video files. If the number of data records that meet the specified filter condition exceeds 2 million, change the filter conditions to narrow down the results. To traverse data page by page, you must set the PageNo, PageSize, and ScrollToken parameters. The total number of data records from the current page to the target page cannot exceed 100. For example, you set PageSize to 20. The following content describes the traverse logic:
        When the PageNo parameter is set to 1, you can traverse data records from page 1 to page 5.
        When the PageNo parameter is set to 2, you can traverse data records from page 2 to page 6.
        Make sure that you set the appropriate page number and page size, and use a traverse method based on the number of results that meet your filter condition.
        
        @param request: SearchMediaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SearchMediaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.fields):
            query['Fields'] = request.fields
        if not UtilClient.is_unset(request.match):
            query['Match'] = request.match
        if not UtilClient.is_unset(request.page_no):
            query['PageNo'] = request.page_no
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.scroll_token):
            query['ScrollToken'] = request.scroll_token
        if not UtilClient.is_unset(request.search_type):
            query['SearchType'] = request.search_type
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SearchMedia',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SearchMediaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def search_media(
        self,
        request: vod_20170321_models.SearchMediaRequest,
    ) -> vod_20170321_models.SearchMediaResponse:
        """
        @summary Queries information about videos, audio, images, and auxiliary media assets. You can call this operation and specify the search protocol to query media assets based on the return fields, fields used for exact match, fields used for fuzzy match, fields used for a multi-value query, fields used for a range query, and sort fields.
        
        @description The maximum number of data records that you can query varies based on the method used to query the data. You can use the following methods to query data:
        Method 1: Traverse data by page
        You can use the PageNo and PageSize parameters to traverse up to 5,000 data records that meet the specified filter condition. PageNo specifies the page number and PageSize specifies the number of data records displayed on a page. If the number of data records that meet the specified filter condition exceeds 5,000, change the filter conditions to narrow down the results. You cannot use this method to traverse all data records. If you want to traverse more data records, use Method 2.
        Method 2: Traverse all data (available only for audio and video files)
        You can use this method to traverse up to 2 million data records related to audio and video files. If the number of data records that meet the specified filter condition exceeds 2 million, change the filter conditions to narrow down the results. To traverse data page by page, you must set the PageNo, PageSize, and ScrollToken parameters. The total number of data records from the current page to the target page cannot exceed 100. For example, you set PageSize to 20. The following content describes the traverse logic:
        When the PageNo parameter is set to 1, you can traverse data records from page 1 to page 5.
        When the PageNo parameter is set to 2, you can traverse data records from page 2 to page 6.
        Make sure that you set the appropriate page number and page size, and use a traverse method based on the number of results that meet your filter condition.
        
        @param request: SearchMediaRequest
        @return: SearchMediaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.search_media_with_options(request, runtime)

    async def search_media_async(
        self,
        request: vod_20170321_models.SearchMediaRequest,
    ) -> vod_20170321_models.SearchMediaResponse:
        """
        @summary Queries information about videos, audio, images, and auxiliary media assets. You can call this operation and specify the search protocol to query media assets based on the return fields, fields used for exact match, fields used for fuzzy match, fields used for a multi-value query, fields used for a range query, and sort fields.
        
        @description The maximum number of data records that you can query varies based on the method used to query the data. You can use the following methods to query data:
        Method 1: Traverse data by page
        You can use the PageNo and PageSize parameters to traverse up to 5,000 data records that meet the specified filter condition. PageNo specifies the page number and PageSize specifies the number of data records displayed on a page. If the number of data records that meet the specified filter condition exceeds 5,000, change the filter conditions to narrow down the results. You cannot use this method to traverse all data records. If you want to traverse more data records, use Method 2.
        Method 2: Traverse all data (available only for audio and video files)
        You can use this method to traverse up to 2 million data records related to audio and video files. If the number of data records that meet the specified filter condition exceeds 2 million, change the filter conditions to narrow down the results. To traverse data page by page, you must set the PageNo, PageSize, and ScrollToken parameters. The total number of data records from the current page to the target page cannot exceed 100. For example, you set PageSize to 20. The following content describes the traverse logic:
        When the PageNo parameter is set to 1, you can traverse data records from page 1 to page 5.
        When the PageNo parameter is set to 2, you can traverse data records from page 2 to page 6.
        Make sure that you set the appropriate page number and page size, and use a traverse method based on the number of results that meet your filter condition.
        
        @param request: SearchMediaRequest
        @return: SearchMediaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.search_media_with_options_async(request, runtime)

    def set_aiservice_with_options(
        self,
        request: vod_20170321_models.SetAIServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetAIServiceResponse:
        """
        @summary 设置AI服务
        
        @param request: SetAIServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetAIServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.operation):
            query['Operation'] = request.operation
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.types):
            query['Types'] = request.types
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetAIService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetAIServiceResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_aiservice_with_options_async(
        self,
        request: vod_20170321_models.SetAIServiceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetAIServiceResponse:
        """
        @summary 设置AI服务
        
        @param request: SetAIServiceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetAIServiceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.operation):
            query['Operation'] = request.operation
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.types):
            query['Types'] = request.types
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetAIService',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetAIServiceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_aiservice(
        self,
        request: vod_20170321_models.SetAIServiceRequest,
    ) -> vod_20170321_models.SetAIServiceResponse:
        """
        @summary 设置AI服务
        
        @param request: SetAIServiceRequest
        @return: SetAIServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_aiservice_with_options(request, runtime)

    async def set_aiservice_async(
        self,
        request: vod_20170321_models.SetAIServiceRequest,
    ) -> vod_20170321_models.SetAIServiceResponse:
        """
        @summary 设置AI服务
        
        @param request: SetAIServiceRequest
        @return: SetAIServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_aiservice_with_options_async(request, runtime)

    def set_audit_security_ip_with_options(
        self,
        request: vod_20170321_models.SetAuditSecurityIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetAuditSecurityIpResponse:
        """
        @summary Manages the IP addresses in review security groups.
        
        @description You can play videos in the Checking or Blocked state only from the IP addresses that are added to review security groups.
        
        @param request: SetAuditSecurityIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetAuditSecurityIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ips):
            query['Ips'] = request.ips
        if not UtilClient.is_unset(request.operate_mode):
            query['OperateMode'] = request.operate_mode
        if not UtilClient.is_unset(request.security_group_name):
            query['SecurityGroupName'] = request.security_group_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetAuditSecurityIp',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetAuditSecurityIpResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_audit_security_ip_with_options_async(
        self,
        request: vod_20170321_models.SetAuditSecurityIpRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetAuditSecurityIpResponse:
        """
        @summary Manages the IP addresses in review security groups.
        
        @description You can play videos in the Checking or Blocked state only from the IP addresses that are added to review security groups.
        
        @param request: SetAuditSecurityIpRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetAuditSecurityIpResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ips):
            query['Ips'] = request.ips
        if not UtilClient.is_unset(request.operate_mode):
            query['OperateMode'] = request.operate_mode
        if not UtilClient.is_unset(request.security_group_name):
            query['SecurityGroupName'] = request.security_group_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetAuditSecurityIp',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetAuditSecurityIpResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_audit_security_ip(
        self,
        request: vod_20170321_models.SetAuditSecurityIpRequest,
    ) -> vod_20170321_models.SetAuditSecurityIpResponse:
        """
        @summary Manages the IP addresses in review security groups.
        
        @description You can play videos in the Checking or Blocked state only from the IP addresses that are added to review security groups.
        
        @param request: SetAuditSecurityIpRequest
        @return: SetAuditSecurityIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_audit_security_ip_with_options(request, runtime)

    async def set_audit_security_ip_async(
        self,
        request: vod_20170321_models.SetAuditSecurityIpRequest,
    ) -> vod_20170321_models.SetAuditSecurityIpResponse:
        """
        @summary Manages the IP addresses in review security groups.
        
        @description You can play videos in the Checking or Blocked state only from the IP addresses that are added to review security groups.
        
        @param request: SetAuditSecurityIpRequest
        @return: SetAuditSecurityIpResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_audit_security_ip_with_options_async(request, runtime)

    def set_check_channel_with_options(
        self,
        request: vod_20170321_models.SetCheckChannelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetCheckChannelResponse:
        """
        @summary 设置检查通道
        
        @param request: SetCheckChannelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetCheckChannelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel):
            query['Channel'] = request.channel
        if not UtilClient.is_unset(request.legal_switch):
            query['LegalSwitch'] = request.legal_switch
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetCheckChannel',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetCheckChannelResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_check_channel_with_options_async(
        self,
        request: vod_20170321_models.SetCheckChannelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetCheckChannelResponse:
        """
        @summary 设置检查通道
        
        @param request: SetCheckChannelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetCheckChannelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.channel):
            query['Channel'] = request.channel
        if not UtilClient.is_unset(request.legal_switch):
            query['LegalSwitch'] = request.legal_switch
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetCheckChannel',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetCheckChannelResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_check_channel(
        self,
        request: vod_20170321_models.SetCheckChannelRequest,
    ) -> vod_20170321_models.SetCheckChannelResponse:
        """
        @summary 设置检查通道
        
        @param request: SetCheckChannelRequest
        @return: SetCheckChannelResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_check_channel_with_options(request, runtime)

    async def set_check_channel_async(
        self,
        request: vod_20170321_models.SetCheckChannelRequest,
    ) -> vod_20170321_models.SetCheckChannelResponse:
        """
        @summary 设置检查通道
        
        @param request: SetCheckChannelRequest
        @return: SetCheckChannelResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_check_channel_with_options_async(request, runtime)

    def set_crossdomain_content_with_options(
        self,
        request: vod_20170321_models.SetCrossdomainContentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetCrossdomainContentResponse:
        """
        @summary Updates the cross-domain policy file crossdomain.xml.
        
        @description > After you use the cross-domain policy file to update the resources on the origin server, you must refresh the resources that are cached on Alibaba Cloud CDN nodes. You can use the ApsaraVideo VOD console to refresh resources. For more information, see [Refresh and prefetch](https://help.aliyun.com/document_detail/86098.html). Alternatively, you can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh resources.
        
        @param request: SetCrossdomainContentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetCrossdomainContentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.content):
            query['Content'] = request.content
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetCrossdomainContent',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetCrossdomainContentResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_crossdomain_content_with_options_async(
        self,
        request: vod_20170321_models.SetCrossdomainContentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetCrossdomainContentResponse:
        """
        @summary Updates the cross-domain policy file crossdomain.xml.
        
        @description > After you use the cross-domain policy file to update the resources on the origin server, you must refresh the resources that are cached on Alibaba Cloud CDN nodes. You can use the ApsaraVideo VOD console to refresh resources. For more information, see [Refresh and prefetch](https://help.aliyun.com/document_detail/86098.html). Alternatively, you can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh resources.
        
        @param request: SetCrossdomainContentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetCrossdomainContentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.content):
            query['Content'] = request.content
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetCrossdomainContent',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetCrossdomainContentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_crossdomain_content(
        self,
        request: vod_20170321_models.SetCrossdomainContentRequest,
    ) -> vod_20170321_models.SetCrossdomainContentResponse:
        """
        @summary Updates the cross-domain policy file crossdomain.xml.
        
        @description > After you use the cross-domain policy file to update the resources on the origin server, you must refresh the resources that are cached on Alibaba Cloud CDN nodes. You can use the ApsaraVideo VOD console to refresh resources. For more information, see [Refresh and prefetch](https://help.aliyun.com/document_detail/86098.html). Alternatively, you can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh resources.
        
        @param request: SetCrossdomainContentRequest
        @return: SetCrossdomainContentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_crossdomain_content_with_options(request, runtime)

    async def set_crossdomain_content_async(
        self,
        request: vod_20170321_models.SetCrossdomainContentRequest,
    ) -> vod_20170321_models.SetCrossdomainContentResponse:
        """
        @summary Updates the cross-domain policy file crossdomain.xml.
        
        @description > After you use the cross-domain policy file to update the resources on the origin server, you must refresh the resources that are cached on Alibaba Cloud CDN nodes. You can use the ApsaraVideo VOD console to refresh resources. For more information, see [Refresh and prefetch](https://help.aliyun.com/document_detail/86098.html). Alternatively, you can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh resources.
        
        @param request: SetCrossdomainContentRequest
        @return: SetCrossdomainContentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_crossdomain_content_with_options_async(request, runtime)

    def set_customer_config_with_options(
        self,
        request: vod_20170321_models.SetCustomerConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetCustomerConfigResponse:
        """
        @summary 设置用户配置
        
        @param request: SetCustomerConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetCustomerConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aiconfig):
            query['AIConfig'] = request.aiconfig
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.audit_config):
            query['AuditConfig'] = request.audit_config
        if not UtilClient.is_unset(request.download_switch):
            query['DownloadSwitch'] = request.download_switch
        if not UtilClient.is_unset(request.metric_config):
            query['MetricConfig'] = request.metric_config
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetCustomerConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetCustomerConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_customer_config_with_options_async(
        self,
        request: vod_20170321_models.SetCustomerConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetCustomerConfigResponse:
        """
        @summary 设置用户配置
        
        @param request: SetCustomerConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetCustomerConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aiconfig):
            query['AIConfig'] = request.aiconfig
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.audit_config):
            query['AuditConfig'] = request.audit_config
        if not UtilClient.is_unset(request.download_switch):
            query['DownloadSwitch'] = request.download_switch
        if not UtilClient.is_unset(request.metric_config):
            query['MetricConfig'] = request.metric_config
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetCustomerConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetCustomerConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_customer_config(
        self,
        request: vod_20170321_models.SetCustomerConfigRequest,
    ) -> vod_20170321_models.SetCustomerConfigResponse:
        """
        @summary 设置用户配置
        
        @param request: SetCustomerConfigRequest
        @return: SetCustomerConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_customer_config_with_options(request, runtime)

    async def set_customer_config_async(
        self,
        request: vod_20170321_models.SetCustomerConfigRequest,
    ) -> vod_20170321_models.SetCustomerConfigResponse:
        """
        @summary 设置用户配置
        
        @param request: SetCustomerConfigRequest
        @return: SetCustomerConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_customer_config_with_options_async(request, runtime)

    def set_default_aitemplate_with_options(
        self,
        request: vod_20170321_models.SetDefaultAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultAITemplateResponse:
        """
        @summary Specifies an AI template as the default template.
        
        @description Specifies an AI template as the default template.
        
        @param request: SetDefaultAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultAITemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_default_aitemplate_with_options_async(
        self,
        request: vod_20170321_models.SetDefaultAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultAITemplateResponse:
        """
        @summary Specifies an AI template as the default template.
        
        @description Specifies an AI template as the default template.
        
        @param request: SetDefaultAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultAITemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_default_aitemplate(
        self,
        request: vod_20170321_models.SetDefaultAITemplateRequest,
    ) -> vod_20170321_models.SetDefaultAITemplateResponse:
        """
        @summary Specifies an AI template as the default template.
        
        @description Specifies an AI template as the default template.
        
        @param request: SetDefaultAITemplateRequest
        @return: SetDefaultAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_default_aitemplate_with_options(request, runtime)

    async def set_default_aitemplate_async(
        self,
        request: vod_20170321_models.SetDefaultAITemplateRequest,
    ) -> vod_20170321_models.SetDefaultAITemplateResponse:
        """
        @summary Specifies an AI template as the default template.
        
        @description Specifies an AI template as the default template.
        
        @param request: SetDefaultAITemplateRequest
        @return: SetDefaultAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_default_aitemplate_with_options_async(request, runtime)

    def set_default_play_domain_with_options(
        self,
        request: vod_20170321_models.SetDefaultPlayDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultPlayDomainResponse:
        """
        @summary 设置默认播放域名
        
        @param request: SetDefaultPlayDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultPlayDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultPlayDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultPlayDomainResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_default_play_domain_with_options_async(
        self,
        request: vod_20170321_models.SetDefaultPlayDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultPlayDomainResponse:
        """
        @summary 设置默认播放域名
        
        @param request: SetDefaultPlayDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultPlayDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultPlayDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultPlayDomainResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_default_play_domain(
        self,
        request: vod_20170321_models.SetDefaultPlayDomainRequest,
    ) -> vod_20170321_models.SetDefaultPlayDomainResponse:
        """
        @summary 设置默认播放域名
        
        @param request: SetDefaultPlayDomainRequest
        @return: SetDefaultPlayDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_default_play_domain_with_options(request, runtime)

    async def set_default_play_domain_async(
        self,
        request: vod_20170321_models.SetDefaultPlayDomainRequest,
    ) -> vod_20170321_models.SetDefaultPlayDomainResponse:
        """
        @summary 设置默认播放域名
        
        @param request: SetDefaultPlayDomainRequest
        @return: SetDefaultPlayDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_default_play_domain_with_options_async(request, runtime)

    def set_default_template_group_console_with_options(
        self,
        request: vod_20170321_models.SetDefaultTemplateGroupConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultTemplateGroupConsoleResponse:
        """
        @summary 设置默认转码模版组
        
        @param request: SetDefaultTemplateGroupConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultTemplateGroupConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.group_symbol):
            query['GroupSymbol'] = request.group_symbol
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultTemplateGroupConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultTemplateGroupConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_default_template_group_console_with_options_async(
        self,
        request: vod_20170321_models.SetDefaultTemplateGroupConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultTemplateGroupConsoleResponse:
        """
        @summary 设置默认转码模版组
        
        @param request: SetDefaultTemplateGroupConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultTemplateGroupConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.group_symbol):
            query['GroupSymbol'] = request.group_symbol
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultTemplateGroupConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultTemplateGroupConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_default_template_group_console(
        self,
        request: vod_20170321_models.SetDefaultTemplateGroupConsoleRequest,
    ) -> vod_20170321_models.SetDefaultTemplateGroupConsoleResponse:
        """
        @summary 设置默认转码模版组
        
        @param request: SetDefaultTemplateGroupConsoleRequest
        @return: SetDefaultTemplateGroupConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_default_template_group_console_with_options(request, runtime)

    async def set_default_template_group_console_async(
        self,
        request: vod_20170321_models.SetDefaultTemplateGroupConsoleRequest,
    ) -> vod_20170321_models.SetDefaultTemplateGroupConsoleResponse:
        """
        @summary 设置默认转码模版组
        
        @param request: SetDefaultTemplateGroupConsoleRequest
        @return: SetDefaultTemplateGroupConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_default_template_group_console_with_options_async(request, runtime)

    def set_default_transcode_template_group_with_options(
        self,
        request: vod_20170321_models.SetDefaultTranscodeTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultTranscodeTemplateGroupResponse:
        """
        @summary Specifies a transcoding template group as the default one.
        
        @param request: SetDefaultTranscodeTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultTranscodeTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.transcode_template_group_id):
            query['TranscodeTemplateGroupId'] = request.transcode_template_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultTranscodeTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultTranscodeTemplateGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_default_transcode_template_group_with_options_async(
        self,
        request: vod_20170321_models.SetDefaultTranscodeTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultTranscodeTemplateGroupResponse:
        """
        @summary Specifies a transcoding template group as the default one.
        
        @param request: SetDefaultTranscodeTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultTranscodeTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.transcode_template_group_id):
            query['TranscodeTemplateGroupId'] = request.transcode_template_group_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultTranscodeTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultTranscodeTemplateGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_default_transcode_template_group(
        self,
        request: vod_20170321_models.SetDefaultTranscodeTemplateGroupRequest,
    ) -> vod_20170321_models.SetDefaultTranscodeTemplateGroupResponse:
        """
        @summary Specifies a transcoding template group as the default one.
        
        @param request: SetDefaultTranscodeTemplateGroupRequest
        @return: SetDefaultTranscodeTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_default_transcode_template_group_with_options(request, runtime)

    async def set_default_transcode_template_group_async(
        self,
        request: vod_20170321_models.SetDefaultTranscodeTemplateGroupRequest,
    ) -> vod_20170321_models.SetDefaultTranscodeTemplateGroupResponse:
        """
        @summary Specifies a transcoding template group as the default one.
        
        @param request: SetDefaultTranscodeTemplateGroupRequest
        @return: SetDefaultTranscodeTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_default_transcode_template_group_with_options_async(request, runtime)

    def set_default_upload_storage_with_options(
        self,
        request: vod_20170321_models.SetDefaultUploadStorageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultUploadStorageResponse:
        """
        @summary 设置默认存储
        
        @param request: SetDefaultUploadStorageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultUploadStorageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultUploadStorage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultUploadStorageResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_default_upload_storage_with_options_async(
        self,
        request: vod_20170321_models.SetDefaultUploadStorageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultUploadStorageResponse:
        """
        @summary 设置默认存储
        
        @param request: SetDefaultUploadStorageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultUploadStorageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultUploadStorage',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultUploadStorageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_default_upload_storage(
        self,
        request: vod_20170321_models.SetDefaultUploadStorageRequest,
    ) -> vod_20170321_models.SetDefaultUploadStorageResponse:
        """
        @summary 设置默认存储
        
        @param request: SetDefaultUploadStorageRequest
        @return: SetDefaultUploadStorageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_default_upload_storage_with_options(request, runtime)

    async def set_default_upload_storage_async(
        self,
        request: vod_20170321_models.SetDefaultUploadStorageRequest,
    ) -> vod_20170321_models.SetDefaultUploadStorageResponse:
        """
        @summary 设置默认存储
        
        @param request: SetDefaultUploadStorageRequest
        @return: SetDefaultUploadStorageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_default_upload_storage_with_options_async(request, runtime)

    def set_default_vod_template_with_options(
        self,
        request: vod_20170321_models.SetDefaultVodTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultVodTemplateResponse:
        """
        @summary 设置默认模版
        
        @param request: SetDefaultVodTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultVodTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vod_template_id):
            query['VodTemplateId'] = request.vod_template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultVodTemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultVodTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_default_vod_template_with_options_async(
        self,
        request: vod_20170321_models.SetDefaultVodTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultVodTemplateResponse:
        """
        @summary 设置默认模版
        
        @param request: SetDefaultVodTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultVodTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.vod_template_id):
            query['VodTemplateId'] = request.vod_template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultVodTemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultVodTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_default_vod_template(
        self,
        request: vod_20170321_models.SetDefaultVodTemplateRequest,
    ) -> vod_20170321_models.SetDefaultVodTemplateResponse:
        """
        @summary 设置默认模版
        
        @param request: SetDefaultVodTemplateRequest
        @return: SetDefaultVodTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_default_vod_template_with_options(request, runtime)

    async def set_default_vod_template_async(
        self,
        request: vod_20170321_models.SetDefaultVodTemplateRequest,
    ) -> vod_20170321_models.SetDefaultVodTemplateResponse:
        """
        @summary 设置默认模版
        
        @param request: SetDefaultVodTemplateRequest
        @return: SetDefaultVodTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_default_vod_template_with_options_async(request, runtime)

    def set_default_watermark_with_options(
        self,
        request: vod_20170321_models.SetDefaultWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultWatermarkResponse:
        """
        @summary Sets a watermark template as the default one.
        
        @param request: SetDefaultWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultWatermark',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultWatermarkResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_default_watermark_with_options_async(
        self,
        request: vod_20170321_models.SetDefaultWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultWatermarkResponse:
        """
        @summary Sets a watermark template as the default one.
        
        @param request: SetDefaultWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultWatermark',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultWatermarkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_default_watermark(
        self,
        request: vod_20170321_models.SetDefaultWatermarkRequest,
    ) -> vod_20170321_models.SetDefaultWatermarkResponse:
        """
        @summary Sets a watermark template as the default one.
        
        @param request: SetDefaultWatermarkRequest
        @return: SetDefaultWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_default_watermark_with_options(request, runtime)

    async def set_default_watermark_async(
        self,
        request: vod_20170321_models.SetDefaultWatermarkRequest,
    ) -> vod_20170321_models.SetDefaultWatermarkResponse:
        """
        @summary Sets a watermark template as the default one.
        
        @param request: SetDefaultWatermarkRequest
        @return: SetDefaultWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_default_watermark_with_options_async(request, runtime)

    def set_default_watermark_console_with_options(
        self,
        request: vod_20170321_models.SetDefaultWatermarkConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultWatermarkConsoleResponse:
        """
        @summary 设置默认水印
        
        @param request: SetDefaultWatermarkConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultWatermarkConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultWatermarkConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultWatermarkConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_default_watermark_console_with_options_async(
        self,
        request: vod_20170321_models.SetDefaultWatermarkConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetDefaultWatermarkConsoleResponse:
        """
        @summary 设置默认水印
        
        @param request: SetDefaultWatermarkConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetDefaultWatermarkConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetDefaultWatermarkConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetDefaultWatermarkConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_default_watermark_console(
        self,
        request: vod_20170321_models.SetDefaultWatermarkConsoleRequest,
    ) -> vod_20170321_models.SetDefaultWatermarkConsoleResponse:
        """
        @summary 设置默认水印
        
        @param request: SetDefaultWatermarkConsoleRequest
        @return: SetDefaultWatermarkConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_default_watermark_console_with_options(request, runtime)

    async def set_default_watermark_console_async(
        self,
        request: vod_20170321_models.SetDefaultWatermarkConsoleRequest,
    ) -> vod_20170321_models.SetDefaultWatermarkConsoleResponse:
        """
        @summary 设置默认水印
        
        @param request: SetDefaultWatermarkConsoleRequest
        @return: SetDefaultWatermarkConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_default_watermark_console_with_options_async(request, runtime)

    def set_editing_project_materials_with_options(
        self,
        request: vod_20170321_models.SetEditingProjectMaterialsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetEditingProjectMaterialsResponse:
        """
        @summary Specifies the media assets that you want to edit in an online editing project.
        
        @param request: SetEditingProjectMaterialsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetEditingProjectMaterialsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.material_ids):
            query['MaterialIds'] = request.material_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetEditingProjectMaterials',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetEditingProjectMaterialsResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_editing_project_materials_with_options_async(
        self,
        request: vod_20170321_models.SetEditingProjectMaterialsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetEditingProjectMaterialsResponse:
        """
        @summary Specifies the media assets that you want to edit in an online editing project.
        
        @param request: SetEditingProjectMaterialsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetEditingProjectMaterialsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.material_ids):
            query['MaterialIds'] = request.material_ids
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetEditingProjectMaterials',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetEditingProjectMaterialsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_editing_project_materials(
        self,
        request: vod_20170321_models.SetEditingProjectMaterialsRequest,
    ) -> vod_20170321_models.SetEditingProjectMaterialsResponse:
        """
        @summary Specifies the media assets that you want to edit in an online editing project.
        
        @param request: SetEditingProjectMaterialsRequest
        @return: SetEditingProjectMaterialsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_editing_project_materials_with_options(request, runtime)

    async def set_editing_project_materials_async(
        self,
        request: vod_20170321_models.SetEditingProjectMaterialsRequest,
    ) -> vod_20170321_models.SetEditingProjectMaterialsResponse:
        """
        @summary Specifies the media assets that you want to edit in an online editing project.
        
        @param request: SetEditingProjectMaterialsRequest
        @return: SetEditingProjectMaterialsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_editing_project_materials_with_options_async(request, runtime)

    def set_l2oss_key_config_with_options(
        self,
        request: vod_20170321_models.SetL2OssKeyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetL2OssKeyConfigResponse:
        """
        @summary 设置L2OssKey配置
        
        @param request: SetL2OssKeyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetL2OssKeyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_oss_auth):
            query['PrivateOssAuth'] = request.private_oss_auth
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetL2OssKeyConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetL2OssKeyConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_l2oss_key_config_with_options_async(
        self,
        request: vod_20170321_models.SetL2OssKeyConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetL2OssKeyConfigResponse:
        """
        @summary 设置L2OssKey配置
        
        @param request: SetL2OssKeyConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetL2OssKeyConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.private_oss_auth):
            query['PrivateOssAuth'] = request.private_oss_auth
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetL2OssKeyConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetL2OssKeyConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_l2oss_key_config(
        self,
        request: vod_20170321_models.SetL2OssKeyConfigRequest,
    ) -> vod_20170321_models.SetL2OssKeyConfigResponse:
        """
        @summary 设置L2OssKey配置
        
        @param request: SetL2OssKeyConfigRequest
        @return: SetL2OssKeyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_l2oss_key_config_with_options(request, runtime)

    async def set_l2oss_key_config_async(
        self,
        request: vod_20170321_models.SetL2OssKeyConfigRequest,
    ) -> vod_20170321_models.SetL2OssKeyConfigResponse:
        """
        @summary 设置L2OssKey配置
        
        @param request: SetL2OssKeyConfigRequest
        @return: SetL2OssKeyConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_l2oss_key_config_with_options_async(request, runtime)

    def set_message_callback_with_options(
        self,
        request: vod_20170321_models.SetMessageCallbackRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetMessageCallbackResponse:
        """
        @summary Sets the callback method, callback URL, and event type of an event notification.
        
        @description HTTP callbacks and MNS callbacks are supported. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: SetMessageCallbackRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetMessageCallbackResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.auth_key):
            query['AuthKey'] = request.auth_key
        if not UtilClient.is_unset(request.auth_switch):
            query['AuthSwitch'] = request.auth_switch
        if not UtilClient.is_unset(request.callback_type):
            query['CallbackType'] = request.callback_type
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackURL'] = request.callback_url
        if not UtilClient.is_unset(request.event_type_list):
            query['EventTypeList'] = request.event_type_list
        if not UtilClient.is_unset(request.mns_endpoint):
            query['MnsEndpoint'] = request.mns_endpoint
        if not UtilClient.is_unset(request.mns_queue_name):
            query['MnsQueueName'] = request.mns_queue_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetMessageCallback',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetMessageCallbackResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_message_callback_with_options_async(
        self,
        request: vod_20170321_models.SetMessageCallbackRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetMessageCallbackResponse:
        """
        @summary Sets the callback method, callback URL, and event type of an event notification.
        
        @description HTTP callbacks and MNS callbacks are supported. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: SetMessageCallbackRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetMessageCallbackResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.auth_key):
            query['AuthKey'] = request.auth_key
        if not UtilClient.is_unset(request.auth_switch):
            query['AuthSwitch'] = request.auth_switch
        if not UtilClient.is_unset(request.callback_type):
            query['CallbackType'] = request.callback_type
        if not UtilClient.is_unset(request.callback_url):
            query['CallbackURL'] = request.callback_url
        if not UtilClient.is_unset(request.event_type_list):
            query['EventTypeList'] = request.event_type_list
        if not UtilClient.is_unset(request.mns_endpoint):
            query['MnsEndpoint'] = request.mns_endpoint
        if not UtilClient.is_unset(request.mns_queue_name):
            query['MnsQueueName'] = request.mns_queue_name
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetMessageCallback',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetMessageCallbackResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_message_callback(
        self,
        request: vod_20170321_models.SetMessageCallbackRequest,
    ) -> vod_20170321_models.SetMessageCallbackResponse:
        """
        @summary Sets the callback method, callback URL, and event type of an event notification.
        
        @description HTTP callbacks and MNS callbacks are supported. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: SetMessageCallbackRequest
        @return: SetMessageCallbackResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_message_callback_with_options(request, runtime)

    async def set_message_callback_async(
        self,
        request: vod_20170321_models.SetMessageCallbackRequest,
    ) -> vod_20170321_models.SetMessageCallbackResponse:
        """
        @summary Sets the callback method, callback URL, and event type of an event notification.
        
        @description HTTP callbacks and MNS callbacks are supported. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
        
        @param request: SetMessageCallbackRequest
        @return: SetMessageCallbackResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_message_callback_with_options_async(request, runtime)

    def set_message_cloud_monitor_config_with_options(
        self,
        request: vod_20170321_models.SetMessageCloudMonitorConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetMessageCloudMonitorConfigResponse:
        """
        @summary 设置云监控配置
        
        @param request: SetMessageCloudMonitorConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetMessageCloudMonitorConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.event_type_list):
            query['EventTypeList'] = request.event_type_list
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetMessageCloudMonitorConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetMessageCloudMonitorConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_message_cloud_monitor_config_with_options_async(
        self,
        request: vod_20170321_models.SetMessageCloudMonitorConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetMessageCloudMonitorConfigResponse:
        """
        @summary 设置云监控配置
        
        @param request: SetMessageCloudMonitorConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetMessageCloudMonitorConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.event_type_list):
            query['EventTypeList'] = request.event_type_list
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetMessageCloudMonitorConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetMessageCloudMonitorConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_message_cloud_monitor_config(
        self,
        request: vod_20170321_models.SetMessageCloudMonitorConfigRequest,
    ) -> vod_20170321_models.SetMessageCloudMonitorConfigResponse:
        """
        @summary 设置云监控配置
        
        @param request: SetMessageCloudMonitorConfigRequest
        @return: SetMessageCloudMonitorConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_message_cloud_monitor_config_with_options(request, runtime)

    async def set_message_cloud_monitor_config_async(
        self,
        request: vod_20170321_models.SetMessageCloudMonitorConfigRequest,
    ) -> vod_20170321_models.SetMessageCloudMonitorConfigResponse:
        """
        @summary 设置云监控配置
        
        @param request: SetMessageCloudMonitorConfigRequest
        @return: SetMessageCloudMonitorConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_message_cloud_monitor_config_with_options_async(request, runtime)

    def set_storage_aclwith_options(
        self,
        request: vod_20170321_models.SetStorageACLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetStorageACLResponse:
        """
        @summary 设置存储ACL
        
        @param request: SetStorageACLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetStorageACLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_acl):
            query['StorageACL'] = request.storage_acl
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetStorageACL',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetStorageACLResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_storage_aclwith_options_async(
        self,
        request: vod_20170321_models.SetStorageACLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetStorageACLResponse:
        """
        @summary 设置存储ACL
        
        @param request: SetStorageACLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetStorageACLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_acl):
            query['StorageACL'] = request.storage_acl
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetStorageACL',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetStorageACLResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_storage_acl(
        self,
        request: vod_20170321_models.SetStorageACLRequest,
    ) -> vod_20170321_models.SetStorageACLResponse:
        """
        @summary 设置存储ACL
        
        @param request: SetStorageACLRequest
        @return: SetStorageACLResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_storage_aclwith_options(request, runtime)

    async def set_storage_acl_async(
        self,
        request: vod_20170321_models.SetStorageACLRequest,
    ) -> vod_20170321_models.SetStorageACLResponse:
        """
        @summary 设置存储ACL
        
        @param request: SetStorageACLRequest
        @return: SetStorageACLResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_storage_aclwith_options_async(request, runtime)

    def set_vod_domain_certificate_with_options(
        self,
        request: vod_20170321_models.SetVodDomainCertificateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetVodDomainCertificateResponse:
        """
        @summary Enables or disables the certificate of a domain name and modifies the certificate information.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: SetVodDomainCertificateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetVodDomainCertificateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_name):
            query['CertName'] = request.cert_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.sslpri):
            query['SSLPri'] = request.sslpri
        if not UtilClient.is_unset(request.sslprotocol):
            query['SSLProtocol'] = request.sslprotocol
        if not UtilClient.is_unset(request.sslpub):
            query['SSLPub'] = request.sslpub
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetVodDomainCertificate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetVodDomainCertificateResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_vod_domain_certificate_with_options_async(
        self,
        request: vod_20170321_models.SetVodDomainCertificateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetVodDomainCertificateResponse:
        """
        @summary Enables or disables the certificate of a domain name and modifies the certificate information.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: SetVodDomainCertificateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetVodDomainCertificateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_name):
            query['CertName'] = request.cert_name
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.sslpri):
            query['SSLPri'] = request.sslpri
        if not UtilClient.is_unset(request.sslprotocol):
            query['SSLProtocol'] = request.sslprotocol
        if not UtilClient.is_unset(request.sslpub):
            query['SSLPub'] = request.sslpub
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetVodDomainCertificate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetVodDomainCertificateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_vod_domain_certificate(
        self,
        request: vod_20170321_models.SetVodDomainCertificateRequest,
    ) -> vod_20170321_models.SetVodDomainCertificateResponse:
        """
        @summary Enables or disables the certificate of a domain name and modifies the certificate information.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: SetVodDomainCertificateRequest
        @return: SetVodDomainCertificateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_vod_domain_certificate_with_options(request, runtime)

    async def set_vod_domain_certificate_async(
        self,
        request: vod_20170321_models.SetVodDomainCertificateRequest,
    ) -> vod_20170321_models.SetVodDomainCertificateResponse:
        """
        @summary Enables or disables the certificate of a domain name and modifies the certificate information.
        
        @description > This operation is available only in the *China (Shanghai)** region.
        
        @param request: SetVodDomainCertificateRequest
        @return: SetVodDomainCertificateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_vod_domain_certificate_with_options_async(request, runtime)

    def set_vod_domain_sslcertificate_with_options(
        self,
        request: vod_20170321_models.SetVodDomainSSLCertificateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetVodDomainSSLCertificateResponse:
        """
        @summary Enables or disables the SSL certificate of a domain name and updates the certificate information.
        
        @param request: SetVodDomainSSLCertificateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetVodDomainSSLCertificateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_id):
            query['CertId'] = request.cert_id
        if not UtilClient.is_unset(request.cert_name):
            query['CertName'] = request.cert_name
        if not UtilClient.is_unset(request.cert_region):
            query['CertRegion'] = request.cert_region
        if not UtilClient.is_unset(request.cert_type):
            query['CertType'] = request.cert_type
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.env):
            query['Env'] = request.env
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.sslpri):
            query['SSLPri'] = request.sslpri
        if not UtilClient.is_unset(request.sslprotocol):
            query['SSLProtocol'] = request.sslprotocol
        if not UtilClient.is_unset(request.sslpub):
            query['SSLPub'] = request.sslpub
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetVodDomainSSLCertificate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetVodDomainSSLCertificateResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_vod_domain_sslcertificate_with_options_async(
        self,
        request: vod_20170321_models.SetVodDomainSSLCertificateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetVodDomainSSLCertificateResponse:
        """
        @summary Enables or disables the SSL certificate of a domain name and updates the certificate information.
        
        @param request: SetVodDomainSSLCertificateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetVodDomainSSLCertificateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cert_id):
            query['CertId'] = request.cert_id
        if not UtilClient.is_unset(request.cert_name):
            query['CertName'] = request.cert_name
        if not UtilClient.is_unset(request.cert_region):
            query['CertRegion'] = request.cert_region
        if not UtilClient.is_unset(request.cert_type):
            query['CertType'] = request.cert_type
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.env):
            query['Env'] = request.env
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.sslpri):
            query['SSLPri'] = request.sslpri
        if not UtilClient.is_unset(request.sslprotocol):
            query['SSLProtocol'] = request.sslprotocol
        if not UtilClient.is_unset(request.sslpub):
            query['SSLPub'] = request.sslpub
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetVodDomainSSLCertificate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetVodDomainSSLCertificateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_vod_domain_sslcertificate(
        self,
        request: vod_20170321_models.SetVodDomainSSLCertificateRequest,
    ) -> vod_20170321_models.SetVodDomainSSLCertificateResponse:
        """
        @summary Enables or disables the SSL certificate of a domain name and updates the certificate information.
        
        @param request: SetVodDomainSSLCertificateRequest
        @return: SetVodDomainSSLCertificateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_vod_domain_sslcertificate_with_options(request, runtime)

    async def set_vod_domain_sslcertificate_async(
        self,
        request: vod_20170321_models.SetVodDomainSSLCertificateRequest,
    ) -> vod_20170321_models.SetVodDomainSSLCertificateResponse:
        """
        @summary Enables or disables the SSL certificate of a domain name and updates the certificate information.
        
        @param request: SetVodDomainSSLCertificateRequest
        @return: SetVodDomainSSLCertificateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_vod_domain_sslcertificate_with_options_async(request, runtime)

    def set_vod_domain_staging_config_with_options(
        self,
        request: vod_20170321_models.SetVodDomainStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetVodDomainStagingConfigResponse:
        """
        @summary 设置VOD域名灰度配置
        
        @param request: SetVodDomainStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetVodDomainStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.functions):
            query['Functions'] = request.functions
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetVodDomainStagingConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetVodDomainStagingConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_vod_domain_staging_config_with_options_async(
        self,
        request: vod_20170321_models.SetVodDomainStagingConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SetVodDomainStagingConfigResponse:
        """
        @summary 设置VOD域名灰度配置
        
        @param request: SetVodDomainStagingConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetVodDomainStagingConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.functions):
            query['Functions'] = request.functions
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetVodDomainStagingConfig',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SetVodDomainStagingConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_vod_domain_staging_config(
        self,
        request: vod_20170321_models.SetVodDomainStagingConfigRequest,
    ) -> vod_20170321_models.SetVodDomainStagingConfigResponse:
        """
        @summary 设置VOD域名灰度配置
        
        @param request: SetVodDomainStagingConfigRequest
        @return: SetVodDomainStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_vod_domain_staging_config_with_options(request, runtime)

    async def set_vod_domain_staging_config_async(
        self,
        request: vod_20170321_models.SetVodDomainStagingConfigRequest,
    ) -> vod_20170321_models.SetVodDomainStagingConfigResponse:
        """
        @summary 设置VOD域名灰度配置
        
        @param request: SetVodDomainStagingConfigRequest
        @return: SetVodDomainStagingConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_vod_domain_staging_config_with_options_async(request, runtime)

    def start_vod_domain_with_options(
        self,
        request: vod_20170321_models.StartVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.StartVodDomainResponse:
        """
        @summary 开启VOD域名
        
        @param request: StartVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.StartVodDomainResponse(),
            self.call_api(params, req, runtime)
        )

    async def start_vod_domain_with_options_async(
        self,
        request: vod_20170321_models.StartVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.StartVodDomainResponse:
        """
        @summary 开启VOD域名
        
        @param request: StartVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StartVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StartVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.StartVodDomainResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def start_vod_domain(
        self,
        request: vod_20170321_models.StartVodDomainRequest,
    ) -> vod_20170321_models.StartVodDomainResponse:
        """
        @summary 开启VOD域名
        
        @param request: StartVodDomainRequest
        @return: StartVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.start_vod_domain_with_options(request, runtime)

    async def start_vod_domain_async(
        self,
        request: vod_20170321_models.StartVodDomainRequest,
    ) -> vod_20170321_models.StartVodDomainResponse:
        """
        @summary 开启VOD域名
        
        @param request: StartVodDomainRequest
        @return: StartVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.start_vod_domain_with_options_async(request, runtime)

    def stop_vod_domain_with_options(
        self,
        request: vod_20170321_models.StopVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.StopVodDomainResponse:
        """
        @summary 停止VOD域名
        
        @param request: StopVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.StopVodDomainResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_vod_domain_with_options_async(
        self,
        request: vod_20170321_models.StopVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.StopVodDomainResponse:
        """
        @summary 停止VOD域名
        
        @param request: StopVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.StopVodDomainResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_vod_domain(
        self,
        request: vod_20170321_models.StopVodDomainRequest,
    ) -> vod_20170321_models.StopVodDomainResponse:
        """
        @summary 停止VOD域名
        
        @param request: StopVodDomainRequest
        @return: StopVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_vod_domain_with_options(request, runtime)

    async def stop_vod_domain_async(
        self,
        request: vod_20170321_models.StopVodDomainRequest,
    ) -> vod_20170321_models.StopVodDomainResponse:
        """
        @summary 停止VOD域名
        
        @param request: StopVodDomainRequest
        @return: StopVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_vod_domain_with_options_async(request, runtime)

    def submit_aiasrjob_with_options(
        self,
        request: vod_20170321_models.SubmitAIASRJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIASRJobResponse:
        """
        @summary 提交AIASR任务
        
        @param request: SubmitAIASRJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIASRJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aiasrconfig):
            query['AIASRConfig'] = request.aiasrconfig
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIASRJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIASRJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aiasrjob_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIASRJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIASRJobResponse:
        """
        @summary 提交AIASR任务
        
        @param request: SubmitAIASRJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIASRJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aiasrconfig):
            query['AIASRConfig'] = request.aiasrconfig
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIASRJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIASRJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aiasrjob(
        self,
        request: vod_20170321_models.SubmitAIASRJobRequest,
    ) -> vod_20170321_models.SubmitAIASRJobResponse:
        """
        @summary 提交AIASR任务
        
        @param request: SubmitAIASRJobRequest
        @return: SubmitAIASRJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aiasrjob_with_options(request, runtime)

    async def submit_aiasrjob_async(
        self,
        request: vod_20170321_models.SubmitAIASRJobRequest,
    ) -> vod_20170321_models.SubmitAIASRJobResponse:
        """
        @summary 提交AIASR任务
        
        @param request: SubmitAIASRJobRequest
        @return: SubmitAIASRJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aiasrjob_with_options_async(request, runtime)

    def submit_aicaption_extraction_job_with_options(
        self,
        request: vod_20170321_models.SubmitAICaptionExtractionJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAICaptionExtractionJobResponse:
        """
        @summary 提交标题提取任务
        
        @param request: SubmitAICaptionExtractionJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAICaptionExtractionJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aipipeline_id):
            query['AIPipelineId'] = request.aipipeline_id
        if not UtilClient.is_unset(request.job_config):
            query['JobConfig'] = request.job_config
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAICaptionExtractionJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAICaptionExtractionJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aicaption_extraction_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitAICaptionExtractionJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAICaptionExtractionJobResponse:
        """
        @summary 提交标题提取任务
        
        @param request: SubmitAICaptionExtractionJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAICaptionExtractionJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aipipeline_id):
            query['AIPipelineId'] = request.aipipeline_id
        if not UtilClient.is_unset(request.job_config):
            query['JobConfig'] = request.job_config
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAICaptionExtractionJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAICaptionExtractionJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aicaption_extraction_job(
        self,
        request: vod_20170321_models.SubmitAICaptionExtractionJobRequest,
    ) -> vod_20170321_models.SubmitAICaptionExtractionJobResponse:
        """
        @summary 提交标题提取任务
        
        @param request: SubmitAICaptionExtractionJobRequest
        @return: SubmitAICaptionExtractionJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aicaption_extraction_job_with_options(request, runtime)

    async def submit_aicaption_extraction_job_async(
        self,
        request: vod_20170321_models.SubmitAICaptionExtractionJobRequest,
    ) -> vod_20170321_models.SubmitAICaptionExtractionJobResponse:
        """
        @summary 提交标题提取任务
        
        @param request: SubmitAICaptionExtractionJobRequest
        @return: SubmitAICaptionExtractionJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aicaption_extraction_job_with_options_async(request, runtime)

    def submit_aiimage_audit_job_with_options(
        self,
        request: vod_20170321_models.SubmitAIImageAuditJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIImageAuditJobResponse:
        """
        @summary Submits an automated review job for an image. After the job is submitted, the job is processed in an asynchronous manner. The operation may return a response before the job is complete.
        
        @description This operation is available only in the Singapore region.
        
        @param request: SubmitAIImageAuditJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIImageAuditJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_audit_configuration):
            query['MediaAuditConfiguration'] = request.media_audit_configuration
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIImageAuditJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIImageAuditJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aiimage_audit_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIImageAuditJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIImageAuditJobResponse:
        """
        @summary Submits an automated review job for an image. After the job is submitted, the job is processed in an asynchronous manner. The operation may return a response before the job is complete.
        
        @description This operation is available only in the Singapore region.
        
        @param request: SubmitAIImageAuditJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIImageAuditJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_audit_configuration):
            query['MediaAuditConfiguration'] = request.media_audit_configuration
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIImageAuditJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIImageAuditJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aiimage_audit_job(
        self,
        request: vod_20170321_models.SubmitAIImageAuditJobRequest,
    ) -> vod_20170321_models.SubmitAIImageAuditJobResponse:
        """
        @summary Submits an automated review job for an image. After the job is submitted, the job is processed in an asynchronous manner. The operation may return a response before the job is complete.
        
        @description This operation is available only in the Singapore region.
        
        @param request: SubmitAIImageAuditJobRequest
        @return: SubmitAIImageAuditJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aiimage_audit_job_with_options(request, runtime)

    async def submit_aiimage_audit_job_async(
        self,
        request: vod_20170321_models.SubmitAIImageAuditJobRequest,
    ) -> vod_20170321_models.SubmitAIImageAuditJobResponse:
        """
        @summary Submits an automated review job for an image. After the job is submitted, the job is processed in an asynchronous manner. The operation may return a response before the job is complete.
        
        @description This operation is available only in the Singapore region.
        
        @param request: SubmitAIImageAuditJobRequest
        @return: SubmitAIImageAuditJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aiimage_audit_job_with_options_async(request, runtime)

    def submit_aiimage_job_with_options(
        self,
        request: vod_20170321_models.SubmitAIImageJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIImageJobResponse:
        """
        @summary Submits jobs of image AI processing.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        After you call this operation, you can call the [GetAIImageJobs](https://help.aliyun.com/document_detail/186923.html) operation to query the job execution result.
        
        @param request: SubmitAIImageJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIImageJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aipipeline_id):
            query['AIPipelineId'] = request.aipipeline_id
        if not UtilClient.is_unset(request.aitemplate_id):
            query['AITemplateId'] = request.aitemplate_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIImageJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIImageJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aiimage_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIImageJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIImageJobResponse:
        """
        @summary Submits jobs of image AI processing.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        After you call this operation, you can call the [GetAIImageJobs](https://help.aliyun.com/document_detail/186923.html) operation to query the job execution result.
        
        @param request: SubmitAIImageJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIImageJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aipipeline_id):
            query['AIPipelineId'] = request.aipipeline_id
        if not UtilClient.is_unset(request.aitemplate_id):
            query['AITemplateId'] = request.aitemplate_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIImageJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIImageJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aiimage_job(
        self,
        request: vod_20170321_models.SubmitAIImageJobRequest,
    ) -> vod_20170321_models.SubmitAIImageJobResponse:
        """
        @summary Submits jobs of image AI processing.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        After you call this operation, you can call the [GetAIImageJobs](https://help.aliyun.com/document_detail/186923.html) operation to query the job execution result.
        
        @param request: SubmitAIImageJobRequest
        @return: SubmitAIImageJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aiimage_job_with_options(request, runtime)

    async def submit_aiimage_job_async(
        self,
        request: vod_20170321_models.SubmitAIImageJobRequest,
    ) -> vod_20170321_models.SubmitAIImageJobResponse:
        """
        @summary Submits jobs of image AI processing.
        
        @description    Regions that support this operation: **China (Beijing)** and **China (Shanghai)**.
        After you call this operation, you can call the [GetAIImageJobs](https://help.aliyun.com/document_detail/186923.html) operation to query the job execution result.
        
        @param request: SubmitAIImageJobRequest
        @return: SubmitAIImageJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aiimage_job_with_options_async(request, runtime)

    def submit_aijob_with_options(
        self,
        request: vod_20170321_models.SubmitAIJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIJobResponse:
        """
        @summary Submits a smart tagging or video fingerprinting job.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for using the smart tagging and video fingerprinting features. For more information, see [Billing of video AI](~~188310#section-g7l-s3o-9ng~~).**\
        Regions that support the video fingerprinting feature: **China (Beijing)**, **China (Shanghai)**, and **Singapore**. Regions that support the smart tagging feature: **China (Beijing)** and **China (Shanghai)**.
        You need to enable the video fingerprinting feature or the smart tagging feature before you can call this operation to submit jobs. For more information, see [Overview](https://help.aliyun.com/document_detail/101148.html).
        If this is the first time you use the video fingerprinting feature, you must submit a ticket to apply for using the media fingerprint library for free. Otherwise, the video fingerprinting feature will be affected. For more information about how to submit a ticket, see [Contact us](https://help.aliyun.com/document_detail/464625.html).
        After you submit an AI job, ApsaraVideo VOD asynchronously processes the job. The operation may return a response before the job is complete. You can configure the [Event Notification](https://help.aliyun.com/document_detail/55627.html) feature and set the callback event to **AI Processing Completed**. After you receive the event notification, you can query the execution result of the AI job.
        
        @param request: SubmitAIJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.config):
            query['Config'] = request.config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.types):
            query['Types'] = request.types
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aijob_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIJobResponse:
        """
        @summary Submits a smart tagging or video fingerprinting job.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for using the smart tagging and video fingerprinting features. For more information, see [Billing of video AI](~~188310#section-g7l-s3o-9ng~~).**\
        Regions that support the video fingerprinting feature: **China (Beijing)**, **China (Shanghai)**, and **Singapore**. Regions that support the smart tagging feature: **China (Beijing)** and **China (Shanghai)**.
        You need to enable the video fingerprinting feature or the smart tagging feature before you can call this operation to submit jobs. For more information, see [Overview](https://help.aliyun.com/document_detail/101148.html).
        If this is the first time you use the video fingerprinting feature, you must submit a ticket to apply for using the media fingerprint library for free. Otherwise, the video fingerprinting feature will be affected. For more information about how to submit a ticket, see [Contact us](https://help.aliyun.com/document_detail/464625.html).
        After you submit an AI job, ApsaraVideo VOD asynchronously processes the job. The operation may return a response before the job is complete. You can configure the [Event Notification](https://help.aliyun.com/document_detail/55627.html) feature and set the callback event to **AI Processing Completed**. After you receive the event notification, you can query the execution result of the AI job.
        
        @param request: SubmitAIJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.config):
            query['Config'] = request.config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.types):
            query['Types'] = request.types
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aijob(
        self,
        request: vod_20170321_models.SubmitAIJobRequest,
    ) -> vod_20170321_models.SubmitAIJobResponse:
        """
        @summary Submits a smart tagging or video fingerprinting job.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for using the smart tagging and video fingerprinting features. For more information, see [Billing of video AI](~~188310#section-g7l-s3o-9ng~~).**\
        Regions that support the video fingerprinting feature: **China (Beijing)**, **China (Shanghai)**, and **Singapore**. Regions that support the smart tagging feature: **China (Beijing)** and **China (Shanghai)**.
        You need to enable the video fingerprinting feature or the smart tagging feature before you can call this operation to submit jobs. For more information, see [Overview](https://help.aliyun.com/document_detail/101148.html).
        If this is the first time you use the video fingerprinting feature, you must submit a ticket to apply for using the media fingerprint library for free. Otherwise, the video fingerprinting feature will be affected. For more information about how to submit a ticket, see [Contact us](https://help.aliyun.com/document_detail/464625.html).
        After you submit an AI job, ApsaraVideo VOD asynchronously processes the job. The operation may return a response before the job is complete. You can configure the [Event Notification](https://help.aliyun.com/document_detail/55627.html) feature and set the callback event to **AI Processing Completed**. After you receive the event notification, you can query the execution result of the AI job.
        
        @param request: SubmitAIJobRequest
        @return: SubmitAIJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aijob_with_options(request, runtime)

    async def submit_aijob_async(
        self,
        request: vod_20170321_models.SubmitAIJobRequest,
    ) -> vod_20170321_models.SubmitAIJobResponse:
        """
        @summary Submits a smart tagging or video fingerprinting job.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for using the smart tagging and video fingerprinting features. For more information, see [Billing of video AI](~~188310#section-g7l-s3o-9ng~~).**\
        Regions that support the video fingerprinting feature: **China (Beijing)**, **China (Shanghai)**, and **Singapore**. Regions that support the smart tagging feature: **China (Beijing)** and **China (Shanghai)**.
        You need to enable the video fingerprinting feature or the smart tagging feature before you can call this operation to submit jobs. For more information, see [Overview](https://help.aliyun.com/document_detail/101148.html).
        If this is the first time you use the video fingerprinting feature, you must submit a ticket to apply for using the media fingerprint library for free. Otherwise, the video fingerprinting feature will be affected. For more information about how to submit a ticket, see [Contact us](https://help.aliyun.com/document_detail/464625.html).
        After you submit an AI job, ApsaraVideo VOD asynchronously processes the job. The operation may return a response before the job is complete. You can configure the [Event Notification](https://help.aliyun.com/document_detail/55627.html) feature and set the callback event to **AI Processing Completed**. After you receive the event notification, you can query the execution result of the AI job.
        
        @param request: SubmitAIJobRequest
        @return: SubmitAIJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aijob_with_options_async(request, runtime)

    def submit_aimedia_audit_job_with_options(
        self,
        request: vod_20170321_models.SubmitAIMediaAuditJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIMediaAuditJobResponse:
        """
        @summary Submits an automated review job for a media file. After the job is submitted, ApsaraVideo VOD asynchronously processes the job. Therefore, the operation may return a response before the job is complete.
        
        @description    **Make sure that you understand the billing methods and price of ApsaraVideo VOD before you call this operation. You are charged for using the automated review feature. For more information about billing, submit a ticket or contact your account manager.**\
        You can call this operation only in the **China (Shanghai)**, **China (Beijing)**, and **Singapore** regions.
        For more information, see [Automated review](https://help.aliyun.com/document_detail/101148.html).
        After an automated review job is complete, the images generated during the review are stored in the VOD bucket for two weeks free of charge. The images are automatically deleted after two weeks.
        
        @param request: SubmitAIMediaAuditJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIMediaAuditJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_audit_configuration):
            query['MediaAuditConfiguration'] = request.media_audit_configuration
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIMediaAuditJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIMediaAuditJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aimedia_audit_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIMediaAuditJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIMediaAuditJobResponse:
        """
        @summary Submits an automated review job for a media file. After the job is submitted, ApsaraVideo VOD asynchronously processes the job. Therefore, the operation may return a response before the job is complete.
        
        @description    **Make sure that you understand the billing methods and price of ApsaraVideo VOD before you call this operation. You are charged for using the automated review feature. For more information about billing, submit a ticket or contact your account manager.**\
        You can call this operation only in the **China (Shanghai)**, **China (Beijing)**, and **Singapore** regions.
        For more information, see [Automated review](https://help.aliyun.com/document_detail/101148.html).
        After an automated review job is complete, the images generated during the review are stored in the VOD bucket for two weeks free of charge. The images are automatically deleted after two weeks.
        
        @param request: SubmitAIMediaAuditJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIMediaAuditJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_audit_configuration):
            query['MediaAuditConfiguration'] = request.media_audit_configuration
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIMediaAuditJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIMediaAuditJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aimedia_audit_job(
        self,
        request: vod_20170321_models.SubmitAIMediaAuditJobRequest,
    ) -> vod_20170321_models.SubmitAIMediaAuditJobResponse:
        """
        @summary Submits an automated review job for a media file. After the job is submitted, ApsaraVideo VOD asynchronously processes the job. Therefore, the operation may return a response before the job is complete.
        
        @description    **Make sure that you understand the billing methods and price of ApsaraVideo VOD before you call this operation. You are charged for using the automated review feature. For more information about billing, submit a ticket or contact your account manager.**\
        You can call this operation only in the **China (Shanghai)**, **China (Beijing)**, and **Singapore** regions.
        For more information, see [Automated review](https://help.aliyun.com/document_detail/101148.html).
        After an automated review job is complete, the images generated during the review are stored in the VOD bucket for two weeks free of charge. The images are automatically deleted after two weeks.
        
        @param request: SubmitAIMediaAuditJobRequest
        @return: SubmitAIMediaAuditJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aimedia_audit_job_with_options(request, runtime)

    async def submit_aimedia_audit_job_async(
        self,
        request: vod_20170321_models.SubmitAIMediaAuditJobRequest,
    ) -> vod_20170321_models.SubmitAIMediaAuditJobResponse:
        """
        @summary Submits an automated review job for a media file. After the job is submitted, ApsaraVideo VOD asynchronously processes the job. Therefore, the operation may return a response before the job is complete.
        
        @description    **Make sure that you understand the billing methods and price of ApsaraVideo VOD before you call this operation. You are charged for using the automated review feature. For more information about billing, submit a ticket or contact your account manager.**\
        You can call this operation only in the **China (Shanghai)**, **China (Beijing)**, and **Singapore** regions.
        For more information, see [Automated review](https://help.aliyun.com/document_detail/101148.html).
        After an automated review job is complete, the images generated during the review are stored in the VOD bucket for two weeks free of charge. The images are automatically deleted after two weeks.
        
        @param request: SubmitAIMediaAuditJobRequest
        @return: SubmitAIMediaAuditJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aimedia_audit_job_with_options_async(request, runtime)

    def submit_aivideo_category_job_with_options(
        self,
        request: vod_20170321_models.SubmitAIVideoCategoryJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoCategoryJobResponse:
        """
        @summary 提交AI智能分类任务
        
        @param request: SubmitAIVideoCategoryJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoCategoryJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_category_config):
            query['AIVideoCategoryConfig'] = request.aivideo_category_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoCategoryJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoCategoryJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aivideo_category_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIVideoCategoryJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoCategoryJobResponse:
        """
        @summary 提交AI智能分类任务
        
        @param request: SubmitAIVideoCategoryJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoCategoryJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_category_config):
            query['AIVideoCategoryConfig'] = request.aivideo_category_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoCategoryJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoCategoryJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aivideo_category_job(
        self,
        request: vod_20170321_models.SubmitAIVideoCategoryJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoCategoryJobResponse:
        """
        @summary 提交AI智能分类任务
        
        @param request: SubmitAIVideoCategoryJobRequest
        @return: SubmitAIVideoCategoryJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aivideo_category_job_with_options(request, runtime)

    async def submit_aivideo_category_job_async(
        self,
        request: vod_20170321_models.SubmitAIVideoCategoryJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoCategoryJobResponse:
        """
        @summary 提交AI智能分类任务
        
        @param request: SubmitAIVideoCategoryJobRequest
        @return: SubmitAIVideoCategoryJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aivideo_category_job_with_options_async(request, runtime)

    def submit_aivideo_censor_job_with_options(
        self,
        request: vod_20170321_models.SubmitAIVideoCensorJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoCensorJobResponse:
        """
        @summary 提交视频审核任务
        
        @param request: SubmitAIVideoCensorJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoCensorJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_censor_config):
            query['AIVideoCensorConfig'] = request.aivideo_censor_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoCensorJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoCensorJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aivideo_censor_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIVideoCensorJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoCensorJobResponse:
        """
        @summary 提交视频审核任务
        
        @param request: SubmitAIVideoCensorJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoCensorJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_censor_config):
            query['AIVideoCensorConfig'] = request.aivideo_censor_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoCensorJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoCensorJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aivideo_censor_job(
        self,
        request: vod_20170321_models.SubmitAIVideoCensorJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoCensorJobResponse:
        """
        @summary 提交视频审核任务
        
        @param request: SubmitAIVideoCensorJobRequest
        @return: SubmitAIVideoCensorJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aivideo_censor_job_with_options(request, runtime)

    async def submit_aivideo_censor_job_async(
        self,
        request: vod_20170321_models.SubmitAIVideoCensorJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoCensorJobResponse:
        """
        @summary 提交视频审核任务
        
        @param request: SubmitAIVideoCensorJobRequest
        @return: SubmitAIVideoCensorJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aivideo_censor_job_with_options_async(request, runtime)

    def submit_aivideo_cover_job_with_options(
        self,
        request: vod_20170321_models.SubmitAIVideoCoverJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoCoverJobResponse:
        """
        @summary 提交智能封面任务
        
        @param request: SubmitAIVideoCoverJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoCoverJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_cover_config):
            query['AIVideoCoverConfig'] = request.aivideo_cover_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoCoverJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoCoverJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aivideo_cover_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIVideoCoverJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoCoverJobResponse:
        """
        @summary 提交智能封面任务
        
        @param request: SubmitAIVideoCoverJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoCoverJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_cover_config):
            query['AIVideoCoverConfig'] = request.aivideo_cover_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoCoverJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoCoverJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aivideo_cover_job(
        self,
        request: vod_20170321_models.SubmitAIVideoCoverJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoCoverJobResponse:
        """
        @summary 提交智能封面任务
        
        @param request: SubmitAIVideoCoverJobRequest
        @return: SubmitAIVideoCoverJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aivideo_cover_job_with_options(request, runtime)

    async def submit_aivideo_cover_job_async(
        self,
        request: vod_20170321_models.SubmitAIVideoCoverJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoCoverJobResponse:
        """
        @summary 提交智能封面任务
        
        @param request: SubmitAIVideoCoverJobRequest
        @return: SubmitAIVideoCoverJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aivideo_cover_job_with_options_async(request, runtime)

    def submit_aivideo_face_recog_job_with_options(
        self,
        request: vod_20170321_models.SubmitAIVideoFaceRecogJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoFaceRecogJobResponse:
        """
        @summary 提交AI人脸识别任务
        
        @param request: SubmitAIVideoFaceRecogJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoFaceRecogJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_face_recog_config):
            query['AIVideoFaceRecogConfig'] = request.aivideo_face_recog_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoFaceRecogJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoFaceRecogJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aivideo_face_recog_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIVideoFaceRecogJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoFaceRecogJobResponse:
        """
        @summary 提交AI人脸识别任务
        
        @param request: SubmitAIVideoFaceRecogJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoFaceRecogJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_face_recog_config):
            query['AIVideoFaceRecogConfig'] = request.aivideo_face_recog_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoFaceRecogJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoFaceRecogJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aivideo_face_recog_job(
        self,
        request: vod_20170321_models.SubmitAIVideoFaceRecogJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoFaceRecogJobResponse:
        """
        @summary 提交AI人脸识别任务
        
        @param request: SubmitAIVideoFaceRecogJobRequest
        @return: SubmitAIVideoFaceRecogJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aivideo_face_recog_job_with_options(request, runtime)

    async def submit_aivideo_face_recog_job_async(
        self,
        request: vod_20170321_models.SubmitAIVideoFaceRecogJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoFaceRecogJobResponse:
        """
        @summary 提交AI人脸识别任务
        
        @param request: SubmitAIVideoFaceRecogJobRequest
        @return: SubmitAIVideoFaceRecogJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aivideo_face_recog_job_with_options_async(request, runtime)

    def submit_aivideo_porn_recog_job_with_options(
        self,
        request: vod_20170321_models.SubmitAIVideoPornRecogJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoPornRecogJobResponse:
        """
        @summary 提交AI视频色情识别任务
        
        @param request: SubmitAIVideoPornRecogJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoPornRecogJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_porn_recog_config):
            query['AIVideoPornRecogConfig'] = request.aivideo_porn_recog_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoPornRecogJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoPornRecogJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aivideo_porn_recog_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIVideoPornRecogJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoPornRecogJobResponse:
        """
        @summary 提交AI视频色情识别任务
        
        @param request: SubmitAIVideoPornRecogJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoPornRecogJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_porn_recog_config):
            query['AIVideoPornRecogConfig'] = request.aivideo_porn_recog_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoPornRecogJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoPornRecogJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aivideo_porn_recog_job(
        self,
        request: vod_20170321_models.SubmitAIVideoPornRecogJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoPornRecogJobResponse:
        """
        @summary 提交AI视频色情识别任务
        
        @param request: SubmitAIVideoPornRecogJobRequest
        @return: SubmitAIVideoPornRecogJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aivideo_porn_recog_job_with_options(request, runtime)

    async def submit_aivideo_porn_recog_job_async(
        self,
        request: vod_20170321_models.SubmitAIVideoPornRecogJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoPornRecogJobResponse:
        """
        @summary 提交AI视频色情识别任务
        
        @param request: SubmitAIVideoPornRecogJobRequest
        @return: SubmitAIVideoPornRecogJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aivideo_porn_recog_job_with_options_async(request, runtime)

    def submit_aivideo_summary_job_with_options(
        self,
        request: vod_20170321_models.SubmitAIVideoSummaryJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoSummaryJobResponse:
        """
        @summary 提交AI摘要任务
        
        @param request: SubmitAIVideoSummaryJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoSummaryJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_summary_config):
            query['AIVideoSummaryConfig'] = request.aivideo_summary_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoSummaryJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoSummaryJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aivideo_summary_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIVideoSummaryJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoSummaryJobResponse:
        """
        @summary 提交AI摘要任务
        
        @param request: SubmitAIVideoSummaryJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoSummaryJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_summary_config):
            query['AIVideoSummaryConfig'] = request.aivideo_summary_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoSummaryJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoSummaryJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aivideo_summary_job(
        self,
        request: vod_20170321_models.SubmitAIVideoSummaryJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoSummaryJobResponse:
        """
        @summary 提交AI摘要任务
        
        @param request: SubmitAIVideoSummaryJobRequest
        @return: SubmitAIVideoSummaryJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aivideo_summary_job_with_options(request, runtime)

    async def submit_aivideo_summary_job_async(
        self,
        request: vod_20170321_models.SubmitAIVideoSummaryJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoSummaryJobResponse:
        """
        @summary 提交AI摘要任务
        
        @param request: SubmitAIVideoSummaryJobRequest
        @return: SubmitAIVideoSummaryJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aivideo_summary_job_with_options_async(request, runtime)

    def submit_aivideo_tag_job_with_options(
        self,
        request: vod_20170321_models.SubmitAIVideoTagJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoTagJobResponse:
        """
        @summary 提交智能标签任务
        
        @param request: SubmitAIVideoTagJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoTagJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_tag_config):
            query['AIVideoTagConfig'] = request.aivideo_tag_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoTagJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoTagJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aivideo_tag_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIVideoTagJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoTagJobResponse:
        """
        @summary 提交智能标签任务
        
        @param request: SubmitAIVideoTagJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoTagJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_tag_config):
            query['AIVideoTagConfig'] = request.aivideo_tag_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoTagJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoTagJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aivideo_tag_job(
        self,
        request: vod_20170321_models.SubmitAIVideoTagJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoTagJobResponse:
        """
        @summary 提交智能标签任务
        
        @param request: SubmitAIVideoTagJobRequest
        @return: SubmitAIVideoTagJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aivideo_tag_job_with_options(request, runtime)

    async def submit_aivideo_tag_job_async(
        self,
        request: vod_20170321_models.SubmitAIVideoTagJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoTagJobResponse:
        """
        @summary 提交智能标签任务
        
        @param request: SubmitAIVideoTagJobRequest
        @return: SubmitAIVideoTagJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aivideo_tag_job_with_options_async(request, runtime)

    def submit_aivideo_terrorism_recog_job_with_options(
        self,
        request: vod_20170321_models.SubmitAIVideoTerrorismRecogJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoTerrorismRecogJobResponse:
        """
        @summary 提交暴力识别任务
        
        @param request: SubmitAIVideoTerrorismRecogJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoTerrorismRecogJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_terrorism_recog_config):
            query['AIVideoTerrorismRecogConfig'] = request.aivideo_terrorism_recog_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoTerrorismRecogJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoTerrorismRecogJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_aivideo_terrorism_recog_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitAIVideoTerrorismRecogJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitAIVideoTerrorismRecogJobResponse:
        """
        @summary 提交暴力识别任务
        
        @param request: SubmitAIVideoTerrorismRecogJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitAIVideoTerrorismRecogJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aivideo_terrorism_recog_config):
            query['AIVideoTerrorismRecogConfig'] = request.aivideo_terrorism_recog_config
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitAIVideoTerrorismRecogJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitAIVideoTerrorismRecogJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_aivideo_terrorism_recog_job(
        self,
        request: vod_20170321_models.SubmitAIVideoTerrorismRecogJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoTerrorismRecogJobResponse:
        """
        @summary 提交暴力识别任务
        
        @param request: SubmitAIVideoTerrorismRecogJobRequest
        @return: SubmitAIVideoTerrorismRecogJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_aivideo_terrorism_recog_job_with_options(request, runtime)

    async def submit_aivideo_terrorism_recog_job_async(
        self,
        request: vod_20170321_models.SubmitAIVideoTerrorismRecogJobRequest,
    ) -> vod_20170321_models.SubmitAIVideoTerrorismRecogJobResponse:
        """
        @summary 提交暴力识别任务
        
        @param request: SubmitAIVideoTerrorismRecogJobRequest
        @return: SubmitAIVideoTerrorismRecogJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_aivideo_terrorism_recog_job_with_options_async(request, runtime)

    def submit_bucket_delete_task_with_options(
        self,
        request: vod_20170321_models.SubmitBucketDeleteTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitBucketDeleteTaskResponse:
        """
        @summary 提交bucket删除任务
        
        @param request: SubmitBucketDeleteTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitBucketDeleteTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.delete_files):
            query['DeleteFiles'] = request.delete_files
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitBucketDeleteTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitBucketDeleteTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_bucket_delete_task_with_options_async(
        self,
        request: vod_20170321_models.SubmitBucketDeleteTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitBucketDeleteTaskResponse:
        """
        @summary 提交bucket删除任务
        
        @param request: SubmitBucketDeleteTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitBucketDeleteTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.delete_files):
            query['DeleteFiles'] = request.delete_files
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitBucketDeleteTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitBucketDeleteTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_bucket_delete_task(
        self,
        request: vod_20170321_models.SubmitBucketDeleteTaskRequest,
    ) -> vod_20170321_models.SubmitBucketDeleteTaskResponse:
        """
        @summary 提交bucket删除任务
        
        @param request: SubmitBucketDeleteTaskRequest
        @return: SubmitBucketDeleteTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_bucket_delete_task_with_options(request, runtime)

    async def submit_bucket_delete_task_async(
        self,
        request: vod_20170321_models.SubmitBucketDeleteTaskRequest,
    ) -> vod_20170321_models.SubmitBucketDeleteTaskResponse:
        """
        @summary 提交bucket删除任务
        
        @param request: SubmitBucketDeleteTaskRequest
        @return: SubmitBucketDeleteTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_bucket_delete_task_with_options_async(request, runtime)

    def submit_bucket_redundancy_transition_with_options(
        self,
        request: vod_20170321_models.SubmitBucketRedundancyTransitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitBucketRedundancyTransitionResponse:
        """
        @summary 修改系统存储冗余类型
        
        @param request: SubmitBucketRedundancyTransitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitBucketRedundancyTransitionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitBucketRedundancyTransition',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitBucketRedundancyTransitionResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_bucket_redundancy_transition_with_options_async(
        self,
        request: vod_20170321_models.SubmitBucketRedundancyTransitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitBucketRedundancyTransitionResponse:
        """
        @summary 修改系统存储冗余类型
        
        @param request: SubmitBucketRedundancyTransitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitBucketRedundancyTransitionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitBucketRedundancyTransition',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitBucketRedundancyTransitionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_bucket_redundancy_transition(
        self,
        request: vod_20170321_models.SubmitBucketRedundancyTransitionRequest,
    ) -> vod_20170321_models.SubmitBucketRedundancyTransitionResponse:
        """
        @summary 修改系统存储冗余类型
        
        @param request: SubmitBucketRedundancyTransitionRequest
        @return: SubmitBucketRedundancyTransitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_bucket_redundancy_transition_with_options(request, runtime)

    async def submit_bucket_redundancy_transition_async(
        self,
        request: vod_20170321_models.SubmitBucketRedundancyTransitionRequest,
    ) -> vod_20170321_models.SubmitBucketRedundancyTransitionResponse:
        """
        @summary 修改系统存储冗余类型
        
        @param request: SubmitBucketRedundancyTransitionRequest
        @return: SubmitBucketRedundancyTransitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_bucket_redundancy_transition_with_options_async(request, runtime)

    def submit_dnainitialization_job_with_options(
        self,
        request: vod_20170321_models.SubmitDNAInitializationJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitDNAInitializationJobResponse:
        """
        @summary 提交DNA初始化任务
        
        @param request: SubmitDNAInitializationJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitDNAInitializationJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.recent_number):
            query['RecentNumber'] = request.recent_number
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitDNAInitializationJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitDNAInitializationJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_dnainitialization_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitDNAInitializationJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitDNAInitializationJobResponse:
        """
        @summary 提交DNA初始化任务
        
        @param request: SubmitDNAInitializationJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitDNAInitializationJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.recent_number):
            query['RecentNumber'] = request.recent_number
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitDNAInitializationJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitDNAInitializationJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_dnainitialization_job(
        self,
        request: vod_20170321_models.SubmitDNAInitializationJobRequest,
    ) -> vod_20170321_models.SubmitDNAInitializationJobResponse:
        """
        @summary 提交DNA初始化任务
        
        @param request: SubmitDNAInitializationJobRequest
        @return: SubmitDNAInitializationJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_dnainitialization_job_with_options(request, runtime)

    async def submit_dnainitialization_job_async(
        self,
        request: vod_20170321_models.SubmitDNAInitializationJobRequest,
    ) -> vod_20170321_models.SubmitDNAInitializationJobResponse:
        """
        @summary 提交DNA初始化任务
        
        @param request: SubmitDNAInitializationJobRequest
        @return: SubmitDNAInitializationJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_dnainitialization_job_with_options_async(request, runtime)

    def submit_digital_watermark_extract_job_with_options(
        self,
        request: vod_20170321_models.SubmitDigitalWatermarkExtractJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitDigitalWatermarkExtractJobResponse:
        """
        @summary Submits a digital watermark extraction job. You can call this operation to asynchronously extract a copyright watermark or user-tracing watermark.
        
        @description    **Make sure that you understand the billing methods and price of ApsaraVideo VOD before you call this operation. You are charged for generating and extracting digital watermarks. For more information, see [Billing](~~188310#62b9c940403se~~).**\
        This operation is supported only in the **China (Shanghai)** and **China (Beijing)** regions.
        Before you submit a digital watermark extraction job, make sure that the following conditions are met:
        The video from which you want to extract the watermark is uploaded to the ApsaraVideo VOD.
        The video from which you want to extract the watermark is longer than 6 minutes.
        
        @param request: SubmitDigitalWatermarkExtractJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitDigitalWatermarkExtractJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.extract_type):
            query['ExtractType'] = request.extract_type
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitDigitalWatermarkExtractJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitDigitalWatermarkExtractJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_digital_watermark_extract_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitDigitalWatermarkExtractJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitDigitalWatermarkExtractJobResponse:
        """
        @summary Submits a digital watermark extraction job. You can call this operation to asynchronously extract a copyright watermark or user-tracing watermark.
        
        @description    **Make sure that you understand the billing methods and price of ApsaraVideo VOD before you call this operation. You are charged for generating and extracting digital watermarks. For more information, see [Billing](~~188310#62b9c940403se~~).**\
        This operation is supported only in the **China (Shanghai)** and **China (Beijing)** regions.
        Before you submit a digital watermark extraction job, make sure that the following conditions are met:
        The video from which you want to extract the watermark is uploaded to the ApsaraVideo VOD.
        The video from which you want to extract the watermark is longer than 6 minutes.
        
        @param request: SubmitDigitalWatermarkExtractJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitDigitalWatermarkExtractJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.extract_type):
            query['ExtractType'] = request.extract_type
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitDigitalWatermarkExtractJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitDigitalWatermarkExtractJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_digital_watermark_extract_job(
        self,
        request: vod_20170321_models.SubmitDigitalWatermarkExtractJobRequest,
    ) -> vod_20170321_models.SubmitDigitalWatermarkExtractJobResponse:
        """
        @summary Submits a digital watermark extraction job. You can call this operation to asynchronously extract a copyright watermark or user-tracing watermark.
        
        @description    **Make sure that you understand the billing methods and price of ApsaraVideo VOD before you call this operation. You are charged for generating and extracting digital watermarks. For more information, see [Billing](~~188310#62b9c940403se~~).**\
        This operation is supported only in the **China (Shanghai)** and **China (Beijing)** regions.
        Before you submit a digital watermark extraction job, make sure that the following conditions are met:
        The video from which you want to extract the watermark is uploaded to the ApsaraVideo VOD.
        The video from which you want to extract the watermark is longer than 6 minutes.
        
        @param request: SubmitDigitalWatermarkExtractJobRequest
        @return: SubmitDigitalWatermarkExtractJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_digital_watermark_extract_job_with_options(request, runtime)

    async def submit_digital_watermark_extract_job_async(
        self,
        request: vod_20170321_models.SubmitDigitalWatermarkExtractJobRequest,
    ) -> vod_20170321_models.SubmitDigitalWatermarkExtractJobResponse:
        """
        @summary Submits a digital watermark extraction job. You can call this operation to asynchronously extract a copyright watermark or user-tracing watermark.
        
        @description    **Make sure that you understand the billing methods and price of ApsaraVideo VOD before you call this operation. You are charged for generating and extracting digital watermarks. For more information, see [Billing](~~188310#62b9c940403se~~).**\
        This operation is supported only in the **China (Shanghai)** and **China (Beijing)** regions.
        Before you submit a digital watermark extraction job, make sure that the following conditions are met:
        The video from which you want to extract the watermark is uploaded to the ApsaraVideo VOD.
        The video from which you want to extract the watermark is longer than 6 minutes.
        
        @param request: SubmitDigitalWatermarkExtractJobRequest
        @return: SubmitDigitalWatermarkExtractJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_digital_watermark_extract_job_with_options_async(request, runtime)

    def submit_dynamic_image_job_with_options(
        self,
        request: vod_20170321_models.SubmitDynamicImageJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitDynamicImageJobResponse:
        """
        @summary Submits a frame animation job and starts asynchronous processing.
        
        @description    You can capture a part of a video and generate animated images only when the video is in the **Uploaded**, **Transcoding**, **Normal**, **Reviewing**, or **Flagged** state.
        The fees for frame animation are included in your video transcoding bill. You are charged based on the output resolution and the duration. For more information, see [Billing of basic services](https://help.aliyun.com/document_detail/188308.html).
        ### QPS limits
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on API operations](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: SubmitDynamicImageJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitDynamicImageJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dynamic_image_template_id):
            query['DynamicImageTemplateId'] = request.dynamic_image_template_id
        if not UtilClient.is_unset(request.override_params):
            query['OverrideParams'] = request.override_params
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitDynamicImageJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitDynamicImageJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_dynamic_image_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitDynamicImageJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitDynamicImageJobResponse:
        """
        @summary Submits a frame animation job and starts asynchronous processing.
        
        @description    You can capture a part of a video and generate animated images only when the video is in the **Uploaded**, **Transcoding**, **Normal**, **Reviewing**, or **Flagged** state.
        The fees for frame animation are included in your video transcoding bill. You are charged based on the output resolution and the duration. For more information, see [Billing of basic services](https://help.aliyun.com/document_detail/188308.html).
        ### QPS limits
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on API operations](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: SubmitDynamicImageJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitDynamicImageJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dynamic_image_template_id):
            query['DynamicImageTemplateId'] = request.dynamic_image_template_id
        if not UtilClient.is_unset(request.override_params):
            query['OverrideParams'] = request.override_params
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitDynamicImageJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitDynamicImageJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_dynamic_image_job(
        self,
        request: vod_20170321_models.SubmitDynamicImageJobRequest,
    ) -> vod_20170321_models.SubmitDynamicImageJobResponse:
        """
        @summary Submits a frame animation job and starts asynchronous processing.
        
        @description    You can capture a part of a video and generate animated images only when the video is in the **Uploaded**, **Transcoding**, **Normal**, **Reviewing**, or **Flagged** state.
        The fees for frame animation are included in your video transcoding bill. You are charged based on the output resolution and the duration. For more information, see [Billing of basic services](https://help.aliyun.com/document_detail/188308.html).
        ### QPS limits
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on API operations](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: SubmitDynamicImageJobRequest
        @return: SubmitDynamicImageJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_dynamic_image_job_with_options(request, runtime)

    async def submit_dynamic_image_job_async(
        self,
        request: vod_20170321_models.SubmitDynamicImageJobRequest,
    ) -> vod_20170321_models.SubmitDynamicImageJobResponse:
        """
        @summary Submits a frame animation job and starts asynchronous processing.
        
        @description    You can capture a part of a video and generate animated images only when the video is in the **Uploaded**, **Transcoding**, **Normal**, **Reviewing**, or **Flagged** state.
        The fees for frame animation are included in your video transcoding bill. You are charged based on the output resolution and the duration. For more information, see [Billing of basic services](https://help.aliyun.com/document_detail/188308.html).
        ### QPS limits
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on API operations](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: SubmitDynamicImageJobRequest
        @return: SubmitDynamicImageJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_dynamic_image_job_with_options_async(request, runtime)

    def submit_live_editing_with_options(
        self,
        request: vod_20170321_models.SubmitLiveEditingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitLiveEditingResponse:
        """
        @summary 直播剪辑
        
        @param request: SubmitLiveEditingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitLiveEditingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.clips):
            query['Clips'] = request.clips
        if not UtilClient.is_unset(request.cover_url):
            query['CoverURL'] = request.cover_url
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.media_metadata):
            query['MediaMetadata'] = request.media_metadata
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.produce_config):
            query['ProduceConfig'] = request.produce_config
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitLiveEditing',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitLiveEditingResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_live_editing_with_options_async(
        self,
        request: vod_20170321_models.SubmitLiveEditingRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitLiveEditingResponse:
        """
        @summary 直播剪辑
        
        @param request: SubmitLiveEditingRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitLiveEditingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.clips):
            query['Clips'] = request.clips
        if not UtilClient.is_unset(request.cover_url):
            query['CoverURL'] = request.cover_url
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.media_metadata):
            query['MediaMetadata'] = request.media_metadata
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.produce_config):
            query['ProduceConfig'] = request.produce_config
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.stream_name):
            query['StreamName'] = request.stream_name
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitLiveEditing',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitLiveEditingResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_live_editing(
        self,
        request: vod_20170321_models.SubmitLiveEditingRequest,
    ) -> vod_20170321_models.SubmitLiveEditingResponse:
        """
        @summary 直播剪辑
        
        @param request: SubmitLiveEditingRequest
        @return: SubmitLiveEditingResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_live_editing_with_options(request, runtime)

    async def submit_live_editing_async(
        self,
        request: vod_20170321_models.SubmitLiveEditingRequest,
    ) -> vod_20170321_models.SubmitLiveEditingResponse:
        """
        @summary 直播剪辑
        
        @param request: SubmitLiveEditingRequest
        @return: SubmitLiveEditingResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_live_editing_with_options_async(request, runtime)

    def submit_media_dnadelete_job_with_options(
        self,
        request: vod_20170321_models.SubmitMediaDNADeleteJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitMediaDNADeleteJobResponse:
        """
        @summary Deletes a video fingerprinting job.
        
        @description Regions that support this operation: *China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        
        @param request: SubmitMediaDNADeleteJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitMediaDNADeleteJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitMediaDNADeleteJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitMediaDNADeleteJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_media_dnadelete_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitMediaDNADeleteJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitMediaDNADeleteJobResponse:
        """
        @summary Deletes a video fingerprinting job.
        
        @description Regions that support this operation: *China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        
        @param request: SubmitMediaDNADeleteJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitMediaDNADeleteJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitMediaDNADeleteJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitMediaDNADeleteJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_media_dnadelete_job(
        self,
        request: vod_20170321_models.SubmitMediaDNADeleteJobRequest,
    ) -> vod_20170321_models.SubmitMediaDNADeleteJobResponse:
        """
        @summary Deletes a video fingerprinting job.
        
        @description Regions that support this operation: *China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        
        @param request: SubmitMediaDNADeleteJobRequest
        @return: SubmitMediaDNADeleteJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_media_dnadelete_job_with_options(request, runtime)

    async def submit_media_dnadelete_job_async(
        self,
        request: vod_20170321_models.SubmitMediaDNADeleteJobRequest,
    ) -> vod_20170321_models.SubmitMediaDNADeleteJobResponse:
        """
        @summary Deletes a video fingerprinting job.
        
        @description Regions that support this operation: *China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        
        @param request: SubmitMediaDNADeleteJobRequest
        @return: SubmitMediaDNADeleteJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_media_dnadelete_job_with_options_async(request, runtime)

    def submit_media_export_job_with_options(
        self,
        request: vod_20170321_models.SubmitMediaExportJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitMediaExportJobResponse:
        """
        @summary 提交媒资导出任务
        
        @param request: SubmitMediaExportJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitMediaExportJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_name):
            query['JobName'] = request.job_name
        if not UtilClient.is_unset(request.match):
            query['Match'] = request.match
        if not UtilClient.is_unset(request.media_export_config):
            query['MediaExportConfig'] = request.media_export_config
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitMediaExportJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitMediaExportJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_media_export_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitMediaExportJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitMediaExportJobResponse:
        """
        @summary 提交媒资导出任务
        
        @param request: SubmitMediaExportJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitMediaExportJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_name):
            query['JobName'] = request.job_name
        if not UtilClient.is_unset(request.match):
            query['Match'] = request.match
        if not UtilClient.is_unset(request.media_export_config):
            query['MediaExportConfig'] = request.media_export_config
        if not UtilClient.is_unset(request.media_type):
            query['MediaType'] = request.media_type
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.sort_by):
            query['SortBy'] = request.sort_by
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitMediaExportJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitMediaExportJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_media_export_job(
        self,
        request: vod_20170321_models.SubmitMediaExportJobRequest,
    ) -> vod_20170321_models.SubmitMediaExportJobResponse:
        """
        @summary 提交媒资导出任务
        
        @param request: SubmitMediaExportJobRequest
        @return: SubmitMediaExportJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_media_export_job_with_options(request, runtime)

    async def submit_media_export_job_async(
        self,
        request: vod_20170321_models.SubmitMediaExportJobRequest,
    ) -> vod_20170321_models.SubmitMediaExportJobResponse:
        """
        @summary 提交媒资导出任务
        
        @param request: SubmitMediaExportJobRequest
        @return: SubmitMediaExportJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_media_export_job_with_options_async(request, runtime)

    def submit_preprocess_jobs_with_options(
        self,
        request: vod_20170321_models.SubmitPreprocessJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitPreprocessJobsResponse:
        """
        @summary Transcodes a video by using the production studio.
        
        @description    During video preprocessing, videos are transcoded to meet the playback requirements of the production studio. Therefore, **you are charged for video preprocessing**. For more information about billing, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
        You can obtain the preprocessing result in the [TranscodeComplete](https://help.aliyun.com/document_detail/55638.html) event notification. If **Preprocess=true** is returned in the event notification, the video is transcoded.
        
        @param request: SubmitPreprocessJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitPreprocessJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.preprocess_type):
            query['PreprocessType'] = request.preprocess_type
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitPreprocessJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitPreprocessJobsResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_preprocess_jobs_with_options_async(
        self,
        request: vod_20170321_models.SubmitPreprocessJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitPreprocessJobsResponse:
        """
        @summary Transcodes a video by using the production studio.
        
        @description    During video preprocessing, videos are transcoded to meet the playback requirements of the production studio. Therefore, **you are charged for video preprocessing**. For more information about billing, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
        You can obtain the preprocessing result in the [TranscodeComplete](https://help.aliyun.com/document_detail/55638.html) event notification. If **Preprocess=true** is returned in the event notification, the video is transcoded.
        
        @param request: SubmitPreprocessJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitPreprocessJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.preprocess_type):
            query['PreprocessType'] = request.preprocess_type
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitPreprocessJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitPreprocessJobsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_preprocess_jobs(
        self,
        request: vod_20170321_models.SubmitPreprocessJobsRequest,
    ) -> vod_20170321_models.SubmitPreprocessJobsResponse:
        """
        @summary Transcodes a video by using the production studio.
        
        @description    During video preprocessing, videos are transcoded to meet the playback requirements of the production studio. Therefore, **you are charged for video preprocessing**. For more information about billing, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
        You can obtain the preprocessing result in the [TranscodeComplete](https://help.aliyun.com/document_detail/55638.html) event notification. If **Preprocess=true** is returned in the event notification, the video is transcoded.
        
        @param request: SubmitPreprocessJobsRequest
        @return: SubmitPreprocessJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_preprocess_jobs_with_options(request, runtime)

    async def submit_preprocess_jobs_async(
        self,
        request: vod_20170321_models.SubmitPreprocessJobsRequest,
    ) -> vod_20170321_models.SubmitPreprocessJobsResponse:
        """
        @summary Transcodes a video by using the production studio.
        
        @description    During video preprocessing, videos are transcoded to meet the playback requirements of the production studio. Therefore, **you are charged for video preprocessing**. For more information about billing, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
        You can obtain the preprocessing result in the [TranscodeComplete](https://help.aliyun.com/document_detail/55638.html) event notification. If **Preprocess=true** is returned in the event notification, the video is transcoded.
        
        @param request: SubmitPreprocessJobsRequest
        @return: SubmitPreprocessJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_preprocess_jobs_with_options_async(request, runtime)

    def submit_preprocess_jobs_console_with_options(
        self,
        request: vod_20170321_models.SubmitPreprocessJobsConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitPreprocessJobsConsoleResponse:
        """
        @summary 提交预处理任务
        
        @param request: SubmitPreprocessJobsConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitPreprocessJobsConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.preprocess_type):
            query['PreprocessType'] = request.preprocess_type
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitPreprocessJobsConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitPreprocessJobsConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_preprocess_jobs_console_with_options_async(
        self,
        request: vod_20170321_models.SubmitPreprocessJobsConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitPreprocessJobsConsoleResponse:
        """
        @summary 提交预处理任务
        
        @param request: SubmitPreprocessJobsConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitPreprocessJobsConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.preprocess_type):
            query['PreprocessType'] = request.preprocess_type
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitPreprocessJobsConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitPreprocessJobsConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_preprocess_jobs_console(
        self,
        request: vod_20170321_models.SubmitPreprocessJobsConsoleRequest,
    ) -> vod_20170321_models.SubmitPreprocessJobsConsoleResponse:
        """
        @summary 提交预处理任务
        
        @param request: SubmitPreprocessJobsConsoleRequest
        @return: SubmitPreprocessJobsConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_preprocess_jobs_console_with_options(request, runtime)

    async def submit_preprocess_jobs_console_async(
        self,
        request: vod_20170321_models.SubmitPreprocessJobsConsoleRequest,
    ) -> vod_20170321_models.SubmitPreprocessJobsConsoleResponse:
        """
        @summary 提交预处理任务
        
        @param request: SubmitPreprocessJobsConsoleRequest
        @return: SubmitPreprocessJobsConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_preprocess_jobs_console_with_options_async(request, runtime)

    def submit_snapshot_job_with_options(
        self,
        tmp_req: vod_20170321_models.SubmitSnapshotJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitSnapshotJobResponse:
        """
        @summary Submits a snapshot job for a video and starts asynchronous snapshot processing.
        
        @description    Only snapshots in the JPG format are generated.
        After a snapshot is captured, the [SnapshotComplete](https://help.aliyun.com/document_detail/57337.html) callback is fired and EventType=SnapshotComplete, SubType=SpecifiedTime is returned.
        ### [](#qps-)QPS limits
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param tmp_req: SubmitSnapshotJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitSnapshotJobResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vod_20170321_models.SubmitSnapshotJobShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.specified_offset_times):
            request.specified_offset_times_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.specified_offset_times, 'SpecifiedOffsetTimes', 'json')
        query = {}
        if not UtilClient.is_unset(request.count):
            query['Count'] = request.count
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.snapshot_template_id):
            query['SnapshotTemplateId'] = request.snapshot_template_id
        if not UtilClient.is_unset(request.specified_offset_time):
            query['SpecifiedOffsetTime'] = request.specified_offset_time
        if not UtilClient.is_unset(request.specified_offset_times_shrink):
            query['SpecifiedOffsetTimes'] = request.specified_offset_times_shrink
        if not UtilClient.is_unset(request.sprite_snapshot_config):
            query['SpriteSnapshotConfig'] = request.sprite_snapshot_config
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitSnapshotJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitSnapshotJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_snapshot_job_with_options_async(
        self,
        tmp_req: vod_20170321_models.SubmitSnapshotJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitSnapshotJobResponse:
        """
        @summary Submits a snapshot job for a video and starts asynchronous snapshot processing.
        
        @description    Only snapshots in the JPG format are generated.
        After a snapshot is captured, the [SnapshotComplete](https://help.aliyun.com/document_detail/57337.html) callback is fired and EventType=SnapshotComplete, SubType=SpecifiedTime is returned.
        ### [](#qps-)QPS limits
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param tmp_req: SubmitSnapshotJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitSnapshotJobResponse
        """
        UtilClient.validate_model(tmp_req)
        request = vod_20170321_models.SubmitSnapshotJobShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.specified_offset_times):
            request.specified_offset_times_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.specified_offset_times, 'SpecifiedOffsetTimes', 'json')
        query = {}
        if not UtilClient.is_unset(request.count):
            query['Count'] = request.count
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.snapshot_template_id):
            query['SnapshotTemplateId'] = request.snapshot_template_id
        if not UtilClient.is_unset(request.specified_offset_time):
            query['SpecifiedOffsetTime'] = request.specified_offset_time
        if not UtilClient.is_unset(request.specified_offset_times_shrink):
            query['SpecifiedOffsetTimes'] = request.specified_offset_times_shrink
        if not UtilClient.is_unset(request.sprite_snapshot_config):
            query['SpriteSnapshotConfig'] = request.sprite_snapshot_config
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitSnapshotJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitSnapshotJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_snapshot_job(
        self,
        request: vod_20170321_models.SubmitSnapshotJobRequest,
    ) -> vod_20170321_models.SubmitSnapshotJobResponse:
        """
        @summary Submits a snapshot job for a video and starts asynchronous snapshot processing.
        
        @description    Only snapshots in the JPG format are generated.
        After a snapshot is captured, the [SnapshotComplete](https://help.aliyun.com/document_detail/57337.html) callback is fired and EventType=SnapshotComplete, SubType=SpecifiedTime is returned.
        ### [](#qps-)QPS limits
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: SubmitSnapshotJobRequest
        @return: SubmitSnapshotJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_snapshot_job_with_options(request, runtime)

    async def submit_snapshot_job_async(
        self,
        request: vod_20170321_models.SubmitSnapshotJobRequest,
    ) -> vod_20170321_models.SubmitSnapshotJobResponse:
        """
        @summary Submits a snapshot job for a video and starts asynchronous snapshot processing.
        
        @description    Only snapshots in the JPG format are generated.
        After a snapshot is captured, the [SnapshotComplete](https://help.aliyun.com/document_detail/57337.html) callback is fired and EventType=SnapshotComplete, SubType=SpecifiedTime is returned.
        ### [](#qps-)QPS limits
        You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: SubmitSnapshotJobRequest
        @return: SubmitSnapshotJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_snapshot_job_with_options_async(request, runtime)

    def submit_transcode_jobs_with_options(
        self,
        request: vod_20170321_models.SubmitTranscodeJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitTranscodeJobsResponse:
        """
        @summary Submits a transcoding job to start transcoding in an asynchronous manner.
        
        @description ### [](#)Usage notes
        **Make sure that you understand the billing methods and prices of ApsaraVideo VOD before you call this operation. For more information about billing of the transcoding feature, see [Billing of basic services](~~188308#section-ejb-nii-nqa~~).**\
        You can transcode a video only in the Uploaded, Normal, or Reviewing state.
        You can obtain the transcoding results from the [StreamTranscodeComplete](https://help.aliyun.com/document_detail/55636.html) or [TranscodeComplete](https://help.aliyun.com/document_detail/55638.html) callback.
        You can call this operation to dynamically override the subtitle URL in an HTTP Live Streaming (HLS) packaging task. If the packaging task does not contain subtitles, we recommend that you specify the ID of the specific packaging template group when you upload the video instead of calling this operation.
        
        @param request: SubmitTranscodeJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitTranscodeJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.encrypt_config):
            query['EncryptConfig'] = request.encrypt_config
        if not UtilClient.is_unset(request.override_params):
            query['OverrideParams'] = request.override_params
        if not UtilClient.is_unset(request.pipeline_id):
            query['PipelineId'] = request.pipeline_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.session_id):
            query['SessionId'] = request.session_id
        if not UtilClient.is_unset(request.template_group_id):
            query['TemplateGroupId'] = request.template_group_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitTranscodeJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitTranscodeJobsResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_transcode_jobs_with_options_async(
        self,
        request: vod_20170321_models.SubmitTranscodeJobsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitTranscodeJobsResponse:
        """
        @summary Submits a transcoding job to start transcoding in an asynchronous manner.
        
        @description ### [](#)Usage notes
        **Make sure that you understand the billing methods and prices of ApsaraVideo VOD before you call this operation. For more information about billing of the transcoding feature, see [Billing of basic services](~~188308#section-ejb-nii-nqa~~).**\
        You can transcode a video only in the Uploaded, Normal, or Reviewing state.
        You can obtain the transcoding results from the [StreamTranscodeComplete](https://help.aliyun.com/document_detail/55636.html) or [TranscodeComplete](https://help.aliyun.com/document_detail/55638.html) callback.
        You can call this operation to dynamically override the subtitle URL in an HTTP Live Streaming (HLS) packaging task. If the packaging task does not contain subtitles, we recommend that you specify the ID of the specific packaging template group when you upload the video instead of calling this operation.
        
        @param request: SubmitTranscodeJobsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitTranscodeJobsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.encrypt_config):
            query['EncryptConfig'] = request.encrypt_config
        if not UtilClient.is_unset(request.override_params):
            query['OverrideParams'] = request.override_params
        if not UtilClient.is_unset(request.pipeline_id):
            query['PipelineId'] = request.pipeline_id
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.session_id):
            query['SessionId'] = request.session_id
        if not UtilClient.is_unset(request.template_group_id):
            query['TemplateGroupId'] = request.template_group_id
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitTranscodeJobs',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitTranscodeJobsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_transcode_jobs(
        self,
        request: vod_20170321_models.SubmitTranscodeJobsRequest,
    ) -> vod_20170321_models.SubmitTranscodeJobsResponse:
        """
        @summary Submits a transcoding job to start transcoding in an asynchronous manner.
        
        @description ### [](#)Usage notes
        **Make sure that you understand the billing methods and prices of ApsaraVideo VOD before you call this operation. For more information about billing of the transcoding feature, see [Billing of basic services](~~188308#section-ejb-nii-nqa~~).**\
        You can transcode a video only in the Uploaded, Normal, or Reviewing state.
        You can obtain the transcoding results from the [StreamTranscodeComplete](https://help.aliyun.com/document_detail/55636.html) or [TranscodeComplete](https://help.aliyun.com/document_detail/55638.html) callback.
        You can call this operation to dynamically override the subtitle URL in an HTTP Live Streaming (HLS) packaging task. If the packaging task does not contain subtitles, we recommend that you specify the ID of the specific packaging template group when you upload the video instead of calling this operation.
        
        @param request: SubmitTranscodeJobsRequest
        @return: SubmitTranscodeJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_transcode_jobs_with_options(request, runtime)

    async def submit_transcode_jobs_async(
        self,
        request: vod_20170321_models.SubmitTranscodeJobsRequest,
    ) -> vod_20170321_models.SubmitTranscodeJobsResponse:
        """
        @summary Submits a transcoding job to start transcoding in an asynchronous manner.
        
        @description ### [](#)Usage notes
        **Make sure that you understand the billing methods and prices of ApsaraVideo VOD before you call this operation. For more information about billing of the transcoding feature, see [Billing of basic services](~~188308#section-ejb-nii-nqa~~).**\
        You can transcode a video only in the Uploaded, Normal, or Reviewing state.
        You can obtain the transcoding results from the [StreamTranscodeComplete](https://help.aliyun.com/document_detail/55636.html) or [TranscodeComplete](https://help.aliyun.com/document_detail/55638.html) callback.
        You can call this operation to dynamically override the subtitle URL in an HTTP Live Streaming (HLS) packaging task. If the packaging task does not contain subtitles, we recommend that you specify the ID of the specific packaging template group when you upload the video instead of calling this operation.
        
        @param request: SubmitTranscodeJobsRequest
        @return: SubmitTranscodeJobsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_transcode_jobs_with_options_async(request, runtime)

    def submit_workflow_job_with_options(
        self,
        request: vod_20170321_models.SubmitWorkflowJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitWorkflowJobResponse:
        """
        @summary Initiates a workflow to process media files.
        
        @description  **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. When you use workflows to process videos, you may be charged for transcoding, encryption, and automated review. For more information, see [Billing overview](https://help.aliyun.com/document_detail/188307.html).**\
        You can call this operation to initiate a VOD workflow to process media files. For more information, see [Workflows](https://help.aliyun.com/document_detail/115347.html).
        
        @param request: SubmitWorkflowJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitWorkflowJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitWorkflowJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitWorkflowJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_workflow_job_with_options_async(
        self,
        request: vod_20170321_models.SubmitWorkflowJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SubmitWorkflowJobResponse:
        """
        @summary Initiates a workflow to process media files.
        
        @description  **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. When you use workflows to process videos, you may be charged for transcoding, encryption, and automated review. For more information, see [Billing overview](https://help.aliyun.com/document_detail/188307.html).**\
        You can call this operation to initiate a VOD workflow to process media files. For more information, see [Workflows](https://help.aliyun.com/document_detail/115347.html).
        
        @param request: SubmitWorkflowJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitWorkflowJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitWorkflowJob',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SubmitWorkflowJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_workflow_job(
        self,
        request: vod_20170321_models.SubmitWorkflowJobRequest,
    ) -> vod_20170321_models.SubmitWorkflowJobResponse:
        """
        @summary Initiates a workflow to process media files.
        
        @description  **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. When you use workflows to process videos, you may be charged for transcoding, encryption, and automated review. For more information, see [Billing overview](https://help.aliyun.com/document_detail/188307.html).**\
        You can call this operation to initiate a VOD workflow to process media files. For more information, see [Workflows](https://help.aliyun.com/document_detail/115347.html).
        
        @param request: SubmitWorkflowJobRequest
        @return: SubmitWorkflowJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_workflow_job_with_options(request, runtime)

    async def submit_workflow_job_async(
        self,
        request: vod_20170321_models.SubmitWorkflowJobRequest,
    ) -> vod_20170321_models.SubmitWorkflowJobResponse:
        """
        @summary Initiates a workflow to process media files.
        
        @description  **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. When you use workflows to process videos, you may be charged for transcoding, encryption, and automated review. For more information, see [Billing overview](https://help.aliyun.com/document_detail/188307.html).**\
        You can call this operation to initiate a VOD workflow to process media files. For more information, see [Workflows](https://help.aliyun.com/document_detail/115347.html).
        
        @param request: SubmitWorkflowJobRequest
        @return: SubmitWorkflowJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_workflow_job_with_options_async(request, runtime)

    def sync_user_prod_account_and_bucket_with_options(
        self,
        request: vod_20170321_models.SyncUserProdAccountAndBucketRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SyncUserProdAccountAndBucketResponse:
        """
        @summary 同步老用户生产账号映射信息并订阅自有bucketoss消息
        
        @param request: SyncUserProdAccountAndBucketRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SyncUserProdAccountAndBucketResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bind_oss_notification):
            query['BindOssNotification'] = request.bind_oss_notification
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SyncUserProdAccountAndBucket',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SyncUserProdAccountAndBucketResponse(),
            self.call_api(params, req, runtime)
        )

    async def sync_user_prod_account_and_bucket_with_options_async(
        self,
        request: vod_20170321_models.SyncUserProdAccountAndBucketRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.SyncUserProdAccountAndBucketResponse:
        """
        @summary 同步老用户生产账号映射信息并订阅自有bucketoss消息
        
        @param request: SyncUserProdAccountAndBucketRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SyncUserProdAccountAndBucketResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bind_oss_notification):
            query['BindOssNotification'] = request.bind_oss_notification
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SyncUserProdAccountAndBucket',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.SyncUserProdAccountAndBucketResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def sync_user_prod_account_and_bucket(
        self,
        request: vod_20170321_models.SyncUserProdAccountAndBucketRequest,
    ) -> vod_20170321_models.SyncUserProdAccountAndBucketResponse:
        """
        @summary 同步老用户生产账号映射信息并订阅自有bucketoss消息
        
        @param request: SyncUserProdAccountAndBucketRequest
        @return: SyncUserProdAccountAndBucketResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.sync_user_prod_account_and_bucket_with_options(request, runtime)

    async def sync_user_prod_account_and_bucket_async(
        self,
        request: vod_20170321_models.SyncUserProdAccountAndBucketRequest,
    ) -> vod_20170321_models.SyncUserProdAccountAndBucketResponse:
        """
        @summary 同步老用户生产账号映射信息并订阅自有bucketoss消息
        
        @param request: SyncUserProdAccountAndBucketRequest
        @return: SyncUserProdAccountAndBucketResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.sync_user_prod_account_and_bucket_with_options_async(request, runtime)

    def tag_resources_with_options(
        self,
        request: vod_20170321_models.TagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.TagResourcesResponse:
        """
        @summary 资源打用户标签
        
        @param request: TagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TagResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.TagResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def tag_resources_with_options_async(
        self,
        request: vod_20170321_models.TagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.TagResourcesResponse:
        """
        @summary 资源打用户标签
        
        @param request: TagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TagResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.TagResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def tag_resources(
        self,
        request: vod_20170321_models.TagResourcesRequest,
    ) -> vod_20170321_models.TagResourcesResponse:
        """
        @summary 资源打用户标签
        
        @param request: TagResourcesRequest
        @return: TagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.tag_resources_with_options(request, runtime)

    async def tag_resources_async(
        self,
        request: vod_20170321_models.TagResourcesRequest,
    ) -> vod_20170321_models.TagResourcesResponse:
        """
        @summary 资源打用户标签
        
        @param request: TagResourcesRequest
        @return: TagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.tag_resources_with_options_async(request, runtime)

    def tag_vod_resources_with_options(
        self,
        request: vod_20170321_models.TagVodResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.TagVodResourcesResponse:
        """
        @summary 打标签
        
        @param request: TagVodResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TagVodResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TagVodResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.TagVodResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def tag_vod_resources_with_options_async(
        self,
        request: vod_20170321_models.TagVodResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.TagVodResourcesResponse:
        """
        @summary 打标签
        
        @param request: TagVodResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TagVodResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag):
            query['Tag'] = request.tag
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TagVodResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.TagVodResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def tag_vod_resources(
        self,
        request: vod_20170321_models.TagVodResourcesRequest,
    ) -> vod_20170321_models.TagVodResourcesResponse:
        """
        @summary 打标签
        
        @param request: TagVodResourcesRequest
        @return: TagVodResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.tag_vod_resources_with_options(request, runtime)

    async def tag_vod_resources_async(
        self,
        request: vod_20170321_models.TagVodResourcesRequest,
    ) -> vod_20170321_models.TagVodResourcesResponse:
        """
        @summary 打标签
        
        @param request: TagVodResourcesRequest
        @return: TagVodResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.tag_vod_resources_with_options_async(request, runtime)

    def terminate_bucket_delete_task_with_options(
        self,
        request: vod_20170321_models.TerminateBucketDeleteTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.TerminateBucketDeleteTaskResponse:
        """
        @summary 中止bucket删除任务
        
        @param request: TerminateBucketDeleteTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TerminateBucketDeleteTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TerminateBucketDeleteTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.TerminateBucketDeleteTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def terminate_bucket_delete_task_with_options_async(
        self,
        request: vod_20170321_models.TerminateBucketDeleteTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.TerminateBucketDeleteTaskResponse:
        """
        @summary 中止bucket删除任务
        
        @param request: TerminateBucketDeleteTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TerminateBucketDeleteTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TerminateBucketDeleteTask',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.TerminateBucketDeleteTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def terminate_bucket_delete_task(
        self,
        request: vod_20170321_models.TerminateBucketDeleteTaskRequest,
    ) -> vod_20170321_models.TerminateBucketDeleteTaskResponse:
        """
        @summary 中止bucket删除任务
        
        @param request: TerminateBucketDeleteTaskRequest
        @return: TerminateBucketDeleteTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.terminate_bucket_delete_task_with_options(request, runtime)

    async def terminate_bucket_delete_task_async(
        self,
        request: vod_20170321_models.TerminateBucketDeleteTaskRequest,
    ) -> vod_20170321_models.TerminateBucketDeleteTaskResponse:
        """
        @summary 中止bucket删除任务
        
        @param request: TerminateBucketDeleteTaskRequest
        @return: TerminateBucketDeleteTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.terminate_bucket_delete_task_with_options_async(request, runtime)

    def un_tag_vod_resources_with_options(
        self,
        request: vod_20170321_models.UnTagVodResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UnTagVodResourcesResponse:
        """
        @summary 去除标签
        
        @param request: UnTagVodResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnTagVodResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.all):
            query['All'] = request.all
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_key):
            query['TagKey'] = request.tag_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnTagVodResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UnTagVodResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def un_tag_vod_resources_with_options_async(
        self,
        request: vod_20170321_models.UnTagVodResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UnTagVodResourcesResponse:
        """
        @summary 去除标签
        
        @param request: UnTagVodResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UnTagVodResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.all):
            query['All'] = request.all
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_key):
            query['TagKey'] = request.tag_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UnTagVodResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UnTagVodResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def un_tag_vod_resources(
        self,
        request: vod_20170321_models.UnTagVodResourcesRequest,
    ) -> vod_20170321_models.UnTagVodResourcesResponse:
        """
        @summary 去除标签
        
        @param request: UnTagVodResourcesRequest
        @return: UnTagVodResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.un_tag_vod_resources_with_options(request, runtime)

    async def un_tag_vod_resources_async(
        self,
        request: vod_20170321_models.UnTagVodResourcesRequest,
    ) -> vod_20170321_models.UnTagVodResourcesResponse:
        """
        @summary 去除标签
        
        @param request: UnTagVodResourcesRequest
        @return: UnTagVodResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.un_tag_vod_resources_with_options_async(request, runtime)

    def untag_resources_with_options(
        self,
        request: vod_20170321_models.UntagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UntagResourcesResponse:
        """
        @summary 资源去除用户标签
        
        @param request: UntagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UntagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.all):
            query['All'] = request.all
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_key):
            query['TagKey'] = request.tag_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UntagResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UntagResourcesResponse(),
            self.call_api(params, req, runtime)
        )

    async def untag_resources_with_options_async(
        self,
        request: vod_20170321_models.UntagResourcesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UntagResourcesResponse:
        """
        @summary 资源去除用户标签
        
        @param request: UntagResourcesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UntagResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.all):
            query['All'] = request.all
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_key):
            query['TagKey'] = request.tag_key
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UntagResources',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UntagResourcesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def untag_resources(
        self,
        request: vod_20170321_models.UntagResourcesRequest,
    ) -> vod_20170321_models.UntagResourcesResponse:
        """
        @summary 资源去除用户标签
        
        @param request: UntagResourcesRequest
        @return: UntagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.untag_resources_with_options(request, runtime)

    async def untag_resources_async(
        self,
        request: vod_20170321_models.UntagResourcesRequest,
    ) -> vod_20170321_models.UntagResourcesResponse:
        """
        @summary 资源去除用户标签
        
        @param request: UntagResourcesRequest
        @return: UntagResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.untag_resources_with_options_async(request, runtime)

    def update_aitemplate_with_options(
        self,
        request: vod_20170321_models.UpdateAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateAITemplateResponse:
        """
        @summary Modifies an AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        After you call the [AddAITemplate](https://help.aliyun.com/document_detail/102930.html) operation to add an AI template, you can call this operation to modify the AI template.
        
        @param request: UpdateAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_config):
            query['TemplateConfig'] = request.template_config
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.template_name):
            query['TemplateName'] = request.template_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateAITemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_aitemplate_with_options_async(
        self,
        request: vod_20170321_models.UpdateAITemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateAITemplateResponse:
        """
        @summary Modifies an AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        After you call the [AddAITemplate](https://help.aliyun.com/document_detail/102930.html) operation to add an AI template, you can call this operation to modify the AI template.
        
        @param request: UpdateAITemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAITemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_config):
            query['TemplateConfig'] = request.template_config
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.template_name):
            query['TemplateName'] = request.template_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateAITemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateAITemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_aitemplate(
        self,
        request: vod_20170321_models.UpdateAITemplateRequest,
    ) -> vod_20170321_models.UpdateAITemplateResponse:
        """
        @summary Modifies an AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        After you call the [AddAITemplate](https://help.aliyun.com/document_detail/102930.html) operation to add an AI template, you can call this operation to modify the AI template.
        
        @param request: UpdateAITemplateRequest
        @return: UpdateAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_aitemplate_with_options(request, runtime)

    async def update_aitemplate_async(
        self,
        request: vod_20170321_models.UpdateAITemplateRequest,
    ) -> vod_20170321_models.UpdateAITemplateResponse:
        """
        @summary Modifies an AI template.
        
        @description    Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
        After you call the [AddAITemplate](https://help.aliyun.com/document_detail/102930.html) operation to add an AI template, you can call this operation to modify the AI template.
        
        @param request: UpdateAITemplateRequest
        @return: UpdateAITemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_aitemplate_with_options_async(request, runtime)

    def update_app_info_with_options(
        self,
        request: vod_20170321_models.UpdateAppInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateAppInfoResponse:
        """
        @summary Updates the information about an application.
        
        @description ## QPS limit
        A single user can perform a maximum of 30 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation.
        
        @param request: UpdateAppInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAppInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateAppInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateAppInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_app_info_with_options_async(
        self,
        request: vod_20170321_models.UpdateAppInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateAppInfoResponse:
        """
        @summary Updates the information about an application.
        
        @description ## QPS limit
        A single user can perform a maximum of 30 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation.
        
        @param request: UpdateAppInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAppInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.app_name):
            query['AppName'] = request.app_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateAppInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateAppInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_app_info(
        self,
        request: vod_20170321_models.UpdateAppInfoRequest,
    ) -> vod_20170321_models.UpdateAppInfoResponse:
        """
        @summary Updates the information about an application.
        
        @description ## QPS limit
        A single user can perform a maximum of 30 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation.
        
        @param request: UpdateAppInfoRequest
        @return: UpdateAppInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_app_info_with_options(request, runtime)

    async def update_app_info_async(
        self,
        request: vod_20170321_models.UpdateAppInfoRequest,
    ) -> vod_20170321_models.UpdateAppInfoResponse:
        """
        @summary Updates the information about an application.
        
        @description ## QPS limit
        A single user can perform a maximum of 30 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation.
        
        @param request: UpdateAppInfoRequest
        @return: UpdateAppInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_app_info_with_options_async(request, runtime)

    def update_app_policy_with_options(
        self,
        request: vod_20170321_models.UpdateAppPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateAppPolicyResponse:
        """
        @summary 更新App策略
        
        @param request: UpdateAppPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAppPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy_name):
            query['PolicyName'] = request.policy_name
        if not UtilClient.is_unset(request.policy_value):
            query['PolicyValue'] = request.policy_value
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateAppPolicy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateAppPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_app_policy_with_options_async(
        self,
        request: vod_20170321_models.UpdateAppPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateAppPolicyResponse:
        """
        @summary 更新App策略
        
        @param request: UpdateAppPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAppPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.policy_name):
            query['PolicyName'] = request.policy_name
        if not UtilClient.is_unset(request.policy_value):
            query['PolicyValue'] = request.policy_value
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateAppPolicy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateAppPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_app_policy(
        self,
        request: vod_20170321_models.UpdateAppPolicyRequest,
    ) -> vod_20170321_models.UpdateAppPolicyResponse:
        """
        @summary 更新App策略
        
        @param request: UpdateAppPolicyRequest
        @return: UpdateAppPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_app_policy_with_options(request, runtime)

    async def update_app_policy_async(
        self,
        request: vod_20170321_models.UpdateAppPolicyRequest,
    ) -> vod_20170321_models.UpdateAppPolicyResponse:
        """
        @summary 更新App策略
        
        @param request: UpdateAppPolicyRequest
        @return: UpdateAppPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_app_policy_with_options_async(request, runtime)

    def update_attached_media_infos_with_options(
        self,
        request: vod_20170321_models.UpdateAttachedMediaInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateAttachedMediaInfosResponse:
        """
        @summary Modifies the information about multiple auxiliary media assets such as watermark images, subtitle files, and materials in a batch based on IDs. You can modify information such as the title, description, tags, and category.
        
        @description You can modify the information about up to 20 auxiliary media assets at a time.
        
        @param request: UpdateAttachedMediaInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAttachedMediaInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.update_content):
            query['UpdateContent'] = request.update_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateAttachedMediaInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateAttachedMediaInfosResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_attached_media_infos_with_options_async(
        self,
        request: vod_20170321_models.UpdateAttachedMediaInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateAttachedMediaInfosResponse:
        """
        @summary Modifies the information about multiple auxiliary media assets such as watermark images, subtitle files, and materials in a batch based on IDs. You can modify information such as the title, description, tags, and category.
        
        @description You can modify the information about up to 20 auxiliary media assets at a time.
        
        @param request: UpdateAttachedMediaInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAttachedMediaInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.update_content):
            query['UpdateContent'] = request.update_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateAttachedMediaInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateAttachedMediaInfosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_attached_media_infos(
        self,
        request: vod_20170321_models.UpdateAttachedMediaInfosRequest,
    ) -> vod_20170321_models.UpdateAttachedMediaInfosResponse:
        """
        @summary Modifies the information about multiple auxiliary media assets such as watermark images, subtitle files, and materials in a batch based on IDs. You can modify information such as the title, description, tags, and category.
        
        @description You can modify the information about up to 20 auxiliary media assets at a time.
        
        @param request: UpdateAttachedMediaInfosRequest
        @return: UpdateAttachedMediaInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_attached_media_infos_with_options(request, runtime)

    async def update_attached_media_infos_async(
        self,
        request: vod_20170321_models.UpdateAttachedMediaInfosRequest,
    ) -> vod_20170321_models.UpdateAttachedMediaInfosResponse:
        """
        @summary Modifies the information about multiple auxiliary media assets such as watermark images, subtitle files, and materials in a batch based on IDs. You can modify information such as the title, description, tags, and category.
        
        @description You can modify the information about up to 20 auxiliary media assets at a time.
        
        @param request: UpdateAttachedMediaInfosRequest
        @return: UpdateAttachedMediaInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_attached_media_infos_with_options_async(request, runtime)

    def update_category_with_options(
        self,
        request: vod_20170321_models.UpdateCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateCategoryResponse:
        """
        @summary Modifies a video category.
        
        @description After you create a category, you can call this operation to modify the name of the category. If you have classified specific media resources to this category, the category names that are labeled on the media resources are automatically updated.
        
        @param request: UpdateCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        if not UtilClient.is_unset(request.cate_name):
            query['CateName'] = request.cate_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateCategory',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateCategoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_category_with_options_async(
        self,
        request: vod_20170321_models.UpdateCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateCategoryResponse:
        """
        @summary Modifies a video category.
        
        @description After you create a category, you can call this operation to modify the name of the category. If you have classified specific media resources to this category, the category names that are labeled on the media resources are automatically updated.
        
        @param request: UpdateCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        if not UtilClient.is_unset(request.cate_name):
            query['CateName'] = request.cate_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateCategory',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateCategoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_category(
        self,
        request: vod_20170321_models.UpdateCategoryRequest,
    ) -> vod_20170321_models.UpdateCategoryResponse:
        """
        @summary Modifies a video category.
        
        @description After you create a category, you can call this operation to modify the name of the category. If you have classified specific media resources to this category, the category names that are labeled on the media resources are automatically updated.
        
        @param request: UpdateCategoryRequest
        @return: UpdateCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_category_with_options(request, runtime)

    async def update_category_async(
        self,
        request: vod_20170321_models.UpdateCategoryRequest,
    ) -> vod_20170321_models.UpdateCategoryResponse:
        """
        @summary Modifies a video category.
        
        @description After you create a category, you can call this operation to modify the name of the category. If you have classified specific media resources to this category, the category names that are labeled on the media resources are automatically updated.
        
        @param request: UpdateCategoryRequest
        @return: UpdateCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_category_with_options_async(request, runtime)

    def update_custom_template_and_group_console_with_options(
        self,
        request: vod_20170321_models.UpdateCustomTemplateAndGroupConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateCustomTemplateAndGroupConsoleResponse:
        """
        @summary 更新模版组
        
        @param request: UpdateCustomTemplateAndGroupConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateCustomTemplateAndGroupConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.configs):
            query['Configs'] = request.configs
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateCustomTemplateAndGroupConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateCustomTemplateAndGroupConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_custom_template_and_group_console_with_options_async(
        self,
        request: vod_20170321_models.UpdateCustomTemplateAndGroupConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateCustomTemplateAndGroupConsoleResponse:
        """
        @summary 更新模版组
        
        @param request: UpdateCustomTemplateAndGroupConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateCustomTemplateAndGroupConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.configs):
            query['Configs'] = request.configs
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateCustomTemplateAndGroupConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateCustomTemplateAndGroupConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_custom_template_and_group_console(
        self,
        request: vod_20170321_models.UpdateCustomTemplateAndGroupConsoleRequest,
    ) -> vod_20170321_models.UpdateCustomTemplateAndGroupConsoleResponse:
        """
        @summary 更新模版组
        
        @param request: UpdateCustomTemplateAndGroupConsoleRequest
        @return: UpdateCustomTemplateAndGroupConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_custom_template_and_group_console_with_options(request, runtime)

    async def update_custom_template_and_group_console_async(
        self,
        request: vod_20170321_models.UpdateCustomTemplateAndGroupConsoleRequest,
    ) -> vod_20170321_models.UpdateCustomTemplateAndGroupConsoleResponse:
        """
        @summary 更新模版组
        
        @param request: UpdateCustomTemplateAndGroupConsoleRequest
        @return: UpdateCustomTemplateAndGroupConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_custom_template_and_group_console_with_options_async(request, runtime)

    def update_dnadbwith_options(
        self,
        request: vod_20170321_models.UpdateDNADBRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateDNADBResponse:
        """
        @summary 更新视频DNADB
        
        @param request: UpdateDNADBRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateDNADBResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dbdescription):
            query['DBDescription'] = request.dbdescription
        if not UtilClient.is_unset(request.dbid):
            query['DBId'] = request.dbid
        if not UtilClient.is_unset(request.dbname):
            query['DBName'] = request.dbname
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateDNADB',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateDNADBResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_dnadbwith_options_async(
        self,
        request: vod_20170321_models.UpdateDNADBRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateDNADBResponse:
        """
        @summary 更新视频DNADB
        
        @param request: UpdateDNADBRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateDNADBResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dbdescription):
            query['DBDescription'] = request.dbdescription
        if not UtilClient.is_unset(request.dbid):
            query['DBId'] = request.dbid
        if not UtilClient.is_unset(request.dbname):
            query['DBName'] = request.dbname
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateDNADB',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateDNADBResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_dnadb(
        self,
        request: vod_20170321_models.UpdateDNADBRequest,
    ) -> vod_20170321_models.UpdateDNADBResponse:
        """
        @summary 更新视频DNADB
        
        @param request: UpdateDNADBRequest
        @return: UpdateDNADBResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_dnadbwith_options(request, runtime)

    async def update_dnadb_async(
        self,
        request: vod_20170321_models.UpdateDNADBRequest,
    ) -> vod_20170321_models.UpdateDNADBResponse:
        """
        @summary 更新视频DNADB
        
        @param request: UpdateDNADBRequest
        @return: UpdateDNADBResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_dnadbwith_options_async(request, runtime)

    def update_editing_project_with_options(
        self,
        request: vod_20170321_models.UpdateEditingProjectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateEditingProjectResponse:
        """
        @summary Modifies an online editing project.
        
        @param request: UpdateEditingProjectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateEditingProjectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cover_url):
            query['CoverURL'] = request.cover_url
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.timeline):
            query['Timeline'] = request.timeline
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateEditingProject',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateEditingProjectResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_editing_project_with_options_async(
        self,
        request: vod_20170321_models.UpdateEditingProjectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateEditingProjectResponse:
        """
        @summary Modifies an online editing project.
        
        @param request: UpdateEditingProjectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateEditingProjectResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cover_url):
            query['CoverURL'] = request.cover_url
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.owner_account):
            query['OwnerAccount'] = request.owner_account
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.project_id):
            query['ProjectId'] = request.project_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.timeline):
            query['Timeline'] = request.timeline
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateEditingProject',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateEditingProjectResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_editing_project(
        self,
        request: vod_20170321_models.UpdateEditingProjectRequest,
    ) -> vod_20170321_models.UpdateEditingProjectResponse:
        """
        @summary Modifies an online editing project.
        
        @param request: UpdateEditingProjectRequest
        @return: UpdateEditingProjectResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_editing_project_with_options(request, runtime)

    async def update_editing_project_async(
        self,
        request: vod_20170321_models.UpdateEditingProjectRequest,
    ) -> vod_20170321_models.UpdateEditingProjectResponse:
        """
        @summary Modifies an online editing project.
        
        @param request: UpdateEditingProjectRequest
        @return: UpdateEditingProjectResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_editing_project_with_options_async(request, runtime)

    def update_image_infos_with_options(
        self,
        request: vod_20170321_models.UpdateImageInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateImageInfosResponse:
        """
        @summary Modifies the information about one or more images at a time.
        
        @description    You can call this operation to modify information such as the title, tags, description, and category about images based on image IDs. You must pass in the parameters that you want to modify. Otherwise, parameter configurations are not overwritten.
        You can modify the information about up to 20 images at a time.
        
        @param request: UpdateImageInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateImageInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.update_content):
            query['UpdateContent'] = request.update_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateImageInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateImageInfosResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_image_infos_with_options_async(
        self,
        request: vod_20170321_models.UpdateImageInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateImageInfosResponse:
        """
        @summary Modifies the information about one or more images at a time.
        
        @description    You can call this operation to modify information such as the title, tags, description, and category about images based on image IDs. You must pass in the parameters that you want to modify. Otherwise, parameter configurations are not overwritten.
        You can modify the information about up to 20 images at a time.
        
        @param request: UpdateImageInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateImageInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.update_content):
            query['UpdateContent'] = request.update_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateImageInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateImageInfosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_image_infos(
        self,
        request: vod_20170321_models.UpdateImageInfosRequest,
    ) -> vod_20170321_models.UpdateImageInfosResponse:
        """
        @summary Modifies the information about one or more images at a time.
        
        @description    You can call this operation to modify information such as the title, tags, description, and category about images based on image IDs. You must pass in the parameters that you want to modify. Otherwise, parameter configurations are not overwritten.
        You can modify the information about up to 20 images at a time.
        
        @param request: UpdateImageInfosRequest
        @return: UpdateImageInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_image_infos_with_options(request, runtime)

    async def update_image_infos_async(
        self,
        request: vod_20170321_models.UpdateImageInfosRequest,
    ) -> vod_20170321_models.UpdateImageInfosResponse:
        """
        @summary Modifies the information about one or more images at a time.
        
        @description    You can call this operation to modify information such as the title, tags, description, and category about images based on image IDs. You must pass in the parameters that you want to modify. Otherwise, parameter configurations are not overwritten.
        You can modify the information about up to 20 images at a time.
        
        @param request: UpdateImageInfosRequest
        @return: UpdateImageInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_image_infos_with_options_async(request, runtime)

    def update_intelligent_strategy_with_options(
        self,
        request: vod_20170321_models.UpdateIntelligentStrategyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateIntelligentStrategyResponse:
        """
        @summary 修改智能策略信息
        
        @param request: UpdateIntelligentStrategyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIntelligentStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.conditions):
            query['Conditions'] = request.conditions
        if not UtilClient.is_unset(request.execute_params):
            query['ExecuteParams'] = request.execute_params
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.state):
            query['State'] = request.state
        if not UtilClient.is_unset(request.strategy_id):
            query['StrategyId'] = request.strategy_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateIntelligentStrategy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateIntelligentStrategyResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_intelligent_strategy_with_options_async(
        self,
        request: vod_20170321_models.UpdateIntelligentStrategyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateIntelligentStrategyResponse:
        """
        @summary 修改智能策略信息
        
        @param request: UpdateIntelligentStrategyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIntelligentStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.conditions):
            query['Conditions'] = request.conditions
        if not UtilClient.is_unset(request.execute_params):
            query['ExecuteParams'] = request.execute_params
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.priority):
            query['Priority'] = request.priority
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.state):
            query['State'] = request.state
        if not UtilClient.is_unset(request.strategy_id):
            query['StrategyId'] = request.strategy_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateIntelligentStrategy',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateIntelligentStrategyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_intelligent_strategy(
        self,
        request: vod_20170321_models.UpdateIntelligentStrategyRequest,
    ) -> vod_20170321_models.UpdateIntelligentStrategyResponse:
        """
        @summary 修改智能策略信息
        
        @param request: UpdateIntelligentStrategyRequest
        @return: UpdateIntelligentStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_intelligent_strategy_with_options(request, runtime)

    async def update_intelligent_strategy_async(
        self,
        request: vod_20170321_models.UpdateIntelligentStrategyRequest,
    ) -> vod_20170321_models.UpdateIntelligentStrategyResponse:
        """
        @summary 修改智能策略信息
        
        @param request: UpdateIntelligentStrategyRequest
        @return: UpdateIntelligentStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_intelligent_strategy_with_options_async(request, runtime)

    def update_media_lifecycle_rule_with_options(
        self,
        request: vod_20170321_models.UpdateMediaLifecycleRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateMediaLifecycleRuleResponse:
        """
        @summary 更新媒资生命周期规则
        
        @param request: UpdateMediaLifecycleRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMediaLifecycleRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.update_content):
            query['UpdateContent'] = request.update_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateMediaLifecycleRule',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateMediaLifecycleRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_media_lifecycle_rule_with_options_async(
        self,
        request: vod_20170321_models.UpdateMediaLifecycleRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateMediaLifecycleRuleResponse:
        """
        @summary 更新媒资生命周期规则
        
        @param request: UpdateMediaLifecycleRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMediaLifecycleRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.update_content):
            query['UpdateContent'] = request.update_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateMediaLifecycleRule',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateMediaLifecycleRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_media_lifecycle_rule(
        self,
        request: vod_20170321_models.UpdateMediaLifecycleRuleRequest,
    ) -> vod_20170321_models.UpdateMediaLifecycleRuleResponse:
        """
        @summary 更新媒资生命周期规则
        
        @param request: UpdateMediaLifecycleRuleRequest
        @return: UpdateMediaLifecycleRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_media_lifecycle_rule_with_options(request, runtime)

    async def update_media_lifecycle_rule_async(
        self,
        request: vod_20170321_models.UpdateMediaLifecycleRuleRequest,
    ) -> vod_20170321_models.UpdateMediaLifecycleRuleResponse:
        """
        @summary 更新媒资生命周期规则
        
        @param request: UpdateMediaLifecycleRuleRequest
        @return: UpdateMediaLifecycleRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_media_lifecycle_rule_with_options_async(request, runtime)

    def update_media_storage_class_with_options(
        self,
        request: vod_20170321_models.UpdateMediaStorageClassRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateMediaStorageClassResponse:
        """
        @summary Modifies the storage classes of media assets.
        
        @description    This operation is an asynchronous operation. You can call this operation to modify the storage classes of media assets. After the storage class is modified, a callback notification is sent.
        If the storage class of the media asset is Archive or Cold Archive and you call this operation to modify the storage class of the media asset, the media asset is automatically restored before the storage class is modified. You do not need to call the RestoreMedia operation to restore the media asset. You must specify the restoration priority for Cold Archive objects. Default configuration: RestoreTier=Standard.
        Media assets whose storage classes are being modified cannot be used or processed.
        Non-Standard objects have minimum storage durations. If an object is stored for less than the minimum storage duration, the storage class of the object cannot be changed. The following content describes the minimum storage durations for objects in different storage classes: IA or IA storage for source files: 30 days, Archive or Archive storage for source files: 60 days, Cold Archive or Cold Archive for source files: 180 days.
        
        @param request: UpdateMediaStorageClassRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMediaStorageClassResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allow_update_without_time_limit):
            query['AllowUpdateWithoutTimeLimit'] = request.allow_update_without_time_limit
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        if not UtilClient.is_unset(request.restore_tier):
            query['RestoreTier'] = request.restore_tier
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.storage_class):
            query['StorageClass'] = request.storage_class
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateMediaStorageClass',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateMediaStorageClassResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_media_storage_class_with_options_async(
        self,
        request: vod_20170321_models.UpdateMediaStorageClassRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateMediaStorageClassResponse:
        """
        @summary Modifies the storage classes of media assets.
        
        @description    This operation is an asynchronous operation. You can call this operation to modify the storage classes of media assets. After the storage class is modified, a callback notification is sent.
        If the storage class of the media asset is Archive or Cold Archive and you call this operation to modify the storage class of the media asset, the media asset is automatically restored before the storage class is modified. You do not need to call the RestoreMedia operation to restore the media asset. You must specify the restoration priority for Cold Archive objects. Default configuration: RestoreTier=Standard.
        Media assets whose storage classes are being modified cannot be used or processed.
        Non-Standard objects have minimum storage durations. If an object is stored for less than the minimum storage duration, the storage class of the object cannot be changed. The following content describes the minimum storage durations for objects in different storage classes: IA or IA storage for source files: 30 days, Archive or Archive storage for source files: 60 days, Cold Archive or Cold Archive for source files: 180 days.
        
        @param request: UpdateMediaStorageClassRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMediaStorageClassResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.allow_update_without_time_limit):
            query['AllowUpdateWithoutTimeLimit'] = request.allow_update_without_time_limit
        if not UtilClient.is_unset(request.media_ids):
            query['MediaIds'] = request.media_ids
        if not UtilClient.is_unset(request.restore_tier):
            query['RestoreTier'] = request.restore_tier
        if not UtilClient.is_unset(request.scope):
            query['Scope'] = request.scope
        if not UtilClient.is_unset(request.storage_class):
            query['StorageClass'] = request.storage_class
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateMediaStorageClass',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateMediaStorageClassResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_media_storage_class(
        self,
        request: vod_20170321_models.UpdateMediaStorageClassRequest,
    ) -> vod_20170321_models.UpdateMediaStorageClassResponse:
        """
        @summary Modifies the storage classes of media assets.
        
        @description    This operation is an asynchronous operation. You can call this operation to modify the storage classes of media assets. After the storage class is modified, a callback notification is sent.
        If the storage class of the media asset is Archive or Cold Archive and you call this operation to modify the storage class of the media asset, the media asset is automatically restored before the storage class is modified. You do not need to call the RestoreMedia operation to restore the media asset. You must specify the restoration priority for Cold Archive objects. Default configuration: RestoreTier=Standard.
        Media assets whose storage classes are being modified cannot be used or processed.
        Non-Standard objects have minimum storage durations. If an object is stored for less than the minimum storage duration, the storage class of the object cannot be changed. The following content describes the minimum storage durations for objects in different storage classes: IA or IA storage for source files: 30 days, Archive or Archive storage for source files: 60 days, Cold Archive or Cold Archive for source files: 180 days.
        
        @param request: UpdateMediaStorageClassRequest
        @return: UpdateMediaStorageClassResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_media_storage_class_with_options(request, runtime)

    async def update_media_storage_class_async(
        self,
        request: vod_20170321_models.UpdateMediaStorageClassRequest,
    ) -> vod_20170321_models.UpdateMediaStorageClassResponse:
        """
        @summary Modifies the storage classes of media assets.
        
        @description    This operation is an asynchronous operation. You can call this operation to modify the storage classes of media assets. After the storage class is modified, a callback notification is sent.
        If the storage class of the media asset is Archive or Cold Archive and you call this operation to modify the storage class of the media asset, the media asset is automatically restored before the storage class is modified. You do not need to call the RestoreMedia operation to restore the media asset. You must specify the restoration priority for Cold Archive objects. Default configuration: RestoreTier=Standard.
        Media assets whose storage classes are being modified cannot be used or processed.
        Non-Standard objects have minimum storage durations. If an object is stored for less than the minimum storage duration, the storage class of the object cannot be changed. The following content describes the minimum storage durations for objects in different storage classes: IA or IA storage for source files: 30 days, Archive or Archive storage for source files: 60 days, Cold Archive or Cold Archive for source files: 180 days.
        
        @param request: UpdateMediaStorageClassRequest
        @return: UpdateMediaStorageClassResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_media_storage_class_with_options_async(request, runtime)

    def update_stream_info_with_options(
        self,
        request: vod_20170321_models.UpdateStreamInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateStreamInfoResponse:
        """
        @summary 更新视频流清晰度与HDR信息
        
        @param request: UpdateStreamInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateStreamInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateStreamInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateStreamInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_stream_info_with_options_async(
        self,
        request: vod_20170321_models.UpdateStreamInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateStreamInfoResponse:
        """
        @summary 更新视频流清晰度与HDR信息
        
        @param request: UpdateStreamInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateStreamInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateStreamInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateStreamInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_stream_info(
        self,
        request: vod_20170321_models.UpdateStreamInfoRequest,
    ) -> vod_20170321_models.UpdateStreamInfoResponse:
        """
        @summary 更新视频流清晰度与HDR信息
        
        @param request: UpdateStreamInfoRequest
        @return: UpdateStreamInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_stream_info_with_options(request, runtime)

    async def update_stream_info_async(
        self,
        request: vod_20170321_models.UpdateStreamInfoRequest,
    ) -> vod_20170321_models.UpdateStreamInfoResponse:
        """
        @summary 更新视频流清晰度与HDR信息
        
        @param request: UpdateStreamInfoRequest
        @return: UpdateStreamInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_stream_info_with_options_async(request, runtime)

    def update_transcode_template_group_with_options(
        self,
        request: vod_20170321_models.UpdateTranscodeTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateTranscodeTemplateGroupResponse:
        """
        @summary Modifies the configurations of a transcoding template group or configurations of transcoding templates in the transcoding template group.
        
        @description For security purposes, you cannot add, modify, or delete transcoding templates in a transcoding template group that is locked. You can call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation to query the configurations of a transcoding template group, check whether the transcoding template group is locked by using the response parameter Locked, and unlock the transcoding template group before you perform operations such as add, modify, and delete transcoding templates.
        
        @param request: UpdateTranscodeTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTranscodeTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.locked):
            query['Locked'] = request.locked
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.transcode_template_group_id):
            query['TranscodeTemplateGroupId'] = request.transcode_template_group_id
        if not UtilClient.is_unset(request.transcode_template_list):
            query['TranscodeTemplateList'] = request.transcode_template_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTranscodeTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateTranscodeTemplateGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_transcode_template_group_with_options_async(
        self,
        request: vod_20170321_models.UpdateTranscodeTemplateGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateTranscodeTemplateGroupResponse:
        """
        @summary Modifies the configurations of a transcoding template group or configurations of transcoding templates in the transcoding template group.
        
        @description For security purposes, you cannot add, modify, or delete transcoding templates in a transcoding template group that is locked. You can call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation to query the configurations of a transcoding template group, check whether the transcoding template group is locked by using the response parameter Locked, and unlock the transcoding template group before you perform operations such as add, modify, and delete transcoding templates.
        
        @param request: UpdateTranscodeTemplateGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTranscodeTemplateGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.locked):
            query['Locked'] = request.locked
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.transcode_template_group_id):
            query['TranscodeTemplateGroupId'] = request.transcode_template_group_id
        if not UtilClient.is_unset(request.transcode_template_list):
            query['TranscodeTemplateList'] = request.transcode_template_list
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTranscodeTemplateGroup',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateTranscodeTemplateGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_transcode_template_group(
        self,
        request: vod_20170321_models.UpdateTranscodeTemplateGroupRequest,
    ) -> vod_20170321_models.UpdateTranscodeTemplateGroupResponse:
        """
        @summary Modifies the configurations of a transcoding template group or configurations of transcoding templates in the transcoding template group.
        
        @description For security purposes, you cannot add, modify, or delete transcoding templates in a transcoding template group that is locked. You can call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation to query the configurations of a transcoding template group, check whether the transcoding template group is locked by using the response parameter Locked, and unlock the transcoding template group before you perform operations such as add, modify, and delete transcoding templates.
        
        @param request: UpdateTranscodeTemplateGroupRequest
        @return: UpdateTranscodeTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_transcode_template_group_with_options(request, runtime)

    async def update_transcode_template_group_async(
        self,
        request: vod_20170321_models.UpdateTranscodeTemplateGroupRequest,
    ) -> vod_20170321_models.UpdateTranscodeTemplateGroupResponse:
        """
        @summary Modifies the configurations of a transcoding template group or configurations of transcoding templates in the transcoding template group.
        
        @description For security purposes, you cannot add, modify, or delete transcoding templates in a transcoding template group that is locked. You can call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation to query the configurations of a transcoding template group, check whether the transcoding template group is locked by using the response parameter Locked, and unlock the transcoding template group before you perform operations such as add, modify, and delete transcoding templates.
        
        @param request: UpdateTranscodeTemplateGroupRequest
        @return: UpdateTranscodeTemplateGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_transcode_template_group_with_options_async(request, runtime)

    def update_video_info_with_options(
        self,
        request: vod_20170321_models.UpdateVideoInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateVideoInfoResponse:
        """
        @summary Modifies the information about an audio or video file.
        
        @description ### [](#)
        You can call this operation to modify information such as the title, tags, and description about audio and video files based on audio or video IDs. You must pass in the parameters that you want to modify. Otherwise, parameter configurations are not overwritten.
        ### [](#qps-)Queries per second (QPS) limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: UpdateVideoInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVideoInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        if not UtilClient.is_unset(request.cover_url):
            query['CoverURL'] = request.cover_url
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVideoInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateVideoInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_video_info_with_options_async(
        self,
        request: vod_20170321_models.UpdateVideoInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateVideoInfoResponse:
        """
        @summary Modifies the information about an audio or video file.
        
        @description ### [](#)
        You can call this operation to modify information such as the title, tags, and description about audio and video files based on audio or video IDs. You must pass in the parameters that you want to modify. Otherwise, parameter configurations are not overwritten.
        ### [](#qps-)Queries per second (QPS) limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: UpdateVideoInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVideoInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cate_id):
            query['CateId'] = request.cate_id
        if not UtilClient.is_unset(request.cover_url):
            query['CoverURL'] = request.cover_url
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.title):
            query['Title'] = request.title
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.video_id):
            query['VideoId'] = request.video_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVideoInfo',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateVideoInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_video_info(
        self,
        request: vod_20170321_models.UpdateVideoInfoRequest,
    ) -> vod_20170321_models.UpdateVideoInfoResponse:
        """
        @summary Modifies the information about an audio or video file.
        
        @description ### [](#)
        You can call this operation to modify information such as the title, tags, and description about audio and video files based on audio or video IDs. You must pass in the parameters that you want to modify. Otherwise, parameter configurations are not overwritten.
        ### [](#qps-)Queries per second (QPS) limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: UpdateVideoInfoRequest
        @return: UpdateVideoInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_video_info_with_options(request, runtime)

    async def update_video_info_async(
        self,
        request: vod_20170321_models.UpdateVideoInfoRequest,
    ) -> vod_20170321_models.UpdateVideoInfoResponse:
        """
        @summary Modifies the information about an audio or video file.
        
        @description ### [](#)
        You can call this operation to modify information such as the title, tags, and description about audio and video files based on audio or video IDs. You must pass in the parameters that you want to modify. Otherwise, parameter configurations are not overwritten.
        ### [](#qps-)Queries per second (QPS) limit
        You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations](https://help.aliyun.com/document_detail/342790.html).
        
        @param request: UpdateVideoInfoRequest
        @return: UpdateVideoInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_video_info_with_options_async(request, runtime)

    def update_video_infos_with_options(
        self,
        request: vod_20170321_models.UpdateVideoInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateVideoInfosResponse:
        """
        @summary Modifies the information about multiple videos at a time.
        
        @description The specific parameter of a video is updated only when a new value is passed in the parameter.
        
        @param request: UpdateVideoInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVideoInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.update_content):
            query['UpdateContent'] = request.update_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVideoInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateVideoInfosResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_video_infos_with_options_async(
        self,
        request: vod_20170321_models.UpdateVideoInfosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateVideoInfosResponse:
        """
        @summary Modifies the information about multiple videos at a time.
        
        @description The specific parameter of a video is updated only when a new value is passed in the parameter.
        
        @param request: UpdateVideoInfosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVideoInfosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.update_content):
            query['UpdateContent'] = request.update_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVideoInfos',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateVideoInfosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_video_infos(
        self,
        request: vod_20170321_models.UpdateVideoInfosRequest,
    ) -> vod_20170321_models.UpdateVideoInfosResponse:
        """
        @summary Modifies the information about multiple videos at a time.
        
        @description The specific parameter of a video is updated only when a new value is passed in the parameter.
        
        @param request: UpdateVideoInfosRequest
        @return: UpdateVideoInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_video_infos_with_options(request, runtime)

    async def update_video_infos_async(
        self,
        request: vod_20170321_models.UpdateVideoInfosRequest,
    ) -> vod_20170321_models.UpdateVideoInfosResponse:
        """
        @summary Modifies the information about multiple videos at a time.
        
        @description The specific parameter of a video is updated only when a new value is passed in the parameter.
        
        @param request: UpdateVideoInfosRequest
        @return: UpdateVideoInfosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_video_infos_with_options_async(request, runtime)

    def update_vod_domain_with_options(
        self,
        request: vod_20170321_models.UpdateVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateVodDomainResponse:
        """
        @summary Modifies a specific accelerated domain name.
        
        @description UpdateVodDomain
        
        @param request: UpdateVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.sources):
            query['Sources'] = request.sources
        if not UtilClient.is_unset(request.top_level_domain):
            query['TopLevelDomain'] = request.top_level_domain
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateVodDomainResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_vod_domain_with_options_async(
        self,
        request: vod_20170321_models.UpdateVodDomainRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateVodDomainResponse:
        """
        @summary Modifies a specific accelerated domain name.
        
        @description UpdateVodDomain
        
        @param request: UpdateVodDomainRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVodDomainResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.security_token):
            query['SecurityToken'] = request.security_token
        if not UtilClient.is_unset(request.sources):
            query['Sources'] = request.sources
        if not UtilClient.is_unset(request.top_level_domain):
            query['TopLevelDomain'] = request.top_level_domain
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVodDomain',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateVodDomainResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_vod_domain(
        self,
        request: vod_20170321_models.UpdateVodDomainRequest,
    ) -> vod_20170321_models.UpdateVodDomainResponse:
        """
        @summary Modifies a specific accelerated domain name.
        
        @description UpdateVodDomain
        
        @param request: UpdateVodDomainRequest
        @return: UpdateVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_vod_domain_with_options(request, runtime)

    async def update_vod_domain_async(
        self,
        request: vod_20170321_models.UpdateVodDomainRequest,
    ) -> vod_20170321_models.UpdateVodDomainResponse:
        """
        @summary Modifies a specific accelerated domain name.
        
        @description UpdateVodDomain
        
        @param request: UpdateVodDomainRequest
        @return: UpdateVodDomainResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_vod_domain_with_options_async(request, runtime)

    def update_vod_template_with_options(
        self,
        request: vod_20170321_models.UpdateVodTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateVodTemplateResponse:
        """
        @summary Modifies a snapshot template.
        
        @param request: UpdateVodTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVodTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.template_config):
            query['TemplateConfig'] = request.template_config
        if not UtilClient.is_unset(request.vod_template_id):
            query['VodTemplateId'] = request.vod_template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVodTemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateVodTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_vod_template_with_options_async(
        self,
        request: vod_20170321_models.UpdateVodTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateVodTemplateResponse:
        """
        @summary Modifies a snapshot template.
        
        @param request: UpdateVodTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateVodTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.template_config):
            query['TemplateConfig'] = request.template_config
        if not UtilClient.is_unset(request.vod_template_id):
            query['VodTemplateId'] = request.vod_template_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateVodTemplate',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateVodTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_vod_template(
        self,
        request: vod_20170321_models.UpdateVodTemplateRequest,
    ) -> vod_20170321_models.UpdateVodTemplateResponse:
        """
        @summary Modifies a snapshot template.
        
        @param request: UpdateVodTemplateRequest
        @return: UpdateVodTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_vod_template_with_options(request, runtime)

    async def update_vod_template_async(
        self,
        request: vod_20170321_models.UpdateVodTemplateRequest,
    ) -> vod_20170321_models.UpdateVodTemplateResponse:
        """
        @summary Modifies a snapshot template.
        
        @param request: UpdateVodTemplateRequest
        @return: UpdateVodTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_vod_template_with_options_async(request, runtime)

    def update_watermark_with_options(
        self,
        request: vod_20170321_models.UpdateWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateWatermarkResponse:
        """
        @summary Modifies the name and configurations of a watermark template after you create a watermark template.
        
        @description    You can modify the name and configurations of the watermark template after you call the [AddWatermark](~~AddWatermark~~) operation to create a watermark template.
        You cannot call this operation to change the image in an image watermark template.
        
        @param request: UpdateWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.watermark_config):
            query['WatermarkConfig'] = request.watermark_config
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateWatermark',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateWatermarkResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_watermark_with_options_async(
        self,
        request: vod_20170321_models.UpdateWatermarkRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateWatermarkResponse:
        """
        @summary Modifies the name and configurations of a watermark template after you create a watermark template.
        
        @description    You can modify the name and configurations of the watermark template after you call the [AddWatermark](~~AddWatermark~~) operation to create a watermark template.
        You cannot call this operation to change the image in an image watermark template.
        
        @param request: UpdateWatermarkRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateWatermarkResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.watermark_config):
            query['WatermarkConfig'] = request.watermark_config
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateWatermark',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateWatermarkResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_watermark(
        self,
        request: vod_20170321_models.UpdateWatermarkRequest,
    ) -> vod_20170321_models.UpdateWatermarkResponse:
        """
        @summary Modifies the name and configurations of a watermark template after you create a watermark template.
        
        @description    You can modify the name and configurations of the watermark template after you call the [AddWatermark](~~AddWatermark~~) operation to create a watermark template.
        You cannot call this operation to change the image in an image watermark template.
        
        @param request: UpdateWatermarkRequest
        @return: UpdateWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_watermark_with_options(request, runtime)

    async def update_watermark_async(
        self,
        request: vod_20170321_models.UpdateWatermarkRequest,
    ) -> vod_20170321_models.UpdateWatermarkResponse:
        """
        @summary Modifies the name and configurations of a watermark template after you create a watermark template.
        
        @description    You can modify the name and configurations of the watermark template after you call the [AddWatermark](~~AddWatermark~~) operation to create a watermark template.
        You cannot call this operation to change the image in an image watermark template.
        
        @param request: UpdateWatermarkRequest
        @return: UpdateWatermarkResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_watermark_with_options_async(request, runtime)

    def update_watermark_console_with_options(
        self,
        request: vod_20170321_models.UpdateWatermarkConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateWatermarkConsoleResponse:
        """
        @summary 更新水印
        
        @param request: UpdateWatermarkConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateWatermarkConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bucket):
            query['Bucket'] = request.bucket
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.horizontal_offet):
            query['HorizontalOffet'] = request.horizontal_offet
        if not UtilClient.is_unset(request.horizontal_offset):
            query['HorizontalOffset'] = request.horizontal_offset
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.object):
            query['Object'] = request.object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.position):
            query['Position'] = request.position
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.screen_mode):
            query['ScreenMode'] = request.screen_mode
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.vertical_offset):
            query['VerticalOffset'] = request.vertical_offset
        if not UtilClient.is_unset(request.video_height):
            query['VideoHeight'] = request.video_height
        if not UtilClient.is_unset(request.video_width):
            query['VideoWidth'] = request.video_width
        if not UtilClient.is_unset(request.watermark_config):
            query['WatermarkConfig'] = request.watermark_config
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateWatermarkConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateWatermarkConsoleResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_watermark_console_with_options_async(
        self,
        request: vod_20170321_models.UpdateWatermarkConsoleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateWatermarkConsoleResponse:
        """
        @summary 更新水印
        
        @param request: UpdateWatermarkConsoleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateWatermarkConsoleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bucket):
            query['Bucket'] = request.bucket
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.height):
            query['Height'] = request.height
        if not UtilClient.is_unset(request.horizontal_offet):
            query['HorizontalOffet'] = request.horizontal_offet
        if not UtilClient.is_unset(request.horizontal_offset):
            query['HorizontalOffset'] = request.horizontal_offset
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.object):
            query['Object'] = request.object
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.position):
            query['Position'] = request.position
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.screen_mode):
            query['ScreenMode'] = request.screen_mode
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        if not UtilClient.is_unset(request.vertical_offset):
            query['VerticalOffset'] = request.vertical_offset
        if not UtilClient.is_unset(request.video_height):
            query['VideoHeight'] = request.video_height
        if not UtilClient.is_unset(request.video_width):
            query['VideoWidth'] = request.video_width
        if not UtilClient.is_unset(request.watermark_config):
            query['WatermarkConfig'] = request.watermark_config
        if not UtilClient.is_unset(request.watermark_id):
            query['WatermarkId'] = request.watermark_id
        if not UtilClient.is_unset(request.width):
            query['Width'] = request.width
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateWatermarkConsole',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateWatermarkConsoleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_watermark_console(
        self,
        request: vod_20170321_models.UpdateWatermarkConsoleRequest,
    ) -> vod_20170321_models.UpdateWatermarkConsoleResponse:
        """
        @summary 更新水印
        
        @param request: UpdateWatermarkConsoleRequest
        @return: UpdateWatermarkConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_watermark_console_with_options(request, runtime)

    async def update_watermark_console_async(
        self,
        request: vod_20170321_models.UpdateWatermarkConsoleRequest,
    ) -> vod_20170321_models.UpdateWatermarkConsoleResponse:
        """
        @summary 更新水印
        
        @param request: UpdateWatermarkConsoleRequest
        @return: UpdateWatermarkConsoleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_watermark_console_with_options_async(request, runtime)

    def update_workflow_with_options(
        self,
        request: vod_20170321_models.UpdateWorkflowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateWorkflowResponse:
        """
        @summary 更新工作流
        
        @param request: UpdateWorkflowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateWorkflowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_list):
            query['ActionList'] = request.action_list
        if not UtilClient.is_unset(request.callback_config):
            query['CallbackConfig'] = request.callback_config
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.state):
            query['State'] = request.state
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateWorkflow',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateWorkflowResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_workflow_with_options_async(
        self,
        request: vod_20170321_models.UpdateWorkflowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UpdateWorkflowResponse:
        """
        @summary 更新工作流
        
        @param request: UpdateWorkflowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateWorkflowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.action_list):
            query['ActionList'] = request.action_list
        if not UtilClient.is_unset(request.callback_config):
            query['CallbackConfig'] = request.callback_config
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_owner_account):
            query['ResourceOwnerAccount'] = request.resource_owner_account
        if not UtilClient.is_unset(request.resource_owner_id):
            query['ResourceOwnerId'] = request.resource_owner_id
        if not UtilClient.is_unset(request.state):
            query['State'] = request.state
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateWorkflow',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UpdateWorkflowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_workflow(
        self,
        request: vod_20170321_models.UpdateWorkflowRequest,
    ) -> vod_20170321_models.UpdateWorkflowResponse:
        """
        @summary 更新工作流
        
        @param request: UpdateWorkflowRequest
        @return: UpdateWorkflowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_workflow_with_options(request, runtime)

    async def update_workflow_async(
        self,
        request: vod_20170321_models.UpdateWorkflowRequest,
    ) -> vod_20170321_models.UpdateWorkflowResponse:
        """
        @summary 更新工作流
        
        @param request: UpdateWorkflowRequest
        @return: UpdateWorkflowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_workflow_with_options_async(request, runtime)

    def upload_media_by_urlwith_options(
        self,
        request: vod_20170321_models.UploadMediaByURLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UploadMediaByURLResponse:
        """
        @summary Uploads media files based on URLs.
        
        @description    You can call this operation to upload media files that are not stored on a local server or device and must be uploaded based on URLs over the Internet.
        The URL-based upload jobs are asynchronous. After you submit a URL-based upload job by calling this operation, it may take hours, even days to complete. If you require high timeliness, we recommend that you use the upload SDK.
        If you configure callbacks, you can receive an [UploadByURLComplete](https://help.aliyun.com/document_detail/86326.html) event notification after the media file is uploaded. You can query the upload status by calling the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
        After you submit an upload job, the job is asynchronously processed on the cloud. All URL-based upload jobs that are submitted in each region are queued. The waiting time for the upload job depends on the number of queued jobs. After the upload job is complete, you can associate the playback URL included in the callback with the media ID.
        You can call this operation only in the **China (Shanghai)** and **Singapore** regions.
        Every time you submit a URL-based upload job, a new media ID is generated in ApsaraVideo VOD.
        
        @param request: UploadMediaByURLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UploadMediaByURLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.session_id):
            query['SessionId'] = request.session_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.template_group_id):
            query['TemplateGroupId'] = request.template_group_id
        if not UtilClient.is_unset(request.upload_metadatas):
            query['UploadMetadatas'] = request.upload_metadatas
        if not UtilClient.is_unset(request.upload_urls):
            query['UploadURLs'] = request.upload_urls
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UploadMediaByURL',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UploadMediaByURLResponse(),
            self.call_api(params, req, runtime)
        )

    async def upload_media_by_urlwith_options_async(
        self,
        request: vod_20170321_models.UploadMediaByURLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UploadMediaByURLResponse:
        """
        @summary Uploads media files based on URLs.
        
        @description    You can call this operation to upload media files that are not stored on a local server or device and must be uploaded based on URLs over the Internet.
        The URL-based upload jobs are asynchronous. After you submit a URL-based upload job by calling this operation, it may take hours, even days to complete. If you require high timeliness, we recommend that you use the upload SDK.
        If you configure callbacks, you can receive an [UploadByURLComplete](https://help.aliyun.com/document_detail/86326.html) event notification after the media file is uploaded. You can query the upload status by calling the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
        After you submit an upload job, the job is asynchronously processed on the cloud. All URL-based upload jobs that are submitted in each region are queued. The waiting time for the upload job depends on the number of queued jobs. After the upload job is complete, you can associate the playback URL included in the callback with the media ID.
        You can call this operation only in the **China (Shanghai)** and **Singapore** regions.
        Every time you submit a URL-based upload job, a new media ID is generated in ApsaraVideo VOD.
        
        @param request: UploadMediaByURLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UploadMediaByURLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_id):
            query['AppId'] = request.app_id
        if not UtilClient.is_unset(request.session_id):
            query['SessionId'] = request.session_id
        if not UtilClient.is_unset(request.storage_location):
            query['StorageLocation'] = request.storage_location
        if not UtilClient.is_unset(request.template_group_id):
            query['TemplateGroupId'] = request.template_group_id
        if not UtilClient.is_unset(request.upload_metadatas):
            query['UploadMetadatas'] = request.upload_metadatas
        if not UtilClient.is_unset(request.upload_urls):
            query['UploadURLs'] = request.upload_urls
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        if not UtilClient.is_unset(request.workflow_id):
            query['WorkflowId'] = request.workflow_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UploadMediaByURL',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UploadMediaByURLResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def upload_media_by_url(
        self,
        request: vod_20170321_models.UploadMediaByURLRequest,
    ) -> vod_20170321_models.UploadMediaByURLResponse:
        """
        @summary Uploads media files based on URLs.
        
        @description    You can call this operation to upload media files that are not stored on a local server or device and must be uploaded based on URLs over the Internet.
        The URL-based upload jobs are asynchronous. After you submit a URL-based upload job by calling this operation, it may take hours, even days to complete. If you require high timeliness, we recommend that you use the upload SDK.
        If you configure callbacks, you can receive an [UploadByURLComplete](https://help.aliyun.com/document_detail/86326.html) event notification after the media file is uploaded. You can query the upload status by calling the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
        After you submit an upload job, the job is asynchronously processed on the cloud. All URL-based upload jobs that are submitted in each region are queued. The waiting time for the upload job depends on the number of queued jobs. After the upload job is complete, you can associate the playback URL included in the callback with the media ID.
        You can call this operation only in the **China (Shanghai)** and **Singapore** regions.
        Every time you submit a URL-based upload job, a new media ID is generated in ApsaraVideo VOD.
        
        @param request: UploadMediaByURLRequest
        @return: UploadMediaByURLResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.upload_media_by_urlwith_options(request, runtime)

    async def upload_media_by_url_async(
        self,
        request: vod_20170321_models.UploadMediaByURLRequest,
    ) -> vod_20170321_models.UploadMediaByURLResponse:
        """
        @summary Uploads media files based on URLs.
        
        @description    You can call this operation to upload media files that are not stored on a local server or device and must be uploaded based on URLs over the Internet.
        The URL-based upload jobs are asynchronous. After you submit a URL-based upload job by calling this operation, it may take hours, even days to complete. If you require high timeliness, we recommend that you use the upload SDK.
        If you configure callbacks, you can receive an [UploadByURLComplete](https://help.aliyun.com/document_detail/86326.html) event notification after the media file is uploaded. You can query the upload status by calling the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
        After you submit an upload job, the job is asynchronously processed on the cloud. All URL-based upload jobs that are submitted in each region are queued. The waiting time for the upload job depends on the number of queued jobs. After the upload job is complete, you can associate the playback URL included in the callback with the media ID.
        You can call this operation only in the **China (Shanghai)** and **Singapore** regions.
        Every time you submit a URL-based upload job, a new media ID is generated in ApsaraVideo VOD.
        
        @param request: UploadMediaByURLRequest
        @return: UploadMediaByURLResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.upload_media_by_urlwith_options_async(request, runtime)

    def upload_stream_by_urlwith_options(
        self,
        request: vod_20170321_models.UploadStreamByURLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UploadStreamByURLResponse:
        """
        @summary Uploads transcoded streams to ApsaraVideo VOD from external storage.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        This operation is available only in the **China (Shanghai)** and **Singapore** regions.
        You can call this operation to upload transcoded streams to ApsaraVideo VOD from external storage. The following HDR types of transcoded streams are supported: HDR, HDR 10, HLG, Dolby Vision, HDR Vivid, and SDR+.
        You can call the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation to query the upload status. After the upload is complete, the callback of the [UploadByURLComplete](https://help.aliyun.com/document_detail/376427.html) event is returned.
        
        @param request: UploadStreamByURLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UploadStreamByURLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.definition):
            query['Definition'] = request.definition
        if not UtilClient.is_unset(request.file_extension):
            query['FileExtension'] = request.file_extension
        if not UtilClient.is_unset(request.hdrtype):
            query['HDRType'] = request.hdrtype
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.stream_url):
            query['StreamURL'] = request.stream_url
        if not UtilClient.is_unset(request.upload_metadata):
            query['UploadMetadata'] = request.upload_metadata
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UploadStreamByURL',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UploadStreamByURLResponse(),
            self.call_api(params, req, runtime)
        )

    async def upload_stream_by_urlwith_options_async(
        self,
        request: vod_20170321_models.UploadStreamByURLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.UploadStreamByURLResponse:
        """
        @summary Uploads transcoded streams to ApsaraVideo VOD from external storage.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        This operation is available only in the **China (Shanghai)** and **Singapore** regions.
        You can call this operation to upload transcoded streams to ApsaraVideo VOD from external storage. The following HDR types of transcoded streams are supported: HDR, HDR 10, HLG, Dolby Vision, HDR Vivid, and SDR+.
        You can call the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation to query the upload status. After the upload is complete, the callback of the [UploadByURLComplete](https://help.aliyun.com/document_detail/376427.html) event is returned.
        
        @param request: UploadStreamByURLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UploadStreamByURLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.definition):
            query['Definition'] = request.definition
        if not UtilClient.is_unset(request.file_extension):
            query['FileExtension'] = request.file_extension
        if not UtilClient.is_unset(request.hdrtype):
            query['HDRType'] = request.hdrtype
        if not UtilClient.is_unset(request.media_id):
            query['MediaId'] = request.media_id
        if not UtilClient.is_unset(request.stream_url):
            query['StreamURL'] = request.stream_url
        if not UtilClient.is_unset(request.upload_metadata):
            query['UploadMetadata'] = request.upload_metadata
        if not UtilClient.is_unset(request.user_data):
            query['UserData'] = request.user_data
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UploadStreamByURL',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.UploadStreamByURLResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def upload_stream_by_url(
        self,
        request: vod_20170321_models.UploadStreamByURLRequest,
    ) -> vod_20170321_models.UploadStreamByURLResponse:
        """
        @summary Uploads transcoded streams to ApsaraVideo VOD from external storage.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        This operation is available only in the **China (Shanghai)** and **Singapore** regions.
        You can call this operation to upload transcoded streams to ApsaraVideo VOD from external storage. The following HDR types of transcoded streams are supported: HDR, HDR 10, HLG, Dolby Vision, HDR Vivid, and SDR+.
        You can call the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation to query the upload status. After the upload is complete, the callback of the [UploadByURLComplete](https://help.aliyun.com/document_detail/376427.html) event is returned.
        
        @param request: UploadStreamByURLRequest
        @return: UploadStreamByURLResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.upload_stream_by_urlwith_options(request, runtime)

    async def upload_stream_by_url_async(
        self,
        request: vod_20170321_models.UploadStreamByURLRequest,
    ) -> vod_20170321_models.UploadStreamByURLResponse:
        """
        @summary Uploads transcoded streams to ApsaraVideo VOD from external storage.
        
        @description    **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**\
        This operation is available only in the **China (Shanghai)** and **Singapore** regions.
        You can call this operation to upload transcoded streams to ApsaraVideo VOD from external storage. The following HDR types of transcoded streams are supported: HDR, HDR 10, HLG, Dolby Vision, HDR Vivid, and SDR+.
        You can call the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation to query the upload status. After the upload is complete, the callback of the [UploadByURLComplete](https://help.aliyun.com/document_detail/376427.html) event is returned.
        
        @param request: UploadStreamByURLRequest
        @return: UploadStreamByURLResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.upload_stream_by_urlwith_options_async(request, runtime)

    def validate_cdn_url_auth_with_options(
        self,
        request: vod_20170321_models.ValidateCdnUrlAuthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ValidateCdnUrlAuthResponse:
        """
        @summary 检查CDN播放URL鉴权
        
        @param request: ValidateCdnUrlAuthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ValidateCdnUrlAuthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.input_url):
            query['InputUrl'] = request.input_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ValidateCdnUrlAuth',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ValidateCdnUrlAuthResponse(),
            self.call_api(params, req, runtime)
        )

    async def validate_cdn_url_auth_with_options_async(
        self,
        request: vod_20170321_models.ValidateCdnUrlAuthRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.ValidateCdnUrlAuthResponse:
        """
        @summary 检查CDN播放URL鉴权
        
        @param request: ValidateCdnUrlAuthRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ValidateCdnUrlAuthResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.input_url):
            query['InputUrl'] = request.input_url
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.resource_real_owner_id):
            query['ResourceRealOwnerId'] = request.resource_real_owner_id
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ValidateCdnUrlAuth',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.ValidateCdnUrlAuthResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def validate_cdn_url_auth(
        self,
        request: vod_20170321_models.ValidateCdnUrlAuthRequest,
    ) -> vod_20170321_models.ValidateCdnUrlAuthResponse:
        """
        @summary 检查CDN播放URL鉴权
        
        @param request: ValidateCdnUrlAuthRequest
        @return: ValidateCdnUrlAuthResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.validate_cdn_url_auth_with_options(request, runtime)

    async def validate_cdn_url_auth_async(
        self,
        request: vod_20170321_models.ValidateCdnUrlAuthRequest,
    ) -> vod_20170321_models.ValidateCdnUrlAuthResponse:
        """
        @summary 检查CDN播放URL鉴权
        
        @param request: ValidateCdnUrlAuthRequest
        @return: ValidateCdnUrlAuthResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.validate_cdn_url_auth_with_options_async(request, runtime)

    def verify_vod_domain_owner_with_options(
        self,
        request: vod_20170321_models.VerifyVodDomainOwnerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.VerifyVodDomainOwnerResponse:
        """
        @summary Verifies the ownership of a specified domain name.
        
        @description This operation is available only in the *China (Shanghai)** region.
        
        @param request: VerifyVodDomainOwnerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: VerifyVodDomainOwnerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.verify_type):
            query['VerifyType'] = request.verify_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='VerifyVodDomainOwner',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.VerifyVodDomainOwnerResponse(),
            self.call_api(params, req, runtime)
        )

    async def verify_vod_domain_owner_with_options_async(
        self,
        request: vod_20170321_models.VerifyVodDomainOwnerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> vod_20170321_models.VerifyVodDomainOwnerResponse:
        """
        @summary Verifies the ownership of a specified domain name.
        
        @description This operation is available only in the *China (Shanghai)** region.
        
        @param request: VerifyVodDomainOwnerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: VerifyVodDomainOwnerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain_name):
            query['DomainName'] = request.domain_name
        if not UtilClient.is_unset(request.owner_id):
            query['OwnerId'] = request.owner_id
        if not UtilClient.is_unset(request.verify_type):
            query['VerifyType'] = request.verify_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='VerifyVodDomainOwner',
            version='2017-03-21',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            vod_20170321_models.VerifyVodDomainOwnerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def verify_vod_domain_owner(
        self,
        request: vod_20170321_models.VerifyVodDomainOwnerRequest,
    ) -> vod_20170321_models.VerifyVodDomainOwnerResponse:
        """
        @summary Verifies the ownership of a specified domain name.
        
        @description This operation is available only in the *China (Shanghai)** region.
        
        @param request: VerifyVodDomainOwnerRequest
        @return: VerifyVodDomainOwnerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.verify_vod_domain_owner_with_options(request, runtime)

    async def verify_vod_domain_owner_async(
        self,
        request: vod_20170321_models.VerifyVodDomainOwnerRequest,
    ) -> vod_20170321_models.VerifyVodDomainOwnerResponse:
        """
        @summary Verifies the ownership of a specified domain name.
        
        @description This operation is available only in the *China (Shanghai)** region.
        
        @param request: VerifyVodDomainOwnerRequest
        @return: VerifyVodDomainOwnerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.verify_vod_domain_owner_with_options_async(request, runtime)
