# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from __future__ import annotations

from typing import List

from darabonba.model import DaraModel

class ModifyADConnectorDirectoryRequest(DaraModel):
    def __init__(
        self,
        ad_hostname: str = None,
        directory_id: str = None,
        directory_name: str = None,
        dns_address: List[str] = None,
        domain_name: str = None,
        domain_password: str = None,
        domain_user_name: str = None,
        mfa_enabled: bool = None,
        ouname: str = None,
        region_id: str = None,
        sub_domain_dns_address: List[str] = None,
        sub_domain_name: str = None,
    ):
        # The hostname of the domain controller. The hostname must comply with the naming conventions for hostnames in Windows.
        self.ad_hostname = ad_hostname
        # The ID of the directory.
        # 
        # This parameter is required.
        self.directory_id = directory_id
        # The name of the AD directory.
        self.directory_name = directory_name
        # The IP address of the DNS server corresponding to the enterprise AD. You can specify only one IP address. Make sure that the specified IP address is accessible in the network of the selected vSwitch.
        self.dns_address = dns_address
        # The domain name. The name must be 2 to 255 characters in length and must be in the two-part domain name format, such as `example.com`. You can register each domain name only once.
        self.domain_name = domain_name
        # The password of the domain administrator. The username can be up to 64 characters in length.
        self.domain_password = domain_password
        # The username of the domain administrator. The username can be up to 64 characters in length.
        self.domain_user_name = domain_user_name
        # Specifies whether to enable Multi-Factor Authentication (MFA). After you enable MFA, all AD users in the directory must enter a dynamic verification code generated by the virtual MFA device in addition to a correct password when they log on to a cloud computer.
        # 
        # >  When end users log on to a cloud computer for the first time, they must bind an MFA device.
        # 
        # Valid values:
        # 
        # *   true
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   <!-- -->
        # 
        #     false (default)
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.mfa_enabled = mfa_enabled
        # The name of the organizational unit (OU) in the AD domain. You can call the ListUserAdOrganizationUnits operation to obtain the name of the OU.
        self.ouname = ouname
        # The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/196646.html) operation to query the most recent region list.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The DNS address of the existing AD subdomain.\\
        # If you specify the `SubDomainName` parameter but you do not specify this parameter, the DNS address of the subdomain is the same as the DNS address of the parent domain.
        self.sub_domain_dns_address = sub_domain_dns_address
        # The domain name of the existing AD subdomain.
        self.sub_domain_name = sub_domain_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        _map = super().to_map()
        if _map is not None:
            result = _map
        if self.ad_hostname is not None:
            result['AdHostname'] = self.ad_hostname

        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id

        if self.directory_name is not None:
            result['DirectoryName'] = self.directory_name

        if self.dns_address is not None:
            result['DnsAddress'] = self.dns_address

        if self.domain_name is not None:
            result['DomainName'] = self.domain_name

        if self.domain_password is not None:
            result['DomainPassword'] = self.domain_password

        if self.domain_user_name is not None:
            result['DomainUserName'] = self.domain_user_name

        if self.mfa_enabled is not None:
            result['MfaEnabled'] = self.mfa_enabled

        if self.ouname is not None:
            result['OUName'] = self.ouname

        if self.region_id is not None:
            result['RegionId'] = self.region_id

        if self.sub_domain_dns_address is not None:
            result['SubDomainDnsAddress'] = self.sub_domain_dns_address

        if self.sub_domain_name is not None:
            result['SubDomainName'] = self.sub_domain_name

        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdHostname') is not None:
            self.ad_hostname = m.get('AdHostname')

        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')

        if m.get('DirectoryName') is not None:
            self.directory_name = m.get('DirectoryName')

        if m.get('DnsAddress') is not None:
            self.dns_address = m.get('DnsAddress')

        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')

        if m.get('DomainPassword') is not None:
            self.domain_password = m.get('DomainPassword')

        if m.get('DomainUserName') is not None:
            self.domain_user_name = m.get('DomainUserName')

        if m.get('MfaEnabled') is not None:
            self.mfa_enabled = m.get('MfaEnabled')

        if m.get('OUName') is not None:
            self.ouname = m.get('OUName')

        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')

        if m.get('SubDomainDnsAddress') is not None:
            self.sub_domain_dns_address = m.get('SubDomainDnsAddress')

        if m.get('SubDomainName') is not None:
            self.sub_domain_name = m.get('SubDomainName')

        return self

