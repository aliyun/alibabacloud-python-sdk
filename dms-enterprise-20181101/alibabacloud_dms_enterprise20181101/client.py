# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from typing import Dict
from Tea.core import TeaCore

from alibabacloud_tea_openapi.client import Client as OpenApiClient
from alibabacloud_tea_openapi import models as open_api_models
from alibabacloud_tea_util.client import Client as UtilClient
from alibabacloud_endpoint_util.client import Client as EndpointUtilClient
from alibabacloud_dms_enterprise20181101 import models as dms_enterprise_20181101_models
from alibabacloud_tea_util import models as util_models
from alibabacloud_openapi_util.client import Client as OpenApiUtilClient


class Client(OpenApiClient):
    """
    *\
    """
    def __init__(
        self, 
        config: open_api_models.Config,
    ):
        super().__init__(config)
        self._endpoint_rule = 'central'
        self.check_config(config)
        self._endpoint = self.get_endpoint('dms-enterprise', self._region_id, self._endpoint_rule, self._network, self._suffix, self._endpoint_map, self._endpoint)

    def get_endpoint(
        self,
        product_id: str,
        region_id: str,
        endpoint_rule: str,
        network: str,
        suffix: str,
        endpoint_map: Dict[str, str],
        endpoint: str,
    ) -> str:
        if not UtilClient.empty(endpoint):
            return endpoint
        if not UtilClient.is_unset(endpoint_map) and not UtilClient.empty(endpoint_map.get(region_id)):
            return endpoint_map.get(region_id)
        return EndpointUtilClient.get_endpoint_rules(product_id, region_id, endpoint_rule, network, suffix)

    def add_authority_template_items_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.AddAuthorityTemplateItemsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddAuthorityTemplateItemsResponse:
        """
        @summary 添加权限模板资源
        
        @param tmp_req: AddAuthorityTemplateItemsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddAuthorityTemplateItemsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.AddAuthorityTemplateItemsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.items):
            request.items_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.items, 'Items', 'json')
        query = {}
        if not UtilClient.is_unset(request.items_shrink):
            query['Items'] = request.items_shrink
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddAuthorityTemplateItems',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddAuthorityTemplateItemsResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_authority_template_items_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.AddAuthorityTemplateItemsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddAuthorityTemplateItemsResponse:
        """
        @summary 添加权限模板资源
        
        @param tmp_req: AddAuthorityTemplateItemsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddAuthorityTemplateItemsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.AddAuthorityTemplateItemsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.items):
            request.items_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.items, 'Items', 'json')
        query = {}
        if not UtilClient.is_unset(request.items_shrink):
            query['Items'] = request.items_shrink
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddAuthorityTemplateItems',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddAuthorityTemplateItemsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_authority_template_items(
        self,
        request: dms_enterprise_20181101_models.AddAuthorityTemplateItemsRequest,
    ) -> dms_enterprise_20181101_models.AddAuthorityTemplateItemsResponse:
        """
        @summary 添加权限模板资源
        
        @param request: AddAuthorityTemplateItemsRequest
        @return: AddAuthorityTemplateItemsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_authority_template_items_with_options(request, runtime)

    async def add_authority_template_items_async(
        self,
        request: dms_enterprise_20181101_models.AddAuthorityTemplateItemsRequest,
    ) -> dms_enterprise_20181101_models.AddAuthorityTemplateItemsResponse:
        """
        @summary 添加权限模板资源
        
        @param request: AddAuthorityTemplateItemsRequest
        @return: AddAuthorityTemplateItemsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_authority_template_items_with_options_async(request, runtime)

    def add_desensitization_rule_with_options(
        self,
        request: dms_enterprise_20181101_models.AddDesensitizationRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddDesensitizationRuleResponse:
        """
        @summary Adds a masking rule.
        
        @param request: AddDesensitizationRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddDesensitizationRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.function_type):
            query['FunctionType'] = request.function_type
        if not UtilClient.is_unset(request.rule_description):
            query['RuleDescription'] = request.rule_description
        if not UtilClient.is_unset(request.rule_name):
            query['RuleName'] = request.rule_name
        if not UtilClient.is_unset(request.rule_type):
            query['RuleType'] = request.rule_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        body = {}
        body_flat = {}
        if not UtilClient.is_unset(request.function_params):
            body_flat['FunctionParams'] = request.function_params
        body = TeaCore.merge(body,
            OpenApiUtilClient.query(body_flat))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='AddDesensitizationRule',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddDesensitizationRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_desensitization_rule_with_options_async(
        self,
        request: dms_enterprise_20181101_models.AddDesensitizationRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddDesensitizationRuleResponse:
        """
        @summary Adds a masking rule.
        
        @param request: AddDesensitizationRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddDesensitizationRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.function_type):
            query['FunctionType'] = request.function_type
        if not UtilClient.is_unset(request.rule_description):
            query['RuleDescription'] = request.rule_description
        if not UtilClient.is_unset(request.rule_name):
            query['RuleName'] = request.rule_name
        if not UtilClient.is_unset(request.rule_type):
            query['RuleType'] = request.rule_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        body = {}
        body_flat = {}
        if not UtilClient.is_unset(request.function_params):
            body_flat['FunctionParams'] = request.function_params
        body = TeaCore.merge(body,
            OpenApiUtilClient.query(body_flat))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='AddDesensitizationRule',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddDesensitizationRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_desensitization_rule(
        self,
        request: dms_enterprise_20181101_models.AddDesensitizationRuleRequest,
    ) -> dms_enterprise_20181101_models.AddDesensitizationRuleResponse:
        """
        @summary Adds a masking rule.
        
        @param request: AddDesensitizationRuleRequest
        @return: AddDesensitizationRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_desensitization_rule_with_options(request, runtime)

    async def add_desensitization_rule_async(
        self,
        request: dms_enterprise_20181101_models.AddDesensitizationRuleRequest,
    ) -> dms_enterprise_20181101_models.AddDesensitizationRuleResponse:
        """
        @summary Adds a masking rule.
        
        @param request: AddDesensitizationRuleRequest
        @return: AddDesensitizationRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_desensitization_rule_with_options_async(request, runtime)

    def add_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.AddInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddInstanceResponse:
        """
        @summary 添加实例
        
        @param request: AddInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_link_name):
            query['DataLinkName'] = request.data_link_name
        if not UtilClient.is_unset(request.database_password):
            query['DatabasePassword'] = request.database_password
        if not UtilClient.is_unset(request.database_user):
            query['DatabaseUser'] = request.database_user
        if not UtilClient.is_unset(request.dba_id):
            query['DbaId'] = request.dba_id
        if not UtilClient.is_unset(request.ddl_online):
            query['DdlOnline'] = request.ddl_online
        if not UtilClient.is_unset(request.ecs_instance_id):
            query['EcsInstanceId'] = request.ecs_instance_id
        if not UtilClient.is_unset(request.ecs_region):
            query['EcsRegion'] = request.ecs_region
        if not UtilClient.is_unset(request.enable_sell_common):
            query['EnableSellCommon'] = request.enable_sell_common
        if not UtilClient.is_unset(request.enable_sell_sitd):
            query['EnableSellSitd'] = request.enable_sell_sitd
        if not UtilClient.is_unset(request.enable_sell_stable):
            query['EnableSellStable'] = request.enable_sell_stable
        if not UtilClient.is_unset(request.enable_sell_trust):
            query['EnableSellTrust'] = request.enable_sell_trust
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.export_timeout):
            query['ExportTimeout'] = request.export_timeout
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.instance_alias):
            query['InstanceAlias'] = request.instance_alias
        if not UtilClient.is_unset(request.instance_source):
            query['InstanceSource'] = request.instance_source
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.query_timeout):
            query['QueryTimeout'] = request.query_timeout
        if not UtilClient.is_unset(request.safe_rule):
            query['SafeRule'] = request.safe_rule
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.skip_test):
            query['SkipTest'] = request.skip_test
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.use_dsql):
            query['UseDsql'] = request.use_dsql
        if not UtilClient.is_unset(request.use_ssl):
            query['UseSsl'] = request.use_ssl
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.AddInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddInstanceResponse:
        """
        @summary 添加实例
        
        @param request: AddInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_link_name):
            query['DataLinkName'] = request.data_link_name
        if not UtilClient.is_unset(request.database_password):
            query['DatabasePassword'] = request.database_password
        if not UtilClient.is_unset(request.database_user):
            query['DatabaseUser'] = request.database_user
        if not UtilClient.is_unset(request.dba_id):
            query['DbaId'] = request.dba_id
        if not UtilClient.is_unset(request.ddl_online):
            query['DdlOnline'] = request.ddl_online
        if not UtilClient.is_unset(request.ecs_instance_id):
            query['EcsInstanceId'] = request.ecs_instance_id
        if not UtilClient.is_unset(request.ecs_region):
            query['EcsRegion'] = request.ecs_region
        if not UtilClient.is_unset(request.enable_sell_common):
            query['EnableSellCommon'] = request.enable_sell_common
        if not UtilClient.is_unset(request.enable_sell_sitd):
            query['EnableSellSitd'] = request.enable_sell_sitd
        if not UtilClient.is_unset(request.enable_sell_stable):
            query['EnableSellStable'] = request.enable_sell_stable
        if not UtilClient.is_unset(request.enable_sell_trust):
            query['EnableSellTrust'] = request.enable_sell_trust
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.export_timeout):
            query['ExportTimeout'] = request.export_timeout
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.instance_alias):
            query['InstanceAlias'] = request.instance_alias
        if not UtilClient.is_unset(request.instance_source):
            query['InstanceSource'] = request.instance_source
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.query_timeout):
            query['QueryTimeout'] = request.query_timeout
        if not UtilClient.is_unset(request.safe_rule):
            query['SafeRule'] = request.safe_rule
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.skip_test):
            query['SkipTest'] = request.skip_test
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.use_dsql):
            query['UseDsql'] = request.use_dsql
        if not UtilClient.is_unset(request.use_ssl):
            query['UseSsl'] = request.use_ssl
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_instance(
        self,
        request: dms_enterprise_20181101_models.AddInstanceRequest,
    ) -> dms_enterprise_20181101_models.AddInstanceResponse:
        """
        @summary 添加实例
        
        @param request: AddInstanceRequest
        @return: AddInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_instance_with_options(request, runtime)

    async def add_instance_async(
        self,
        request: dms_enterprise_20181101_models.AddInstanceRequest,
    ) -> dms_enterprise_20181101_models.AddInstanceResponse:
        """
        @summary 添加实例
        
        @param request: AddInstanceRequest
        @return: AddInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_instance_with_options_async(request, runtime)

    def add_lh_members_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.AddLhMembersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddLhMembersResponse:
        """
        @summary Adds a workspace administrator, a workspace member, or a task flow developer in Data Management (DMS).
        
        @description You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
        Usage notes:
        Before you call this operation to add a user as a task flow developer, make sure that you have added the user as a workspace member.
        You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
        For more information about workspace roles and permissions, see [Manage permissions on a workspace](https://help.aliyun.com/document_detail/410893.html).
        
        @param tmp_req: AddLhMembersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLhMembersResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.AddLhMembersShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.members):
            request.members_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.members, 'Members', 'json')
        query = {}
        if not UtilClient.is_unset(request.members_shrink):
            query['Members'] = request.members_shrink
        if not UtilClient.is_unset(request.object_id):
            query['ObjectId'] = request.object_id
        if not UtilClient.is_unset(request.object_type):
            query['ObjectType'] = request.object_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLhMembers',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddLhMembersResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_lh_members_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.AddLhMembersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddLhMembersResponse:
        """
        @summary Adds a workspace administrator, a workspace member, or a task flow developer in Data Management (DMS).
        
        @description You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
        Usage notes:
        Before you call this operation to add a user as a task flow developer, make sure that you have added the user as a workspace member.
        You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
        For more information about workspace roles and permissions, see [Manage permissions on a workspace](https://help.aliyun.com/document_detail/410893.html).
        
        @param tmp_req: AddLhMembersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLhMembersResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.AddLhMembersShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.members):
            request.members_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.members, 'Members', 'json')
        query = {}
        if not UtilClient.is_unset(request.members_shrink):
            query['Members'] = request.members_shrink
        if not UtilClient.is_unset(request.object_id):
            query['ObjectId'] = request.object_id
        if not UtilClient.is_unset(request.object_type):
            query['ObjectType'] = request.object_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLhMembers',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddLhMembersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_lh_members(
        self,
        request: dms_enterprise_20181101_models.AddLhMembersRequest,
    ) -> dms_enterprise_20181101_models.AddLhMembersResponse:
        """
        @summary Adds a workspace administrator, a workspace member, or a task flow developer in Data Management (DMS).
        
        @description You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
        Usage notes:
        Before you call this operation to add a user as a task flow developer, make sure that you have added the user as a workspace member.
        You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
        For more information about workspace roles and permissions, see [Manage permissions on a workspace](https://help.aliyun.com/document_detail/410893.html).
        
        @param request: AddLhMembersRequest
        @return: AddLhMembersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_lh_members_with_options(request, runtime)

    async def add_lh_members_async(
        self,
        request: dms_enterprise_20181101_models.AddLhMembersRequest,
    ) -> dms_enterprise_20181101_models.AddLhMembersResponse:
        """
        @summary Adds a workspace administrator, a workspace member, or a task flow developer in Data Management (DMS).
        
        @description You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
        Usage notes:
        Before you call this operation to add a user as a task flow developer, make sure that you have added the user as a workspace member.
        You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
        For more information about workspace roles and permissions, see [Manage permissions on a workspace](https://help.aliyun.com/document_detail/410893.html).
        
        @param request: AddLhMembersRequest
        @return: AddLhMembersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_lh_members_with_options_async(request, runtime)

    def add_logic_table_route_config_with_options(
        self,
        request: dms_enterprise_20181101_models.AddLogicTableRouteConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddLogicTableRouteConfigResponse:
        """
        @summary Adds a routing algorithm to a logical table.
        
        @param request: AddLogicTableRouteConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLogicTableRouteConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.route_expr):
            query['RouteExpr'] = request.route_expr
        if not UtilClient.is_unset(request.route_key):
            query['RouteKey'] = request.route_key
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLogicTableRouteConfig',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddLogicTableRouteConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_logic_table_route_config_with_options_async(
        self,
        request: dms_enterprise_20181101_models.AddLogicTableRouteConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddLogicTableRouteConfigResponse:
        """
        @summary Adds a routing algorithm to a logical table.
        
        @param request: AddLogicTableRouteConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddLogicTableRouteConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.route_expr):
            query['RouteExpr'] = request.route_expr
        if not UtilClient.is_unset(request.route_key):
            query['RouteKey'] = request.route_key
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddLogicTableRouteConfig',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddLogicTableRouteConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_logic_table_route_config(
        self,
        request: dms_enterprise_20181101_models.AddLogicTableRouteConfigRequest,
    ) -> dms_enterprise_20181101_models.AddLogicTableRouteConfigResponse:
        """
        @summary Adds a routing algorithm to a logical table.
        
        @param request: AddLogicTableRouteConfigRequest
        @return: AddLogicTableRouteConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_logic_table_route_config_with_options(request, runtime)

    async def add_logic_table_route_config_async(
        self,
        request: dms_enterprise_20181101_models.AddLogicTableRouteConfigRequest,
    ) -> dms_enterprise_20181101_models.AddLogicTableRouteConfigResponse:
        """
        @summary Adds a routing algorithm to a logical table.
        
        @param request: AddLogicTableRouteConfigRequest
        @return: AddLogicTableRouteConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_logic_table_route_config_with_options_async(request, runtime)

    def add_table_to_category_with_options(
        self,
        request: dms_enterprise_20181101_models.AddTableToCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddTableToCategoryResponse:
        """
        @summary 添加表到资产类目
        
        @param request: AddTableToCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddTableToCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category_id):
            query['CategoryId'] = request.category_id
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.table_schema_name):
            query['TableSchemaName'] = request.table_schema_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddTableToCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddTableToCategoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_table_to_category_with_options_async(
        self,
        request: dms_enterprise_20181101_models.AddTableToCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddTableToCategoryResponse:
        """
        @summary 添加表到资产类目
        
        @param request: AddTableToCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddTableToCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category_id):
            query['CategoryId'] = request.category_id
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.table_schema_name):
            query['TableSchemaName'] = request.table_schema_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddTableToCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddTableToCategoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_table_to_category(
        self,
        request: dms_enterprise_20181101_models.AddTableToCategoryRequest,
    ) -> dms_enterprise_20181101_models.AddTableToCategoryResponse:
        """
        @summary 添加表到资产类目
        
        @param request: AddTableToCategoryRequest
        @return: AddTableToCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_table_to_category_with_options(request, runtime)

    async def add_table_to_category_async(
        self,
        request: dms_enterprise_20181101_models.AddTableToCategoryRequest,
    ) -> dms_enterprise_20181101_models.AddTableToCategoryResponse:
        """
        @summary 添加表到资产类目
        
        @param request: AddTableToCategoryRequest
        @return: AddTableToCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_table_to_category_with_options_async(request, runtime)

    def add_task_flow_edges_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.AddTaskFlowEdgesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddTaskFlowEdgesResponse:
        """
        @summary Adds directed edges for an existing task node.
        
        @description When you add directed edges for a task node, take note of the following limits:
        1. The endpoints of the specified edge exist in the Directed Acyclic Graph (DAG) of the task flow specified by DagId.
        2. After a backward edge is added, the DAG does not contain loops.
        
        @param tmp_req: AddTaskFlowEdgesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddTaskFlowEdgesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.AddTaskFlowEdgesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.edges):
            request.edges_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.edges, 'Edges', 'json')
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.edges_shrink):
            query['Edges'] = request.edges_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddTaskFlowEdges',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddTaskFlowEdgesResponse(),
            self.call_api(params, req, runtime)
        )

    async def add_task_flow_edges_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.AddTaskFlowEdgesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AddTaskFlowEdgesResponse:
        """
        @summary Adds directed edges for an existing task node.
        
        @description When you add directed edges for a task node, take note of the following limits:
        1. The endpoints of the specified edge exist in the Directed Acyclic Graph (DAG) of the task flow specified by DagId.
        2. After a backward edge is added, the DAG does not contain loops.
        
        @param tmp_req: AddTaskFlowEdgesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AddTaskFlowEdgesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.AddTaskFlowEdgesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.edges):
            request.edges_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.edges, 'Edges', 'json')
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.edges_shrink):
            query['Edges'] = request.edges_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AddTaskFlowEdges',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AddTaskFlowEdgesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def add_task_flow_edges(
        self,
        request: dms_enterprise_20181101_models.AddTaskFlowEdgesRequest,
    ) -> dms_enterprise_20181101_models.AddTaskFlowEdgesResponse:
        """
        @summary Adds directed edges for an existing task node.
        
        @description When you add directed edges for a task node, take note of the following limits:
        1. The endpoints of the specified edge exist in the Directed Acyclic Graph (DAG) of the task flow specified by DagId.
        2. After a backward edge is added, the DAG does not contain loops.
        
        @param request: AddTaskFlowEdgesRequest
        @return: AddTaskFlowEdgesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.add_task_flow_edges_with_options(request, runtime)

    async def add_task_flow_edges_async(
        self,
        request: dms_enterprise_20181101_models.AddTaskFlowEdgesRequest,
    ) -> dms_enterprise_20181101_models.AddTaskFlowEdgesResponse:
        """
        @summary Adds directed edges for an existing task node.
        
        @description When you add directed edges for a task node, take note of the following limits:
        1. The endpoints of the specified edge exist in the Directed Acyclic Graph (DAG) of the task flow specified by DagId.
        2. After a backward edge is added, the DAG does not contain loops.
        
        @param request: AddTaskFlowEdgesRequest
        @return: AddTaskFlowEdgesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.add_task_flow_edges_with_options_async(request, runtime)

    def analyze_sqllineage_with_options(
        self,
        request: dms_enterprise_20181101_models.AnalyzeSQLLineageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AnalyzeSQLLineageResponse:
        """
        @summary Analyzes the lineage (dependencies and influence) between tables and between fields in SQL statements.
        
        @description The following conditions must be met before you call this API operation.
        The database instance is of one of the following types: ApsaraDB RDS for MySQL, PolarDB for MySQL, AnalyticDB for MySQL, ApsaraDB RDS for PostgreSQL, PolarDB for PostgreSQL, AnalyticDB for PostgreSQL, Oracle, and openGauss.
        A database instance is managed in Security Collaboration mode. For more information about control modes, see [Control modes](https://help.aliyun.com/document_detail/151629.html).
        
        @param request: AnalyzeSQLLineageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AnalyzeSQLLineageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.sql_content):
            query['SqlContent'] = request.sql_content
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AnalyzeSQLLineage',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AnalyzeSQLLineageResponse(),
            self.call_api(params, req, runtime)
        )

    async def analyze_sqllineage_with_options_async(
        self,
        request: dms_enterprise_20181101_models.AnalyzeSQLLineageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.AnalyzeSQLLineageResponse:
        """
        @summary Analyzes the lineage (dependencies and influence) between tables and between fields in SQL statements.
        
        @description The following conditions must be met before you call this API operation.
        The database instance is of one of the following types: ApsaraDB RDS for MySQL, PolarDB for MySQL, AnalyticDB for MySQL, ApsaraDB RDS for PostgreSQL, PolarDB for PostgreSQL, AnalyticDB for PostgreSQL, Oracle, and openGauss.
        A database instance is managed in Security Collaboration mode. For more information about control modes, see [Control modes](https://help.aliyun.com/document_detail/151629.html).
        
        @param request: AnalyzeSQLLineageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: AnalyzeSQLLineageResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.sql_content):
            query['SqlContent'] = request.sql_content
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='AnalyzeSQLLineage',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.AnalyzeSQLLineageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def analyze_sqllineage(
        self,
        request: dms_enterprise_20181101_models.AnalyzeSQLLineageRequest,
    ) -> dms_enterprise_20181101_models.AnalyzeSQLLineageResponse:
        """
        @summary Analyzes the lineage (dependencies and influence) between tables and between fields in SQL statements.
        
        @description The following conditions must be met before you call this API operation.
        The database instance is of one of the following types: ApsaraDB RDS for MySQL, PolarDB for MySQL, AnalyticDB for MySQL, ApsaraDB RDS for PostgreSQL, PolarDB for PostgreSQL, AnalyticDB for PostgreSQL, Oracle, and openGauss.
        A database instance is managed in Security Collaboration mode. For more information about control modes, see [Control modes](https://help.aliyun.com/document_detail/151629.html).
        
        @param request: AnalyzeSQLLineageRequest
        @return: AnalyzeSQLLineageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.analyze_sqllineage_with_options(request, runtime)

    async def analyze_sqllineage_async(
        self,
        request: dms_enterprise_20181101_models.AnalyzeSQLLineageRequest,
    ) -> dms_enterprise_20181101_models.AnalyzeSQLLineageResponse:
        """
        @summary Analyzes the lineage (dependencies and influence) between tables and between fields in SQL statements.
        
        @description The following conditions must be met before you call this API operation.
        The database instance is of one of the following types: ApsaraDB RDS for MySQL, PolarDB for MySQL, AnalyticDB for MySQL, ApsaraDB RDS for PostgreSQL, PolarDB for PostgreSQL, AnalyticDB for PostgreSQL, Oracle, and openGauss.
        A database instance is managed in Security Collaboration mode. For more information about control modes, see [Control modes](https://help.aliyun.com/document_detail/151629.html).
        
        @param request: AnalyzeSQLLineageRequest
        @return: AnalyzeSQLLineageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.analyze_sqllineage_with_options_async(request, runtime)

    def approve_order_with_options(
        self,
        request: dms_enterprise_20181101_models.ApproveOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ApproveOrderResponse:
        """
        @summary Reviews a ticket.
        
        @param request: ApproveOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ApproveOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.approval_node_id):
            query['ApprovalNodeId'] = request.approval_node_id
        if not UtilClient.is_unset(request.approval_node_pos):
            query['ApprovalNodePos'] = request.approval_node_pos
        if not UtilClient.is_unset(request.approval_type):
            query['ApprovalType'] = request.approval_type
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.new_approver):
            query['NewApprover'] = request.new_approver
        if not UtilClient.is_unset(request.new_approver_list):
            query['NewApproverList'] = request.new_approver_list
        if not UtilClient.is_unset(request.old_approver):
            query['OldApprover'] = request.old_approver
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workflow_instance_id):
            query['WorkflowInstanceId'] = request.workflow_instance_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ApproveOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ApproveOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def approve_order_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ApproveOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ApproveOrderResponse:
        """
        @summary Reviews a ticket.
        
        @param request: ApproveOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ApproveOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.approval_node_id):
            query['ApprovalNodeId'] = request.approval_node_id
        if not UtilClient.is_unset(request.approval_node_pos):
            query['ApprovalNodePos'] = request.approval_node_pos
        if not UtilClient.is_unset(request.approval_type):
            query['ApprovalType'] = request.approval_type
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.new_approver):
            query['NewApprover'] = request.new_approver
        if not UtilClient.is_unset(request.new_approver_list):
            query['NewApproverList'] = request.new_approver_list
        if not UtilClient.is_unset(request.old_approver):
            query['OldApprover'] = request.old_approver
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workflow_instance_id):
            query['WorkflowInstanceId'] = request.workflow_instance_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ApproveOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ApproveOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def approve_order(
        self,
        request: dms_enterprise_20181101_models.ApproveOrderRequest,
    ) -> dms_enterprise_20181101_models.ApproveOrderResponse:
        """
        @summary Reviews a ticket.
        
        @param request: ApproveOrderRequest
        @return: ApproveOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.approve_order_with_options(request, runtime)

    async def approve_order_async(
        self,
        request: dms_enterprise_20181101_models.ApproveOrderRequest,
    ) -> dms_enterprise_20181101_models.ApproveOrderResponse:
        """
        @summary Reviews a ticket.
        
        @param request: ApproveOrderRequest
        @return: ApproveOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.approve_order_with_options_async(request, runtime)

    def back_fill_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.BackFillRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.BackFillResponse:
        """
        @summary Backfills data for task orchestration.
        
        @description During a data backfill, task flows are run in sequence based on their dates. You can specify whether task flows are run in chronological or reverse chronological order. After the data backfill is complete, you can specify a date or date range, and a node range to run task flows.
        
        @param tmp_req: BackFillRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BackFillResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.BackFillShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.filter_node_ids):
            request.filter_node_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.filter_node_ids, 'FilterNodeIds', 'json')
        if not UtilClient.is_unset(tmp_req.start_node_ids):
            request.start_node_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.start_node_ids, 'StartNodeIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.asc):
            query['Asc'] = request.asc
        if not UtilClient.is_unset(request.back_fill_date):
            query['BackFillDate'] = request.back_fill_date
        if not UtilClient.is_unset(request.back_fill_date_begin):
            query['BackFillDateBegin'] = request.back_fill_date_begin
        if not UtilClient.is_unset(request.back_fill_date_end):
            query['BackFillDateEnd'] = request.back_fill_date_end
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.filter_node_ids_shrink):
            query['FilterNodeIds'] = request.filter_node_ids_shrink
        if not UtilClient.is_unset(request.history_dag_id):
            query['HistoryDagId'] = request.history_dag_id
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.is_trigger_sub_tree):
            query['IsTriggerSubTree'] = request.is_trigger_sub_tree
        if not UtilClient.is_unset(request.start_node_ids_shrink):
            query['StartNodeIds'] = request.start_node_ids_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BackFill',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.BackFillResponse(),
            self.call_api(params, req, runtime)
        )

    async def back_fill_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.BackFillRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.BackFillResponse:
        """
        @summary Backfills data for task orchestration.
        
        @description During a data backfill, task flows are run in sequence based on their dates. You can specify whether task flows are run in chronological or reverse chronological order. After the data backfill is complete, you can specify a date or date range, and a node range to run task flows.
        
        @param tmp_req: BackFillRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BackFillResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.BackFillShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.filter_node_ids):
            request.filter_node_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.filter_node_ids, 'FilterNodeIds', 'json')
        if not UtilClient.is_unset(tmp_req.start_node_ids):
            request.start_node_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.start_node_ids, 'StartNodeIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.asc):
            query['Asc'] = request.asc
        if not UtilClient.is_unset(request.back_fill_date):
            query['BackFillDate'] = request.back_fill_date
        if not UtilClient.is_unset(request.back_fill_date_begin):
            query['BackFillDateBegin'] = request.back_fill_date_begin
        if not UtilClient.is_unset(request.back_fill_date_end):
            query['BackFillDateEnd'] = request.back_fill_date_end
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.filter_node_ids_shrink):
            query['FilterNodeIds'] = request.filter_node_ids_shrink
        if not UtilClient.is_unset(request.history_dag_id):
            query['HistoryDagId'] = request.history_dag_id
        if not UtilClient.is_unset(request.interval):
            query['Interval'] = request.interval
        if not UtilClient.is_unset(request.is_trigger_sub_tree):
            query['IsTriggerSubTree'] = request.is_trigger_sub_tree
        if not UtilClient.is_unset(request.start_node_ids_shrink):
            query['StartNodeIds'] = request.start_node_ids_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BackFill',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.BackFillResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def back_fill(
        self,
        request: dms_enterprise_20181101_models.BackFillRequest,
    ) -> dms_enterprise_20181101_models.BackFillResponse:
        """
        @summary Backfills data for task orchestration.
        
        @description During a data backfill, task flows are run in sequence based on their dates. You can specify whether task flows are run in chronological or reverse chronological order. After the data backfill is complete, you can specify a date or date range, and a node range to run task flows.
        
        @param request: BackFillRequest
        @return: BackFillResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.back_fill_with_options(request, runtime)

    async def back_fill_async(
        self,
        request: dms_enterprise_20181101_models.BackFillRequest,
    ) -> dms_enterprise_20181101_models.BackFillResponse:
        """
        @summary Backfills data for task orchestration.
        
        @description During a data backfill, task flows are run in sequence based on their dates. You can specify whether task flows are run in chronological or reverse chronological order. After the data backfill is complete, you can specify a date or date range, and a node range to run task flows.
        
        @param request: BackFillRequest
        @return: BackFillResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.back_fill_with_options_async(request, runtime)

    def batch_create_data_lake_partitions_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.BatchCreateDataLakePartitionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.BatchCreateDataLakePartitionsResponse:
        """
        @summary 批量新建湖仓表分区
        
        @param tmp_req: BatchCreateDataLakePartitionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchCreateDataLakePartitionsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.BatchCreateDataLakePartitionsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.partition_inputs):
            request.partition_inputs_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.partition_inputs, 'PartitionInputs', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.if_not_exists):
            query['IfNotExists'] = request.if_not_exists
        if not UtilClient.is_unset(request.need_result):
            query['NeedResult'] = request.need_result
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.partition_inputs_shrink):
            body['PartitionInputs'] = request.partition_inputs_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='BatchCreateDataLakePartitions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.BatchCreateDataLakePartitionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def batch_create_data_lake_partitions_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.BatchCreateDataLakePartitionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.BatchCreateDataLakePartitionsResponse:
        """
        @summary 批量新建湖仓表分区
        
        @param tmp_req: BatchCreateDataLakePartitionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchCreateDataLakePartitionsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.BatchCreateDataLakePartitionsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.partition_inputs):
            request.partition_inputs_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.partition_inputs, 'PartitionInputs', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.if_not_exists):
            query['IfNotExists'] = request.if_not_exists
        if not UtilClient.is_unset(request.need_result):
            query['NeedResult'] = request.need_result
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.partition_inputs_shrink):
            body['PartitionInputs'] = request.partition_inputs_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='BatchCreateDataLakePartitions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.BatchCreateDataLakePartitionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def batch_create_data_lake_partitions(
        self,
        request: dms_enterprise_20181101_models.BatchCreateDataLakePartitionsRequest,
    ) -> dms_enterprise_20181101_models.BatchCreateDataLakePartitionsResponse:
        """
        @summary 批量新建湖仓表分区
        
        @param request: BatchCreateDataLakePartitionsRequest
        @return: BatchCreateDataLakePartitionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.batch_create_data_lake_partitions_with_options(request, runtime)

    async def batch_create_data_lake_partitions_async(
        self,
        request: dms_enterprise_20181101_models.BatchCreateDataLakePartitionsRequest,
    ) -> dms_enterprise_20181101_models.BatchCreateDataLakePartitionsResponse:
        """
        @summary 批量新建湖仓表分区
        
        @param request: BatchCreateDataLakePartitionsRequest
        @return: BatchCreateDataLakePartitionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.batch_create_data_lake_partitions_with_options_async(request, runtime)

    def batch_delete_data_lake_partitions_with_options(
        self,
        request: dms_enterprise_20181101_models.BatchDeleteDataLakePartitionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.BatchDeleteDataLakePartitionsResponse:
        """
        @summary 批量删除湖仓表分区
        
        @param request: BatchDeleteDataLakePartitionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchDeleteDataLakePartitionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.if_exists):
            query['IfExists'] = request.if_exists
        if not UtilClient.is_unset(request.partition_values_list):
            query['PartitionValuesList'] = request.partition_values_list
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchDeleteDataLakePartitions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.BatchDeleteDataLakePartitionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def batch_delete_data_lake_partitions_with_options_async(
        self,
        request: dms_enterprise_20181101_models.BatchDeleteDataLakePartitionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.BatchDeleteDataLakePartitionsResponse:
        """
        @summary 批量删除湖仓表分区
        
        @param request: BatchDeleteDataLakePartitionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchDeleteDataLakePartitionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.if_exists):
            query['IfExists'] = request.if_exists
        if not UtilClient.is_unset(request.partition_values_list):
            query['PartitionValuesList'] = request.partition_values_list
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BatchDeleteDataLakePartitions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.BatchDeleteDataLakePartitionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def batch_delete_data_lake_partitions(
        self,
        request: dms_enterprise_20181101_models.BatchDeleteDataLakePartitionsRequest,
    ) -> dms_enterprise_20181101_models.BatchDeleteDataLakePartitionsResponse:
        """
        @summary 批量删除湖仓表分区
        
        @param request: BatchDeleteDataLakePartitionsRequest
        @return: BatchDeleteDataLakePartitionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.batch_delete_data_lake_partitions_with_options(request, runtime)

    async def batch_delete_data_lake_partitions_async(
        self,
        request: dms_enterprise_20181101_models.BatchDeleteDataLakePartitionsRequest,
    ) -> dms_enterprise_20181101_models.BatchDeleteDataLakePartitionsResponse:
        """
        @summary 批量删除湖仓表分区
        
        @param request: BatchDeleteDataLakePartitionsRequest
        @return: BatchDeleteDataLakePartitionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.batch_delete_data_lake_partitions_with_options_async(request, runtime)

    def batch_update_data_lake_partitions_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.BatchUpdateDataLakePartitionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.BatchUpdateDataLakePartitionsResponse:
        """
        @summary 批量更新湖仓表分区
        
        @param tmp_req: BatchUpdateDataLakePartitionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchUpdateDataLakePartitionsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.BatchUpdateDataLakePartitionsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.partition_inputs):
            request.partition_inputs_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.partition_inputs, 'PartitionInputs', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.partition_inputs_shrink):
            body['PartitionInputs'] = request.partition_inputs_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='BatchUpdateDataLakePartitions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.BatchUpdateDataLakePartitionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def batch_update_data_lake_partitions_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.BatchUpdateDataLakePartitionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.BatchUpdateDataLakePartitionsResponse:
        """
        @summary 批量更新湖仓表分区
        
        @param tmp_req: BatchUpdateDataLakePartitionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BatchUpdateDataLakePartitionsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.BatchUpdateDataLakePartitionsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.partition_inputs):
            request.partition_inputs_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.partition_inputs, 'PartitionInputs', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.partition_inputs_shrink):
            body['PartitionInputs'] = request.partition_inputs_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='BatchUpdateDataLakePartitions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.BatchUpdateDataLakePartitionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def batch_update_data_lake_partitions(
        self,
        request: dms_enterprise_20181101_models.BatchUpdateDataLakePartitionsRequest,
    ) -> dms_enterprise_20181101_models.BatchUpdateDataLakePartitionsResponse:
        """
        @summary 批量更新湖仓表分区
        
        @param request: BatchUpdateDataLakePartitionsRequest
        @return: BatchUpdateDataLakePartitionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.batch_update_data_lake_partitions_with_options(request, runtime)

    async def batch_update_data_lake_partitions_async(
        self,
        request: dms_enterprise_20181101_models.BatchUpdateDataLakePartitionsRequest,
    ) -> dms_enterprise_20181101_models.BatchUpdateDataLakePartitionsResponse:
        """
        @summary 批量更新湖仓表分区
        
        @param request: BatchUpdateDataLakePartitionsRequest
        @return: BatchUpdateDataLakePartitionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.batch_update_data_lake_partitions_with_options_async(request, runtime)

    def buy_pay_as_you_go_order_with_options(
        self,
        request: dms_enterprise_20181101_models.BuyPayAsYouGoOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.BuyPayAsYouGoOrderResponse:
        """
        @summary Purchases a pay-as-you-go Data Management (DMS) resource.
        
        @param request: BuyPayAsYouGoOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BuyPayAsYouGoOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.commodity_type):
            query['CommodityType'] = request.commodity_type
        if not UtilClient.is_unset(request.ins_num):
            query['InsNum'] = request.ins_num
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.version_type):
            query['VersionType'] = request.version_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BuyPayAsYouGoOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.BuyPayAsYouGoOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def buy_pay_as_you_go_order_with_options_async(
        self,
        request: dms_enterprise_20181101_models.BuyPayAsYouGoOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.BuyPayAsYouGoOrderResponse:
        """
        @summary Purchases a pay-as-you-go Data Management (DMS) resource.
        
        @param request: BuyPayAsYouGoOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: BuyPayAsYouGoOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.commodity_type):
            query['CommodityType'] = request.commodity_type
        if not UtilClient.is_unset(request.ins_num):
            query['InsNum'] = request.ins_num
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.version_type):
            query['VersionType'] = request.version_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='BuyPayAsYouGoOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.BuyPayAsYouGoOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def buy_pay_as_you_go_order(
        self,
        request: dms_enterprise_20181101_models.BuyPayAsYouGoOrderRequest,
    ) -> dms_enterprise_20181101_models.BuyPayAsYouGoOrderResponse:
        """
        @summary Purchases a pay-as-you-go Data Management (DMS) resource.
        
        @param request: BuyPayAsYouGoOrderRequest
        @return: BuyPayAsYouGoOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.buy_pay_as_you_go_order_with_options(request, runtime)

    async def buy_pay_as_you_go_order_async(
        self,
        request: dms_enterprise_20181101_models.BuyPayAsYouGoOrderRequest,
    ) -> dms_enterprise_20181101_models.BuyPayAsYouGoOrderResponse:
        """
        @summary Purchases a pay-as-you-go Data Management (DMS) resource.
        
        @param request: BuyPayAsYouGoOrderRequest
        @return: BuyPayAsYouGoOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.buy_pay_as_you_go_order_with_options_async(request, runtime)

    def change_column_sec_level_with_options(
        self,
        request: dms_enterprise_20181101_models.ChangeColumnSecLevelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ChangeColumnSecLevelResponse:
        """
        @summary Adjusts the sensitivity level of one or more fields.
        
        @param request: ChangeColumnSecLevelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ChangeColumnSecLevelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.is_logic):
            query['IsLogic'] = request.is_logic
        if not UtilClient.is_unset(request.new_level):
            query['NewLevel'] = request.new_level
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ChangeColumnSecLevel',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ChangeColumnSecLevelResponse(),
            self.call_api(params, req, runtime)
        )

    async def change_column_sec_level_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ChangeColumnSecLevelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ChangeColumnSecLevelResponse:
        """
        @summary Adjusts the sensitivity level of one or more fields.
        
        @param request: ChangeColumnSecLevelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ChangeColumnSecLevelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.is_logic):
            query['IsLogic'] = request.is_logic
        if not UtilClient.is_unset(request.new_level):
            query['NewLevel'] = request.new_level
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ChangeColumnSecLevel',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ChangeColumnSecLevelResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def change_column_sec_level(
        self,
        request: dms_enterprise_20181101_models.ChangeColumnSecLevelRequest,
    ) -> dms_enterprise_20181101_models.ChangeColumnSecLevelResponse:
        """
        @summary Adjusts the sensitivity level of one or more fields.
        
        @param request: ChangeColumnSecLevelRequest
        @return: ChangeColumnSecLevelResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.change_column_sec_level_with_options(request, runtime)

    async def change_column_sec_level_async(
        self,
        request: dms_enterprise_20181101_models.ChangeColumnSecLevelRequest,
    ) -> dms_enterprise_20181101_models.ChangeColumnSecLevelResponse:
        """
        @summary Adjusts the sensitivity level of one or more fields.
        
        @param request: ChangeColumnSecLevelRequest
        @return: ChangeColumnSecLevelResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.change_column_sec_level_with_options_async(request, runtime)

    def change_column_security_level_with_options(
        self,
        request: dms_enterprise_20181101_models.ChangeColumnSecurityLevelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ChangeColumnSecurityLevelResponse:
        """
        @summary 修改字段敏感序列
        
        @param request: ChangeColumnSecurityLevelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ChangeColumnSecurityLevelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.is_logic):
            query['IsLogic'] = request.is_logic
        if not UtilClient.is_unset(request.new_sensitivity_level):
            query['NewSensitivityLevel'] = request.new_sensitivity_level
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ChangeColumnSecurityLevel',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ChangeColumnSecurityLevelResponse(),
            self.call_api(params, req, runtime)
        )

    async def change_column_security_level_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ChangeColumnSecurityLevelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ChangeColumnSecurityLevelResponse:
        """
        @summary 修改字段敏感序列
        
        @param request: ChangeColumnSecurityLevelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ChangeColumnSecurityLevelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.is_logic):
            query['IsLogic'] = request.is_logic
        if not UtilClient.is_unset(request.new_sensitivity_level):
            query['NewSensitivityLevel'] = request.new_sensitivity_level
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ChangeColumnSecurityLevel',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ChangeColumnSecurityLevelResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def change_column_security_level(
        self,
        request: dms_enterprise_20181101_models.ChangeColumnSecurityLevelRequest,
    ) -> dms_enterprise_20181101_models.ChangeColumnSecurityLevelResponse:
        """
        @summary 修改字段敏感序列
        
        @param request: ChangeColumnSecurityLevelRequest
        @return: ChangeColumnSecurityLevelResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.change_column_security_level_with_options(request, runtime)

    async def change_column_security_level_async(
        self,
        request: dms_enterprise_20181101_models.ChangeColumnSecurityLevelRequest,
    ) -> dms_enterprise_20181101_models.ChangeColumnSecurityLevelResponse:
        """
        @summary 修改字段敏感序列
        
        @param request: ChangeColumnSecurityLevelRequest
        @return: ChangeColumnSecurityLevelResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.change_column_security_level_with_options_async(request, runtime)

    def change_lh_dag_owner_with_options(
        self,
        request: dms_enterprise_20181101_models.ChangeLhDagOwnerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ChangeLhDagOwnerResponse:
        """
        @summary 移交数仓开发任务流
        
        @description Usage notes:
        If you call this operation to transfer the ownership of a published task flow, the ownership transfer does not take effect.
        You can call the [ReDeployLhDagVersion](https://help.aliyun.com/document_detail/424712.html) operation to redeploy a published version of a task flow.
        
        @param request: ChangeLhDagOwnerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ChangeLhDagOwnerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.owner_user_id):
            query['OwnerUserId'] = request.owner_user_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ChangeLhDagOwner',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ChangeLhDagOwnerResponse(),
            self.call_api(params, req, runtime)
        )

    async def change_lh_dag_owner_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ChangeLhDagOwnerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ChangeLhDagOwnerResponse:
        """
        @summary 移交数仓开发任务流
        
        @description Usage notes:
        If you call this operation to transfer the ownership of a published task flow, the ownership transfer does not take effect.
        You can call the [ReDeployLhDagVersion](https://help.aliyun.com/document_detail/424712.html) operation to redeploy a published version of a task flow.
        
        @param request: ChangeLhDagOwnerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ChangeLhDagOwnerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.owner_user_id):
            query['OwnerUserId'] = request.owner_user_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ChangeLhDagOwner',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ChangeLhDagOwnerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def change_lh_dag_owner(
        self,
        request: dms_enterprise_20181101_models.ChangeLhDagOwnerRequest,
    ) -> dms_enterprise_20181101_models.ChangeLhDagOwnerResponse:
        """
        @summary 移交数仓开发任务流
        
        @description Usage notes:
        If you call this operation to transfer the ownership of a published task flow, the ownership transfer does not take effect.
        You can call the [ReDeployLhDagVersion](https://help.aliyun.com/document_detail/424712.html) operation to redeploy a published version of a task flow.
        
        @param request: ChangeLhDagOwnerRequest
        @return: ChangeLhDagOwnerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.change_lh_dag_owner_with_options(request, runtime)

    async def change_lh_dag_owner_async(
        self,
        request: dms_enterprise_20181101_models.ChangeLhDagOwnerRequest,
    ) -> dms_enterprise_20181101_models.ChangeLhDagOwnerResponse:
        """
        @summary 移交数仓开发任务流
        
        @description Usage notes:
        If you call this operation to transfer the ownership of a published task flow, the ownership transfer does not take effect.
        You can call the [ReDeployLhDagVersion](https://help.aliyun.com/document_detail/424712.html) operation to redeploy a published version of a task flow.
        
        @param request: ChangeLhDagOwnerRequest
        @return: ChangeLhDagOwnerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.change_lh_dag_owner_with_options_async(request, runtime)

    def close_order_with_options(
        self,
        request: dms_enterprise_20181101_models.CloseOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CloseOrderResponse:
        """
        @summary Closes a ticket.
        
        @param request: CloseOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CloseOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.close_reason):
            query['CloseReason'] = request.close_reason
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CloseOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CloseOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def close_order_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CloseOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CloseOrderResponse:
        """
        @summary Closes a ticket.
        
        @param request: CloseOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CloseOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.close_reason):
            query['CloseReason'] = request.close_reason
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CloseOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CloseOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def close_order(
        self,
        request: dms_enterprise_20181101_models.CloseOrderRequest,
    ) -> dms_enterprise_20181101_models.CloseOrderResponse:
        """
        @summary Closes a ticket.
        
        @param request: CloseOrderRequest
        @return: CloseOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.close_order_with_options(request, runtime)

    async def close_order_async(
        self,
        request: dms_enterprise_20181101_models.CloseOrderRequest,
    ) -> dms_enterprise_20181101_models.CloseOrderResponse:
        """
        @summary Closes a ticket.
        
        @param request: CloseOrderRequest
        @return: CloseOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.close_order_with_options_async(request, runtime)

    def create_abac_authorization_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateAbacAuthorizationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateAbacAuthorizationResponse:
        """
        @summary 创建权限策略授权
        
        @param request: CreateAbacAuthorizationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAbacAuthorizationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.identity_type):
            query['IdentityType'] = request.identity_type
        if not UtilClient.is_unset(request.policy_id):
            query['PolicyId'] = request.policy_id
        if not UtilClient.is_unset(request.role_id):
            query['RoleId'] = request.role_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAbacAuthorization',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateAbacAuthorizationResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_abac_authorization_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateAbacAuthorizationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateAbacAuthorizationResponse:
        """
        @summary 创建权限策略授权
        
        @param request: CreateAbacAuthorizationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAbacAuthorizationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.identity_type):
            query['IdentityType'] = request.identity_type
        if not UtilClient.is_unset(request.policy_id):
            query['PolicyId'] = request.policy_id
        if not UtilClient.is_unset(request.role_id):
            query['RoleId'] = request.role_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAbacAuthorization',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateAbacAuthorizationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_abac_authorization(
        self,
        request: dms_enterprise_20181101_models.CreateAbacAuthorizationRequest,
    ) -> dms_enterprise_20181101_models.CreateAbacAuthorizationResponse:
        """
        @summary 创建权限策略授权
        
        @param request: CreateAbacAuthorizationRequest
        @return: CreateAbacAuthorizationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_abac_authorization_with_options(request, runtime)

    async def create_abac_authorization_async(
        self,
        request: dms_enterprise_20181101_models.CreateAbacAuthorizationRequest,
    ) -> dms_enterprise_20181101_models.CreateAbacAuthorizationResponse:
        """
        @summary 创建权限策略授权
        
        @param request: CreateAbacAuthorizationRequest
        @return: CreateAbacAuthorizationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_abac_authorization_with_options_async(request, runtime)

    def create_abac_policy_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateAbacPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateAbacPolicyResponse:
        """
        @summary 创建权限策略
        
        @param request: CreateAbacPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAbacPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.abac_policy_content):
            query['AbacPolicyContent'] = request.abac_policy_content
        if not UtilClient.is_unset(request.abac_policy_desc):
            query['AbacPolicyDesc'] = request.abac_policy_desc
        if not UtilClient.is_unset(request.abac_policy_name):
            query['AbacPolicyName'] = request.abac_policy_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAbacPolicy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateAbacPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_abac_policy_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateAbacPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateAbacPolicyResponse:
        """
        @summary 创建权限策略
        
        @param request: CreateAbacPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAbacPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.abac_policy_content):
            query['AbacPolicyContent'] = request.abac_policy_content
        if not UtilClient.is_unset(request.abac_policy_desc):
            query['AbacPolicyDesc'] = request.abac_policy_desc
        if not UtilClient.is_unset(request.abac_policy_name):
            query['AbacPolicyName'] = request.abac_policy_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAbacPolicy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateAbacPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_abac_policy(
        self,
        request: dms_enterprise_20181101_models.CreateAbacPolicyRequest,
    ) -> dms_enterprise_20181101_models.CreateAbacPolicyResponse:
        """
        @summary 创建权限策略
        
        @param request: CreateAbacPolicyRequest
        @return: CreateAbacPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_abac_policy_with_options(request, runtime)

    async def create_abac_policy_async(
        self,
        request: dms_enterprise_20181101_models.CreateAbacPolicyRequest,
    ) -> dms_enterprise_20181101_models.CreateAbacPolicyResponse:
        """
        @summary 创建权限策略
        
        @param request: CreateAbacPolicyRequest
        @return: CreateAbacPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_abac_policy_with_options_async(request, runtime)

    def create_authority_template_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateAuthorityTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateAuthorityTemplateResponse:
        """
        @summary Creates a permission template
        
        @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: CreateAuthorityTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAuthorityTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAuthorityTemplate',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateAuthorityTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_authority_template_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateAuthorityTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateAuthorityTemplateResponse:
        """
        @summary Creates a permission template
        
        @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: CreateAuthorityTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAuthorityTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateAuthorityTemplate',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateAuthorityTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_authority_template(
        self,
        request: dms_enterprise_20181101_models.CreateAuthorityTemplateRequest,
    ) -> dms_enterprise_20181101_models.CreateAuthorityTemplateResponse:
        """
        @summary Creates a permission template
        
        @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: CreateAuthorityTemplateRequest
        @return: CreateAuthorityTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_authority_template_with_options(request, runtime)

    async def create_authority_template_async(
        self,
        request: dms_enterprise_20181101_models.CreateAuthorityTemplateRequest,
    ) -> dms_enterprise_20181101_models.CreateAuthorityTemplateResponse:
        """
        @summary Creates a permission template
        
        @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: CreateAuthorityTemplateRequest
        @return: CreateAuthorityTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_authority_template_with_options_async(request, runtime)

    def create_data_archive_order_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataArchiveOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataArchiveOrderResponse:
        """
        @summary Creates a data archiving ticket to archive data to destinations such as dedicated storage space or ApsaraDB RDS for MySQL instances.
        
        @description You can call this API operation only for database instances that are managed in Security Collaboration mode.
        
        @param tmp_req: CreateDataArchiveOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataArchiveOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataArchiveOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.parent_id):
            query['ParentId'] = request.parent_id
        if not UtilClient.is_unset(request.plugin_type):
            query['PluginType'] = request.plugin_type
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataArchiveOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataArchiveOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_data_archive_order_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataArchiveOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataArchiveOrderResponse:
        """
        @summary Creates a data archiving ticket to archive data to destinations such as dedicated storage space or ApsaraDB RDS for MySQL instances.
        
        @description You can call this API operation only for database instances that are managed in Security Collaboration mode.
        
        @param tmp_req: CreateDataArchiveOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataArchiveOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataArchiveOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.parent_id):
            query['ParentId'] = request.parent_id
        if not UtilClient.is_unset(request.plugin_type):
            query['PluginType'] = request.plugin_type
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataArchiveOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataArchiveOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_data_archive_order(
        self,
        request: dms_enterprise_20181101_models.CreateDataArchiveOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDataArchiveOrderResponse:
        """
        @summary Creates a data archiving ticket to archive data to destinations such as dedicated storage space or ApsaraDB RDS for MySQL instances.
        
        @description You can call this API operation only for database instances that are managed in Security Collaboration mode.
        
        @param request: CreateDataArchiveOrderRequest
        @return: CreateDataArchiveOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_data_archive_order_with_options(request, runtime)

    async def create_data_archive_order_async(
        self,
        request: dms_enterprise_20181101_models.CreateDataArchiveOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDataArchiveOrderResponse:
        """
        @summary Creates a data archiving ticket to archive data to destinations such as dedicated storage space or ApsaraDB RDS for MySQL instances.
        
        @description You can call this API operation only for database instances that are managed in Security Collaboration mode.
        
        @param request: CreateDataArchiveOrderRequest
        @return: CreateDataArchiveOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_data_archive_order_with_options_async(request, runtime)

    def create_data_correct_order_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataCorrectOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataCorrectOrderResponse:
        """
        @summary Creates a ticket for changing data in Data Management (DMS).
        
        @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
        
        @param tmp_req: CreateDataCorrectOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataCorrectOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataCorrectOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataCorrectOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataCorrectOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_data_correct_order_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataCorrectOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataCorrectOrderResponse:
        """
        @summary Creates a ticket for changing data in Data Management (DMS).
        
        @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
        
        @param tmp_req: CreateDataCorrectOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataCorrectOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataCorrectOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataCorrectOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataCorrectOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_data_correct_order(
        self,
        request: dms_enterprise_20181101_models.CreateDataCorrectOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDataCorrectOrderResponse:
        """
        @summary Creates a ticket for changing data in Data Management (DMS).
        
        @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
        
        @param request: CreateDataCorrectOrderRequest
        @return: CreateDataCorrectOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_data_correct_order_with_options(request, runtime)

    async def create_data_correct_order_async(
        self,
        request: dms_enterprise_20181101_models.CreateDataCorrectOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDataCorrectOrderResponse:
        """
        @summary Creates a ticket for changing data in Data Management (DMS).
        
        @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
        
        @param request: CreateDataCorrectOrderRequest
        @return: CreateDataCorrectOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_data_correct_order_with_options_async(request, runtime)

    def create_data_cron_clear_order_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataCronClearOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataCronClearOrderResponse:
        """
        @summary Creates a ticket for clearing historical data.
        
        @description For more information about the historical data cleaning, see [Clear historical data](https://help.aliyun.com/document_detail/162507.html).
        This operation can be used only for MySQL databases.
        
        @param tmp_req: CreateDataCronClearOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataCronClearOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataCronClearOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataCronClearOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataCronClearOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_data_cron_clear_order_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataCronClearOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataCronClearOrderResponse:
        """
        @summary Creates a ticket for clearing historical data.
        
        @description For more information about the historical data cleaning, see [Clear historical data](https://help.aliyun.com/document_detail/162507.html).
        This operation can be used only for MySQL databases.
        
        @param tmp_req: CreateDataCronClearOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataCronClearOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataCronClearOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataCronClearOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataCronClearOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_data_cron_clear_order(
        self,
        request: dms_enterprise_20181101_models.CreateDataCronClearOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDataCronClearOrderResponse:
        """
        @summary Creates a ticket for clearing historical data.
        
        @description For more information about the historical data cleaning, see [Clear historical data](https://help.aliyun.com/document_detail/162507.html).
        This operation can be used only for MySQL databases.
        
        @param request: CreateDataCronClearOrderRequest
        @return: CreateDataCronClearOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_data_cron_clear_order_with_options(request, runtime)

    async def create_data_cron_clear_order_async(
        self,
        request: dms_enterprise_20181101_models.CreateDataCronClearOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDataCronClearOrderResponse:
        """
        @summary Creates a ticket for clearing historical data.
        
        @description For more information about the historical data cleaning, see [Clear historical data](https://help.aliyun.com/document_detail/162507.html).
        This operation can be used only for MySQL databases.
        
        @param request: CreateDataCronClearOrderRequest
        @return: CreateDataCronClearOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_data_cron_clear_order_with_options_async(request, runtime)

    def create_data_export_order_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataExportOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataExportOrderResponse:
        """
        @summary Creates a ticket to export an SQL result set.
        
        @param tmp_req: CreateDataExportOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataExportOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataExportOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.plugin_param):
            request.plugin_param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.plugin_param, 'PluginParam', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.parent_id):
            query['ParentId'] = request.parent_id
        if not UtilClient.is_unset(request.plugin_param_shrink):
            query['PluginParam'] = request.plugin_param_shrink
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataExportOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataExportOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_data_export_order_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataExportOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataExportOrderResponse:
        """
        @summary Creates a ticket to export an SQL result set.
        
        @param tmp_req: CreateDataExportOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataExportOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataExportOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.plugin_param):
            request.plugin_param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.plugin_param, 'PluginParam', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.parent_id):
            query['ParentId'] = request.parent_id
        if not UtilClient.is_unset(request.plugin_param_shrink):
            query['PluginParam'] = request.plugin_param_shrink
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataExportOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataExportOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_data_export_order(
        self,
        request: dms_enterprise_20181101_models.CreateDataExportOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDataExportOrderResponse:
        """
        @summary Creates a ticket to export an SQL result set.
        
        @param request: CreateDataExportOrderRequest
        @return: CreateDataExportOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_data_export_order_with_options(request, runtime)

    async def create_data_export_order_async(
        self,
        request: dms_enterprise_20181101_models.CreateDataExportOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDataExportOrderResponse:
        """
        @summary Creates a ticket to export an SQL result set.
        
        @param request: CreateDataExportOrderRequest
        @return: CreateDataExportOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_data_export_order_with_options_async(request, runtime)

    def create_data_import_order_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataImportOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataImportOrderResponse:
        """
        @summary Creates a ticket for importing data to Data Management (DMS).
        
        @description For more information about the Large Data Import feature, see [Import data](https://help.aliyun.com/document_detail/161439.html).
        
        @param tmp_req: CreateDataImportOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataImportOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataImportOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataImportOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataImportOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_data_import_order_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataImportOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataImportOrderResponse:
        """
        @summary Creates a ticket for importing data to Data Management (DMS).
        
        @description For more information about the Large Data Import feature, see [Import data](https://help.aliyun.com/document_detail/161439.html).
        
        @param tmp_req: CreateDataImportOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataImportOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataImportOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataImportOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataImportOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_data_import_order(
        self,
        request: dms_enterprise_20181101_models.CreateDataImportOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDataImportOrderResponse:
        """
        @summary Creates a ticket for importing data to Data Management (DMS).
        
        @description For more information about the Large Data Import feature, see [Import data](https://help.aliyun.com/document_detail/161439.html).
        
        @param request: CreateDataImportOrderRequest
        @return: CreateDataImportOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_data_import_order_with_options(request, runtime)

    async def create_data_import_order_async(
        self,
        request: dms_enterprise_20181101_models.CreateDataImportOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDataImportOrderResponse:
        """
        @summary Creates a ticket for importing data to Data Management (DMS).
        
        @description For more information about the Large Data Import feature, see [Import data](https://help.aliyun.com/document_detail/161439.html).
        
        @param request: CreateDataImportOrderRequest
        @return: CreateDataImportOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_data_import_order_with_options_async(request, runtime)

    def create_data_lake_database_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataLakeDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataLakeDatabaseResponse:
        """
        @summary 新建湖仓数据库
        
        @param tmp_req: CreateDataLakeDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataLakeDatabaseResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataLakeDatabaseShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.parameters):
            request.parameters_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.parameters, 'Parameters', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.location):
            query['Location'] = request.location
        if not UtilClient.is_unset(request.parameters_shrink):
            query['Parameters'] = request.parameters_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataLakeDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataLakeDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_data_lake_database_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataLakeDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataLakeDatabaseResponse:
        """
        @summary 新建湖仓数据库
        
        @param tmp_req: CreateDataLakeDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataLakeDatabaseResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataLakeDatabaseShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.parameters):
            request.parameters_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.parameters, 'Parameters', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.location):
            query['Location'] = request.location
        if not UtilClient.is_unset(request.parameters_shrink):
            query['Parameters'] = request.parameters_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataLakeDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataLakeDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_data_lake_database(
        self,
        request: dms_enterprise_20181101_models.CreateDataLakeDatabaseRequest,
    ) -> dms_enterprise_20181101_models.CreateDataLakeDatabaseResponse:
        """
        @summary 新建湖仓数据库
        
        @param request: CreateDataLakeDatabaseRequest
        @return: CreateDataLakeDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_data_lake_database_with_options(request, runtime)

    async def create_data_lake_database_async(
        self,
        request: dms_enterprise_20181101_models.CreateDataLakeDatabaseRequest,
    ) -> dms_enterprise_20181101_models.CreateDataLakeDatabaseResponse:
        """
        @summary 新建湖仓数据库
        
        @param request: CreateDataLakeDatabaseRequest
        @return: CreateDataLakeDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_data_lake_database_with_options_async(request, runtime)

    def create_data_lake_function_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataLakeFunctionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataLakeFunctionResponse:
        """
        @summary 新建湖仓自定义函数
        
        @param tmp_req: CreateDataLakeFunctionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataLakeFunctionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataLakeFunctionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.function_input):
            request.function_input_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.function_input, 'FunctionInput', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.function_input_shrink):
            body['FunctionInput'] = request.function_input_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateDataLakeFunction',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataLakeFunctionResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_data_lake_function_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataLakeFunctionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataLakeFunctionResponse:
        """
        @summary 新建湖仓自定义函数
        
        @param tmp_req: CreateDataLakeFunctionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataLakeFunctionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataLakeFunctionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.function_input):
            request.function_input_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.function_input, 'FunctionInput', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.function_input_shrink):
            body['FunctionInput'] = request.function_input_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateDataLakeFunction',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataLakeFunctionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_data_lake_function(
        self,
        request: dms_enterprise_20181101_models.CreateDataLakeFunctionRequest,
    ) -> dms_enterprise_20181101_models.CreateDataLakeFunctionResponse:
        """
        @summary 新建湖仓自定义函数
        
        @param request: CreateDataLakeFunctionRequest
        @return: CreateDataLakeFunctionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_data_lake_function_with_options(request, runtime)

    async def create_data_lake_function_async(
        self,
        request: dms_enterprise_20181101_models.CreateDataLakeFunctionRequest,
    ) -> dms_enterprise_20181101_models.CreateDataLakeFunctionResponse:
        """
        @summary 新建湖仓自定义函数
        
        @param request: CreateDataLakeFunctionRequest
        @return: CreateDataLakeFunctionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_data_lake_function_with_options_async(request, runtime)

    def create_data_lake_partition_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataLakePartitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataLakePartitionResponse:
        """
        @summary 新建湖仓表分区
        
        @param tmp_req: CreateDataLakePartitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataLakePartitionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataLakePartitionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.partition_input):
            request.partition_input_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.partition_input, 'PartitionInput', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.if_not_exists):
            query['IfNotExists'] = request.if_not_exists
        if not UtilClient.is_unset(request.need_result):
            query['NeedResult'] = request.need_result
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.partition_input_shrink):
            body['PartitionInput'] = request.partition_input_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateDataLakePartition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataLakePartitionResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_data_lake_partition_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataLakePartitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataLakePartitionResponse:
        """
        @summary 新建湖仓表分区
        
        @param tmp_req: CreateDataLakePartitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataLakePartitionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataLakePartitionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.partition_input):
            request.partition_input_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.partition_input, 'PartitionInput', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.if_not_exists):
            query['IfNotExists'] = request.if_not_exists
        if not UtilClient.is_unset(request.need_result):
            query['NeedResult'] = request.need_result
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.partition_input_shrink):
            body['PartitionInput'] = request.partition_input_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateDataLakePartition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataLakePartitionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_data_lake_partition(
        self,
        request: dms_enterprise_20181101_models.CreateDataLakePartitionRequest,
    ) -> dms_enterprise_20181101_models.CreateDataLakePartitionResponse:
        """
        @summary 新建湖仓表分区
        
        @param request: CreateDataLakePartitionRequest
        @return: CreateDataLakePartitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_data_lake_partition_with_options(request, runtime)

    async def create_data_lake_partition_async(
        self,
        request: dms_enterprise_20181101_models.CreateDataLakePartitionRequest,
    ) -> dms_enterprise_20181101_models.CreateDataLakePartitionResponse:
        """
        @summary 新建湖仓表分区
        
        @param request: CreateDataLakePartitionRequest
        @return: CreateDataLakePartitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_data_lake_partition_with_options_async(request, runtime)

    def create_data_lake_table_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataLakeTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataLakeTableResponse:
        """
        @summary 新建湖仓表
        
        @param tmp_req: CreateDataLakeTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataLakeTableResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataLakeTableShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.table_input):
            request.table_input_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.table_input, 'TableInput', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.table_input_shrink):
            body['TableInput'] = request.table_input_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateDataLakeTable',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataLakeTableResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_data_lake_table_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataLakeTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataLakeTableResponse:
        """
        @summary 新建湖仓表
        
        @param tmp_req: CreateDataLakeTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataLakeTableResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataLakeTableShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.table_input):
            request.table_input_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.table_input, 'TableInput', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.table_input_shrink):
            body['TableInput'] = request.table_input_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateDataLakeTable',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataLakeTableResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_data_lake_table(
        self,
        request: dms_enterprise_20181101_models.CreateDataLakeTableRequest,
    ) -> dms_enterprise_20181101_models.CreateDataLakeTableResponse:
        """
        @summary 新建湖仓表
        
        @param request: CreateDataLakeTableRequest
        @return: CreateDataLakeTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_data_lake_table_with_options(request, runtime)

    async def create_data_lake_table_async(
        self,
        request: dms_enterprise_20181101_models.CreateDataLakeTableRequest,
    ) -> dms_enterprise_20181101_models.CreateDataLakeTableResponse:
        """
        @summary 新建湖仓表
        
        @param request: CreateDataLakeTableRequest
        @return: CreateDataLakeTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_data_lake_table_with_options_async(request, runtime)

    def create_data_track_order_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataTrackOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataTrackOrderResponse:
        """
        @summary Creates a data tracking ticket.
        
        @description This operation is available only for instances that are managed in Security Collaboration mode.
        
        @param tmp_req: CreateDataTrackOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataTrackOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataTrackOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataTrackOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataTrackOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_data_track_order_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDataTrackOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDataTrackOrderResponse:
        """
        @summary Creates a data tracking ticket.
        
        @description This operation is available only for instances that are managed in Security Collaboration mode.
        
        @param tmp_req: CreateDataTrackOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDataTrackOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDataTrackOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDataTrackOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDataTrackOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_data_track_order(
        self,
        request: dms_enterprise_20181101_models.CreateDataTrackOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDataTrackOrderResponse:
        """
        @summary Creates a data tracking ticket.
        
        @description This operation is available only for instances that are managed in Security Collaboration mode.
        
        @param request: CreateDataTrackOrderRequest
        @return: CreateDataTrackOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_data_track_order_with_options(request, runtime)

    async def create_data_track_order_async(
        self,
        request: dms_enterprise_20181101_models.CreateDataTrackOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDataTrackOrderResponse:
        """
        @summary Creates a data tracking ticket.
        
        @description This operation is available only for instances that are managed in Security Collaboration mode.
        
        @param request: CreateDataTrackOrderRequest
        @return: CreateDataTrackOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_data_track_order_with_options_async(request, runtime)

    def create_database_export_order_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDatabaseExportOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDatabaseExportOrderResponse:
        """
        @summary Creates a database export ticket.
        
        @param tmp_req: CreateDatabaseExportOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDatabaseExportOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDatabaseExportOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.plugin_param):
            request.plugin_param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.plugin_param, 'PluginParam', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.parent_id):
            query['ParentId'] = request.parent_id
        if not UtilClient.is_unset(request.plugin_param_shrink):
            query['PluginParam'] = request.plugin_param_shrink
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDatabaseExportOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDatabaseExportOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_database_export_order_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateDatabaseExportOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDatabaseExportOrderResponse:
        """
        @summary Creates a database export ticket.
        
        @param tmp_req: CreateDatabaseExportOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDatabaseExportOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateDatabaseExportOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.plugin_param):
            request.plugin_param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.plugin_param, 'PluginParam', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.parent_id):
            query['ParentId'] = request.parent_id
        if not UtilClient.is_unset(request.plugin_param_shrink):
            query['PluginParam'] = request.plugin_param_shrink
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDatabaseExportOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDatabaseExportOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_database_export_order(
        self,
        request: dms_enterprise_20181101_models.CreateDatabaseExportOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDatabaseExportOrderResponse:
        """
        @summary Creates a database export ticket.
        
        @param request: CreateDatabaseExportOrderRequest
        @return: CreateDatabaseExportOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_database_export_order_with_options(request, runtime)

    async def create_database_export_order_async(
        self,
        request: dms_enterprise_20181101_models.CreateDatabaseExportOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateDatabaseExportOrderResponse:
        """
        @summary Creates a database export ticket.
        
        @param request: CreateDatabaseExportOrderRequest
        @return: CreateDatabaseExportOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_database_export_order_with_options_async(request, runtime)

    def create_dify_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateDifyInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDifyInstanceResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: CreateDifyInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDifyInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.adbpg_instance_mode):
            query['AdbpgInstanceMode'] = request.adbpg_instance_mode
        if not UtilClient.is_unset(request.backup_vswitch_id):
            query['BackupVSwitchId'] = request.backup_vswitch_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.database_option):
            query['DatabaseOption'] = request.database_option
        if not UtilClient.is_unset(request.db_engine_type):
            query['DbEngineType'] = request.db_engine_type
        if not UtilClient.is_unset(request.db_engine_version):
            query['DbEngineVersion'] = request.db_engine_version
        if not UtilClient.is_unset(request.db_instance_account):
            query['DbInstanceAccount'] = request.db_instance_account
        if not UtilClient.is_unset(request.db_instance_category):
            query['DbInstanceCategory'] = request.db_instance_category
        if not UtilClient.is_unset(request.db_instance_class):
            query['DbInstanceClass'] = request.db_instance_class
        if not UtilClient.is_unset(request.db_instance_password):
            query['DbInstancePassword'] = request.db_instance_password
        if not UtilClient.is_unset(request.db_resource_id):
            query['DbResourceId'] = request.db_resource_id
        if not UtilClient.is_unset(request.db_storage_size):
            query['DbStorageSize'] = request.db_storage_size
        if not UtilClient.is_unset(request.db_storage_type):
            query['DbStorageType'] = request.db_storage_type
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.edition):
            query['Edition'] = request.edition
        if not UtilClient.is_unset(request.enable_extra_endpoint):
            query['EnableExtraEndpoint'] = request.enable_extra_endpoint
        if not UtilClient.is_unset(request.gpu_node_spec):
            query['GpuNodeSpec'] = request.gpu_node_spec
        if not UtilClient.is_unset(request.kv_store_account):
            query['KvStoreAccount'] = request.kv_store_account
        if not UtilClient.is_unset(request.kv_store_engine_version):
            query['KvStoreEngineVersion'] = request.kv_store_engine_version
        if not UtilClient.is_unset(request.kv_store_instance_class):
            query['KvStoreInstanceClass'] = request.kv_store_instance_class
        if not UtilClient.is_unset(request.kv_store_node_type):
            query['KvStoreNodeType'] = request.kv_store_node_type
        if not UtilClient.is_unset(request.kv_store_option):
            query['KvStoreOption'] = request.kv_store_option
        if not UtilClient.is_unset(request.kv_store_password):
            query['KvStorePassword'] = request.kv_store_password
        if not UtilClient.is_unset(request.kv_store_resource_id):
            query['KvStoreResourceId'] = request.kv_store_resource_id
        if not UtilClient.is_unset(request.kv_store_type):
            query['KvStoreType'] = request.kv_store_type
        if not UtilClient.is_unset(request.major_version):
            query['MajorVersion'] = request.major_version
        if not UtilClient.is_unset(request.model_id):
            query['ModelId'] = request.model_id
        if not UtilClient.is_unset(request.model_option):
            query['ModelOption'] = request.model_option
        if not UtilClient.is_unset(request.nat_gateway_option):
            query['NatGatewayOption'] = request.nat_gateway_option
        if not UtilClient.is_unset(request.oss_path):
            query['OssPath'] = request.oss_path
        if not UtilClient.is_unset(request.oss_resource_id):
            query['OssResourceId'] = request.oss_resource_id
        if not UtilClient.is_unset(request.pay_period):
            query['PayPeriod'] = request.pay_period
        if not UtilClient.is_unset(request.pay_period_type):
            query['PayPeriodType'] = request.pay_period_type
        if not UtilClient.is_unset(request.pay_type):
            query['PayType'] = request.pay_type
        if not UtilClient.is_unset(request.replicas):
            query['Replicas'] = request.replicas
        if not UtilClient.is_unset(request.resource_quota):
            query['ResourceQuota'] = request.resource_quota
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.seg_disk_performance_level):
            query['SegDiskPerformanceLevel'] = request.seg_disk_performance_level
        if not UtilClient.is_unset(request.seg_node_num):
            query['SegNodeNum'] = request.seg_node_num
        if not UtilClient.is_unset(request.storage_type):
            query['StorageType'] = request.storage_type
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vectordb_account):
            query['VectordbAccount'] = request.vectordb_account
        if not UtilClient.is_unset(request.vectordb_category):
            query['VectordbCategory'] = request.vectordb_category
        if not UtilClient.is_unset(request.vectordb_engine_version):
            query['VectordbEngineVersion'] = request.vectordb_engine_version
        if not UtilClient.is_unset(request.vectordb_instance_spec):
            query['VectordbInstanceSpec'] = request.vectordb_instance_spec
        if not UtilClient.is_unset(request.vectordb_option):
            query['VectordbOption'] = request.vectordb_option
        if not UtilClient.is_unset(request.vectordb_password):
            query['VectordbPassword'] = request.vectordb_password
        if not UtilClient.is_unset(request.vectordb_resource_id):
            query['VectordbResourceId'] = request.vectordb_resource_id
        if not UtilClient.is_unset(request.vectordb_storage_size):
            query['VectordbStorageSize'] = request.vectordb_storage_size
        if not UtilClient.is_unset(request.vectordb_storage_type):
            query['VectordbStorageType'] = request.vectordb_storage_type
        if not UtilClient.is_unset(request.vectordb_type):
            query['VectordbType'] = request.vectordb_type
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.workspace_description):
            query['WorkspaceDescription'] = request.workspace_description
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        if not UtilClient.is_unset(request.workspace_name):
            query['WorkspaceName'] = request.workspace_name
        if not UtilClient.is_unset(request.workspace_option):
            query['WorkspaceOption'] = request.workspace_option
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDifyInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDifyInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_dify_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateDifyInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateDifyInstanceResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: CreateDifyInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateDifyInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.adbpg_instance_mode):
            query['AdbpgInstanceMode'] = request.adbpg_instance_mode
        if not UtilClient.is_unset(request.backup_vswitch_id):
            query['BackupVSwitchId'] = request.backup_vswitch_id
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.database_option):
            query['DatabaseOption'] = request.database_option
        if not UtilClient.is_unset(request.db_engine_type):
            query['DbEngineType'] = request.db_engine_type
        if not UtilClient.is_unset(request.db_engine_version):
            query['DbEngineVersion'] = request.db_engine_version
        if not UtilClient.is_unset(request.db_instance_account):
            query['DbInstanceAccount'] = request.db_instance_account
        if not UtilClient.is_unset(request.db_instance_category):
            query['DbInstanceCategory'] = request.db_instance_category
        if not UtilClient.is_unset(request.db_instance_class):
            query['DbInstanceClass'] = request.db_instance_class
        if not UtilClient.is_unset(request.db_instance_password):
            query['DbInstancePassword'] = request.db_instance_password
        if not UtilClient.is_unset(request.db_resource_id):
            query['DbResourceId'] = request.db_resource_id
        if not UtilClient.is_unset(request.db_storage_size):
            query['DbStorageSize'] = request.db_storage_size
        if not UtilClient.is_unset(request.db_storage_type):
            query['DbStorageType'] = request.db_storage_type
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.edition):
            query['Edition'] = request.edition
        if not UtilClient.is_unset(request.enable_extra_endpoint):
            query['EnableExtraEndpoint'] = request.enable_extra_endpoint
        if not UtilClient.is_unset(request.gpu_node_spec):
            query['GpuNodeSpec'] = request.gpu_node_spec
        if not UtilClient.is_unset(request.kv_store_account):
            query['KvStoreAccount'] = request.kv_store_account
        if not UtilClient.is_unset(request.kv_store_engine_version):
            query['KvStoreEngineVersion'] = request.kv_store_engine_version
        if not UtilClient.is_unset(request.kv_store_instance_class):
            query['KvStoreInstanceClass'] = request.kv_store_instance_class
        if not UtilClient.is_unset(request.kv_store_node_type):
            query['KvStoreNodeType'] = request.kv_store_node_type
        if not UtilClient.is_unset(request.kv_store_option):
            query['KvStoreOption'] = request.kv_store_option
        if not UtilClient.is_unset(request.kv_store_password):
            query['KvStorePassword'] = request.kv_store_password
        if not UtilClient.is_unset(request.kv_store_resource_id):
            query['KvStoreResourceId'] = request.kv_store_resource_id
        if not UtilClient.is_unset(request.kv_store_type):
            query['KvStoreType'] = request.kv_store_type
        if not UtilClient.is_unset(request.major_version):
            query['MajorVersion'] = request.major_version
        if not UtilClient.is_unset(request.model_id):
            query['ModelId'] = request.model_id
        if not UtilClient.is_unset(request.model_option):
            query['ModelOption'] = request.model_option
        if not UtilClient.is_unset(request.nat_gateway_option):
            query['NatGatewayOption'] = request.nat_gateway_option
        if not UtilClient.is_unset(request.oss_path):
            query['OssPath'] = request.oss_path
        if not UtilClient.is_unset(request.oss_resource_id):
            query['OssResourceId'] = request.oss_resource_id
        if not UtilClient.is_unset(request.pay_period):
            query['PayPeriod'] = request.pay_period
        if not UtilClient.is_unset(request.pay_period_type):
            query['PayPeriodType'] = request.pay_period_type
        if not UtilClient.is_unset(request.pay_type):
            query['PayType'] = request.pay_type
        if not UtilClient.is_unset(request.replicas):
            query['Replicas'] = request.replicas
        if not UtilClient.is_unset(request.resource_quota):
            query['ResourceQuota'] = request.resource_quota
        if not UtilClient.is_unset(request.security_group_id):
            query['SecurityGroupId'] = request.security_group_id
        if not UtilClient.is_unset(request.seg_disk_performance_level):
            query['SegDiskPerformanceLevel'] = request.seg_disk_performance_level
        if not UtilClient.is_unset(request.seg_node_num):
            query['SegNodeNum'] = request.seg_node_num
        if not UtilClient.is_unset(request.storage_type):
            query['StorageType'] = request.storage_type
        if not UtilClient.is_unset(request.v_switch_id):
            query['VSwitchId'] = request.v_switch_id
        if not UtilClient.is_unset(request.vectordb_account):
            query['VectordbAccount'] = request.vectordb_account
        if not UtilClient.is_unset(request.vectordb_category):
            query['VectordbCategory'] = request.vectordb_category
        if not UtilClient.is_unset(request.vectordb_engine_version):
            query['VectordbEngineVersion'] = request.vectordb_engine_version
        if not UtilClient.is_unset(request.vectordb_instance_spec):
            query['VectordbInstanceSpec'] = request.vectordb_instance_spec
        if not UtilClient.is_unset(request.vectordb_option):
            query['VectordbOption'] = request.vectordb_option
        if not UtilClient.is_unset(request.vectordb_password):
            query['VectordbPassword'] = request.vectordb_password
        if not UtilClient.is_unset(request.vectordb_resource_id):
            query['VectordbResourceId'] = request.vectordb_resource_id
        if not UtilClient.is_unset(request.vectordb_storage_size):
            query['VectordbStorageSize'] = request.vectordb_storage_size
        if not UtilClient.is_unset(request.vectordb_storage_type):
            query['VectordbStorageType'] = request.vectordb_storage_type
        if not UtilClient.is_unset(request.vectordb_type):
            query['VectordbType'] = request.vectordb_type
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        if not UtilClient.is_unset(request.workspace_description):
            query['WorkspaceDescription'] = request.workspace_description
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        if not UtilClient.is_unset(request.workspace_name):
            query['WorkspaceName'] = request.workspace_name
        if not UtilClient.is_unset(request.workspace_option):
            query['WorkspaceOption'] = request.workspace_option
        if not UtilClient.is_unset(request.zone_id):
            query['ZoneId'] = request.zone_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateDifyInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateDifyInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_dify_instance(
        self,
        request: dms_enterprise_20181101_models.CreateDifyInstanceRequest,
    ) -> dms_enterprise_20181101_models.CreateDifyInstanceResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: CreateDifyInstanceRequest
        @return: CreateDifyInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_dify_instance_with_options(request, runtime)

    async def create_dify_instance_async(
        self,
        request: dms_enterprise_20181101_models.CreateDifyInstanceRequest,
    ) -> dms_enterprise_20181101_models.CreateDifyInstanceResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: CreateDifyInstanceRequest
        @return: CreateDifyInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_dify_instance_with_options_async(request, runtime)

    def create_free_lock_correct_order_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateFreeLockCorrectOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateFreeLockCorrectOrderResponse:
        """
        @summary 创建无锁变更工单
        
        @description For more information about the lock-free change feature, see [Overview](https://help.aliyun.com/document_detail/207847.html).
        This operation can be used only for instances that are managed in Stable Change or Security Collaboration mode. For more information, see [Change data without the need to lock tables](https://help.aliyun.com/document_detail/96145.html) and [Change schemas without locking tables](https://help.aliyun.com/document_detail/98373.html).
        
        @param tmp_req: CreateFreeLockCorrectOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateFreeLockCorrectOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateFreeLockCorrectOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateFreeLockCorrectOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateFreeLockCorrectOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_free_lock_correct_order_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateFreeLockCorrectOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateFreeLockCorrectOrderResponse:
        """
        @summary 创建无锁变更工单
        
        @description For more information about the lock-free change feature, see [Overview](https://help.aliyun.com/document_detail/207847.html).
        This operation can be used only for instances that are managed in Stable Change or Security Collaboration mode. For more information, see [Change data without the need to lock tables](https://help.aliyun.com/document_detail/96145.html) and [Change schemas without locking tables](https://help.aliyun.com/document_detail/98373.html).
        
        @param tmp_req: CreateFreeLockCorrectOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateFreeLockCorrectOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateFreeLockCorrectOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateFreeLockCorrectOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateFreeLockCorrectOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_free_lock_correct_order(
        self,
        request: dms_enterprise_20181101_models.CreateFreeLockCorrectOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateFreeLockCorrectOrderResponse:
        """
        @summary 创建无锁变更工单
        
        @description For more information about the lock-free change feature, see [Overview](https://help.aliyun.com/document_detail/207847.html).
        This operation can be used only for instances that are managed in Stable Change or Security Collaboration mode. For more information, see [Change data without the need to lock tables](https://help.aliyun.com/document_detail/96145.html) and [Change schemas without locking tables](https://help.aliyun.com/document_detail/98373.html).
        
        @param request: CreateFreeLockCorrectOrderRequest
        @return: CreateFreeLockCorrectOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_free_lock_correct_order_with_options(request, runtime)

    async def create_free_lock_correct_order_async(
        self,
        request: dms_enterprise_20181101_models.CreateFreeLockCorrectOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateFreeLockCorrectOrderResponse:
        """
        @summary 创建无锁变更工单
        
        @description For more information about the lock-free change feature, see [Overview](https://help.aliyun.com/document_detail/207847.html).
        This operation can be used only for instances that are managed in Stable Change or Security Collaboration mode. For more information, see [Change data without the need to lock tables](https://help.aliyun.com/document_detail/96145.html) and [Change schemas without locking tables](https://help.aliyun.com/document_detail/98373.html).
        
        @param request: CreateFreeLockCorrectOrderRequest
        @return: CreateFreeLockCorrectOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_free_lock_correct_order_with_options_async(request, runtime)

    def create_lake_house_space_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateLakeHouseSpaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateLakeHouseSpaceResponse:
        """
        @summary Creates a workspace for data warehouse development in Data Management (DMS).
        
        @description    The workspace name must be unique within a tenant. If a workspace with the same name already exists within the tenant, the call may fail.
        You can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to query whether a workspace with a specific name already exists as a DMS administrator or database administrator (DBA).
        
        @param request: CreateLakeHouseSpaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLakeHouseSpaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dev_db_id):
            query['DevDbId'] = request.dev_db_id
        if not UtilClient.is_unset(request.dw_db_type):
            query['DwDbType'] = request.dw_db_type
        if not UtilClient.is_unset(request.mode):
            query['Mode'] = request.mode
        if not UtilClient.is_unset(request.prod_db_id):
            query['ProdDbId'] = request.prod_db_id
        if not UtilClient.is_unset(request.space_config):
            query['SpaceConfig'] = request.space_config
        if not UtilClient.is_unset(request.space_name):
            query['SpaceName'] = request.space_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLakeHouseSpace',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateLakeHouseSpaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_lake_house_space_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateLakeHouseSpaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateLakeHouseSpaceResponse:
        """
        @summary Creates a workspace for data warehouse development in Data Management (DMS).
        
        @description    The workspace name must be unique within a tenant. If a workspace with the same name already exists within the tenant, the call may fail.
        You can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to query whether a workspace with a specific name already exists as a DMS administrator or database administrator (DBA).
        
        @param request: CreateLakeHouseSpaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLakeHouseSpaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.dev_db_id):
            query['DevDbId'] = request.dev_db_id
        if not UtilClient.is_unset(request.dw_db_type):
            query['DwDbType'] = request.dw_db_type
        if not UtilClient.is_unset(request.mode):
            query['Mode'] = request.mode
        if not UtilClient.is_unset(request.prod_db_id):
            query['ProdDbId'] = request.prod_db_id
        if not UtilClient.is_unset(request.space_config):
            query['SpaceConfig'] = request.space_config
        if not UtilClient.is_unset(request.space_name):
            query['SpaceName'] = request.space_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLakeHouseSpace',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateLakeHouseSpaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_lake_house_space(
        self,
        request: dms_enterprise_20181101_models.CreateLakeHouseSpaceRequest,
    ) -> dms_enterprise_20181101_models.CreateLakeHouseSpaceResponse:
        """
        @summary Creates a workspace for data warehouse development in Data Management (DMS).
        
        @description    The workspace name must be unique within a tenant. If a workspace with the same name already exists within the tenant, the call may fail.
        You can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to query whether a workspace with a specific name already exists as a DMS administrator or database administrator (DBA).
        
        @param request: CreateLakeHouseSpaceRequest
        @return: CreateLakeHouseSpaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_lake_house_space_with_options(request, runtime)

    async def create_lake_house_space_async(
        self,
        request: dms_enterprise_20181101_models.CreateLakeHouseSpaceRequest,
    ) -> dms_enterprise_20181101_models.CreateLakeHouseSpaceResponse:
        """
        @summary Creates a workspace for data warehouse development in Data Management (DMS).
        
        @description    The workspace name must be unique within a tenant. If a workspace with the same name already exists within the tenant, the call may fail.
        You can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to query whether a workspace with a specific name already exists as a DMS administrator or database administrator (DBA).
        
        @param request: CreateLakeHouseSpaceRequest
        @return: CreateLakeHouseSpaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_lake_house_space_with_options_async(request, runtime)

    def create_logic_database_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateLogicDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateLogicDatabaseResponse:
        """
        @summary Creates a logical database in Database Management (DMS).
        
        @param tmp_req: CreateLogicDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLogicDatabaseResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateLogicDatabaseShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.database_ids):
            request.database_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.database_ids, 'DatabaseIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alias):
            query['Alias'] = request.alias
        if not UtilClient.is_unset(request.database_ids_shrink):
            query['DatabaseIds'] = request.database_ids_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLogicDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateLogicDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_logic_database_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateLogicDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateLogicDatabaseResponse:
        """
        @summary Creates a logical database in Database Management (DMS).
        
        @param tmp_req: CreateLogicDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateLogicDatabaseResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateLogicDatabaseShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.database_ids):
            request.database_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.database_ids, 'DatabaseIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alias):
            query['Alias'] = request.alias
        if not UtilClient.is_unset(request.database_ids_shrink):
            query['DatabaseIds'] = request.database_ids_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateLogicDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateLogicDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_logic_database(
        self,
        request: dms_enterprise_20181101_models.CreateLogicDatabaseRequest,
    ) -> dms_enterprise_20181101_models.CreateLogicDatabaseResponse:
        """
        @summary Creates a logical database in Database Management (DMS).
        
        @param request: CreateLogicDatabaseRequest
        @return: CreateLogicDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_logic_database_with_options(request, runtime)

    async def create_logic_database_async(
        self,
        request: dms_enterprise_20181101_models.CreateLogicDatabaseRequest,
    ) -> dms_enterprise_20181101_models.CreateLogicDatabaseResponse:
        """
        @summary Creates a logical database in Database Management (DMS).
        
        @param request: CreateLogicDatabaseRequest
        @return: CreateLogicDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_logic_database_with_options_async(request, runtime)

    def create_meta_category_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateMetaCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateMetaCategoryResponse:
        """
        @summary 创建资产类目
        
        @param request: CreateMetaCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMetaCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.parent_category_id):
            query['ParentCategoryId'] = request.parent_category_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateMetaCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateMetaCategoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_meta_category_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateMetaCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateMetaCategoryResponse:
        """
        @summary 创建资产类目
        
        @param request: CreateMetaCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMetaCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.parent_category_id):
            query['ParentCategoryId'] = request.parent_category_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateMetaCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateMetaCategoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_meta_category(
        self,
        request: dms_enterprise_20181101_models.CreateMetaCategoryRequest,
    ) -> dms_enterprise_20181101_models.CreateMetaCategoryResponse:
        """
        @summary 创建资产类目
        
        @param request: CreateMetaCategoryRequest
        @return: CreateMetaCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_meta_category_with_options(request, runtime)

    async def create_meta_category_async(
        self,
        request: dms_enterprise_20181101_models.CreateMetaCategoryRequest,
    ) -> dms_enterprise_20181101_models.CreateMetaCategoryResponse:
        """
        @summary 创建资产类目
        
        @param request: CreateMetaCategoryRequest
        @return: CreateMetaCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_meta_category_with_options_async(request, runtime)

    def create_order_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateOrderResponse:
        """
        @summary Creates a ticket in Data Management (DMS).
        
        @description To facilitate ticket creation, you can call the following dedicated operations to create some types of tickets:
        [CreateDataCorrectOrder](https://help.aliyun.com/document_detail/208388.html): creates a regular data change ticket.
        [CreateDataCronClearOrder](https://help.aliyun.com/document_detail/208385.html): creates a ticket to clear historical data.
        [CreateDataImportOrder](https://help.aliyun.com/document_detail/208387.html): creates a data import ticket.
        [CreateFreeLockCorrectOrder](https://help.aliyun.com/document_detail/208386.html): creates a lock-free change ticket.
        
        @param tmp_req: CreateOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.plugin_param):
            request.plugin_param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.plugin_param, 'PluginParam', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.plugin_type):
            query['PluginType'] = request.plugin_type
        if not UtilClient.is_unset(request.related_user_list):
            query['RelatedUserList'] = request.related_user_list
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        body = {}
        if not UtilClient.is_unset(request.plugin_param_shrink):
            body['PluginParam'] = request.plugin_param_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_order_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateOrderResponse:
        """
        @summary Creates a ticket in Data Management (DMS).
        
        @description To facilitate ticket creation, you can call the following dedicated operations to create some types of tickets:
        [CreateDataCorrectOrder](https://help.aliyun.com/document_detail/208388.html): creates a regular data change ticket.
        [CreateDataCronClearOrder](https://help.aliyun.com/document_detail/208385.html): creates a ticket to clear historical data.
        [CreateDataImportOrder](https://help.aliyun.com/document_detail/208387.html): creates a data import ticket.
        [CreateFreeLockCorrectOrder](https://help.aliyun.com/document_detail/208386.html): creates a lock-free change ticket.
        
        @param tmp_req: CreateOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.plugin_param):
            request.plugin_param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.plugin_param, 'PluginParam', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.plugin_type):
            query['PluginType'] = request.plugin_type
        if not UtilClient.is_unset(request.related_user_list):
            query['RelatedUserList'] = request.related_user_list
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        body = {}
        if not UtilClient.is_unset(request.plugin_param_shrink):
            body['PluginParam'] = request.plugin_param_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_order(
        self,
        request: dms_enterprise_20181101_models.CreateOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateOrderResponse:
        """
        @summary Creates a ticket in Data Management (DMS).
        
        @description To facilitate ticket creation, you can call the following dedicated operations to create some types of tickets:
        [CreateDataCorrectOrder](https://help.aliyun.com/document_detail/208388.html): creates a regular data change ticket.
        [CreateDataCronClearOrder](https://help.aliyun.com/document_detail/208385.html): creates a ticket to clear historical data.
        [CreateDataImportOrder](https://help.aliyun.com/document_detail/208387.html): creates a data import ticket.
        [CreateFreeLockCorrectOrder](https://help.aliyun.com/document_detail/208386.html): creates a lock-free change ticket.
        
        @param request: CreateOrderRequest
        @return: CreateOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_order_with_options(request, runtime)

    async def create_order_async(
        self,
        request: dms_enterprise_20181101_models.CreateOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateOrderResponse:
        """
        @summary Creates a ticket in Data Management (DMS).
        
        @description To facilitate ticket creation, you can call the following dedicated operations to create some types of tickets:
        [CreateDataCorrectOrder](https://help.aliyun.com/document_detail/208388.html): creates a regular data change ticket.
        [CreateDataCronClearOrder](https://help.aliyun.com/document_detail/208385.html): creates a ticket to clear historical data.
        [CreateDataImportOrder](https://help.aliyun.com/document_detail/208387.html): creates a data import ticket.
        [CreateFreeLockCorrectOrder](https://help.aliyun.com/document_detail/208386.html): creates a lock-free change ticket.
        
        @param request: CreateOrderRequest
        @return: CreateOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_order_with_options_async(request, runtime)

    def create_proc_correct_order_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateProcCorrectOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateProcCorrectOrderResponse:
        """
        @summary 创建可编程对象变更工单
        
        @param tmp_req: CreateProcCorrectOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateProcCorrectOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateProcCorrectOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateProcCorrectOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateProcCorrectOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_proc_correct_order_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateProcCorrectOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateProcCorrectOrderResponse:
        """
        @summary 创建可编程对象变更工单
        
        @param tmp_req: CreateProcCorrectOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateProcCorrectOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateProcCorrectOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateProcCorrectOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateProcCorrectOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_proc_correct_order(
        self,
        request: dms_enterprise_20181101_models.CreateProcCorrectOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateProcCorrectOrderResponse:
        """
        @summary 创建可编程对象变更工单
        
        @param request: CreateProcCorrectOrderRequest
        @return: CreateProcCorrectOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_proc_correct_order_with_options(request, runtime)

    async def create_proc_correct_order_async(
        self,
        request: dms_enterprise_20181101_models.CreateProcCorrectOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateProcCorrectOrderResponse:
        """
        @summary 创建可编程对象变更工单
        
        @param request: CreateProcCorrectOrderRequest
        @return: CreateProcCorrectOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_proc_correct_order_with_options_async(request, runtime)

    def create_proxy_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateProxyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateProxyResponse:
        """
        @summary Enables the secure access proxy feature for a database instance.
        
        @description - The database instance runs the MySQL or MariaDB database engine. For example, the database instance can be an ApsaraDB RDS for MySQL instance, a PolarDB for MySQL cluster, a Distributed Relational Database Service (DRDS) cluster, or an AnalyticDB for MySQL cluster. The database instance can also be a self-managed MySQL or MariaDB database, or a MySQL or MariaDB database in a third-party cloud.
        - The database instance resides in the China (Hangzhou) or China (Beijing) region.
        - You are a Data Management (DMS) administrator, a database administrator (DBA), or the owner of the database instance.
        
        @param request: CreateProxyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateProxyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.username):
            query['Username'] = request.username
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateProxy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateProxyResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_proxy_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateProxyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateProxyResponse:
        """
        @summary Enables the secure access proxy feature for a database instance.
        
        @description - The database instance runs the MySQL or MariaDB database engine. For example, the database instance can be an ApsaraDB RDS for MySQL instance, a PolarDB for MySQL cluster, a Distributed Relational Database Service (DRDS) cluster, or an AnalyticDB for MySQL cluster. The database instance can also be a self-managed MySQL or MariaDB database, or a MySQL or MariaDB database in a third-party cloud.
        - The database instance resides in the China (Hangzhou) or China (Beijing) region.
        - You are a Data Management (DMS) administrator, a database administrator (DBA), or the owner of the database instance.
        
        @param request: CreateProxyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateProxyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.password):
            query['Password'] = request.password
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.username):
            query['Username'] = request.username
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateProxy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateProxyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_proxy(
        self,
        request: dms_enterprise_20181101_models.CreateProxyRequest,
    ) -> dms_enterprise_20181101_models.CreateProxyResponse:
        """
        @summary Enables the secure access proxy feature for a database instance.
        
        @description - The database instance runs the MySQL or MariaDB database engine. For example, the database instance can be an ApsaraDB RDS for MySQL instance, a PolarDB for MySQL cluster, a Distributed Relational Database Service (DRDS) cluster, or an AnalyticDB for MySQL cluster. The database instance can also be a self-managed MySQL or MariaDB database, or a MySQL or MariaDB database in a third-party cloud.
        - The database instance resides in the China (Hangzhou) or China (Beijing) region.
        - You are a Data Management (DMS) administrator, a database administrator (DBA), or the owner of the database instance.
        
        @param request: CreateProxyRequest
        @return: CreateProxyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_proxy_with_options(request, runtime)

    async def create_proxy_async(
        self,
        request: dms_enterprise_20181101_models.CreateProxyRequest,
    ) -> dms_enterprise_20181101_models.CreateProxyResponse:
        """
        @summary Enables the secure access proxy feature for a database instance.
        
        @description - The database instance runs the MySQL or MariaDB database engine. For example, the database instance can be an ApsaraDB RDS for MySQL instance, a PolarDB for MySQL cluster, a Distributed Relational Database Service (DRDS) cluster, or an AnalyticDB for MySQL cluster. The database instance can also be a self-managed MySQL or MariaDB database, or a MySQL or MariaDB database in a third-party cloud.
        - The database instance resides in the China (Hangzhou) or China (Beijing) region.
        - You are a Data Management (DMS) administrator, a database administrator (DBA), or the owner of the database instance.
        
        @param request: CreateProxyRequest
        @return: CreateProxyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_proxy_with_options_async(request, runtime)

    def create_proxy_access_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateProxyAccessRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateProxyAccessResponse:
        """
        @summary You can call the CreateProxyAccess to authorize users to access the DB instance through the Data Security Protection agent.
        
        @description - The data security protection feature is enabled for the instance.
        - Your user role is the administrator role, DBA role, or the owner of data security protection for the current instance.
        
        @param request: CreateProxyAccessRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateProxyAccessResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.indep_account):
            query['IndepAccount'] = request.indep_account
        if not UtilClient.is_unset(request.indep_password):
            query['IndepPassword'] = request.indep_password
        if not UtilClient.is_unset(request.proxy_id):
            query['ProxyId'] = request.proxy_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateProxyAccess',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateProxyAccessResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_proxy_access_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateProxyAccessRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateProxyAccessResponse:
        """
        @summary You can call the CreateProxyAccess to authorize users to access the DB instance through the Data Security Protection agent.
        
        @description - The data security protection feature is enabled for the instance.
        - Your user role is the administrator role, DBA role, or the owner of data security protection for the current instance.
        
        @param request: CreateProxyAccessRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateProxyAccessResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.indep_account):
            query['IndepAccount'] = request.indep_account
        if not UtilClient.is_unset(request.indep_password):
            query['IndepPassword'] = request.indep_password
        if not UtilClient.is_unset(request.proxy_id):
            query['ProxyId'] = request.proxy_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateProxyAccess',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateProxyAccessResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_proxy_access(
        self,
        request: dms_enterprise_20181101_models.CreateProxyAccessRequest,
    ) -> dms_enterprise_20181101_models.CreateProxyAccessResponse:
        """
        @summary You can call the CreateProxyAccess to authorize users to access the DB instance through the Data Security Protection agent.
        
        @description - The data security protection feature is enabled for the instance.
        - Your user role is the administrator role, DBA role, or the owner of data security protection for the current instance.
        
        @param request: CreateProxyAccessRequest
        @return: CreateProxyAccessResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_proxy_access_with_options(request, runtime)

    async def create_proxy_access_async(
        self,
        request: dms_enterprise_20181101_models.CreateProxyAccessRequest,
    ) -> dms_enterprise_20181101_models.CreateProxyAccessResponse:
        """
        @summary You can call the CreateProxyAccess to authorize users to access the DB instance through the Data Security Protection agent.
        
        @description - The data security protection feature is enabled for the instance.
        - Your user role is the administrator role, DBA role, or the owner of data security protection for the current instance.
        
        @param request: CreateProxyAccessRequest
        @return: CreateProxyAccessResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_proxy_access_with_options_async(request, runtime)

    def create_publish_group_task_with_options(
        self,
        request: dms_enterprise_20181101_models.CreatePublishGroupTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreatePublishGroupTaskResponse:
        """
        @summary Executes a schema design ticket.
        
        @param request: CreatePublishGroupTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePublishGroupTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.plan_time):
            query['PlanTime'] = request.plan_time
        if not UtilClient.is_unset(request.publish_strategy):
            query['PublishStrategy'] = request.publish_strategy
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePublishGroupTask',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreatePublishGroupTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_publish_group_task_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreatePublishGroupTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreatePublishGroupTaskResponse:
        """
        @summary Executes a schema design ticket.
        
        @param request: CreatePublishGroupTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePublishGroupTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.plan_time):
            query['PlanTime'] = request.plan_time
        if not UtilClient.is_unset(request.publish_strategy):
            query['PublishStrategy'] = request.publish_strategy
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreatePublishGroupTask',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreatePublishGroupTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_publish_group_task(
        self,
        request: dms_enterprise_20181101_models.CreatePublishGroupTaskRequest,
    ) -> dms_enterprise_20181101_models.CreatePublishGroupTaskResponse:
        """
        @summary Executes a schema design ticket.
        
        @param request: CreatePublishGroupTaskRequest
        @return: CreatePublishGroupTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_publish_group_task_with_options(request, runtime)

    async def create_publish_group_task_async(
        self,
        request: dms_enterprise_20181101_models.CreatePublishGroupTaskRequest,
    ) -> dms_enterprise_20181101_models.CreatePublishGroupTaskResponse:
        """
        @summary Executes a schema design ticket.
        
        @param request: CreatePublishGroupTaskRequest
        @return: CreatePublishGroupTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_publish_group_task_with_options_async(request, runtime)

    def create_sqlreview_order_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateSQLReviewOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateSQLReviewOrderResponse:
        """
        @summary Creates a SQL review ticket.
        
        @description You can call this operation only for database instances that are managed in Security Collaboration mode.
        For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param tmp_req: CreateSQLReviewOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSQLReviewOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateSQLReviewOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSQLReviewOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateSQLReviewOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_sqlreview_order_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateSQLReviewOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateSQLReviewOrderResponse:
        """
        @summary Creates a SQL review ticket.
        
        @description You can call this operation only for database instances that are managed in Security Collaboration mode.
        For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param tmp_req: CreateSQLReviewOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSQLReviewOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateSQLReviewOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateSQLReviewOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateSQLReviewOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_sqlreview_order(
        self,
        request: dms_enterprise_20181101_models.CreateSQLReviewOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateSQLReviewOrderResponse:
        """
        @summary Creates a SQL review ticket.
        
        @description You can call this operation only for database instances that are managed in Security Collaboration mode.
        For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param request: CreateSQLReviewOrderRequest
        @return: CreateSQLReviewOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_sqlreview_order_with_options(request, runtime)

    async def create_sqlreview_order_async(
        self,
        request: dms_enterprise_20181101_models.CreateSQLReviewOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateSQLReviewOrderResponse:
        """
        @summary Creates a SQL review ticket.
        
        @description You can call this operation only for database instances that are managed in Security Collaboration mode.
        For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param request: CreateSQLReviewOrderRequest
        @return: CreateSQLReviewOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_sqlreview_order_with_options_async(request, runtime)

    def create_scenario_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateScenarioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateScenarioResponse:
        """
        @summary Creates a business scenario to group task flows by business scenario.
        
        @param request: CreateScenarioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateScenarioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.scenario_name):
            query['ScenarioName'] = request.scenario_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateScenario',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateScenarioResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_scenario_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateScenarioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateScenarioResponse:
        """
        @summary Creates a business scenario to group task flows by business scenario.
        
        @param request: CreateScenarioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateScenarioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.scenario_name):
            query['ScenarioName'] = request.scenario_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateScenario',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateScenarioResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_scenario(
        self,
        request: dms_enterprise_20181101_models.CreateScenarioRequest,
    ) -> dms_enterprise_20181101_models.CreateScenarioResponse:
        """
        @summary Creates a business scenario to group task flows by business scenario.
        
        @param request: CreateScenarioRequest
        @return: CreateScenarioResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_scenario_with_options(request, runtime)

    async def create_scenario_async(
        self,
        request: dms_enterprise_20181101_models.CreateScenarioRequest,
    ) -> dms_enterprise_20181101_models.CreateScenarioResponse:
        """
        @summary Creates a business scenario to group task flows by business scenario.
        
        @param request: CreateScenarioRequest
        @return: CreateScenarioResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_scenario_with_options_async(request, runtime)

    def create_standard_group_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateStandardGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateStandardGroupResponse:
        """
        @summary Creates a security rule set.
        
        @param request: CreateStandardGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateStandardGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.group_name):
            query['GroupName'] = request.group_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateStandardGroup',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateStandardGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_standard_group_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateStandardGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateStandardGroupResponse:
        """
        @summary Creates a security rule set.
        
        @param request: CreateStandardGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateStandardGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.group_name):
            query['GroupName'] = request.group_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateStandardGroup',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateStandardGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_standard_group(
        self,
        request: dms_enterprise_20181101_models.CreateStandardGroupRequest,
    ) -> dms_enterprise_20181101_models.CreateStandardGroupResponse:
        """
        @summary Creates a security rule set.
        
        @param request: CreateStandardGroupRequest
        @return: CreateStandardGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_standard_group_with_options(request, runtime)

    async def create_standard_group_async(
        self,
        request: dms_enterprise_20181101_models.CreateStandardGroupRequest,
    ) -> dms_enterprise_20181101_models.CreateStandardGroupResponse:
        """
        @summary Creates a security rule set.
        
        @param request: CreateStandardGroupRequest
        @return: CreateStandardGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_standard_group_with_options_async(request, runtime)

    def create_struct_sync_order_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateStructSyncOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateStructSyncOrderResponse:
        """
        @summary Creates a schema synchronization ticket.
        
        @param tmp_req: CreateStructSyncOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateStructSyncOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateStructSyncOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateStructSyncOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateStructSyncOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_struct_sync_order_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateStructSyncOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateStructSyncOrderResponse:
        """
        @summary Creates a schema synchronization ticket.
        
        @param tmp_req: CreateStructSyncOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateStructSyncOrderResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateStructSyncOrderShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.param):
            request.param_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param, 'Param', 'json')
        if not UtilClient.is_unset(tmp_req.related_user_list):
            request.related_user_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.related_user_list, 'RelatedUserList', 'json')
        query = {}
        if not UtilClient.is_unset(request.attachment_key):
            query['AttachmentKey'] = request.attachment_key
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.param_shrink):
            query['Param'] = request.param_shrink
        if not UtilClient.is_unset(request.related_user_list_shrink):
            query['RelatedUserList'] = request.related_user_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateStructSyncOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateStructSyncOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_struct_sync_order(
        self,
        request: dms_enterprise_20181101_models.CreateStructSyncOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateStructSyncOrderResponse:
        """
        @summary Creates a schema synchronization ticket.
        
        @param request: CreateStructSyncOrderRequest
        @return: CreateStructSyncOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_struct_sync_order_with_options(request, runtime)

    async def create_struct_sync_order_async(
        self,
        request: dms_enterprise_20181101_models.CreateStructSyncOrderRequest,
    ) -> dms_enterprise_20181101_models.CreateStructSyncOrderResponse:
        """
        @summary Creates a schema synchronization ticket.
        
        @param request: CreateStructSyncOrderRequest
        @return: CreateStructSyncOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_struct_sync_order_with_options_async(request, runtime)

    def create_task_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateTaskResponse:
        """
        @summary Creates a task node for a task flow.
        
        @param request: CreateTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.graph_param):
            query['GraphParam'] = request.graph_param
        if not UtilClient.is_unset(request.node_content):
            query['NodeContent'] = request.node_content
        if not UtilClient.is_unset(request.node_name):
            query['NodeName'] = request.node_name
        if not UtilClient.is_unset(request.node_output):
            query['NodeOutput'] = request.node_output
        if not UtilClient.is_unset(request.node_type):
            query['NodeType'] = request.node_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.time_variables):
            query['TimeVariables'] = request.time_variables
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateTask',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_task_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateTaskResponse:
        """
        @summary Creates a task node for a task flow.
        
        @param request: CreateTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.graph_param):
            query['GraphParam'] = request.graph_param
        if not UtilClient.is_unset(request.node_content):
            query['NodeContent'] = request.node_content
        if not UtilClient.is_unset(request.node_name):
            query['NodeName'] = request.node_name
        if not UtilClient.is_unset(request.node_output):
            query['NodeOutput'] = request.node_output
        if not UtilClient.is_unset(request.node_type):
            query['NodeType'] = request.node_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.time_variables):
            query['TimeVariables'] = request.time_variables
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateTask',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_task(
        self,
        request: dms_enterprise_20181101_models.CreateTaskRequest,
    ) -> dms_enterprise_20181101_models.CreateTaskResponse:
        """
        @summary Creates a task node for a task flow.
        
        @param request: CreateTaskRequest
        @return: CreateTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_task_with_options(request, runtime)

    async def create_task_async(
        self,
        request: dms_enterprise_20181101_models.CreateTaskRequest,
    ) -> dms_enterprise_20181101_models.CreateTaskResponse:
        """
        @summary Creates a task node for a task flow.
        
        @param request: CreateTaskRequest
        @return: CreateTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_task_with_options_async(request, runtime)

    def create_task_flow_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateTaskFlowResponse:
        """
        @summary Creates a task flow.
        
        @param request: CreateTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_name):
            query['DagName'] = request.dag_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.scenario_id):
            query['ScenarioId'] = request.scenario_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateTaskFlowResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_task_flow_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateTaskFlowResponse:
        """
        @summary Creates a task flow.
        
        @param request: CreateTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_name):
            query['DagName'] = request.dag_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.scenario_id):
            query['ScenarioId'] = request.scenario_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateTaskFlowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_task_flow(
        self,
        request: dms_enterprise_20181101_models.CreateTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.CreateTaskFlowResponse:
        """
        @summary Creates a task flow.
        
        @param request: CreateTaskFlowRequest
        @return: CreateTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_task_flow_with_options(request, runtime)

    async def create_task_flow_async(
        self,
        request: dms_enterprise_20181101_models.CreateTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.CreateTaskFlowResponse:
        """
        @summary Creates a task flow.
        
        @param request: CreateTaskFlowRequest
        @return: CreateTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_task_flow_with_options_async(request, runtime)

    def create_upload_file_job_with_options(
        self,
        request: dms_enterprise_20181101_models.CreateUploadFileJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateUploadFileJobResponse:
        """
        @summary 创建上传附件任务
        
        @param request: CreateUploadFileJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateUploadFileJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.file_source):
            query['FileSource'] = request.file_source
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.upload_url):
            query['UploadURL'] = request.upload_url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateUploadFileJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateUploadFileJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_upload_file_job_with_options_async(
        self,
        request: dms_enterprise_20181101_models.CreateUploadFileJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateUploadFileJobResponse:
        """
        @summary 创建上传附件任务
        
        @param request: CreateUploadFileJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateUploadFileJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.file_source):
            query['FileSource'] = request.file_source
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.upload_url):
            query['UploadURL'] = request.upload_url
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateUploadFileJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateUploadFileJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_upload_file_job(
        self,
        request: dms_enterprise_20181101_models.CreateUploadFileJobRequest,
    ) -> dms_enterprise_20181101_models.CreateUploadFileJobResponse:
        """
        @summary 创建上传附件任务
        
        @param request: CreateUploadFileJobRequest
        @return: CreateUploadFileJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_upload_file_job_with_options(request, runtime)

    async def create_upload_file_job_async(
        self,
        request: dms_enterprise_20181101_models.CreateUploadFileJobRequest,
    ) -> dms_enterprise_20181101_models.CreateUploadFileJobResponse:
        """
        @summary 创建上传附件任务
        
        @param request: CreateUploadFileJobRequest
        @return: CreateUploadFileJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_upload_file_job_with_options_async(request, runtime)

    def create_upload_ossfile_job_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateUploadOSSFileJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateUploadOSSFileJobResponse:
        """
        @summary Creates a task to upload an Object Storage Service (OSS) file and obtain the key of the task.
        
        @param tmp_req: CreateUploadOSSFileJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateUploadOSSFileJobResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateUploadOSSFileJobShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.upload_target):
            request.upload_target_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.upload_target, 'UploadTarget', 'json')
        query = {}
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.file_source):
            query['FileSource'] = request.file_source
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.upload_target_shrink):
            query['UploadTarget'] = request.upload_target_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateUploadOSSFileJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateUploadOSSFileJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def create_upload_ossfile_job_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.CreateUploadOSSFileJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.CreateUploadOSSFileJobResponse:
        """
        @summary Creates a task to upload an Object Storage Service (OSS) file and obtain the key of the task.
        
        @param tmp_req: CreateUploadOSSFileJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateUploadOSSFileJobResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.CreateUploadOSSFileJobShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.upload_target):
            request.upload_target_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.upload_target, 'UploadTarget', 'json')
        query = {}
        if not UtilClient.is_unset(request.file_name):
            query['FileName'] = request.file_name
        if not UtilClient.is_unset(request.file_source):
            query['FileSource'] = request.file_source
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.upload_target_shrink):
            query['UploadTarget'] = request.upload_target_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateUploadOSSFileJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.CreateUploadOSSFileJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def create_upload_ossfile_job(
        self,
        request: dms_enterprise_20181101_models.CreateUploadOSSFileJobRequest,
    ) -> dms_enterprise_20181101_models.CreateUploadOSSFileJobResponse:
        """
        @summary Creates a task to upload an Object Storage Service (OSS) file and obtain the key of the task.
        
        @param request: CreateUploadOSSFileJobRequest
        @return: CreateUploadOSSFileJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.create_upload_ossfile_job_with_options(request, runtime)

    async def create_upload_ossfile_job_async(
        self,
        request: dms_enterprise_20181101_models.CreateUploadOSSFileJobRequest,
    ) -> dms_enterprise_20181101_models.CreateUploadOSSFileJobResponse:
        """
        @summary Creates a task to upload an Object Storage Service (OSS) file and obtain the key of the task.
        
        @param request: CreateUploadOSSFileJobRequest
        @return: CreateUploadOSSFileJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.create_upload_ossfile_job_with_options_async(request, runtime)

    def delete_abac_authorization_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteAbacAuthorizationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteAbacAuthorizationResponse:
        """
        @summary 删除权限策略授权
        
        @param request: DeleteAbacAuthorizationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAbacAuthorizationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.authorization_id):
            query['AuthorizationId'] = request.authorization_id
        if not UtilClient.is_unset(request.identity_type):
            query['IdentityType'] = request.identity_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAbacAuthorization',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteAbacAuthorizationResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_abac_authorization_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteAbacAuthorizationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteAbacAuthorizationResponse:
        """
        @summary 删除权限策略授权
        
        @param request: DeleteAbacAuthorizationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAbacAuthorizationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.authorization_id):
            query['AuthorizationId'] = request.authorization_id
        if not UtilClient.is_unset(request.identity_type):
            query['IdentityType'] = request.identity_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAbacAuthorization',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteAbacAuthorizationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_abac_authorization(
        self,
        request: dms_enterprise_20181101_models.DeleteAbacAuthorizationRequest,
    ) -> dms_enterprise_20181101_models.DeleteAbacAuthorizationResponse:
        """
        @summary 删除权限策略授权
        
        @param request: DeleteAbacAuthorizationRequest
        @return: DeleteAbacAuthorizationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_abac_authorization_with_options(request, runtime)

    async def delete_abac_authorization_async(
        self,
        request: dms_enterprise_20181101_models.DeleteAbacAuthorizationRequest,
    ) -> dms_enterprise_20181101_models.DeleteAbacAuthorizationResponse:
        """
        @summary 删除权限策略授权
        
        @param request: DeleteAbacAuthorizationRequest
        @return: DeleteAbacAuthorizationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_abac_authorization_with_options_async(request, runtime)

    def delete_abac_policy_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteAbacPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteAbacPolicyResponse:
        """
        @summary 删除权限策略
        
        @param request: DeleteAbacPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAbacPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.abac_policy_id):
            query['AbacPolicyId'] = request.abac_policy_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAbacPolicy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteAbacPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_abac_policy_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteAbacPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteAbacPolicyResponse:
        """
        @summary 删除权限策略
        
        @param request: DeleteAbacPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAbacPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.abac_policy_id):
            query['AbacPolicyId'] = request.abac_policy_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAbacPolicy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteAbacPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_abac_policy(
        self,
        request: dms_enterprise_20181101_models.DeleteAbacPolicyRequest,
    ) -> dms_enterprise_20181101_models.DeleteAbacPolicyResponse:
        """
        @summary 删除权限策略
        
        @param request: DeleteAbacPolicyRequest
        @return: DeleteAbacPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_abac_policy_with_options(request, runtime)

    async def delete_abac_policy_async(
        self,
        request: dms_enterprise_20181101_models.DeleteAbacPolicyRequest,
    ) -> dms_enterprise_20181101_models.DeleteAbacPolicyResponse:
        """
        @summary 删除权限策略
        
        @param request: DeleteAbacPolicyRequest
        @return: DeleteAbacPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_abac_policy_with_options_async(request, runtime)

    def delete_authority_template_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteAuthorityTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteAuthorityTemplateResponse:
        """
        @summary 删除权限模版
        
        @param request: DeleteAuthorityTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAuthorityTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAuthorityTemplate',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteAuthorityTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_authority_template_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteAuthorityTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteAuthorityTemplateResponse:
        """
        @summary 删除权限模版
        
        @param request: DeleteAuthorityTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAuthorityTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAuthorityTemplate',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteAuthorityTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_authority_template(
        self,
        request: dms_enterprise_20181101_models.DeleteAuthorityTemplateRequest,
    ) -> dms_enterprise_20181101_models.DeleteAuthorityTemplateResponse:
        """
        @summary 删除权限模版
        
        @param request: DeleteAuthorityTemplateRequest
        @return: DeleteAuthorityTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_authority_template_with_options(request, runtime)

    async def delete_authority_template_async(
        self,
        request: dms_enterprise_20181101_models.DeleteAuthorityTemplateRequest,
    ) -> dms_enterprise_20181101_models.DeleteAuthorityTemplateResponse:
        """
        @summary 删除权限模版
        
        @param request: DeleteAuthorityTemplateRequest
        @return: DeleteAuthorityTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_authority_template_with_options_async(request, runtime)

    def delete_data_lake_database_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakeDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteDataLakeDatabaseResponse:
        """
        @summary 删除湖仓数据库
        
        @param request: DeleteDataLakeDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDataLakeDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDataLakeDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteDataLakeDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_data_lake_database_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakeDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteDataLakeDatabaseResponse:
        """
        @summary 删除湖仓数据库
        
        @param request: DeleteDataLakeDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDataLakeDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDataLakeDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteDataLakeDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_data_lake_database(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakeDatabaseRequest,
    ) -> dms_enterprise_20181101_models.DeleteDataLakeDatabaseResponse:
        """
        @summary 删除湖仓数据库
        
        @param request: DeleteDataLakeDatabaseRequest
        @return: DeleteDataLakeDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_data_lake_database_with_options(request, runtime)

    async def delete_data_lake_database_async(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakeDatabaseRequest,
    ) -> dms_enterprise_20181101_models.DeleteDataLakeDatabaseResponse:
        """
        @summary 删除湖仓数据库
        
        @param request: DeleteDataLakeDatabaseRequest
        @return: DeleteDataLakeDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_data_lake_database_with_options_async(request, runtime)

    def delete_data_lake_function_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakeFunctionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteDataLakeFunctionResponse:
        """
        @summary 删除湖仓自定义函数
        
        @param request: DeleteDataLakeFunctionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDataLakeFunctionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.function_name):
            query['FunctionName'] = request.function_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDataLakeFunction',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteDataLakeFunctionResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_data_lake_function_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakeFunctionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteDataLakeFunctionResponse:
        """
        @summary 删除湖仓自定义函数
        
        @param request: DeleteDataLakeFunctionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDataLakeFunctionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.function_name):
            query['FunctionName'] = request.function_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDataLakeFunction',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteDataLakeFunctionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_data_lake_function(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakeFunctionRequest,
    ) -> dms_enterprise_20181101_models.DeleteDataLakeFunctionResponse:
        """
        @summary 删除湖仓自定义函数
        
        @param request: DeleteDataLakeFunctionRequest
        @return: DeleteDataLakeFunctionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_data_lake_function_with_options(request, runtime)

    async def delete_data_lake_function_async(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakeFunctionRequest,
    ) -> dms_enterprise_20181101_models.DeleteDataLakeFunctionResponse:
        """
        @summary 删除湖仓自定义函数
        
        @param request: DeleteDataLakeFunctionRequest
        @return: DeleteDataLakeFunctionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_data_lake_function_with_options_async(request, runtime)

    def delete_data_lake_partition_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.DeleteDataLakePartitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteDataLakePartitionResponse:
        """
        @summary 删除湖仓表分区
        
        @param tmp_req: DeleteDataLakePartitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDataLakePartitionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.DeleteDataLakePartitionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.partition_values):
            request.partition_values_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.partition_values, 'PartitionValues', 'simple')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.if_exists):
            query['IfExists'] = request.if_exists
        if not UtilClient.is_unset(request.partition_values_shrink):
            query['PartitionValues'] = request.partition_values_shrink
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDataLakePartition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteDataLakePartitionResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_data_lake_partition_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.DeleteDataLakePartitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteDataLakePartitionResponse:
        """
        @summary 删除湖仓表分区
        
        @param tmp_req: DeleteDataLakePartitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDataLakePartitionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.DeleteDataLakePartitionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.partition_values):
            request.partition_values_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.partition_values, 'PartitionValues', 'simple')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.if_exists):
            query['IfExists'] = request.if_exists
        if not UtilClient.is_unset(request.partition_values_shrink):
            query['PartitionValues'] = request.partition_values_shrink
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDataLakePartition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteDataLakePartitionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_data_lake_partition(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakePartitionRequest,
    ) -> dms_enterprise_20181101_models.DeleteDataLakePartitionResponse:
        """
        @summary 删除湖仓表分区
        
        @param request: DeleteDataLakePartitionRequest
        @return: DeleteDataLakePartitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_data_lake_partition_with_options(request, runtime)

    async def delete_data_lake_partition_async(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakePartitionRequest,
    ) -> dms_enterprise_20181101_models.DeleteDataLakePartitionResponse:
        """
        @summary 删除湖仓表分区
        
        @param request: DeleteDataLakePartitionRequest
        @return: DeleteDataLakePartitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_data_lake_partition_with_options_async(request, runtime)

    def delete_data_lake_table_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakeTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteDataLakeTableResponse:
        """
        @summary 删除湖仓表
        
        @param request: DeleteDataLakeTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDataLakeTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDataLakeTable',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteDataLakeTableResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_data_lake_table_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakeTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteDataLakeTableResponse:
        """
        @summary 删除湖仓表
        
        @param request: DeleteDataLakeTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteDataLakeTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteDataLakeTable',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteDataLakeTableResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_data_lake_table(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakeTableRequest,
    ) -> dms_enterprise_20181101_models.DeleteDataLakeTableResponse:
        """
        @summary 删除湖仓表
        
        @param request: DeleteDataLakeTableRequest
        @return: DeleteDataLakeTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_data_lake_table_with_options(request, runtime)

    async def delete_data_lake_table_async(
        self,
        request: dms_enterprise_20181101_models.DeleteDataLakeTableRequest,
    ) -> dms_enterprise_20181101_models.DeleteDataLakeTableResponse:
        """
        @summary 删除湖仓表
        
        @param request: DeleteDataLakeTableRequest
        @return: DeleteDataLakeTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_data_lake_table_with_options_async(request, runtime)

    def delete_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteInstanceResponse:
        """
        @summary Removes a database instance from Data Management (DMS).
        
        @description Note: You can call this operation only to remove a database instance from the instance list of DMS. The instance is not deleted or shut down.
        
        @param request: DeleteInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteInstanceResponse:
        """
        @summary Removes a database instance from Data Management (DMS).
        
        @description Note: You can call this operation only to remove a database instance from the instance list of DMS. The instance is not deleted or shut down.
        
        @param request: DeleteInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_instance(
        self,
        request: dms_enterprise_20181101_models.DeleteInstanceRequest,
    ) -> dms_enterprise_20181101_models.DeleteInstanceResponse:
        """
        @summary Removes a database instance from Data Management (DMS).
        
        @description Note: You can call this operation only to remove a database instance from the instance list of DMS. The instance is not deleted or shut down.
        
        @param request: DeleteInstanceRequest
        @return: DeleteInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_instance_with_options(request, runtime)

    async def delete_instance_async(
        self,
        request: dms_enterprise_20181101_models.DeleteInstanceRequest,
    ) -> dms_enterprise_20181101_models.DeleteInstanceResponse:
        """
        @summary Removes a database instance from Data Management (DMS).
        
        @description Note: You can call this operation only to remove a database instance from the instance list of DMS. The instance is not deleted or shut down.
        
        @param request: DeleteInstanceRequest
        @return: DeleteInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_instance_with_options_async(request, runtime)

    def delete_lake_house_space_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteLakeHouseSpaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteLakeHouseSpaceResponse:
        """
        @summary Deletes a workspace.
        
        @param request: DeleteLakeHouseSpaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLakeHouseSpaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.space_id):
            query['SpaceId'] = request.space_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLakeHouseSpace',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteLakeHouseSpaceResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_lake_house_space_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteLakeHouseSpaceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteLakeHouseSpaceResponse:
        """
        @summary Deletes a workspace.
        
        @param request: DeleteLakeHouseSpaceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLakeHouseSpaceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.space_id):
            query['SpaceId'] = request.space_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLakeHouseSpace',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteLakeHouseSpaceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_lake_house_space(
        self,
        request: dms_enterprise_20181101_models.DeleteLakeHouseSpaceRequest,
    ) -> dms_enterprise_20181101_models.DeleteLakeHouseSpaceResponse:
        """
        @summary Deletes a workspace.
        
        @param request: DeleteLakeHouseSpaceRequest
        @return: DeleteLakeHouseSpaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_lake_house_space_with_options(request, runtime)

    async def delete_lake_house_space_async(
        self,
        request: dms_enterprise_20181101_models.DeleteLakeHouseSpaceRequest,
    ) -> dms_enterprise_20181101_models.DeleteLakeHouseSpaceResponse:
        """
        @summary Deletes a workspace.
        
        @param request: DeleteLakeHouseSpaceRequest
        @return: DeleteLakeHouseSpaceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_lake_house_space_with_options_async(request, runtime)

    def delete_lh_members_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.DeleteLhMembersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteLhMembersResponse:
        """
        @summary 删除数仓空间成员
        
        @description You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
        You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
        
        @param tmp_req: DeleteLhMembersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLhMembersResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.DeleteLhMembersShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.member_ids):
            request.member_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.member_ids, 'MemberIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.member_ids_shrink):
            query['MemberIds'] = request.member_ids_shrink
        if not UtilClient.is_unset(request.object_id):
            query['ObjectId'] = request.object_id
        if not UtilClient.is_unset(request.object_type):
            query['ObjectType'] = request.object_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLhMembers',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteLhMembersResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_lh_members_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.DeleteLhMembersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteLhMembersResponse:
        """
        @summary 删除数仓空间成员
        
        @description You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
        You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
        
        @param tmp_req: DeleteLhMembersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLhMembersResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.DeleteLhMembersShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.member_ids):
            request.member_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.member_ids, 'MemberIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.member_ids_shrink):
            query['MemberIds'] = request.member_ids_shrink
        if not UtilClient.is_unset(request.object_id):
            query['ObjectId'] = request.object_id
        if not UtilClient.is_unset(request.object_type):
            query['ObjectType'] = request.object_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLhMembers',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteLhMembersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_lh_members(
        self,
        request: dms_enterprise_20181101_models.DeleteLhMembersRequest,
    ) -> dms_enterprise_20181101_models.DeleteLhMembersResponse:
        """
        @summary 删除数仓空间成员
        
        @description You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
        You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
        
        @param request: DeleteLhMembersRequest
        @return: DeleteLhMembersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_lh_members_with_options(request, runtime)

    async def delete_lh_members_async(
        self,
        request: dms_enterprise_20181101_models.DeleteLhMembersRequest,
    ) -> dms_enterprise_20181101_models.DeleteLhMembersResponse:
        """
        @summary 删除数仓空间成员
        
        @description You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
        You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
        
        @param request: DeleteLhMembersRequest
        @return: DeleteLhMembersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_lh_members_with_options_async(request, runtime)

    def delete_logic_database_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteLogicDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteLogicDatabaseResponse:
        """
        @summary Deletes a logical database in Database Management (DMS). This operation only deletes the specified logical database but does not delete physical databases.
        
        @param request: DeleteLogicDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLogicDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.logic_db_id):
            query['LogicDbId'] = request.logic_db_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLogicDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteLogicDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_logic_database_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteLogicDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteLogicDatabaseResponse:
        """
        @summary Deletes a logical database in Database Management (DMS). This operation only deletes the specified logical database but does not delete physical databases.
        
        @param request: DeleteLogicDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLogicDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.logic_db_id):
            query['LogicDbId'] = request.logic_db_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLogicDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteLogicDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_logic_database(
        self,
        request: dms_enterprise_20181101_models.DeleteLogicDatabaseRequest,
    ) -> dms_enterprise_20181101_models.DeleteLogicDatabaseResponse:
        """
        @summary Deletes a logical database in Database Management (DMS). This operation only deletes the specified logical database but does not delete physical databases.
        
        @param request: DeleteLogicDatabaseRequest
        @return: DeleteLogicDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_logic_database_with_options(request, runtime)

    async def delete_logic_database_async(
        self,
        request: dms_enterprise_20181101_models.DeleteLogicDatabaseRequest,
    ) -> dms_enterprise_20181101_models.DeleteLogicDatabaseResponse:
        """
        @summary Deletes a logical database in Database Management (DMS). This operation only deletes the specified logical database but does not delete physical databases.
        
        @param request: DeleteLogicDatabaseRequest
        @return: DeleteLogicDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_logic_database_with_options_async(request, runtime)

    def delete_logic_table_route_config_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteLogicTableRouteConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteLogicTableRouteConfigResponse:
        """
        @summary Deletes the routing algorithm of a logical table.
        
        @param request: DeleteLogicTableRouteConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLogicTableRouteConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.route_key):
            query['RouteKey'] = request.route_key
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLogicTableRouteConfig',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteLogicTableRouteConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_logic_table_route_config_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteLogicTableRouteConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteLogicTableRouteConfigResponse:
        """
        @summary Deletes the routing algorithm of a logical table.
        
        @param request: DeleteLogicTableRouteConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteLogicTableRouteConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.route_key):
            query['RouteKey'] = request.route_key
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteLogicTableRouteConfig',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteLogicTableRouteConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_logic_table_route_config(
        self,
        request: dms_enterprise_20181101_models.DeleteLogicTableRouteConfigRequest,
    ) -> dms_enterprise_20181101_models.DeleteLogicTableRouteConfigResponse:
        """
        @summary Deletes the routing algorithm of a logical table.
        
        @param request: DeleteLogicTableRouteConfigRequest
        @return: DeleteLogicTableRouteConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_logic_table_route_config_with_options(request, runtime)

    async def delete_logic_table_route_config_async(
        self,
        request: dms_enterprise_20181101_models.DeleteLogicTableRouteConfigRequest,
    ) -> dms_enterprise_20181101_models.DeleteLogicTableRouteConfigResponse:
        """
        @summary Deletes the routing algorithm of a logical table.
        
        @param request: DeleteLogicTableRouteConfigRequest
        @return: DeleteLogicTableRouteConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_logic_table_route_config_with_options_async(request, runtime)

    def delete_meta_category_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteMetaCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteMetaCategoryResponse:
        """
        @summary 删除资产类目
        
        @param request: DeleteMetaCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMetaCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category_id):
            query['CategoryId'] = request.category_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMetaCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteMetaCategoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_meta_category_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteMetaCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteMetaCategoryResponse:
        """
        @summary 删除资产类目
        
        @param request: DeleteMetaCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMetaCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category_id):
            query['CategoryId'] = request.category_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMetaCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteMetaCategoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_meta_category(
        self,
        request: dms_enterprise_20181101_models.DeleteMetaCategoryRequest,
    ) -> dms_enterprise_20181101_models.DeleteMetaCategoryResponse:
        """
        @summary 删除资产类目
        
        @param request: DeleteMetaCategoryRequest
        @return: DeleteMetaCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_meta_category_with_options(request, runtime)

    async def delete_meta_category_async(
        self,
        request: dms_enterprise_20181101_models.DeleteMetaCategoryRequest,
    ) -> dms_enterprise_20181101_models.DeleteMetaCategoryResponse:
        """
        @summary 删除资产类目
        
        @param request: DeleteMetaCategoryRequest
        @return: DeleteMetaCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_meta_category_with_options_async(request, runtime)

    def delete_proxy_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteProxyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteProxyResponse:
        """
        @summary You can call this operation to disable the data security protection proxy of a DB instance.
        
        @description After you disable this feature, your DB instance loses the JDBC protocol. All authorization information is recycled.
        
        @param request: DeleteProxyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteProxyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.proxy_id):
            query['ProxyId'] = request.proxy_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteProxy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteProxyResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_proxy_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteProxyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteProxyResponse:
        """
        @summary You can call this operation to disable the data security protection proxy of a DB instance.
        
        @description After you disable this feature, your DB instance loses the JDBC protocol. All authorization information is recycled.
        
        @param request: DeleteProxyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteProxyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.proxy_id):
            query['ProxyId'] = request.proxy_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteProxy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteProxyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_proxy(
        self,
        request: dms_enterprise_20181101_models.DeleteProxyRequest,
    ) -> dms_enterprise_20181101_models.DeleteProxyResponse:
        """
        @summary You can call this operation to disable the data security protection proxy of a DB instance.
        
        @description After you disable this feature, your DB instance loses the JDBC protocol. All authorization information is recycled.
        
        @param request: DeleteProxyRequest
        @return: DeleteProxyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_proxy_with_options(request, runtime)

    async def delete_proxy_async(
        self,
        request: dms_enterprise_20181101_models.DeleteProxyRequest,
    ) -> dms_enterprise_20181101_models.DeleteProxyResponse:
        """
        @summary You can call this operation to disable the data security protection proxy of a DB instance.
        
        @description After you disable this feature, your DB instance loses the JDBC protocol. All authorization information is recycled.
        
        @param request: DeleteProxyRequest
        @return: DeleteProxyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_proxy_with_options_async(request, runtime)

    def delete_proxy_access_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteProxyAccessRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteProxyAccessResponse:
        """
        @summary You can call this operation to DeleteProxyAccess reclaim the data security protection authorization of the target user.
        
        @param request: DeleteProxyAccessRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteProxyAccessResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.proxy_access_id):
            query['ProxyAccessId'] = request.proxy_access_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteProxyAccess',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteProxyAccessResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_proxy_access_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteProxyAccessRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteProxyAccessResponse:
        """
        @summary You can call this operation to DeleteProxyAccess reclaim the data security protection authorization of the target user.
        
        @param request: DeleteProxyAccessRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteProxyAccessResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.proxy_access_id):
            query['ProxyAccessId'] = request.proxy_access_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteProxyAccess',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteProxyAccessResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_proxy_access(
        self,
        request: dms_enterprise_20181101_models.DeleteProxyAccessRequest,
    ) -> dms_enterprise_20181101_models.DeleteProxyAccessResponse:
        """
        @summary You can call this operation to DeleteProxyAccess reclaim the data security protection authorization of the target user.
        
        @param request: DeleteProxyAccessRequest
        @return: DeleteProxyAccessResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_proxy_access_with_options(request, runtime)

    async def delete_proxy_access_async(
        self,
        request: dms_enterprise_20181101_models.DeleteProxyAccessRequest,
    ) -> dms_enterprise_20181101_models.DeleteProxyAccessResponse:
        """
        @summary You can call this operation to DeleteProxyAccess reclaim the data security protection authorization of the target user.
        
        @param request: DeleteProxyAccessRequest
        @return: DeleteProxyAccessResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_proxy_access_with_options_async(request, runtime)

    def delete_scenario_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteScenarioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteScenarioResponse:
        """
        @summary Deletes a business scenario.
        
        @description When you call this operation, make sure that no task flow is specified in the business scenario.
        
        @param request: DeleteScenarioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteScenarioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.scenario_id):
            query['ScenarioId'] = request.scenario_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteScenario',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteScenarioResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_scenario_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteScenarioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteScenarioResponse:
        """
        @summary Deletes a business scenario.
        
        @description When you call this operation, make sure that no task flow is specified in the business scenario.
        
        @param request: DeleteScenarioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteScenarioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.scenario_id):
            query['ScenarioId'] = request.scenario_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteScenario',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteScenarioResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_scenario(
        self,
        request: dms_enterprise_20181101_models.DeleteScenarioRequest,
    ) -> dms_enterprise_20181101_models.DeleteScenarioResponse:
        """
        @summary Deletes a business scenario.
        
        @description When you call this operation, make sure that no task flow is specified in the business scenario.
        
        @param request: DeleteScenarioRequest
        @return: DeleteScenarioResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_scenario_with_options(request, runtime)

    async def delete_scenario_async(
        self,
        request: dms_enterprise_20181101_models.DeleteScenarioRequest,
    ) -> dms_enterprise_20181101_models.DeleteScenarioResponse:
        """
        @summary Deletes a business scenario.
        
        @description When you call this operation, make sure that no task flow is specified in the business scenario.
        
        @param request: DeleteScenarioRequest
        @return: DeleteScenarioResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_scenario_with_options_async(request, runtime)

    def delete_standard_group_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteStandardGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteStandardGroupResponse:
        """
        @summary 删除安全规则
        
        @param request: DeleteStandardGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteStandardGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteStandardGroup',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteStandardGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_standard_group_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteStandardGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteStandardGroupResponse:
        """
        @summary 删除安全规则
        
        @param request: DeleteStandardGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteStandardGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteStandardGroup',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteStandardGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_standard_group(
        self,
        request: dms_enterprise_20181101_models.DeleteStandardGroupRequest,
    ) -> dms_enterprise_20181101_models.DeleteStandardGroupResponse:
        """
        @summary 删除安全规则
        
        @param request: DeleteStandardGroupRequest
        @return: DeleteStandardGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_standard_group_with_options(request, runtime)

    async def delete_standard_group_async(
        self,
        request: dms_enterprise_20181101_models.DeleteStandardGroupRequest,
    ) -> dms_enterprise_20181101_models.DeleteStandardGroupResponse:
        """
        @summary 删除安全规则
        
        @param request: DeleteStandardGroupRequest
        @return: DeleteStandardGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_standard_group_with_options_async(request, runtime)

    def delete_task_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteTaskResponse:
        """
        @summary Deletes a task in a specified task flow.
        
        @param request: DeleteTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTask',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_task_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteTaskResponse:
        """
        @summary Deletes a task in a specified task flow.
        
        @param request: DeleteTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTask',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_task(
        self,
        request: dms_enterprise_20181101_models.DeleteTaskRequest,
    ) -> dms_enterprise_20181101_models.DeleteTaskResponse:
        """
        @summary Deletes a task in a specified task flow.
        
        @param request: DeleteTaskRequest
        @return: DeleteTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_task_with_options(request, runtime)

    async def delete_task_async(
        self,
        request: dms_enterprise_20181101_models.DeleteTaskRequest,
    ) -> dms_enterprise_20181101_models.DeleteTaskResponse:
        """
        @summary Deletes a task in a specified task flow.
        
        @param request: DeleteTaskRequest
        @return: DeleteTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_task_with_options_async(request, runtime)

    def delete_task_flow_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteTaskFlowResponse:
        """
        @summary Deletes a task flow.
        
        @param request: DeleteTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteTaskFlowResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_task_flow_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteTaskFlowResponse:
        """
        @summary Deletes a task flow.
        
        @param request: DeleteTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteTaskFlowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_task_flow(
        self,
        request: dms_enterprise_20181101_models.DeleteTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.DeleteTaskFlowResponse:
        """
        @summary Deletes a task flow.
        
        @param request: DeleteTaskFlowRequest
        @return: DeleteTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_task_flow_with_options(request, runtime)

    async def delete_task_flow_async(
        self,
        request: dms_enterprise_20181101_models.DeleteTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.DeleteTaskFlowResponse:
        """
        @summary Deletes a task flow.
        
        @param request: DeleteTaskFlowRequest
        @return: DeleteTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_task_flow_with_options_async(request, runtime)

    def delete_task_flow_edges_by_condition_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteTaskFlowEdgesByConditionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteTaskFlowEdgesByConditionResponse:
        """
        @summary Deletes task flow edges based on multiple conditions.
        
        @description This operation is used for multi-condition query. You can call it to delete the edges of a specified task flow that meet all specified conditions.
        
        @param request: DeleteTaskFlowEdgesByConditionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTaskFlowEdgesByConditionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.id):
            query['Id'] = request.id
        if not UtilClient.is_unset(request.node_end):
            query['NodeEnd'] = request.node_end
        if not UtilClient.is_unset(request.node_from):
            query['NodeFrom'] = request.node_from
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTaskFlowEdgesByCondition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteTaskFlowEdgesByConditionResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_task_flow_edges_by_condition_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteTaskFlowEdgesByConditionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteTaskFlowEdgesByConditionResponse:
        """
        @summary Deletes task flow edges based on multiple conditions.
        
        @description This operation is used for multi-condition query. You can call it to delete the edges of a specified task flow that meet all specified conditions.
        
        @param request: DeleteTaskFlowEdgesByConditionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTaskFlowEdgesByConditionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.id):
            query['Id'] = request.id
        if not UtilClient.is_unset(request.node_end):
            query['NodeEnd'] = request.node_end
        if not UtilClient.is_unset(request.node_from):
            query['NodeFrom'] = request.node_from
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTaskFlowEdgesByCondition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteTaskFlowEdgesByConditionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_task_flow_edges_by_condition(
        self,
        request: dms_enterprise_20181101_models.DeleteTaskFlowEdgesByConditionRequest,
    ) -> dms_enterprise_20181101_models.DeleteTaskFlowEdgesByConditionResponse:
        """
        @summary Deletes task flow edges based on multiple conditions.
        
        @description This operation is used for multi-condition query. You can call it to delete the edges of a specified task flow that meet all specified conditions.
        
        @param request: DeleteTaskFlowEdgesByConditionRequest
        @return: DeleteTaskFlowEdgesByConditionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_task_flow_edges_by_condition_with_options(request, runtime)

    async def delete_task_flow_edges_by_condition_async(
        self,
        request: dms_enterprise_20181101_models.DeleteTaskFlowEdgesByConditionRequest,
    ) -> dms_enterprise_20181101_models.DeleteTaskFlowEdgesByConditionResponse:
        """
        @summary Deletes task flow edges based on multiple conditions.
        
        @description This operation is used for multi-condition query. You can call it to delete the edges of a specified task flow that meet all specified conditions.
        
        @param request: DeleteTaskFlowEdgesByConditionRequest
        @return: DeleteTaskFlowEdgesByConditionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_task_flow_edges_by_condition_with_options_async(request, runtime)

    def delete_user_with_options(
        self,
        request: dms_enterprise_20181101_models.DeleteUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteUserResponse:
        """
        @summary Deletes an Alibaba Cloud account that is no longer used.
        
        @description The effect of deleting a user by calling this operation is the same as that of deleting a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to delete a user that is no longer used from DMS Enterprise. After the user is deleted, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
        >  This operation only removes the association of the Alibaba Cloud account or RAM user with DMS Enterprise of the enterprise, rather than actually deleting the Alibaba Cloud account or RAM user. After the user is deleted, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is added to DMS Enterprise again.
        
        @param request: DeleteUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.uid):
            query['Uid'] = request.uid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def delete_user_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DeleteUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DeleteUserResponse:
        """
        @summary Deletes an Alibaba Cloud account that is no longer used.
        
        @description The effect of deleting a user by calling this operation is the same as that of deleting a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to delete a user that is no longer used from DMS Enterprise. After the user is deleted, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
        >  This operation only removes the association of the Alibaba Cloud account or RAM user with DMS Enterprise of the enterprise, rather than actually deleting the Alibaba Cloud account or RAM user. After the user is deleted, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is added to DMS Enterprise again.
        
        @param request: DeleteUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.uid):
            query['Uid'] = request.uid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DeleteUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def delete_user(
        self,
        request: dms_enterprise_20181101_models.DeleteUserRequest,
    ) -> dms_enterprise_20181101_models.DeleteUserResponse:
        """
        @summary Deletes an Alibaba Cloud account that is no longer used.
        
        @description The effect of deleting a user by calling this operation is the same as that of deleting a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to delete a user that is no longer used from DMS Enterprise. After the user is deleted, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
        >  This operation only removes the association of the Alibaba Cloud account or RAM user with DMS Enterprise of the enterprise, rather than actually deleting the Alibaba Cloud account or RAM user. After the user is deleted, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is added to DMS Enterprise again.
        
        @param request: DeleteUserRequest
        @return: DeleteUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.delete_user_with_options(request, runtime)

    async def delete_user_async(
        self,
        request: dms_enterprise_20181101_models.DeleteUserRequest,
    ) -> dms_enterprise_20181101_models.DeleteUserResponse:
        """
        @summary Deletes an Alibaba Cloud account that is no longer used.
        
        @description The effect of deleting a user by calling this operation is the same as that of deleting a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to delete a user that is no longer used from DMS Enterprise. After the user is deleted, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
        >  This operation only removes the association of the Alibaba Cloud account or RAM user with DMS Enterprise of the enterprise, rather than actually deleting the Alibaba Cloud account or RAM user. After the user is deleted, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is added to DMS Enterprise again.
        
        @param request: DeleteUserRequest
        @return: DeleteUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.delete_user_with_options_async(request, runtime)

    def describe_dify_attribute_with_options(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DescribeDifyAttributeResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDifyAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_uuid):
            query['AppUuid'] = request.app_uuid
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDifyAttribute',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DescribeDifyAttributeResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_dify_attribute_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyAttributeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DescribeDifyAttributeResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyAttributeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDifyAttributeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.app_uuid):
            query['AppUuid'] = request.app_uuid
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDifyAttribute',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DescribeDifyAttributeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_dify_attribute(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyAttributeRequest,
    ) -> dms_enterprise_20181101_models.DescribeDifyAttributeResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyAttributeRequest
        @return: DescribeDifyAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_dify_attribute_with_options(request, runtime)

    async def describe_dify_attribute_async(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyAttributeRequest,
    ) -> dms_enterprise_20181101_models.DescribeDifyAttributeResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyAttributeRequest
        @return: DescribeDifyAttributeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_dify_attribute_with_options_async(request, runtime)

    def describe_dify_default_vpc_with_options(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyDefaultVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DescribeDifyDefaultVpcResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyDefaultVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDifyDefaultVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDifyDefaultVpc',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DescribeDifyDefaultVpcResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_dify_default_vpc_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyDefaultVpcRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DescribeDifyDefaultVpcResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyDefaultVpcRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDifyDefaultVpcResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDifyDefaultVpc',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DescribeDifyDefaultVpcResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_dify_default_vpc(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyDefaultVpcRequest,
    ) -> dms_enterprise_20181101_models.DescribeDifyDefaultVpcResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyDefaultVpcRequest
        @return: DescribeDifyDefaultVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_dify_default_vpc_with_options(request, runtime)

    async def describe_dify_default_vpc_async(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyDefaultVpcRequest,
    ) -> dms_enterprise_20181101_models.DescribeDifyDefaultVpcResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyDefaultVpcRequest
        @return: DescribeDifyDefaultVpcResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_dify_default_vpc_with_options_async(request, runtime)

    def describe_dify_editions_with_options(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyEditionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DescribeDifyEditionsResponse:
        """
        @summary 用于获取Dify当前支持的版本信息
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyEditionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDifyEditionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDifyEditions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DescribeDifyEditionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_dify_editions_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyEditionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DescribeDifyEditionsResponse:
        """
        @summary 用于获取Dify当前支持的版本信息
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyEditionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDifyEditionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDifyEditions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DescribeDifyEditionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_dify_editions(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyEditionsRequest,
    ) -> dms_enterprise_20181101_models.DescribeDifyEditionsResponse:
        """
        @summary 用于获取Dify当前支持的版本信息
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyEditionsRequest
        @return: DescribeDifyEditionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_dify_editions_with_options(request, runtime)

    async def describe_dify_editions_async(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyEditionsRequest,
    ) -> dms_enterprise_20181101_models.DescribeDifyEditionsResponse:
        """
        @summary 用于获取Dify当前支持的版本信息
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyEditionsRequest
        @return: DescribeDifyEditionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_dify_editions_with_options_async(request, runtime)

    def describe_dify_regions_with_options(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyRegionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DescribeDifyRegionsResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyRegionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDifyRegionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDifyRegions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DescribeDifyRegionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def describe_dify_regions_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyRegionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DescribeDifyRegionsResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyRegionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeDifyRegionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeDifyRegions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DescribeDifyRegionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def describe_dify_regions(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyRegionsRequest,
    ) -> dms_enterprise_20181101_models.DescribeDifyRegionsResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyRegionsRequest
        @return: DescribeDifyRegionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.describe_dify_regions_with_options(request, runtime)

    async def describe_dify_regions_async(
        self,
        request: dms_enterprise_20181101_models.DescribeDifyRegionsRequest,
    ) -> dms_enterprise_20181101_models.DescribeDifyRegionsResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: DescribeDifyRegionsRequest
        @return: DescribeDifyRegionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.describe_dify_regions_with_options_async(request, runtime)

    def disable_user_with_options(
        self,
        request: dms_enterprise_20181101_models.DisableUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DisableUserResponse:
        """
        @summary You can call this operation to disable a user that is temporarily not used in Data Management (DMS) Enterprise.
        
        @description The effect of disabling a user by calling this operation is the same as that of disabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to disable a user that is temporarily not used in DMS Enterprise. After the user is disabled, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
        >  This operation only stops the Alibaba Cloud account or RAM user from logging on to DMS Enterprise of the enterprise, rather than actually disabling the Alibaba Cloud account or RAM user. After the user is disabled, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is enabled again. The disabled user, however, still exists in DMS Enterprise.
        
        @param request: DisableUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.uid):
            query['Uid'] = request.uid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DisableUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def disable_user_with_options_async(
        self,
        request: dms_enterprise_20181101_models.DisableUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DisableUserResponse:
        """
        @summary You can call this operation to disable a user that is temporarily not used in Data Management (DMS) Enterprise.
        
        @description The effect of disabling a user by calling this operation is the same as that of disabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to disable a user that is temporarily not used in DMS Enterprise. After the user is disabled, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
        >  This operation only stops the Alibaba Cloud account or RAM user from logging on to DMS Enterprise of the enterprise, rather than actually disabling the Alibaba Cloud account or RAM user. After the user is disabled, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is enabled again. The disabled user, however, still exists in DMS Enterprise.
        
        @param request: DisableUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.uid):
            query['Uid'] = request.uid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DisableUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def disable_user(
        self,
        request: dms_enterprise_20181101_models.DisableUserRequest,
    ) -> dms_enterprise_20181101_models.DisableUserResponse:
        """
        @summary You can call this operation to disable a user that is temporarily not used in Data Management (DMS) Enterprise.
        
        @description The effect of disabling a user by calling this operation is the same as that of disabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to disable a user that is temporarily not used in DMS Enterprise. After the user is disabled, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
        >  This operation only stops the Alibaba Cloud account or RAM user from logging on to DMS Enterprise of the enterprise, rather than actually disabling the Alibaba Cloud account or RAM user. After the user is disabled, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is enabled again. The disabled user, however, still exists in DMS Enterprise.
        
        @param request: DisableUserRequest
        @return: DisableUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.disable_user_with_options(request, runtime)

    async def disable_user_async(
        self,
        request: dms_enterprise_20181101_models.DisableUserRequest,
    ) -> dms_enterprise_20181101_models.DisableUserResponse:
        """
        @summary You can call this operation to disable a user that is temporarily not used in Data Management (DMS) Enterprise.
        
        @description The effect of disabling a user by calling this operation is the same as that of disabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to disable a user that is temporarily not used in DMS Enterprise. After the user is disabled, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
        >  This operation only stops the Alibaba Cloud account or RAM user from logging on to DMS Enterprise of the enterprise, rather than actually disabling the Alibaba Cloud account or RAM user. After the user is disabled, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is enabled again. The disabled user, however, still exists in DMS Enterprise.
        
        @param request: DisableUserRequest
        @return: DisableUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.disable_user_with_options_async(request, runtime)

    def download_data_track_result_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.DownloadDataTrackResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DownloadDataTrackResultResponse:
        """
        @summary Downloads the parsing result of a data tracking task.
        
        @param tmp_req: DownloadDataTrackResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DownloadDataTrackResultResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.DownloadDataTrackResultShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.column_filter):
            request.column_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.column_filter, 'ColumnFilter', 'json')
        if not UtilClient.is_unset(tmp_req.event_id_list):
            request.event_id_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.event_id_list, 'EventIdList', 'json')
        if not UtilClient.is_unset(tmp_req.filter_table_list):
            request.filter_table_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.filter_table_list, 'FilterTableList', 'json')
        if not UtilClient.is_unset(tmp_req.filter_type_list):
            request.filter_type_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.filter_type_list, 'FilterTypeList', 'json')
        query = {}
        if not UtilClient.is_unset(request.column_filter_shrink):
            query['ColumnFilter'] = request.column_filter_shrink
        if not UtilClient.is_unset(request.event_id_list_shrink):
            query['EventIdList'] = request.event_id_list_shrink
        if not UtilClient.is_unset(request.filter_end_time):
            query['FilterEndTime'] = request.filter_end_time
        if not UtilClient.is_unset(request.filter_start_time):
            query['FilterStartTime'] = request.filter_start_time
        if not UtilClient.is_unset(request.filter_table_list_shrink):
            query['FilterTableList'] = request.filter_table_list_shrink
        if not UtilClient.is_unset(request.filter_type_list_shrink):
            query['FilterTypeList'] = request.filter_type_list_shrink
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.rollback_sqltype):
            query['RollbackSQLType'] = request.rollback_sqltype
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DownloadDataTrackResult',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DownloadDataTrackResultResponse(),
            self.call_api(params, req, runtime)
        )

    async def download_data_track_result_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.DownloadDataTrackResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.DownloadDataTrackResultResponse:
        """
        @summary Downloads the parsing result of a data tracking task.
        
        @param tmp_req: DownloadDataTrackResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: DownloadDataTrackResultResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.DownloadDataTrackResultShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.column_filter):
            request.column_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.column_filter, 'ColumnFilter', 'json')
        if not UtilClient.is_unset(tmp_req.event_id_list):
            request.event_id_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.event_id_list, 'EventIdList', 'json')
        if not UtilClient.is_unset(tmp_req.filter_table_list):
            request.filter_table_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.filter_table_list, 'FilterTableList', 'json')
        if not UtilClient.is_unset(tmp_req.filter_type_list):
            request.filter_type_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.filter_type_list, 'FilterTypeList', 'json')
        query = {}
        if not UtilClient.is_unset(request.column_filter_shrink):
            query['ColumnFilter'] = request.column_filter_shrink
        if not UtilClient.is_unset(request.event_id_list_shrink):
            query['EventIdList'] = request.event_id_list_shrink
        if not UtilClient.is_unset(request.filter_end_time):
            query['FilterEndTime'] = request.filter_end_time
        if not UtilClient.is_unset(request.filter_start_time):
            query['FilterStartTime'] = request.filter_start_time
        if not UtilClient.is_unset(request.filter_table_list_shrink):
            query['FilterTableList'] = request.filter_table_list_shrink
        if not UtilClient.is_unset(request.filter_type_list_shrink):
            query['FilterTypeList'] = request.filter_type_list_shrink
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.rollback_sqltype):
            query['RollbackSQLType'] = request.rollback_sqltype
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DownloadDataTrackResult',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.DownloadDataTrackResultResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def download_data_track_result(
        self,
        request: dms_enterprise_20181101_models.DownloadDataTrackResultRequest,
    ) -> dms_enterprise_20181101_models.DownloadDataTrackResultResponse:
        """
        @summary Downloads the parsing result of a data tracking task.
        
        @param request: DownloadDataTrackResultRequest
        @return: DownloadDataTrackResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.download_data_track_result_with_options(request, runtime)

    async def download_data_track_result_async(
        self,
        request: dms_enterprise_20181101_models.DownloadDataTrackResultRequest,
    ) -> dms_enterprise_20181101_models.DownloadDataTrackResultResponse:
        """
        @summary Downloads the parsing result of a data tracking task.
        
        @param request: DownloadDataTrackResultRequest
        @return: DownloadDataTrackResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.download_data_track_result_with_options_async(request, runtime)

    def edit_logic_database_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.EditLogicDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.EditLogicDatabaseResponse:
        """
        @summary Modifies the information about a logical database.
        
        @param tmp_req: EditLogicDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EditLogicDatabaseResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.EditLogicDatabaseShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.database_ids):
            request.database_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.database_ids, 'DatabaseIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alias):
            query['Alias'] = request.alias
        if not UtilClient.is_unset(request.database_ids_shrink):
            query['DatabaseIds'] = request.database_ids_shrink
        if not UtilClient.is_unset(request.logic_db_id):
            query['LogicDbId'] = request.logic_db_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EditLogicDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.EditLogicDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def edit_logic_database_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.EditLogicDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.EditLogicDatabaseResponse:
        """
        @summary Modifies the information about a logical database.
        
        @param tmp_req: EditLogicDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EditLogicDatabaseResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.EditLogicDatabaseShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.database_ids):
            request.database_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.database_ids, 'DatabaseIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alias):
            query['Alias'] = request.alias
        if not UtilClient.is_unset(request.database_ids_shrink):
            query['DatabaseIds'] = request.database_ids_shrink
        if not UtilClient.is_unset(request.logic_db_id):
            query['LogicDbId'] = request.logic_db_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EditLogicDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.EditLogicDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def edit_logic_database(
        self,
        request: dms_enterprise_20181101_models.EditLogicDatabaseRequest,
    ) -> dms_enterprise_20181101_models.EditLogicDatabaseResponse:
        """
        @summary Modifies the information about a logical database.
        
        @param request: EditLogicDatabaseRequest
        @return: EditLogicDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.edit_logic_database_with_options(request, runtime)

    async def edit_logic_database_async(
        self,
        request: dms_enterprise_20181101_models.EditLogicDatabaseRequest,
    ) -> dms_enterprise_20181101_models.EditLogicDatabaseResponse:
        """
        @summary Modifies the information about a logical database.
        
        @param request: EditLogicDatabaseRequest
        @return: EditLogicDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.edit_logic_database_with_options_async(request, runtime)

    def edit_meta_knowledge_asset_with_options(
        self,
        request: dms_enterprise_20181101_models.EditMetaKnowledgeAssetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.EditMetaKnowledgeAssetResponse:
        """
        @summary 编辑指定guid的元数据业务知识
        
        @param request: EditMetaKnowledgeAssetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EditMetaKnowledgeAssetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.asset_description):
            query['AssetDescription'] = request.asset_description
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.table_schema_name):
            query['TableSchemaName'] = request.table_schema_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EditMetaKnowledgeAsset',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.EditMetaKnowledgeAssetResponse(),
            self.call_api(params, req, runtime)
        )

    async def edit_meta_knowledge_asset_with_options_async(
        self,
        request: dms_enterprise_20181101_models.EditMetaKnowledgeAssetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.EditMetaKnowledgeAssetResponse:
        """
        @summary 编辑指定guid的元数据业务知识
        
        @param request: EditMetaKnowledgeAssetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EditMetaKnowledgeAssetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.asset_description):
            query['AssetDescription'] = request.asset_description
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.table_schema_name):
            query['TableSchemaName'] = request.table_schema_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EditMetaKnowledgeAsset',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.EditMetaKnowledgeAssetResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def edit_meta_knowledge_asset(
        self,
        request: dms_enterprise_20181101_models.EditMetaKnowledgeAssetRequest,
    ) -> dms_enterprise_20181101_models.EditMetaKnowledgeAssetResponse:
        """
        @summary 编辑指定guid的元数据业务知识
        
        @param request: EditMetaKnowledgeAssetRequest
        @return: EditMetaKnowledgeAssetResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.edit_meta_knowledge_asset_with_options(request, runtime)

    async def edit_meta_knowledge_asset_async(
        self,
        request: dms_enterprise_20181101_models.EditMetaKnowledgeAssetRequest,
    ) -> dms_enterprise_20181101_models.EditMetaKnowledgeAssetResponse:
        """
        @summary 编辑指定guid的元数据业务知识
        
        @param request: EditMetaKnowledgeAssetRequest
        @return: EditMetaKnowledgeAssetResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.edit_meta_knowledge_asset_with_options_async(request, runtime)

    def enable_user_with_options(
        self,
        request: dms_enterprise_20181101_models.EnableUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.EnableUserResponse:
        """
        @summary You can call this operation to enable a user that has been disabled in Data Management (DMS) Enterprise.
        
        @description The effect of enabling a user by calling this operation is the same as that of enabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to enable a user that has been disabled in DMS Enterprise. After the user is enabled, the corresponding Alibaba Cloud account or Resource Access Management (RAM) user can continue to log on to DMS Enterprise and perform relevant operations.
        >  This operation only enables the Alibaba Cloud account or RAM user to log on to DMS Enterprise of the enterprise and perform relevant operations, rather than granting other permissions to the Alibaba Cloud account or RAM user.
        
        @param request: EnableUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.uid):
            query['Uid'] = request.uid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.EnableUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def enable_user_with_options_async(
        self,
        request: dms_enterprise_20181101_models.EnableUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.EnableUserResponse:
        """
        @summary You can call this operation to enable a user that has been disabled in Data Management (DMS) Enterprise.
        
        @description The effect of enabling a user by calling this operation is the same as that of enabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to enable a user that has been disabled in DMS Enterprise. After the user is enabled, the corresponding Alibaba Cloud account or Resource Access Management (RAM) user can continue to log on to DMS Enterprise and perform relevant operations.
        >  This operation only enables the Alibaba Cloud account or RAM user to log on to DMS Enterprise of the enterprise and perform relevant operations, rather than granting other permissions to the Alibaba Cloud account or RAM user.
        
        @param request: EnableUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.uid):
            query['Uid'] = request.uid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.EnableUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def enable_user(
        self,
        request: dms_enterprise_20181101_models.EnableUserRequest,
    ) -> dms_enterprise_20181101_models.EnableUserResponse:
        """
        @summary You can call this operation to enable a user that has been disabled in Data Management (DMS) Enterprise.
        
        @description The effect of enabling a user by calling this operation is the same as that of enabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to enable a user that has been disabled in DMS Enterprise. After the user is enabled, the corresponding Alibaba Cloud account or Resource Access Management (RAM) user can continue to log on to DMS Enterprise and perform relevant operations.
        >  This operation only enables the Alibaba Cloud account or RAM user to log on to DMS Enterprise of the enterprise and perform relevant operations, rather than granting other permissions to the Alibaba Cloud account or RAM user.
        
        @param request: EnableUserRequest
        @return: EnableUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.enable_user_with_options(request, runtime)

    async def enable_user_async(
        self,
        request: dms_enterprise_20181101_models.EnableUserRequest,
    ) -> dms_enterprise_20181101_models.EnableUserResponse:
        """
        @summary You can call this operation to enable a user that has been disabled in Data Management (DMS) Enterprise.
        
        @description The effect of enabling a user by calling this operation is the same as that of enabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to enable a user that has been disabled in DMS Enterprise. After the user is enabled, the corresponding Alibaba Cloud account or Resource Access Management (RAM) user can continue to log on to DMS Enterprise and perform relevant operations.
        >  This operation only enables the Alibaba Cloud account or RAM user to log on to DMS Enterprise of the enterprise and perform relevant operations, rather than granting other permissions to the Alibaba Cloud account or RAM user.
        
        @param request: EnableUserRequest
        @return: EnableUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.enable_user_with_options_async(request, runtime)

    def execute_data_correct_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.ExecuteDataCorrectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ExecuteDataCorrectResponse:
        """
        @summary Submits a ticket for data change.
        
        @param tmp_req: ExecuteDataCorrectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ExecuteDataCorrectResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.ExecuteDataCorrectShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.action_detail):
            request.action_detail_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.action_detail, 'ActionDetail', 'json')
        query = {}
        if not UtilClient.is_unset(request.action_detail_shrink):
            query['ActionDetail'] = request.action_detail_shrink
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ExecuteDataCorrect',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ExecuteDataCorrectResponse(),
            self.call_api(params, req, runtime)
        )

    async def execute_data_correct_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.ExecuteDataCorrectRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ExecuteDataCorrectResponse:
        """
        @summary Submits a ticket for data change.
        
        @param tmp_req: ExecuteDataCorrectRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ExecuteDataCorrectResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.ExecuteDataCorrectShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.action_detail):
            request.action_detail_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.action_detail, 'ActionDetail', 'json')
        query = {}
        if not UtilClient.is_unset(request.action_detail_shrink):
            query['ActionDetail'] = request.action_detail_shrink
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ExecuteDataCorrect',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ExecuteDataCorrectResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def execute_data_correct(
        self,
        request: dms_enterprise_20181101_models.ExecuteDataCorrectRequest,
    ) -> dms_enterprise_20181101_models.ExecuteDataCorrectResponse:
        """
        @summary Submits a ticket for data change.
        
        @param request: ExecuteDataCorrectRequest
        @return: ExecuteDataCorrectResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.execute_data_correct_with_options(request, runtime)

    async def execute_data_correct_async(
        self,
        request: dms_enterprise_20181101_models.ExecuteDataCorrectRequest,
    ) -> dms_enterprise_20181101_models.ExecuteDataCorrectResponse:
        """
        @summary Submits a ticket for data change.
        
        @param request: ExecuteDataCorrectRequest
        @return: ExecuteDataCorrectResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.execute_data_correct_with_options_async(request, runtime)

    def execute_data_export_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.ExecuteDataExportRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ExecuteDataExportResponse:
        """
        @summary Executes a data export ticket.
        
        @param tmp_req: ExecuteDataExportRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ExecuteDataExportResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.ExecuteDataExportShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.action_detail):
            request.action_detail_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.action_detail, 'ActionDetail', 'json')
        query = {}
        if not UtilClient.is_unset(request.action_detail_shrink):
            query['ActionDetail'] = request.action_detail_shrink
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ExecuteDataExport',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ExecuteDataExportResponse(),
            self.call_api(params, req, runtime)
        )

    async def execute_data_export_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.ExecuteDataExportRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ExecuteDataExportResponse:
        """
        @summary Executes a data export ticket.
        
        @param tmp_req: ExecuteDataExportRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ExecuteDataExportResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.ExecuteDataExportShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.action_detail):
            request.action_detail_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.action_detail, 'ActionDetail', 'json')
        query = {}
        if not UtilClient.is_unset(request.action_detail_shrink):
            query['ActionDetail'] = request.action_detail_shrink
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ExecuteDataExport',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ExecuteDataExportResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def execute_data_export(
        self,
        request: dms_enterprise_20181101_models.ExecuteDataExportRequest,
    ) -> dms_enterprise_20181101_models.ExecuteDataExportResponse:
        """
        @summary Executes a data export ticket.
        
        @param request: ExecuteDataExportRequest
        @return: ExecuteDataExportResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.execute_data_export_with_options(request, runtime)

    async def execute_data_export_async(
        self,
        request: dms_enterprise_20181101_models.ExecuteDataExportRequest,
    ) -> dms_enterprise_20181101_models.ExecuteDataExportResponse:
        """
        @summary Executes a data export ticket.
        
        @param request: ExecuteDataExportRequest
        @return: ExecuteDataExportResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.execute_data_export_with_options_async(request, runtime)

    def execute_script_with_options(
        self,
        request: dms_enterprise_20181101_models.ExecuteScriptRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ExecuteScriptResponse:
        """
        @summary Executes SQL statements.
        
        @description You can call this operation only for instances that are managed in Security Collaboration mode.
        
        @param request: ExecuteScriptRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ExecuteScriptResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.script):
            query['Script'] = request.script
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ExecuteScript',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ExecuteScriptResponse(),
            self.call_api(params, req, runtime)
        )

    async def execute_script_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ExecuteScriptRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ExecuteScriptResponse:
        """
        @summary Executes SQL statements.
        
        @description You can call this operation only for instances that are managed in Security Collaboration mode.
        
        @param request: ExecuteScriptRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ExecuteScriptResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.script):
            query['Script'] = request.script
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ExecuteScript',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ExecuteScriptResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def execute_script(
        self,
        request: dms_enterprise_20181101_models.ExecuteScriptRequest,
    ) -> dms_enterprise_20181101_models.ExecuteScriptResponse:
        """
        @summary Executes SQL statements.
        
        @description You can call this operation only for instances that are managed in Security Collaboration mode.
        
        @param request: ExecuteScriptRequest
        @return: ExecuteScriptResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.execute_script_with_options(request, runtime)

    async def execute_script_async(
        self,
        request: dms_enterprise_20181101_models.ExecuteScriptRequest,
    ) -> dms_enterprise_20181101_models.ExecuteScriptResponse:
        """
        @summary Executes SQL statements.
        
        @description You can call this operation only for instances that are managed in Security Collaboration mode.
        
        @param request: ExecuteScriptRequest
        @return: ExecuteScriptResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.execute_script_with_options_async(request, runtime)

    def execute_struct_sync_with_options(
        self,
        request: dms_enterprise_20181101_models.ExecuteStructSyncRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ExecuteStructSyncResponse:
        """
        @summary Executes a schema synchronization task.
        
        @description If the security rules of an instance indicate that a ticket must be approved before you perform schema synchronization, you can call the [SubmitStructSyncOrderApproval](https://help.aliyun.com/document_detail/206166.html) operation to submit the ticket for approval.
        >  You can call the [GetStructSyncJobDetail](https://help.aliyun.com/document_detail/206160.html) operation to query whether you need to submit a ticket for approval.
        
        @param request: ExecuteStructSyncRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ExecuteStructSyncResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ExecuteStructSync',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ExecuteStructSyncResponse(),
            self.call_api(params, req, runtime)
        )

    async def execute_struct_sync_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ExecuteStructSyncRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ExecuteStructSyncResponse:
        """
        @summary Executes a schema synchronization task.
        
        @description If the security rules of an instance indicate that a ticket must be approved before you perform schema synchronization, you can call the [SubmitStructSyncOrderApproval](https://help.aliyun.com/document_detail/206166.html) operation to submit the ticket for approval.
        >  You can call the [GetStructSyncJobDetail](https://help.aliyun.com/document_detail/206160.html) operation to query whether you need to submit a ticket for approval.
        
        @param request: ExecuteStructSyncRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ExecuteStructSyncResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ExecuteStructSync',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ExecuteStructSyncResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def execute_struct_sync(
        self,
        request: dms_enterprise_20181101_models.ExecuteStructSyncRequest,
    ) -> dms_enterprise_20181101_models.ExecuteStructSyncResponse:
        """
        @summary Executes a schema synchronization task.
        
        @description If the security rules of an instance indicate that a ticket must be approved before you perform schema synchronization, you can call the [SubmitStructSyncOrderApproval](https://help.aliyun.com/document_detail/206166.html) operation to submit the ticket for approval.
        >  You can call the [GetStructSyncJobDetail](https://help.aliyun.com/document_detail/206160.html) operation to query whether you need to submit a ticket for approval.
        
        @param request: ExecuteStructSyncRequest
        @return: ExecuteStructSyncResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.execute_struct_sync_with_options(request, runtime)

    async def execute_struct_sync_async(
        self,
        request: dms_enterprise_20181101_models.ExecuteStructSyncRequest,
    ) -> dms_enterprise_20181101_models.ExecuteStructSyncResponse:
        """
        @summary Executes a schema synchronization task.
        
        @description If the security rules of an instance indicate that a ticket must be approved before you perform schema synchronization, you can call the [SubmitStructSyncOrderApproval](https://help.aliyun.com/document_detail/206166.html) operation to submit the ticket for approval.
        >  You can call the [GetStructSyncJobDetail](https://help.aliyun.com/document_detail/206160.html) operation to query whether you need to submit a ticket for approval.
        
        @param request: ExecuteStructSyncRequest
        @return: ExecuteStructSyncResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.execute_struct_sync_with_options_async(request, runtime)

    def gen_meta_knowledge_asset_with_options(
        self,
        request: dms_enterprise_20181101_models.GenMetaKnowledgeAssetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GenMetaKnowledgeAssetResponse:
        """
        @summary 数据库知识库补数据接口
        
        @param request: GenMetaKnowledgeAssetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GenMetaKnowledgeAssetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GenMetaKnowledgeAsset',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GenMetaKnowledgeAssetResponse(),
            self.call_api(params, req, runtime)
        )

    async def gen_meta_knowledge_asset_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GenMetaKnowledgeAssetRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GenMetaKnowledgeAssetResponse:
        """
        @summary 数据库知识库补数据接口
        
        @param request: GenMetaKnowledgeAssetRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GenMetaKnowledgeAssetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GenMetaKnowledgeAsset',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GenMetaKnowledgeAssetResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def gen_meta_knowledge_asset(
        self,
        request: dms_enterprise_20181101_models.GenMetaKnowledgeAssetRequest,
    ) -> dms_enterprise_20181101_models.GenMetaKnowledgeAssetResponse:
        """
        @summary 数据库知识库补数据接口
        
        @param request: GenMetaKnowledgeAssetRequest
        @return: GenMetaKnowledgeAssetResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.gen_meta_knowledge_asset_with_options(request, runtime)

    async def gen_meta_knowledge_asset_async(
        self,
        request: dms_enterprise_20181101_models.GenMetaKnowledgeAssetRequest,
    ) -> dms_enterprise_20181101_models.GenMetaKnowledgeAssetResponse:
        """
        @summary 数据库知识库补数据接口
        
        @param request: GenMetaKnowledgeAssetRequest
        @return: GenMetaKnowledgeAssetResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.gen_meta_knowledge_asset_with_options_async(request, runtime)

    def generate_sql_from_nlwith_options(
        self,
        request: dms_enterprise_20181101_models.GenerateSqlFromNLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GenerateSqlFromNLResponse:
        """
        @summary 根据用户提供的自然语言描述和数据库信息生成对应的SQL语句。
        
        @description ## 请求说明
        - 该API用于将用户的自然语言问题转换为可执行的SQL查询语句。
        - 用户需要提供数据库ID (`dbId`) 和实例ID (`instanceId`)，以及想要查询的问题描述 (`question`)。
        - 可选参数包括业务知识 (`knowledge`)、数据库方言 (`dialect`)、历史消息 (`history`)、算法级别 (`level`) 和指定模型名称 (`model`)。
        - `dialect` 默认值为 "SQL"，表示生成标准SQL语句；`level` 默认值为 "base"，代表基础级别的处理。
        - 如果请求中包含多个表且这些表不属于同一个数据库，则返回的 `dbId` 将为0，表明这是一个跨库查询。
        - 返回结果中除了生成的SQL语句外，还包括了求解时用到的表、引用的知识点、展示用的SQL等信息，方便进一步理解和使用。
        
        @param request: GenerateSqlFromNLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GenerateSqlFromNLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.dialect):
            query['Dialect'] = request.dialect
        if not UtilClient.is_unset(request.knowledge):
            query['Knowledge'] = request.knowledge
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.model):
            query['Model'] = request.model
        if not UtilClient.is_unset(request.question):
            query['Question'] = request.question
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GenerateSqlFromNL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GenerateSqlFromNLResponse(),
            self.call_api(params, req, runtime)
        )

    async def generate_sql_from_nlwith_options_async(
        self,
        request: dms_enterprise_20181101_models.GenerateSqlFromNLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GenerateSqlFromNLResponse:
        """
        @summary 根据用户提供的自然语言描述和数据库信息生成对应的SQL语句。
        
        @description ## 请求说明
        - 该API用于将用户的自然语言问题转换为可执行的SQL查询语句。
        - 用户需要提供数据库ID (`dbId`) 和实例ID (`instanceId`)，以及想要查询的问题描述 (`question`)。
        - 可选参数包括业务知识 (`knowledge`)、数据库方言 (`dialect`)、历史消息 (`history`)、算法级别 (`level`) 和指定模型名称 (`model`)。
        - `dialect` 默认值为 "SQL"，表示生成标准SQL语句；`level` 默认值为 "base"，代表基础级别的处理。
        - 如果请求中包含多个表且这些表不属于同一个数据库，则返回的 `dbId` 将为0，表明这是一个跨库查询。
        - 返回结果中除了生成的SQL语句外，还包括了求解时用到的表、引用的知识点、展示用的SQL等信息，方便进一步理解和使用。
        
        @param request: GenerateSqlFromNLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GenerateSqlFromNLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.dialect):
            query['Dialect'] = request.dialect
        if not UtilClient.is_unset(request.knowledge):
            query['Knowledge'] = request.knowledge
        if not UtilClient.is_unset(request.level):
            query['Level'] = request.level
        if not UtilClient.is_unset(request.model):
            query['Model'] = request.model
        if not UtilClient.is_unset(request.question):
            query['Question'] = request.question
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GenerateSqlFromNL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GenerateSqlFromNLResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def generate_sql_from_nl(
        self,
        request: dms_enterprise_20181101_models.GenerateSqlFromNLRequest,
    ) -> dms_enterprise_20181101_models.GenerateSqlFromNLResponse:
        """
        @summary 根据用户提供的自然语言描述和数据库信息生成对应的SQL语句。
        
        @description ## 请求说明
        - 该API用于将用户的自然语言问题转换为可执行的SQL查询语句。
        - 用户需要提供数据库ID (`dbId`) 和实例ID (`instanceId`)，以及想要查询的问题描述 (`question`)。
        - 可选参数包括业务知识 (`knowledge`)、数据库方言 (`dialect`)、历史消息 (`history`)、算法级别 (`level`) 和指定模型名称 (`model`)。
        - `dialect` 默认值为 "SQL"，表示生成标准SQL语句；`level` 默认值为 "base"，代表基础级别的处理。
        - 如果请求中包含多个表且这些表不属于同一个数据库，则返回的 `dbId` 将为0，表明这是一个跨库查询。
        - 返回结果中除了生成的SQL语句外，还包括了求解时用到的表、引用的知识点、展示用的SQL等信息，方便进一步理解和使用。
        
        @param request: GenerateSqlFromNLRequest
        @return: GenerateSqlFromNLResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.generate_sql_from_nlwith_options(request, runtime)

    async def generate_sql_from_nl_async(
        self,
        request: dms_enterprise_20181101_models.GenerateSqlFromNLRequest,
    ) -> dms_enterprise_20181101_models.GenerateSqlFromNLResponse:
        """
        @summary 根据用户提供的自然语言描述和数据库信息生成对应的SQL语句。
        
        @description ## 请求说明
        - 该API用于将用户的自然语言问题转换为可执行的SQL查询语句。
        - 用户需要提供数据库ID (`dbId`) 和实例ID (`instanceId`)，以及想要查询的问题描述 (`question`)。
        - 可选参数包括业务知识 (`knowledge`)、数据库方言 (`dialect`)、历史消息 (`history`)、算法级别 (`level`) 和指定模型名称 (`model`)。
        - `dialect` 默认值为 "SQL"，表示生成标准SQL语句；`level` 默认值为 "base"，代表基础级别的处理。
        - 如果请求中包含多个表且这些表不属于同一个数据库，则返回的 `dbId` 将为0，表明这是一个跨库查询。
        - 返回结果中除了生成的SQL语句外，还包括了求解时用到的表、引用的知识点、展示用的SQL等信息，方便进一步理解和使用。
        
        @param request: GenerateSqlFromNLRequest
        @return: GenerateSqlFromNLResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.generate_sql_from_nlwith_options_async(request, runtime)

    def get_abac_policy_with_options(
        self,
        request: dms_enterprise_20181101_models.GetAbacPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetAbacPolicyResponse:
        """
        @summary 获取策略详情
        
        @param request: GetAbacPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAbacPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.abac_policy_id):
            query['AbacPolicyId'] = request.abac_policy_id
        if not UtilClient.is_unset(request.abac_policy_name):
            query['AbacPolicyName'] = request.abac_policy_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAbacPolicy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetAbacPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_abac_policy_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetAbacPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetAbacPolicyResponse:
        """
        @summary 获取策略详情
        
        @param request: GetAbacPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAbacPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.abac_policy_id):
            query['AbacPolicyId'] = request.abac_policy_id
        if not UtilClient.is_unset(request.abac_policy_name):
            query['AbacPolicyName'] = request.abac_policy_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAbacPolicy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetAbacPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_abac_policy(
        self,
        request: dms_enterprise_20181101_models.GetAbacPolicyRequest,
    ) -> dms_enterprise_20181101_models.GetAbacPolicyResponse:
        """
        @summary 获取策略详情
        
        @param request: GetAbacPolicyRequest
        @return: GetAbacPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_abac_policy_with_options(request, runtime)

    async def get_abac_policy_async(
        self,
        request: dms_enterprise_20181101_models.GetAbacPolicyRequest,
    ) -> dms_enterprise_20181101_models.GetAbacPolicyResponse:
        """
        @summary 获取策略详情
        
        @param request: GetAbacPolicyRequest
        @return: GetAbacPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_abac_policy_with_options_async(request, runtime)

    def get_approval_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetApprovalDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetApprovalDetailResponse:
        """
        @summary Queries the approval details of a ticket.
        
        @param request: GetApprovalDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetApprovalDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workflow_instance_id):
            query['WorkflowInstanceId'] = request.workflow_instance_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetApprovalDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetApprovalDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_approval_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetApprovalDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetApprovalDetailResponse:
        """
        @summary Queries the approval details of a ticket.
        
        @param request: GetApprovalDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetApprovalDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workflow_instance_id):
            query['WorkflowInstanceId'] = request.workflow_instance_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetApprovalDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetApprovalDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_approval_detail(
        self,
        request: dms_enterprise_20181101_models.GetApprovalDetailRequest,
    ) -> dms_enterprise_20181101_models.GetApprovalDetailResponse:
        """
        @summary Queries the approval details of a ticket.
        
        @param request: GetApprovalDetailRequest
        @return: GetApprovalDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_approval_detail_with_options(request, runtime)

    async def get_approval_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetApprovalDetailRequest,
    ) -> dms_enterprise_20181101_models.GetApprovalDetailResponse:
        """
        @summary Queries the approval details of a ticket.
        
        @param request: GetApprovalDetailRequest
        @return: GetApprovalDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_approval_detail_with_options_async(request, runtime)

    def get_authority_template_with_options(
        self,
        request: dms_enterprise_20181101_models.GetAuthorityTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetAuthorityTemplateResponse:
        """
        @summary Queries the information about a permission template.
        
        @description You must be a Data Management (DMS) administrator or a database administrator (DBA). For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: GetAuthorityTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAuthorityTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAuthorityTemplate',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetAuthorityTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_authority_template_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetAuthorityTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetAuthorityTemplateResponse:
        """
        @summary Queries the information about a permission template.
        
        @description You must be a Data Management (DMS) administrator or a database administrator (DBA). For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: GetAuthorityTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAuthorityTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAuthorityTemplate',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetAuthorityTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_authority_template(
        self,
        request: dms_enterprise_20181101_models.GetAuthorityTemplateRequest,
    ) -> dms_enterprise_20181101_models.GetAuthorityTemplateResponse:
        """
        @summary Queries the information about a permission template.
        
        @description You must be a Data Management (DMS) administrator or a database administrator (DBA). For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: GetAuthorityTemplateRequest
        @return: GetAuthorityTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_authority_template_with_options(request, runtime)

    async def get_authority_template_async(
        self,
        request: dms_enterprise_20181101_models.GetAuthorityTemplateRequest,
    ) -> dms_enterprise_20181101_models.GetAuthorityTemplateResponse:
        """
        @summary Queries the information about a permission template.
        
        @description You must be a Data Management (DMS) administrator or a database administrator (DBA). For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: GetAuthorityTemplateRequest
        @return: GetAuthorityTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_authority_template_with_options_async(request, runtime)

    def get_authority_template_item_with_options(
        self,
        request: dms_enterprise_20181101_models.GetAuthorityTemplateItemRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetAuthorityTemplateItemResponse:
        """
        @summary Queries the resources in a permission template.
        
        @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: GetAuthorityTemplateItemRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAuthorityTemplateItemResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAuthorityTemplateItem',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetAuthorityTemplateItemResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_authority_template_item_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetAuthorityTemplateItemRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetAuthorityTemplateItemResponse:
        """
        @summary Queries the resources in a permission template.
        
        @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: GetAuthorityTemplateItemRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAuthorityTemplateItemResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAuthorityTemplateItem',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetAuthorityTemplateItemResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_authority_template_item(
        self,
        request: dms_enterprise_20181101_models.GetAuthorityTemplateItemRequest,
    ) -> dms_enterprise_20181101_models.GetAuthorityTemplateItemResponse:
        """
        @summary Queries the resources in a permission template.
        
        @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: GetAuthorityTemplateItemRequest
        @return: GetAuthorityTemplateItemResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_authority_template_item_with_options(request, runtime)

    async def get_authority_template_item_async(
        self,
        request: dms_enterprise_20181101_models.GetAuthorityTemplateItemRequest,
    ) -> dms_enterprise_20181101_models.GetAuthorityTemplateItemResponse:
        """
        @summary Queries the resources in a permission template.
        
        @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: GetAuthorityTemplateItemRequest
        @return: GetAuthorityTemplateItemResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_authority_template_item_with_options_async(request, runtime)

    def get_classification_template_with_options(
        self,
        request: dms_enterprise_20181101_models.GetClassificationTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetClassificationTemplateResponse:
        """
        @summary 获取实例绑定的分类分级模板
        
        @param request: GetClassificationTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetClassificationTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetClassificationTemplate',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetClassificationTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_classification_template_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetClassificationTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetClassificationTemplateResponse:
        """
        @summary 获取实例绑定的分类分级模板
        
        @param request: GetClassificationTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetClassificationTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetClassificationTemplate',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetClassificationTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_classification_template(
        self,
        request: dms_enterprise_20181101_models.GetClassificationTemplateRequest,
    ) -> dms_enterprise_20181101_models.GetClassificationTemplateResponse:
        """
        @summary 获取实例绑定的分类分级模板
        
        @param request: GetClassificationTemplateRequest
        @return: GetClassificationTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_classification_template_with_options(request, runtime)

    async def get_classification_template_async(
        self,
        request: dms_enterprise_20181101_models.GetClassificationTemplateRequest,
    ) -> dms_enterprise_20181101_models.GetClassificationTemplateResponse:
        """
        @summary 获取实例绑定的分类分级模板
        
        @param request: GetClassificationTemplateRequest
        @return: GetClassificationTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_classification_template_with_options_async(request, runtime)

    def get_dbtask_sqljob_log_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDBTaskSQLJobLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDBTaskSQLJobLogResponse:
        """
        @summary Queries the log that records the scheduling details of an SQL task.
        
        @param request: GetDBTaskSQLJobLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDBTaskSQLJobLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDBTaskSQLJobLog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDBTaskSQLJobLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_dbtask_sqljob_log_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDBTaskSQLJobLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDBTaskSQLJobLogResponse:
        """
        @summary Queries the log that records the scheduling details of an SQL task.
        
        @param request: GetDBTaskSQLJobLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDBTaskSQLJobLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDBTaskSQLJobLog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDBTaskSQLJobLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_dbtask_sqljob_log(
        self,
        request: dms_enterprise_20181101_models.GetDBTaskSQLJobLogRequest,
    ) -> dms_enterprise_20181101_models.GetDBTaskSQLJobLogResponse:
        """
        @summary Queries the log that records the scheduling details of an SQL task.
        
        @param request: GetDBTaskSQLJobLogRequest
        @return: GetDBTaskSQLJobLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_dbtask_sqljob_log_with_options(request, runtime)

    async def get_dbtask_sqljob_log_async(
        self,
        request: dms_enterprise_20181101_models.GetDBTaskSQLJobLogRequest,
    ) -> dms_enterprise_20181101_models.GetDBTaskSQLJobLogResponse:
        """
        @summary Queries the log that records the scheduling details of an SQL task.
        
        @param request: GetDBTaskSQLJobLogRequest
        @return: GetDBTaskSQLJobLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_dbtask_sqljob_log_with_options_async(request, runtime)

    def get_dbtopology_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDBTopologyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDBTopologyResponse:
        """
        @summary Queries the topologies of a logical database and its physical database shards.
        
        @param request: GetDBTopologyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDBTopologyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.logic_db_id):
            query['LogicDbId'] = request.logic_db_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDBTopology',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDBTopologyResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_dbtopology_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDBTopologyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDBTopologyResponse:
        """
        @summary Queries the topologies of a logical database and its physical database shards.
        
        @param request: GetDBTopologyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDBTopologyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.logic_db_id):
            query['LogicDbId'] = request.logic_db_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDBTopology',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDBTopologyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_dbtopology(
        self,
        request: dms_enterprise_20181101_models.GetDBTopologyRequest,
    ) -> dms_enterprise_20181101_models.GetDBTopologyResponse:
        """
        @summary Queries the topologies of a logical database and its physical database shards.
        
        @param request: GetDBTopologyRequest
        @return: GetDBTopologyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_dbtopology_with_options(request, runtime)

    async def get_dbtopology_async(
        self,
        request: dms_enterprise_20181101_models.GetDBTopologyRequest,
    ) -> dms_enterprise_20181101_models.GetDBTopologyResponse:
        """
        @summary Queries the topologies of a logical database and its physical database shards.
        
        @param request: GetDBTopologyRequest
        @return: GetDBTopologyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_dbtopology_with_options_async(request, runtime)

    def get_data_archive_count_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataArchiveCountRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataArchiveCountResponse:
        """
        @summary Queries the statistics on the number of data archiving tickets, including the number of tickets of successful data archiving, failed data archiving,and in-progress data archiving, and the total number of data archiving tickets.
        
        @param request: GetDataArchiveCountRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataArchiveCountResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_result_type):
            query['OrderResultType'] = request.order_result_type
        if not UtilClient.is_unset(request.plugin_type):
            query['PluginType'] = request.plugin_type
        if not UtilClient.is_unset(request.search_date_type):
            query['SearchDateType'] = request.search_date_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataArchiveCount',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataArchiveCountResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_archive_count_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataArchiveCountRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataArchiveCountResponse:
        """
        @summary Queries the statistics on the number of data archiving tickets, including the number of tickets of successful data archiving, failed data archiving,and in-progress data archiving, and the total number of data archiving tickets.
        
        @param request: GetDataArchiveCountRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataArchiveCountResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_result_type):
            query['OrderResultType'] = request.order_result_type
        if not UtilClient.is_unset(request.plugin_type):
            query['PluginType'] = request.plugin_type
        if not UtilClient.is_unset(request.search_date_type):
            query['SearchDateType'] = request.search_date_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataArchiveCount',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataArchiveCountResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_archive_count(
        self,
        request: dms_enterprise_20181101_models.GetDataArchiveCountRequest,
    ) -> dms_enterprise_20181101_models.GetDataArchiveCountResponse:
        """
        @summary Queries the statistics on the number of data archiving tickets, including the number of tickets of successful data archiving, failed data archiving,and in-progress data archiving, and the total number of data archiving tickets.
        
        @param request: GetDataArchiveCountRequest
        @return: GetDataArchiveCountResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_archive_count_with_options(request, runtime)

    async def get_data_archive_count_async(
        self,
        request: dms_enterprise_20181101_models.GetDataArchiveCountRequest,
    ) -> dms_enterprise_20181101_models.GetDataArchiveCountResponse:
        """
        @summary Queries the statistics on the number of data archiving tickets, including the number of tickets of successful data archiving, failed data archiving,and in-progress data archiving, and the total number of data archiving tickets.
        
        @param request: GetDataArchiveCountRequest
        @return: GetDataArchiveCountResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_archive_count_with_options_async(request, runtime)

    def get_data_archive_order_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataArchiveOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataArchiveOrderDetailResponse:
        """
        @summary Queries the details of a data archiving ticket, including the time when the ticket was created, the scheduling information of the data archiving task, the logs of the data archiving task, and the database to which data is archived.
        
        @param request: GetDataArchiveOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataArchiveOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataArchiveOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataArchiveOrderDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_archive_order_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataArchiveOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataArchiveOrderDetailResponse:
        """
        @summary Queries the details of a data archiving ticket, including the time when the ticket was created, the scheduling information of the data archiving task, the logs of the data archiving task, and the database to which data is archived.
        
        @param request: GetDataArchiveOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataArchiveOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataArchiveOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataArchiveOrderDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_archive_order_detail(
        self,
        request: dms_enterprise_20181101_models.GetDataArchiveOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDataArchiveOrderDetailResponse:
        """
        @summary Queries the details of a data archiving ticket, including the time when the ticket was created, the scheduling information of the data archiving task, the logs of the data archiving task, and the database to which data is archived.
        
        @param request: GetDataArchiveOrderDetailRequest
        @return: GetDataArchiveOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_archive_order_detail_with_options(request, runtime)

    async def get_data_archive_order_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetDataArchiveOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDataArchiveOrderDetailResponse:
        """
        @summary Queries the details of a data archiving ticket, including the time when the ticket was created, the scheduling information of the data archiving task, the logs of the data archiving task, and the database to which data is archived.
        
        @param request: GetDataArchiveOrderDetailRequest
        @return: GetDataArchiveOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_archive_order_detail_with_options_async(request, runtime)

    def get_data_correct_backup_files_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.GetDataCorrectBackupFilesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCorrectBackupFilesResponse:
        """
        @summary Queries the download URL of the backup file for a data change ticket in Data Management (DMS).
        
        @param tmp_req: GetDataCorrectBackupFilesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCorrectBackupFilesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.GetDataCorrectBackupFilesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.action_detail):
            request.action_detail_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.action_detail, 'ActionDetail', 'json')
        query = {}
        if not UtilClient.is_unset(request.action_detail_shrink):
            query['ActionDetail'] = request.action_detail_shrink
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCorrectBackupFiles',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCorrectBackupFilesResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_correct_backup_files_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.GetDataCorrectBackupFilesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCorrectBackupFilesResponse:
        """
        @summary Queries the download URL of the backup file for a data change ticket in Data Management (DMS).
        
        @param tmp_req: GetDataCorrectBackupFilesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCorrectBackupFilesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.GetDataCorrectBackupFilesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.action_detail):
            request.action_detail_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.action_detail, 'ActionDetail', 'json')
        query = {}
        if not UtilClient.is_unset(request.action_detail_shrink):
            query['ActionDetail'] = request.action_detail_shrink
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCorrectBackupFiles',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCorrectBackupFilesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_correct_backup_files(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectBackupFilesRequest,
    ) -> dms_enterprise_20181101_models.GetDataCorrectBackupFilesResponse:
        """
        @summary Queries the download URL of the backup file for a data change ticket in Data Management (DMS).
        
        @param request: GetDataCorrectBackupFilesRequest
        @return: GetDataCorrectBackupFilesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_correct_backup_files_with_options(request, runtime)

    async def get_data_correct_backup_files_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectBackupFilesRequest,
    ) -> dms_enterprise_20181101_models.GetDataCorrectBackupFilesResponse:
        """
        @summary Queries the download URL of the backup file for a data change ticket in Data Management (DMS).
        
        @param request: GetDataCorrectBackupFilesRequest
        @return: GetDataCorrectBackupFilesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_correct_backup_files_with_options_async(request, runtime)

    def get_data_correct_order_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCorrectOrderDetailResponse:
        """
        @summary Queries the information about a data change ticket in Data Management (DMS).
        
        @param request: GetDataCorrectOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCorrectOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCorrectOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCorrectOrderDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_correct_order_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCorrectOrderDetailResponse:
        """
        @summary Queries the information about a data change ticket in Data Management (DMS).
        
        @param request: GetDataCorrectOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCorrectOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCorrectOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCorrectOrderDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_correct_order_detail(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDataCorrectOrderDetailResponse:
        """
        @summary Queries the information about a data change ticket in Data Management (DMS).
        
        @param request: GetDataCorrectOrderDetailRequest
        @return: GetDataCorrectOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_correct_order_detail_with_options(request, runtime)

    async def get_data_correct_order_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDataCorrectOrderDetailResponse:
        """
        @summary Queries the information about a data change ticket in Data Management (DMS).
        
        @param request: GetDataCorrectOrderDetailRequest
        @return: GetDataCorrectOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_correct_order_detail_with_options_async(request, runtime)

    def get_data_correct_rollback_file_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectRollbackFileRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCorrectRollbackFileResponse:
        """
        @summary Queries the download URL of the rollback attachment submitted along with a data change ticket.
        
        @param request: GetDataCorrectRollbackFileRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCorrectRollbackFileResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCorrectRollbackFile',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCorrectRollbackFileResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_correct_rollback_file_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectRollbackFileRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCorrectRollbackFileResponse:
        """
        @summary Queries the download URL of the rollback attachment submitted along with a data change ticket.
        
        @param request: GetDataCorrectRollbackFileRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCorrectRollbackFileResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCorrectRollbackFile',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCorrectRollbackFileResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_correct_rollback_file(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectRollbackFileRequest,
    ) -> dms_enterprise_20181101_models.GetDataCorrectRollbackFileResponse:
        """
        @summary Queries the download URL of the rollback attachment submitted along with a data change ticket.
        
        @param request: GetDataCorrectRollbackFileRequest
        @return: GetDataCorrectRollbackFileResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_correct_rollback_file_with_options(request, runtime)

    async def get_data_correct_rollback_file_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectRollbackFileRequest,
    ) -> dms_enterprise_20181101_models.GetDataCorrectRollbackFileResponse:
        """
        @summary Queries the download URL of the rollback attachment submitted along with a data change ticket.
        
        @param request: GetDataCorrectRollbackFileRequest
        @return: GetDataCorrectRollbackFileResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_correct_rollback_file_with_options_async(request, runtime)

    def get_data_correct_sqlfile_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectSQLFileRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCorrectSQLFileResponse:
        """
        @summary Queries the download URL of the SQL script for a data change task.
        
        @description This operation applies to [regular data change](https://help.aliyun.com/document_detail/58419.html) and [batch data import](https://help.aliyun.com/document_detail/144643.html).
        
        @param request: GetDataCorrectSQLFileRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCorrectSQLFileResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCorrectSQLFile',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCorrectSQLFileResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_correct_sqlfile_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectSQLFileRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCorrectSQLFileResponse:
        """
        @summary Queries the download URL of the SQL script for a data change task.
        
        @description This operation applies to [regular data change](https://help.aliyun.com/document_detail/58419.html) and [batch data import](https://help.aliyun.com/document_detail/144643.html).
        
        @param request: GetDataCorrectSQLFileRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCorrectSQLFileResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCorrectSQLFile',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCorrectSQLFileResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_correct_sqlfile(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectSQLFileRequest,
    ) -> dms_enterprise_20181101_models.GetDataCorrectSQLFileResponse:
        """
        @summary Queries the download URL of the SQL script for a data change task.
        
        @description This operation applies to [regular data change](https://help.aliyun.com/document_detail/58419.html) and [batch data import](https://help.aliyun.com/document_detail/144643.html).
        
        @param request: GetDataCorrectSQLFileRequest
        @return: GetDataCorrectSQLFileResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_correct_sqlfile_with_options(request, runtime)

    async def get_data_correct_sqlfile_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectSQLFileRequest,
    ) -> dms_enterprise_20181101_models.GetDataCorrectSQLFileResponse:
        """
        @summary Queries the download URL of the SQL script for a data change task.
        
        @description This operation applies to [regular data change](https://help.aliyun.com/document_detail/58419.html) and [batch data import](https://help.aliyun.com/document_detail/144643.html).
        
        @param request: GetDataCorrectSQLFileRequest
        @return: GetDataCorrectSQLFileResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_correct_sqlfile_with_options_async(request, runtime)

    def get_data_correct_task_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectTaskDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCorrectTaskDetailResponse:
        """
        @summary Queries the information about a data change, lock-free data change, or data import task.
        
        @param request: GetDataCorrectTaskDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCorrectTaskDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCorrectTaskDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCorrectTaskDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_correct_task_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectTaskDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCorrectTaskDetailResponse:
        """
        @summary Queries the information about a data change, lock-free data change, or data import task.
        
        @param request: GetDataCorrectTaskDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCorrectTaskDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCorrectTaskDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCorrectTaskDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_correct_task_detail(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectTaskDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDataCorrectTaskDetailResponse:
        """
        @summary Queries the information about a data change, lock-free data change, or data import task.
        
        @param request: GetDataCorrectTaskDetailRequest
        @return: GetDataCorrectTaskDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_correct_task_detail_with_options(request, runtime)

    async def get_data_correct_task_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCorrectTaskDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDataCorrectTaskDetailResponse:
        """
        @summary Queries the information about a data change, lock-free data change, or data import task.
        
        @param request: GetDataCorrectTaskDetailRequest
        @return: GetDataCorrectTaskDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_correct_task_detail_with_options_async(request, runtime)

    def get_data_cron_clear_config_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataCronClearConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCronClearConfigResponse:
        """
        @summary Queries the scheduling configuration of a ticket for cleaning up historical data.
        
        @param request: GetDataCronClearConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCronClearConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCronClearConfig',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCronClearConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_cron_clear_config_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCronClearConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCronClearConfigResponse:
        """
        @summary Queries the scheduling configuration of a ticket for cleaning up historical data.
        
        @param request: GetDataCronClearConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCronClearConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCronClearConfig',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCronClearConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_cron_clear_config(
        self,
        request: dms_enterprise_20181101_models.GetDataCronClearConfigRequest,
    ) -> dms_enterprise_20181101_models.GetDataCronClearConfigResponse:
        """
        @summary Queries the scheduling configuration of a ticket for cleaning up historical data.
        
        @param request: GetDataCronClearConfigRequest
        @return: GetDataCronClearConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_cron_clear_config_with_options(request, runtime)

    async def get_data_cron_clear_config_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCronClearConfigRequest,
    ) -> dms_enterprise_20181101_models.GetDataCronClearConfigResponse:
        """
        @summary Queries the scheduling configuration of a ticket for cleaning up historical data.
        
        @param request: GetDataCronClearConfigRequest
        @return: GetDataCronClearConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_cron_clear_config_with_options_async(request, runtime)

    def get_data_cron_clear_task_detail_list_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataCronClearTaskDetailListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCronClearTaskDetailListResponse:
        """
        @summary Queries the details of a historical data cleansing ticket.
        
        @param request: GetDataCronClearTaskDetailListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCronClearTaskDetailListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCronClearTaskDetailList',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCronClearTaskDetailListResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_cron_clear_task_detail_list_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCronClearTaskDetailListRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataCronClearTaskDetailListResponse:
        """
        @summary Queries the details of a historical data cleansing ticket.
        
        @param request: GetDataCronClearTaskDetailListRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataCronClearTaskDetailListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataCronClearTaskDetailList',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataCronClearTaskDetailListResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_cron_clear_task_detail_list(
        self,
        request: dms_enterprise_20181101_models.GetDataCronClearTaskDetailListRequest,
    ) -> dms_enterprise_20181101_models.GetDataCronClearTaskDetailListResponse:
        """
        @summary Queries the details of a historical data cleansing ticket.
        
        @param request: GetDataCronClearTaskDetailListRequest
        @return: GetDataCronClearTaskDetailListResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_cron_clear_task_detail_list_with_options(request, runtime)

    async def get_data_cron_clear_task_detail_list_async(
        self,
        request: dms_enterprise_20181101_models.GetDataCronClearTaskDetailListRequest,
    ) -> dms_enterprise_20181101_models.GetDataCronClearTaskDetailListResponse:
        """
        @summary Queries the details of a historical data cleansing ticket.
        
        @param request: GetDataCronClearTaskDetailListRequest
        @return: GetDataCronClearTaskDetailListResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_cron_clear_task_detail_list_with_options_async(request, runtime)

    def get_data_export_download_urlwith_options(
        self,
        request: dms_enterprise_20181101_models.GetDataExportDownloadURLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataExportDownloadURLResponse:
        """
        @summary Queries the download URL of export results for a data export ticket.
        
        @param request: GetDataExportDownloadURLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataExportDownloadURLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataExportDownloadURL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataExportDownloadURLResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_export_download_urlwith_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataExportDownloadURLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataExportDownloadURLResponse:
        """
        @summary Queries the download URL of export results for a data export ticket.
        
        @param request: GetDataExportDownloadURLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataExportDownloadURLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataExportDownloadURL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataExportDownloadURLResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_export_download_url(
        self,
        request: dms_enterprise_20181101_models.GetDataExportDownloadURLRequest,
    ) -> dms_enterprise_20181101_models.GetDataExportDownloadURLResponse:
        """
        @summary Queries the download URL of export results for a data export ticket.
        
        @param request: GetDataExportDownloadURLRequest
        @return: GetDataExportDownloadURLResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_export_download_urlwith_options(request, runtime)

    async def get_data_export_download_url_async(
        self,
        request: dms_enterprise_20181101_models.GetDataExportDownloadURLRequest,
    ) -> dms_enterprise_20181101_models.GetDataExportDownloadURLResponse:
        """
        @summary Queries the download URL of export results for a data export ticket.
        
        @param request: GetDataExportDownloadURLRequest
        @return: GetDataExportDownloadURLResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_export_download_urlwith_options_async(request, runtime)

    def get_data_export_order_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataExportOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataExportOrderDetailResponse:
        """
        @summary Queries the information about a data export ticket.
        
        @param request: GetDataExportOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataExportOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        body = {}
        if not UtilClient.is_unset(request.order_id):
            body['OrderId'] = request.order_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetDataExportOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataExportOrderDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_export_order_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataExportOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataExportOrderDetailResponse:
        """
        @summary Queries the information about a data export ticket.
        
        @param request: GetDataExportOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataExportOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        body = {}
        if not UtilClient.is_unset(request.order_id):
            body['OrderId'] = request.order_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetDataExportOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataExportOrderDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_export_order_detail(
        self,
        request: dms_enterprise_20181101_models.GetDataExportOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDataExportOrderDetailResponse:
        """
        @summary Queries the information about a data export ticket.
        
        @param request: GetDataExportOrderDetailRequest
        @return: GetDataExportOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_export_order_detail_with_options(request, runtime)

    async def get_data_export_order_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetDataExportOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDataExportOrderDetailResponse:
        """
        @summary Queries the information about a data export ticket.
        
        @param request: GetDataExportOrderDetailRequest
        @return: GetDataExportOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_export_order_detail_with_options_async(request, runtime)

    def get_data_export_pre_check_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataExportPreCheckDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataExportPreCheckDetailResponse:
        """
        @summary Queries the precheck details of an SQL result set export ticket.
        
        @param request: GetDataExportPreCheckDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataExportPreCheckDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataExportPreCheckDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataExportPreCheckDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_export_pre_check_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataExportPreCheckDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataExportPreCheckDetailResponse:
        """
        @summary Queries the precheck details of an SQL result set export ticket.
        
        @param request: GetDataExportPreCheckDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataExportPreCheckDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataExportPreCheckDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataExportPreCheckDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_export_pre_check_detail(
        self,
        request: dms_enterprise_20181101_models.GetDataExportPreCheckDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDataExportPreCheckDetailResponse:
        """
        @summary Queries the precheck details of an SQL result set export ticket.
        
        @param request: GetDataExportPreCheckDetailRequest
        @return: GetDataExportPreCheckDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_export_pre_check_detail_with_options(request, runtime)

    async def get_data_export_pre_check_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetDataExportPreCheckDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDataExportPreCheckDetailResponse:
        """
        @summary Queries the precheck details of an SQL result set export ticket.
        
        @param request: GetDataExportPreCheckDetailRequest
        @return: GetDataExportPreCheckDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_export_pre_check_detail_with_options_async(request, runtime)

    def get_data_import_sqlwith_options(
        self,
        request: dms_enterprise_20181101_models.GetDataImportSQLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataImportSQLResponse:
        """
        @summary Queries the SQL statements used for data import in a ticket.
        
        @description You can call this operation only if the data is imported in security mode in your data import ticket.
        
        @param request: GetDataImportSQLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataImportSQLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.sql_id):
            query['SqlId'] = request.sql_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataImportSQL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataImportSQLResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_import_sqlwith_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataImportSQLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataImportSQLResponse:
        """
        @summary Queries the SQL statements used for data import in a ticket.
        
        @description You can call this operation only if the data is imported in security mode in your data import ticket.
        
        @param request: GetDataImportSQLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataImportSQLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.sql_id):
            query['SqlId'] = request.sql_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataImportSQL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataImportSQLResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_import_sql(
        self,
        request: dms_enterprise_20181101_models.GetDataImportSQLRequest,
    ) -> dms_enterprise_20181101_models.GetDataImportSQLResponse:
        """
        @summary Queries the SQL statements used for data import in a ticket.
        
        @description You can call this operation only if the data is imported in security mode in your data import ticket.
        
        @param request: GetDataImportSQLRequest
        @return: GetDataImportSQLResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_import_sqlwith_options(request, runtime)

    async def get_data_import_sql_async(
        self,
        request: dms_enterprise_20181101_models.GetDataImportSQLRequest,
    ) -> dms_enterprise_20181101_models.GetDataImportSQLResponse:
        """
        @summary Queries the SQL statements used for data import in a ticket.
        
        @description You can call this operation only if the data is imported in security mode in your data import ticket.
        
        @param request: GetDataImportSQLRequest
        @return: GetDataImportSQLResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_import_sqlwith_options_async(request, runtime)

    def get_data_lake_catalog_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeCatalogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataLakeCatalogResponse:
        """
        @summary 获取uc的数据库目录
        
        @param request: GetDataLakeCatalogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataLakeCatalogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataLakeCatalog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataLakeCatalogResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_lake_catalog_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeCatalogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataLakeCatalogResponse:
        """
        @summary 获取uc的数据库目录
        
        @param request: GetDataLakeCatalogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataLakeCatalogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataLakeCatalog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataLakeCatalogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_lake_catalog(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeCatalogRequest,
    ) -> dms_enterprise_20181101_models.GetDataLakeCatalogResponse:
        """
        @summary 获取uc的数据库目录
        
        @param request: GetDataLakeCatalogRequest
        @return: GetDataLakeCatalogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_lake_catalog_with_options(request, runtime)

    async def get_data_lake_catalog_async(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeCatalogRequest,
    ) -> dms_enterprise_20181101_models.GetDataLakeCatalogResponse:
        """
        @summary 获取uc的数据库目录
        
        @param request: GetDataLakeCatalogRequest
        @return: GetDataLakeCatalogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_lake_catalog_with_options_async(request, runtime)

    def get_data_lake_database_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataLakeDatabaseResponse:
        """
        @summary 获取UC的数据库
        
        @param request: GetDataLakeDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataLakeDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataLakeDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataLakeDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_lake_database_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataLakeDatabaseResponse:
        """
        @summary 获取UC的数据库
        
        @param request: GetDataLakeDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataLakeDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataLakeDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataLakeDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_lake_database(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeDatabaseRequest,
    ) -> dms_enterprise_20181101_models.GetDataLakeDatabaseResponse:
        """
        @summary 获取UC的数据库
        
        @param request: GetDataLakeDatabaseRequest
        @return: GetDataLakeDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_lake_database_with_options(request, runtime)

    async def get_data_lake_database_async(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeDatabaseRequest,
    ) -> dms_enterprise_20181101_models.GetDataLakeDatabaseResponse:
        """
        @summary 获取UC的数据库
        
        @param request: GetDataLakeDatabaseRequest
        @return: GetDataLakeDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_lake_database_with_options_async(request, runtime)

    def get_data_lake_function_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeFunctionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataLakeFunctionResponse:
        """
        @summary 获取湖仓自定义函数详细信息
        
        @param request: GetDataLakeFunctionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataLakeFunctionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.function_name):
            query['FunctionName'] = request.function_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataLakeFunction',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataLakeFunctionResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_lake_function_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeFunctionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataLakeFunctionResponse:
        """
        @summary 获取湖仓自定义函数详细信息
        
        @param request: GetDataLakeFunctionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataLakeFunctionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.function_name):
            query['FunctionName'] = request.function_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataLakeFunction',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataLakeFunctionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_lake_function(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeFunctionRequest,
    ) -> dms_enterprise_20181101_models.GetDataLakeFunctionResponse:
        """
        @summary 获取湖仓自定义函数详细信息
        
        @param request: GetDataLakeFunctionRequest
        @return: GetDataLakeFunctionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_lake_function_with_options(request, runtime)

    async def get_data_lake_function_async(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeFunctionRequest,
    ) -> dms_enterprise_20181101_models.GetDataLakeFunctionResponse:
        """
        @summary 获取湖仓自定义函数详细信息
        
        @param request: GetDataLakeFunctionRequest
        @return: GetDataLakeFunctionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_lake_function_with_options_async(request, runtime)

    def get_data_lake_partition_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.GetDataLakePartitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataLakePartitionResponse:
        """
        @summary 获取湖仓表分区详情
        
        @param tmp_req: GetDataLakePartitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataLakePartitionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.GetDataLakePartitionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.partition_values):
            request.partition_values_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.partition_values, 'PartitionValues', 'simple')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.partition_values_shrink):
            query['PartitionValues'] = request.partition_values_shrink
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataLakePartition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataLakePartitionResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_lake_partition_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.GetDataLakePartitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataLakePartitionResponse:
        """
        @summary 获取湖仓表分区详情
        
        @param tmp_req: GetDataLakePartitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataLakePartitionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.GetDataLakePartitionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.partition_values):
            request.partition_values_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.partition_values, 'PartitionValues', 'simple')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.partition_values_shrink):
            query['PartitionValues'] = request.partition_values_shrink
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataLakePartition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataLakePartitionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_lake_partition(
        self,
        request: dms_enterprise_20181101_models.GetDataLakePartitionRequest,
    ) -> dms_enterprise_20181101_models.GetDataLakePartitionResponse:
        """
        @summary 获取湖仓表分区详情
        
        @param request: GetDataLakePartitionRequest
        @return: GetDataLakePartitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_lake_partition_with_options(request, runtime)

    async def get_data_lake_partition_async(
        self,
        request: dms_enterprise_20181101_models.GetDataLakePartitionRequest,
    ) -> dms_enterprise_20181101_models.GetDataLakePartitionResponse:
        """
        @summary 获取湖仓表分区详情
        
        @param request: GetDataLakePartitionRequest
        @return: GetDataLakePartitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_lake_partition_with_options_async(request, runtime)

    def get_data_lake_table_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataLakeTableResponse:
        """
        @summary 获取表信息
        
        @param request: GetDataLakeTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataLakeTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataLakeTable',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataLakeTableResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_lake_table_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataLakeTableResponse:
        """
        @summary 获取表信息
        
        @param request: GetDataLakeTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataLakeTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataLakeTable',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataLakeTableResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_lake_table(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeTableRequest,
    ) -> dms_enterprise_20181101_models.GetDataLakeTableResponse:
        """
        @summary 获取表信息
        
        @param request: GetDataLakeTableRequest
        @return: GetDataLakeTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_lake_table_with_options(request, runtime)

    async def get_data_lake_table_async(
        self,
        request: dms_enterprise_20181101_models.GetDataLakeTableRequest,
    ) -> dms_enterprise_20181101_models.GetDataLakeTableResponse:
        """
        @summary 获取表信息
        
        @param request: GetDataLakeTableRequest
        @return: GetDataLakeTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_lake_table_with_options_async(request, runtime)

    def get_data_track_job_degree_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataTrackJobDegreeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataTrackJobDegreeResponse:
        """
        @summary Queries the progress of a data tracking task.
        
        @param request: GetDataTrackJobDegreeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataTrackJobDegreeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataTrackJobDegree',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataTrackJobDegreeResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_track_job_degree_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataTrackJobDegreeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataTrackJobDegreeResponse:
        """
        @summary Queries the progress of a data tracking task.
        
        @param request: GetDataTrackJobDegreeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataTrackJobDegreeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataTrackJobDegree',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataTrackJobDegreeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_track_job_degree(
        self,
        request: dms_enterprise_20181101_models.GetDataTrackJobDegreeRequest,
    ) -> dms_enterprise_20181101_models.GetDataTrackJobDegreeResponse:
        """
        @summary Queries the progress of a data tracking task.
        
        @param request: GetDataTrackJobDegreeRequest
        @return: GetDataTrackJobDegreeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_track_job_degree_with_options(request, runtime)

    async def get_data_track_job_degree_async(
        self,
        request: dms_enterprise_20181101_models.GetDataTrackJobDegreeRequest,
    ) -> dms_enterprise_20181101_models.GetDataTrackJobDegreeResponse:
        """
        @summary Queries the progress of a data tracking task.
        
        @param request: GetDataTrackJobDegreeRequest
        @return: GetDataTrackJobDegreeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_track_job_degree_with_options_async(request, runtime)

    def get_data_track_job_table_meta_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataTrackJobTableMetaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataTrackJobTableMetaResponse:
        """
        @summary Queries the metadata of tables involved in a data tracking task.
        
        @param request: GetDataTrackJobTableMetaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataTrackJobTableMetaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataTrackJobTableMeta',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataTrackJobTableMetaResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_track_job_table_meta_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataTrackJobTableMetaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataTrackJobTableMetaResponse:
        """
        @summary Queries the metadata of tables involved in a data tracking task.
        
        @param request: GetDataTrackJobTableMetaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataTrackJobTableMetaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataTrackJobTableMeta',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataTrackJobTableMetaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_track_job_table_meta(
        self,
        request: dms_enterprise_20181101_models.GetDataTrackJobTableMetaRequest,
    ) -> dms_enterprise_20181101_models.GetDataTrackJobTableMetaResponse:
        """
        @summary Queries the metadata of tables involved in a data tracking task.
        
        @param request: GetDataTrackJobTableMetaRequest
        @return: GetDataTrackJobTableMetaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_track_job_table_meta_with_options(request, runtime)

    async def get_data_track_job_table_meta_async(
        self,
        request: dms_enterprise_20181101_models.GetDataTrackJobTableMetaRequest,
    ) -> dms_enterprise_20181101_models.GetDataTrackJobTableMetaResponse:
        """
        @summary Queries the metadata of tables involved in a data tracking task.
        
        @param request: GetDataTrackJobTableMetaRequest
        @return: GetDataTrackJobTableMetaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_track_job_table_meta_with_options_async(request, runtime)

    def get_data_track_order_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDataTrackOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataTrackOrderDetailResponse:
        """
        @summary Queries the details of a data tracking ticket.
        
        @param request: GetDataTrackOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataTrackOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataTrackOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataTrackOrderDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_data_track_order_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDataTrackOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDataTrackOrderDetailResponse:
        """
        @summary Queries the details of a data tracking ticket.
        
        @param request: GetDataTrackOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDataTrackOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDataTrackOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDataTrackOrderDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_data_track_order_detail(
        self,
        request: dms_enterprise_20181101_models.GetDataTrackOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDataTrackOrderDetailResponse:
        """
        @summary Queries the details of a data tracking ticket.
        
        @param request: GetDataTrackOrderDetailRequest
        @return: GetDataTrackOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_data_track_order_detail_with_options(request, runtime)

    async def get_data_track_order_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetDataTrackOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDataTrackOrderDetailResponse:
        """
        @summary Queries the details of a data tracking ticket.
        
        @param request: GetDataTrackOrderDetailRequest
        @return: GetDataTrackOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_data_track_order_detail_with_options_async(request, runtime)

    def get_database_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDatabaseResponse:
        """
        @summary Queries details of a specific database.
        
        @param request: GetDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_database_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDatabaseResponse:
        """
        @summary Queries details of a specific database.
        
        @param request: GetDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_database(
        self,
        request: dms_enterprise_20181101_models.GetDatabaseRequest,
    ) -> dms_enterprise_20181101_models.GetDatabaseResponse:
        """
        @summary Queries details of a specific database.
        
        @param request: GetDatabaseRequest
        @return: GetDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_database_with_options(request, runtime)

    async def get_database_async(
        self,
        request: dms_enterprise_20181101_models.GetDatabaseRequest,
    ) -> dms_enterprise_20181101_models.GetDatabaseResponse:
        """
        @summary Queries details of a specific database.
        
        @param request: GetDatabaseRequest
        @return: GetDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_database_with_options_async(request, runtime)

    def get_database_export_order_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetDatabaseExportOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDatabaseExportOrderDetailResponse:
        """
        @summary Queries the details of a database export ticket.
        
        @param request: GetDatabaseExportOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDatabaseExportOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        body = {}
        if not UtilClient.is_unset(request.order_id):
            body['OrderId'] = request.order_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetDatabaseExportOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDatabaseExportOrderDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_database_export_order_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDatabaseExportOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDatabaseExportOrderDetailResponse:
        """
        @summary Queries the details of a database export ticket.
        
        @param request: GetDatabaseExportOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDatabaseExportOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        body = {}
        if not UtilClient.is_unset(request.order_id):
            body['OrderId'] = request.order_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetDatabaseExportOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDatabaseExportOrderDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_database_export_order_detail(
        self,
        request: dms_enterprise_20181101_models.GetDatabaseExportOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDatabaseExportOrderDetailResponse:
        """
        @summary Queries the details of a database export ticket.
        
        @param request: GetDatabaseExportOrderDetailRequest
        @return: GetDatabaseExportOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_database_export_order_detail_with_options(request, runtime)

    async def get_database_export_order_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetDatabaseExportOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetDatabaseExportOrderDetailResponse:
        """
        @summary Queries the details of a database export ticket.
        
        @param request: GetDatabaseExportOrderDetailRequest
        @return: GetDatabaseExportOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_database_export_order_detail_with_options_async(request, runtime)

    def get_db_export_download_urlwith_options(
        self,
        request: dms_enterprise_20181101_models.GetDbExportDownloadURLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDbExportDownloadURLResponse:
        """
        @summary 获取数据库导出下载地址
        
        @param request: GetDbExportDownloadURLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDbExportDownloadURLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDbExportDownloadURL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDbExportDownloadURLResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_db_export_download_urlwith_options_async(
        self,
        request: dms_enterprise_20181101_models.GetDbExportDownloadURLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetDbExportDownloadURLResponse:
        """
        @summary 获取数据库导出下载地址
        
        @param request: GetDbExportDownloadURLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetDbExportDownloadURLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetDbExportDownloadURL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetDbExportDownloadURLResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_db_export_download_url(
        self,
        request: dms_enterprise_20181101_models.GetDbExportDownloadURLRequest,
    ) -> dms_enterprise_20181101_models.GetDbExportDownloadURLResponse:
        """
        @summary 获取数据库导出下载地址
        
        @param request: GetDbExportDownloadURLRequest
        @return: GetDbExportDownloadURLResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_db_export_download_urlwith_options(request, runtime)

    async def get_db_export_download_url_async(
        self,
        request: dms_enterprise_20181101_models.GetDbExportDownloadURLRequest,
    ) -> dms_enterprise_20181101_models.GetDbExportDownloadURLResponse:
        """
        @summary 获取数据库导出下载地址
        
        @param request: GetDbExportDownloadURLRequest
        @return: GetDbExportDownloadURLResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_db_export_download_urlwith_options_async(request, runtime)

    def get_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.GetInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetInstanceResponse:
        """
        @summary Queries the details of a database instance.
        
        @param request: GetInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetInstanceResponse:
        """
        @summary Queries the details of a database instance.
        
        @param request: GetInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_instance(
        self,
        request: dms_enterprise_20181101_models.GetInstanceRequest,
    ) -> dms_enterprise_20181101_models.GetInstanceResponse:
        """
        @summary Queries the details of a database instance.
        
        @param request: GetInstanceRequest
        @return: GetInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_instance_with_options(request, runtime)

    async def get_instance_async(
        self,
        request: dms_enterprise_20181101_models.GetInstanceRequest,
    ) -> dms_enterprise_20181101_models.GetInstanceResponse:
        """
        @summary Queries the details of a database instance.
        
        @param request: GetInstanceRequest
        @return: GetInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_instance_with_options_async(request, runtime)

    def get_interval_limit_of_slawith_options(
        self,
        request: dms_enterprise_20181101_models.GetIntervalLimitOfSLARequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetIntervalLimitOfSLAResponse:
        """
        @summary Queries the minimum scheduling cycle of a task flow when a service level agreement (SLA) timeout rule is configured for the task flow.
        
        @description The scheduling cycle of a task flow must be greater than the minimum scheduling cycle configured in the SLA rule for the task flow.
        
        @param request: GetIntervalLimitOfSLARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIntervalLimitOfSLAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIntervalLimitOfSLA',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetIntervalLimitOfSLAResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_interval_limit_of_slawith_options_async(
        self,
        request: dms_enterprise_20181101_models.GetIntervalLimitOfSLARequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetIntervalLimitOfSLAResponse:
        """
        @summary Queries the minimum scheduling cycle of a task flow when a service level agreement (SLA) timeout rule is configured for the task flow.
        
        @description The scheduling cycle of a task flow must be greater than the minimum scheduling cycle configured in the SLA rule for the task flow.
        
        @param request: GetIntervalLimitOfSLARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIntervalLimitOfSLAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIntervalLimitOfSLA',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetIntervalLimitOfSLAResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_interval_limit_of_sla(
        self,
        request: dms_enterprise_20181101_models.GetIntervalLimitOfSLARequest,
    ) -> dms_enterprise_20181101_models.GetIntervalLimitOfSLAResponse:
        """
        @summary Queries the minimum scheduling cycle of a task flow when a service level agreement (SLA) timeout rule is configured for the task flow.
        
        @description The scheduling cycle of a task flow must be greater than the minimum scheduling cycle configured in the SLA rule for the task flow.
        
        @param request: GetIntervalLimitOfSLARequest
        @return: GetIntervalLimitOfSLAResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_interval_limit_of_slawith_options(request, runtime)

    async def get_interval_limit_of_sla_async(
        self,
        request: dms_enterprise_20181101_models.GetIntervalLimitOfSLARequest,
    ) -> dms_enterprise_20181101_models.GetIntervalLimitOfSLAResponse:
        """
        @summary Queries the minimum scheduling cycle of a task flow when a service level agreement (SLA) timeout rule is configured for the task flow.
        
        @description The scheduling cycle of a task flow must be greater than the minimum scheduling cycle configured in the SLA rule for the task flow.
        
        @param request: GetIntervalLimitOfSLARequest
        @return: GetIntervalLimitOfSLAResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_interval_limit_of_slawith_options_async(request, runtime)

    def get_lh_space_by_name_with_options(
        self,
        request: dms_enterprise_20181101_models.GetLhSpaceByNameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetLhSpaceByNameResponse:
        """
        @summary Queries the information about a workspace based on the workspace name in Data Management (DMS).
        
        @description You are a DMS administrator or a database administrator (DBA).
        
        @param request: GetLhSpaceByNameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetLhSpaceByNameResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.space_name):
            query['SpaceName'] = request.space_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetLhSpaceByName',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetLhSpaceByNameResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_lh_space_by_name_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetLhSpaceByNameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetLhSpaceByNameResponse:
        """
        @summary Queries the information about a workspace based on the workspace name in Data Management (DMS).
        
        @description You are a DMS administrator or a database administrator (DBA).
        
        @param request: GetLhSpaceByNameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetLhSpaceByNameResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.space_name):
            query['SpaceName'] = request.space_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetLhSpaceByName',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetLhSpaceByNameResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_lh_space_by_name(
        self,
        request: dms_enterprise_20181101_models.GetLhSpaceByNameRequest,
    ) -> dms_enterprise_20181101_models.GetLhSpaceByNameResponse:
        """
        @summary Queries the information about a workspace based on the workspace name in Data Management (DMS).
        
        @description You are a DMS administrator or a database administrator (DBA).
        
        @param request: GetLhSpaceByNameRequest
        @return: GetLhSpaceByNameResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_lh_space_by_name_with_options(request, runtime)

    async def get_lh_space_by_name_async(
        self,
        request: dms_enterprise_20181101_models.GetLhSpaceByNameRequest,
    ) -> dms_enterprise_20181101_models.GetLhSpaceByNameResponse:
        """
        @summary Queries the information about a workspace based on the workspace name in Data Management (DMS).
        
        @description You are a DMS administrator or a database administrator (DBA).
        
        @param request: GetLhSpaceByNameRequest
        @return: GetLhSpaceByNameResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_lh_space_by_name_with_options_async(request, runtime)

    def get_logic_database_with_options(
        self,
        request: dms_enterprise_20181101_models.GetLogicDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetLogicDatabaseResponse:
        """
        @summary Queries the details of a logical database.
        
        @param request: GetLogicDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetLogicDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetLogicDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetLogicDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_logic_database_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetLogicDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetLogicDatabaseResponse:
        """
        @summary Queries the details of a logical database.
        
        @param request: GetLogicDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetLogicDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetLogicDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetLogicDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_logic_database(
        self,
        request: dms_enterprise_20181101_models.GetLogicDatabaseRequest,
    ) -> dms_enterprise_20181101_models.GetLogicDatabaseResponse:
        """
        @summary Queries the details of a logical database.
        
        @param request: GetLogicDatabaseRequest
        @return: GetLogicDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_logic_database_with_options(request, runtime)

    async def get_logic_database_async(
        self,
        request: dms_enterprise_20181101_models.GetLogicDatabaseRequest,
    ) -> dms_enterprise_20181101_models.GetLogicDatabaseResponse:
        """
        @summary Queries the details of a logical database.
        
        @param request: GetLogicDatabaseRequest
        @return: GetLogicDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_logic_database_with_options_async(request, runtime)

    def get_meta_table_column_with_options(
        self,
        request: dms_enterprise_20181101_models.GetMetaTableColumnRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetMetaTableColumnResponse:
        """
        @summary Queries the details of columns in a table.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: GetMetaTableColumnRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMetaTableColumnResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.table_guid):
            query['TableGuid'] = request.table_guid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMetaTableColumn',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetMetaTableColumnResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_meta_table_column_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetMetaTableColumnRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetMetaTableColumnResponse:
        """
        @summary Queries the details of columns in a table.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: GetMetaTableColumnRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMetaTableColumnResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.table_guid):
            query['TableGuid'] = request.table_guid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMetaTableColumn',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetMetaTableColumnResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_meta_table_column(
        self,
        request: dms_enterprise_20181101_models.GetMetaTableColumnRequest,
    ) -> dms_enterprise_20181101_models.GetMetaTableColumnResponse:
        """
        @summary Queries the details of columns in a table.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: GetMetaTableColumnRequest
        @return: GetMetaTableColumnResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_meta_table_column_with_options(request, runtime)

    async def get_meta_table_column_async(
        self,
        request: dms_enterprise_20181101_models.GetMetaTableColumnRequest,
    ) -> dms_enterprise_20181101_models.GetMetaTableColumnResponse:
        """
        @summary Queries the details of columns in a table.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: GetMetaTableColumnRequest
        @return: GetMetaTableColumnResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_meta_table_column_with_options_async(request, runtime)

    def get_meta_table_detail_info_with_options(
        self,
        request: dms_enterprise_20181101_models.GetMetaTableDetailInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetMetaTableDetailInfoResponse:
        """
        @summary Queries the details of columns and indexes in a table.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: GetMetaTableDetailInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMetaTableDetailInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.table_guid):
            query['TableGuid'] = request.table_guid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMetaTableDetailInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetMetaTableDetailInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_meta_table_detail_info_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetMetaTableDetailInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetMetaTableDetailInfoResponse:
        """
        @summary Queries the details of columns and indexes in a table.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: GetMetaTableDetailInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMetaTableDetailInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.table_guid):
            query['TableGuid'] = request.table_guid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMetaTableDetailInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetMetaTableDetailInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_meta_table_detail_info(
        self,
        request: dms_enterprise_20181101_models.GetMetaTableDetailInfoRequest,
    ) -> dms_enterprise_20181101_models.GetMetaTableDetailInfoResponse:
        """
        @summary Queries the details of columns and indexes in a table.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: GetMetaTableDetailInfoRequest
        @return: GetMetaTableDetailInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_meta_table_detail_info_with_options(request, runtime)

    async def get_meta_table_detail_info_async(
        self,
        request: dms_enterprise_20181101_models.GetMetaTableDetailInfoRequest,
    ) -> dms_enterprise_20181101_models.GetMetaTableDetailInfoResponse:
        """
        @summary Queries the details of columns and indexes in a table.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: GetMetaTableDetailInfoRequest
        @return: GetMetaTableDetailInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_meta_table_detail_info_with_options_async(request, runtime)

    def get_online_ddlprogress_with_options(
        self,
        request: dms_enterprise_20181101_models.GetOnlineDDLProgressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetOnlineDDLProgressResponse:
        """
        @summary Queries the details and progress of an OnlineDDL task.
        
        @param request: GetOnlineDDLProgressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOnlineDDLProgressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_detail_id):
            query['JobDetailId'] = request.job_detail_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOnlineDDLProgress',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetOnlineDDLProgressResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_online_ddlprogress_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetOnlineDDLProgressRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetOnlineDDLProgressResponse:
        """
        @summary Queries the details and progress of an OnlineDDL task.
        
        @param request: GetOnlineDDLProgressRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOnlineDDLProgressResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_detail_id):
            query['JobDetailId'] = request.job_detail_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOnlineDDLProgress',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetOnlineDDLProgressResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_online_ddlprogress(
        self,
        request: dms_enterprise_20181101_models.GetOnlineDDLProgressRequest,
    ) -> dms_enterprise_20181101_models.GetOnlineDDLProgressResponse:
        """
        @summary Queries the details and progress of an OnlineDDL task.
        
        @param request: GetOnlineDDLProgressRequest
        @return: GetOnlineDDLProgressResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_online_ddlprogress_with_options(request, runtime)

    async def get_online_ddlprogress_async(
        self,
        request: dms_enterprise_20181101_models.GetOnlineDDLProgressRequest,
    ) -> dms_enterprise_20181101_models.GetOnlineDDLProgressResponse:
        """
        @summary Queries the details and progress of an OnlineDDL task.
        
        @param request: GetOnlineDDLProgressRequest
        @return: GetOnlineDDLProgressResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_online_ddlprogress_with_options_async(request, runtime)

    def get_op_log_with_options(
        self,
        request: dms_enterprise_20181101_models.GetOpLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetOpLogResponse:
        """
        @summary Queries the details of operation logs that are generated in a specified period of time.
        
        @description Prerequisites: You are an administrator of Data Management (DMS) or a security administrator. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain your user role from the RoleIdList parameter that is returned.
        
        @param request: GetOpLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOpLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.database_name):
            query['DatabaseName'] = request.database_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.module):
            query['Module'] = request.module
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_nick):
            query['UserNick'] = request.user_nick
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOpLog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetOpLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_op_log_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetOpLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetOpLogResponse:
        """
        @summary Queries the details of operation logs that are generated in a specified period of time.
        
        @description Prerequisites: You are an administrator of Data Management (DMS) or a security administrator. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain your user role from the RoleIdList parameter that is returned.
        
        @param request: GetOpLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOpLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.database_name):
            query['DatabaseName'] = request.database_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.module):
            query['Module'] = request.module
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_nick):
            query['UserNick'] = request.user_nick
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOpLog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetOpLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_op_log(
        self,
        request: dms_enterprise_20181101_models.GetOpLogRequest,
    ) -> dms_enterprise_20181101_models.GetOpLogResponse:
        """
        @summary Queries the details of operation logs that are generated in a specified period of time.
        
        @description Prerequisites: You are an administrator of Data Management (DMS) or a security administrator. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain your user role from the RoleIdList parameter that is returned.
        
        @param request: GetOpLogRequest
        @return: GetOpLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_op_log_with_options(request, runtime)

    async def get_op_log_async(
        self,
        request: dms_enterprise_20181101_models.GetOpLogRequest,
    ) -> dms_enterprise_20181101_models.GetOpLogResponse:
        """
        @summary Queries the details of operation logs that are generated in a specified period of time.
        
        @description Prerequisites: You are an administrator of Data Management (DMS) or a security administrator. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain your user role from the RoleIdList parameter that is returned.
        
        @param request: GetOpLogRequest
        @return: GetOpLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_op_log_with_options_async(request, runtime)

    def get_order_attachment_file_with_options(
        self,
        request: dms_enterprise_20181101_models.GetOrderAttachmentFileRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetOrderAttachmentFileResponse:
        """
        @summary Queries the download URL of the attachment of a ticket.
        
        @param request: GetOrderAttachmentFileRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOrderAttachmentFileResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOrderAttachmentFile',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetOrderAttachmentFileResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_order_attachment_file_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetOrderAttachmentFileRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetOrderAttachmentFileResponse:
        """
        @summary Queries the download URL of the attachment of a ticket.
        
        @param request: GetOrderAttachmentFileRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOrderAttachmentFileResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOrderAttachmentFile',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetOrderAttachmentFileResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_order_attachment_file(
        self,
        request: dms_enterprise_20181101_models.GetOrderAttachmentFileRequest,
    ) -> dms_enterprise_20181101_models.GetOrderAttachmentFileResponse:
        """
        @summary Queries the download URL of the attachment of a ticket.
        
        @param request: GetOrderAttachmentFileRequest
        @return: GetOrderAttachmentFileResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_order_attachment_file_with_options(request, runtime)

    async def get_order_attachment_file_async(
        self,
        request: dms_enterprise_20181101_models.GetOrderAttachmentFileRequest,
    ) -> dms_enterprise_20181101_models.GetOrderAttachmentFileResponse:
        """
        @summary Queries the download URL of the attachment of a ticket.
        
        @param request: GetOrderAttachmentFileRequest
        @return: GetOrderAttachmentFileResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_order_attachment_file_with_options_async(request, runtime)

    def get_order_base_info_with_options(
        self,
        request: dms_enterprise_20181101_models.GetOrderBaseInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetOrderBaseInfoResponse:
        """
        @summary Queries the basic information about a ticket.
        
        @param request: GetOrderBaseInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOrderBaseInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOrderBaseInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetOrderBaseInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_order_base_info_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetOrderBaseInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetOrderBaseInfoResponse:
        """
        @summary Queries the basic information about a ticket.
        
        @param request: GetOrderBaseInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOrderBaseInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOrderBaseInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetOrderBaseInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_order_base_info(
        self,
        request: dms_enterprise_20181101_models.GetOrderBaseInfoRequest,
    ) -> dms_enterprise_20181101_models.GetOrderBaseInfoResponse:
        """
        @summary Queries the basic information about a ticket.
        
        @param request: GetOrderBaseInfoRequest
        @return: GetOrderBaseInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_order_base_info_with_options(request, runtime)

    async def get_order_base_info_async(
        self,
        request: dms_enterprise_20181101_models.GetOrderBaseInfoRequest,
    ) -> dms_enterprise_20181101_models.GetOrderBaseInfoResponse:
        """
        @summary Queries the basic information about a ticket.
        
        @param request: GetOrderBaseInfoRequest
        @return: GetOrderBaseInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_order_base_info_with_options_async(request, runtime)

    def get_owner_apply_order_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetOwnerApplyOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetOwnerApplyOrderDetailResponse:
        """
        @summary Queries the details of the Database-OWNER, Table-OWNER, and Instance-OWNER tickets.
        
        @param request: GetOwnerApplyOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOwnerApplyOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOwnerApplyOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetOwnerApplyOrderDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_owner_apply_order_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetOwnerApplyOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetOwnerApplyOrderDetailResponse:
        """
        @summary Queries the details of the Database-OWNER, Table-OWNER, and Instance-OWNER tickets.
        
        @param request: GetOwnerApplyOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOwnerApplyOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOwnerApplyOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetOwnerApplyOrderDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_owner_apply_order_detail(
        self,
        request: dms_enterprise_20181101_models.GetOwnerApplyOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetOwnerApplyOrderDetailResponse:
        """
        @summary Queries the details of the Database-OWNER, Table-OWNER, and Instance-OWNER tickets.
        
        @param request: GetOwnerApplyOrderDetailRequest
        @return: GetOwnerApplyOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_owner_apply_order_detail_with_options(request, runtime)

    async def get_owner_apply_order_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetOwnerApplyOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetOwnerApplyOrderDetailResponse:
        """
        @summary Queries the details of the Database-OWNER, Table-OWNER, and Instance-OWNER tickets.
        
        @param request: GetOwnerApplyOrderDetailRequest
        @return: GetOwnerApplyOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_owner_apply_order_detail_with_options_async(request, runtime)

    def get_paged_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.GetPagedInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetPagedInstanceResponse:
        """
        @summary 获取数据归档工单任务实例
        
        @param request: GetPagedInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPagedInstanceResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPagedInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetPagedInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_paged_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetPagedInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetPagedInstanceResponse:
        """
        @summary 获取数据归档工单任务实例
        
        @param request: GetPagedInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPagedInstanceResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPagedInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetPagedInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_paged_instance(
        self,
        request: dms_enterprise_20181101_models.GetPagedInstanceRequest,
    ) -> dms_enterprise_20181101_models.GetPagedInstanceResponse:
        """
        @summary 获取数据归档工单任务实例
        
        @param request: GetPagedInstanceRequest
        @return: GetPagedInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_paged_instance_with_options(request, runtime)

    async def get_paged_instance_async(
        self,
        request: dms_enterprise_20181101_models.GetPagedInstanceRequest,
    ) -> dms_enterprise_20181101_models.GetPagedInstanceResponse:
        """
        @summary 获取数据归档工单任务实例
        
        @param request: GetPagedInstanceRequest
        @return: GetPagedInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_paged_instance_with_options_async(request, runtime)

    def get_perm_apply_order_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetPermApplyOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetPermApplyOrderDetailResponse:
        """
        @summary Queries the details of a ticket that applies for permissions.
        
        @description You can call this operation to query the information about tickets that apply for permissions on databases, tables, and sensitive columns.
        
        @param request: GetPermApplyOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPermApplyOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPermApplyOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetPermApplyOrderDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_perm_apply_order_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetPermApplyOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetPermApplyOrderDetailResponse:
        """
        @summary Queries the details of a ticket that applies for permissions.
        
        @description You can call this operation to query the information about tickets that apply for permissions on databases, tables, and sensitive columns.
        
        @param request: GetPermApplyOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPermApplyOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPermApplyOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetPermApplyOrderDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_perm_apply_order_detail(
        self,
        request: dms_enterprise_20181101_models.GetPermApplyOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetPermApplyOrderDetailResponse:
        """
        @summary Queries the details of a ticket that applies for permissions.
        
        @description You can call this operation to query the information about tickets that apply for permissions on databases, tables, and sensitive columns.
        
        @param request: GetPermApplyOrderDetailRequest
        @return: GetPermApplyOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_perm_apply_order_detail_with_options(request, runtime)

    async def get_perm_apply_order_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetPermApplyOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetPermApplyOrderDetailResponse:
        """
        @summary Queries the details of a ticket that applies for permissions.
        
        @description You can call this operation to query the information about tickets that apply for permissions on databases, tables, and sensitive columns.
        
        @param request: GetPermApplyOrderDetailRequest
        @return: GetPermApplyOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_perm_apply_order_detail_with_options_async(request, runtime)

    def get_physical_database_with_options(
        self,
        request: dms_enterprise_20181101_models.GetPhysicalDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetPhysicalDatabaseResponse:
        """
        @summary Queries the details of a physical database.
        
        @param request: GetPhysicalDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPhysicalDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPhysicalDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetPhysicalDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_physical_database_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetPhysicalDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetPhysicalDatabaseResponse:
        """
        @summary Queries the details of a physical database.
        
        @param request: GetPhysicalDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPhysicalDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPhysicalDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetPhysicalDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_physical_database(
        self,
        request: dms_enterprise_20181101_models.GetPhysicalDatabaseRequest,
    ) -> dms_enterprise_20181101_models.GetPhysicalDatabaseResponse:
        """
        @summary Queries the details of a physical database.
        
        @param request: GetPhysicalDatabaseRequest
        @return: GetPhysicalDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_physical_database_with_options(request, runtime)

    async def get_physical_database_async(
        self,
        request: dms_enterprise_20181101_models.GetPhysicalDatabaseRequest,
    ) -> dms_enterprise_20181101_models.GetPhysicalDatabaseResponse:
        """
        @summary Queries the details of a physical database.
        
        @param request: GetPhysicalDatabaseRequest
        @return: GetPhysicalDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_physical_database_with_options_async(request, runtime)

    def get_proxy_with_options(
        self,
        request: dms_enterprise_20181101_models.GetProxyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetProxyResponse:
        """
        @summary Queries the details of a secure access proxy.
        
        @param request: GetProxyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetProxyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.proxy_id):
            query['ProxyId'] = request.proxy_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetProxy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetProxyResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_proxy_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetProxyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetProxyResponse:
        """
        @summary Queries the details of a secure access proxy.
        
        @param request: GetProxyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetProxyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.proxy_id):
            query['ProxyId'] = request.proxy_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetProxy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetProxyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_proxy(
        self,
        request: dms_enterprise_20181101_models.GetProxyRequest,
    ) -> dms_enterprise_20181101_models.GetProxyResponse:
        """
        @summary Queries the details of a secure access proxy.
        
        @param request: GetProxyRequest
        @return: GetProxyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_proxy_with_options(request, runtime)

    async def get_proxy_async(
        self,
        request: dms_enterprise_20181101_models.GetProxyRequest,
    ) -> dms_enterprise_20181101_models.GetProxyResponse:
        """
        @summary Queries the details of a secure access proxy.
        
        @param request: GetProxyRequest
        @return: GetProxyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_proxy_with_options_async(request, runtime)

    def get_proxy_access_with_options(
        self,
        request: dms_enterprise_20181101_models.GetProxyAccessRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetProxyAccessResponse:
        """
        @summary Queries the authorization information about the secure access proxy feature.
        
        @param request: GetProxyAccessRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetProxyAccessResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.proxy_access_id):
            query['ProxyAccessId'] = request.proxy_access_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetProxyAccess',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetProxyAccessResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_proxy_access_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetProxyAccessRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetProxyAccessResponse:
        """
        @summary Queries the authorization information about the secure access proxy feature.
        
        @param request: GetProxyAccessRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetProxyAccessResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.proxy_access_id):
            query['ProxyAccessId'] = request.proxy_access_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetProxyAccess',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetProxyAccessResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_proxy_access(
        self,
        request: dms_enterprise_20181101_models.GetProxyAccessRequest,
    ) -> dms_enterprise_20181101_models.GetProxyAccessResponse:
        """
        @summary Queries the authorization information about the secure access proxy feature.
        
        @param request: GetProxyAccessRequest
        @return: GetProxyAccessResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_proxy_access_with_options(request, runtime)

    async def get_proxy_access_async(
        self,
        request: dms_enterprise_20181101_models.GetProxyAccessRequest,
    ) -> dms_enterprise_20181101_models.GetProxyAccessResponse:
        """
        @summary Queries the authorization information about the secure access proxy feature.
        
        @param request: GetProxyAccessRequest
        @return: GetProxyAccessResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_proxy_access_with_options_async(request, runtime)

    def get_rule_num_limit_of_slawith_options(
        self,
        request: dms_enterprise_20181101_models.GetRuleNumLimitOfSLARequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetRuleNumLimitOfSLAResponse:
        """
        @summary Queries the maximum number of custom service-level agreement (SLA) rules for task orchestration.
        
        @param request: GetRuleNumLimitOfSLARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetRuleNumLimitOfSLAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetRuleNumLimitOfSLA',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetRuleNumLimitOfSLAResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_rule_num_limit_of_slawith_options_async(
        self,
        request: dms_enterprise_20181101_models.GetRuleNumLimitOfSLARequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetRuleNumLimitOfSLAResponse:
        """
        @summary Queries the maximum number of custom service-level agreement (SLA) rules for task orchestration.
        
        @param request: GetRuleNumLimitOfSLARequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetRuleNumLimitOfSLAResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetRuleNumLimitOfSLA',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetRuleNumLimitOfSLAResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_rule_num_limit_of_sla(
        self,
        request: dms_enterprise_20181101_models.GetRuleNumLimitOfSLARequest,
    ) -> dms_enterprise_20181101_models.GetRuleNumLimitOfSLAResponse:
        """
        @summary Queries the maximum number of custom service-level agreement (SLA) rules for task orchestration.
        
        @param request: GetRuleNumLimitOfSLARequest
        @return: GetRuleNumLimitOfSLAResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_rule_num_limit_of_slawith_options(request, runtime)

    async def get_rule_num_limit_of_sla_async(
        self,
        request: dms_enterprise_20181101_models.GetRuleNumLimitOfSLARequest,
    ) -> dms_enterprise_20181101_models.GetRuleNumLimitOfSLAResponse:
        """
        @summary Queries the maximum number of custom service-level agreement (SLA) rules for task orchestration.
        
        @param request: GetRuleNumLimitOfSLARequest
        @return: GetRuleNumLimitOfSLAResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_rule_num_limit_of_slawith_options_async(request, runtime)

    def get_sqlreview_check_result_status_with_options(
        self,
        request: dms_enterprise_20181101_models.GetSQLReviewCheckResultStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetSQLReviewCheckResultStatusResponse:
        """
        @summary Queries the result of an SQL review.
        
        @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param request: GetSQLReviewCheckResultStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSQLReviewCheckResultStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSQLReviewCheckResultStatus',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetSQLReviewCheckResultStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_sqlreview_check_result_status_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetSQLReviewCheckResultStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetSQLReviewCheckResultStatusResponse:
        """
        @summary Queries the result of an SQL review.
        
        @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param request: GetSQLReviewCheckResultStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSQLReviewCheckResultStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSQLReviewCheckResultStatus',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetSQLReviewCheckResultStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_sqlreview_check_result_status(
        self,
        request: dms_enterprise_20181101_models.GetSQLReviewCheckResultStatusRequest,
    ) -> dms_enterprise_20181101_models.GetSQLReviewCheckResultStatusResponse:
        """
        @summary Queries the result of an SQL review.
        
        @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param request: GetSQLReviewCheckResultStatusRequest
        @return: GetSQLReviewCheckResultStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_sqlreview_check_result_status_with_options(request, runtime)

    async def get_sqlreview_check_result_status_async(
        self,
        request: dms_enterprise_20181101_models.GetSQLReviewCheckResultStatusRequest,
    ) -> dms_enterprise_20181101_models.GetSQLReviewCheckResultStatusResponse:
        """
        @summary Queries the result of an SQL review.
        
        @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param request: GetSQLReviewCheckResultStatusRequest
        @return: GetSQLReviewCheckResultStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_sqlreview_check_result_status_with_options_async(request, runtime)

    def get_sqlreview_optimize_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetSQLReviewOptimizeDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetSQLReviewOptimizeDetailResponse:
        """
        @summary Queries the details of optimization suggestions. The operation applies only to the tickets for the data changes and SQL review.
        
        @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param request: GetSQLReviewOptimizeDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSQLReviewOptimizeDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.sqlreview_query_key):
            query['SQLReviewQueryKey'] = request.sqlreview_query_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSQLReviewOptimizeDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetSQLReviewOptimizeDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_sqlreview_optimize_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetSQLReviewOptimizeDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetSQLReviewOptimizeDetailResponse:
        """
        @summary Queries the details of optimization suggestions. The operation applies only to the tickets for the data changes and SQL review.
        
        @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param request: GetSQLReviewOptimizeDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSQLReviewOptimizeDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.sqlreview_query_key):
            query['SQLReviewQueryKey'] = request.sqlreview_query_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSQLReviewOptimizeDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetSQLReviewOptimizeDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_sqlreview_optimize_detail(
        self,
        request: dms_enterprise_20181101_models.GetSQLReviewOptimizeDetailRequest,
    ) -> dms_enterprise_20181101_models.GetSQLReviewOptimizeDetailResponse:
        """
        @summary Queries the details of optimization suggestions. The operation applies only to the tickets for the data changes and SQL review.
        
        @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param request: GetSQLReviewOptimizeDetailRequest
        @return: GetSQLReviewOptimizeDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_sqlreview_optimize_detail_with_options(request, runtime)

    async def get_sqlreview_optimize_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetSQLReviewOptimizeDetailRequest,
    ) -> dms_enterprise_20181101_models.GetSQLReviewOptimizeDetailResponse:
        """
        @summary Queries the details of optimization suggestions. The operation applies only to the tickets for the data changes and SQL review.
        
        @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param request: GetSQLReviewOptimizeDetailRequest
        @return: GetSQLReviewOptimizeDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_sqlreview_optimize_detail_with_options_async(request, runtime)

    def get_standard_group_with_options(
        self,
        request: dms_enterprise_20181101_models.GetStandardGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetStandardGroupResponse:
        """
        @summary 获取安全规则
        
        @param request: GetStandardGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStandardGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStandardGroup',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetStandardGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_standard_group_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetStandardGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetStandardGroupResponse:
        """
        @summary 获取安全规则
        
        @param request: GetStandardGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStandardGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStandardGroup',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetStandardGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_standard_group(
        self,
        request: dms_enterprise_20181101_models.GetStandardGroupRequest,
    ) -> dms_enterprise_20181101_models.GetStandardGroupResponse:
        """
        @summary 获取安全规则
        
        @param request: GetStandardGroupRequest
        @return: GetStandardGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_standard_group_with_options(request, runtime)

    async def get_standard_group_async(
        self,
        request: dms_enterprise_20181101_models.GetStandardGroupRequest,
    ) -> dms_enterprise_20181101_models.GetStandardGroupResponse:
        """
        @summary 获取安全规则
        
        @param request: GetStandardGroupRequest
        @return: GetStandardGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_standard_group_with_options_async(request, runtime)

    def get_struct_sync_exec_sql_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncExecSqlDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetStructSyncExecSqlDetailResponse:
        """
        @summary Queries the SQL statements that are involved in a schema synchronization ticket.
        
        @param request: GetStructSyncExecSqlDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStructSyncExecSqlDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStructSyncExecSqlDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetStructSyncExecSqlDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_struct_sync_exec_sql_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncExecSqlDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetStructSyncExecSqlDetailResponse:
        """
        @summary Queries the SQL statements that are involved in a schema synchronization ticket.
        
        @param request: GetStructSyncExecSqlDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStructSyncExecSqlDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStructSyncExecSqlDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetStructSyncExecSqlDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_struct_sync_exec_sql_detail(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncExecSqlDetailRequest,
    ) -> dms_enterprise_20181101_models.GetStructSyncExecSqlDetailResponse:
        """
        @summary Queries the SQL statements that are involved in a schema synchronization ticket.
        
        @param request: GetStructSyncExecSqlDetailRequest
        @return: GetStructSyncExecSqlDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_struct_sync_exec_sql_detail_with_options(request, runtime)

    async def get_struct_sync_exec_sql_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncExecSqlDetailRequest,
    ) -> dms_enterprise_20181101_models.GetStructSyncExecSqlDetailResponse:
        """
        @summary Queries the SQL statements that are involved in a schema synchronization ticket.
        
        @param request: GetStructSyncExecSqlDetailRequest
        @return: GetStructSyncExecSqlDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_struct_sync_exec_sql_detail_with_options_async(request, runtime)

    def get_struct_sync_job_analyze_result_with_options(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncJobAnalyzeResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetStructSyncJobAnalyzeResultResponse:
        """
        @summary Queries the analysis result of a schema synchronization task.
        
        @param request: GetStructSyncJobAnalyzeResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStructSyncJobAnalyzeResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.compare_type):
            query['CompareType'] = request.compare_type
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStructSyncJobAnalyzeResult',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetStructSyncJobAnalyzeResultResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_struct_sync_job_analyze_result_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncJobAnalyzeResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetStructSyncJobAnalyzeResultResponse:
        """
        @summary Queries the analysis result of a schema synchronization task.
        
        @param request: GetStructSyncJobAnalyzeResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStructSyncJobAnalyzeResultResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.compare_type):
            query['CompareType'] = request.compare_type
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStructSyncJobAnalyzeResult',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetStructSyncJobAnalyzeResultResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_struct_sync_job_analyze_result(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncJobAnalyzeResultRequest,
    ) -> dms_enterprise_20181101_models.GetStructSyncJobAnalyzeResultResponse:
        """
        @summary Queries the analysis result of a schema synchronization task.
        
        @param request: GetStructSyncJobAnalyzeResultRequest
        @return: GetStructSyncJobAnalyzeResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_struct_sync_job_analyze_result_with_options(request, runtime)

    async def get_struct_sync_job_analyze_result_async(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncJobAnalyzeResultRequest,
    ) -> dms_enterprise_20181101_models.GetStructSyncJobAnalyzeResultResponse:
        """
        @summary Queries the analysis result of a schema synchronization task.
        
        @param request: GetStructSyncJobAnalyzeResultRequest
        @return: GetStructSyncJobAnalyzeResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_struct_sync_job_analyze_result_with_options_async(request, runtime)

    def get_struct_sync_job_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncJobDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetStructSyncJobDetailResponse:
        """
        @summary Queries the information of a schema synchronization task.
        
        @param request: GetStructSyncJobDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStructSyncJobDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStructSyncJobDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetStructSyncJobDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_struct_sync_job_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncJobDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetStructSyncJobDetailResponse:
        """
        @summary Queries the information of a schema synchronization task.
        
        @param request: GetStructSyncJobDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStructSyncJobDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStructSyncJobDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetStructSyncJobDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_struct_sync_job_detail(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncJobDetailRequest,
    ) -> dms_enterprise_20181101_models.GetStructSyncJobDetailResponse:
        """
        @summary Queries the information of a schema synchronization task.
        
        @param request: GetStructSyncJobDetailRequest
        @return: GetStructSyncJobDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_struct_sync_job_detail_with_options(request, runtime)

    async def get_struct_sync_job_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncJobDetailRequest,
    ) -> dms_enterprise_20181101_models.GetStructSyncJobDetailResponse:
        """
        @summary Queries the information of a schema synchronization task.
        
        @param request: GetStructSyncJobDetailRequest
        @return: GetStructSyncJobDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_struct_sync_job_detail_with_options_async(request, runtime)

    def get_struct_sync_order_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetStructSyncOrderDetailResponse:
        """
        @summary Queries the details of a schema synchronization ticket.
        
        @param request: GetStructSyncOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStructSyncOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStructSyncOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetStructSyncOrderDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_struct_sync_order_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncOrderDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetStructSyncOrderDetailResponse:
        """
        @summary Queries the details of a schema synchronization ticket.
        
        @param request: GetStructSyncOrderDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetStructSyncOrderDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetStructSyncOrderDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetStructSyncOrderDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_struct_sync_order_detail(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetStructSyncOrderDetailResponse:
        """
        @summary Queries the details of a schema synchronization ticket.
        
        @param request: GetStructSyncOrderDetailRequest
        @return: GetStructSyncOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_struct_sync_order_detail_with_options(request, runtime)

    async def get_struct_sync_order_detail_async(
        self,
        request: dms_enterprise_20181101_models.GetStructSyncOrderDetailRequest,
    ) -> dms_enterprise_20181101_models.GetStructSyncOrderDetailResponse:
        """
        @summary Queries the details of a schema synchronization ticket.
        
        @param request: GetStructSyncOrderDetailRequest
        @return: GetStructSyncOrderDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_struct_sync_order_detail_with_options_async(request, runtime)

    def get_table_dbtopology_with_options(
        self,
        request: dms_enterprise_20181101_models.GetTableDBTopologyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTableDBTopologyResponse:
        """
        @summary Queries the topology of a data table.
        
        @param request: GetTableDBTopologyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTableDBTopologyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.table_guid):
            query['TableGuid'] = request.table_guid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTableDBTopology',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTableDBTopologyResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_table_dbtopology_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetTableDBTopologyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTableDBTopologyResponse:
        """
        @summary Queries the topology of a data table.
        
        @param request: GetTableDBTopologyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTableDBTopologyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.table_guid):
            query['TableGuid'] = request.table_guid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTableDBTopology',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTableDBTopologyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_table_dbtopology(
        self,
        request: dms_enterprise_20181101_models.GetTableDBTopologyRequest,
    ) -> dms_enterprise_20181101_models.GetTableDBTopologyResponse:
        """
        @summary Queries the topology of a data table.
        
        @param request: GetTableDBTopologyRequest
        @return: GetTableDBTopologyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_table_dbtopology_with_options(request, runtime)

    async def get_table_dbtopology_async(
        self,
        request: dms_enterprise_20181101_models.GetTableDBTopologyRequest,
    ) -> dms_enterprise_20181101_models.GetTableDBTopologyResponse:
        """
        @summary Queries the topology of a data table.
        
        @param request: GetTableDBTopologyRequest
        @return: GetTableDBTopologyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_table_dbtopology_with_options_async(request, runtime)

    def get_table_design_project_flow_with_options(
        self,
        request: dms_enterprise_20181101_models.GetTableDesignProjectFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTableDesignProjectFlowResponse:
        """
        @summary Queries the information about a schema design ticket, such as the current node of the ticket, whether the ticket can be returned to the schema design node, and the publishing strategy.
        
        @param request: GetTableDesignProjectFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTableDesignProjectFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTableDesignProjectFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTableDesignProjectFlowResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_table_design_project_flow_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetTableDesignProjectFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTableDesignProjectFlowResponse:
        """
        @summary Queries the information about a schema design ticket, such as the current node of the ticket, whether the ticket can be returned to the schema design node, and the publishing strategy.
        
        @param request: GetTableDesignProjectFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTableDesignProjectFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTableDesignProjectFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTableDesignProjectFlowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_table_design_project_flow(
        self,
        request: dms_enterprise_20181101_models.GetTableDesignProjectFlowRequest,
    ) -> dms_enterprise_20181101_models.GetTableDesignProjectFlowResponse:
        """
        @summary Queries the information about a schema design ticket, such as the current node of the ticket, whether the ticket can be returned to the schema design node, and the publishing strategy.
        
        @param request: GetTableDesignProjectFlowRequest
        @return: GetTableDesignProjectFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_table_design_project_flow_with_options(request, runtime)

    async def get_table_design_project_flow_async(
        self,
        request: dms_enterprise_20181101_models.GetTableDesignProjectFlowRequest,
    ) -> dms_enterprise_20181101_models.GetTableDesignProjectFlowResponse:
        """
        @summary Queries the information about a schema design ticket, such as the current node of the ticket, whether the ticket can be returned to the schema design node, and the publishing strategy.
        
        @param request: GetTableDesignProjectFlowRequest
        @return: GetTableDesignProjectFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_table_design_project_flow_with_options_async(request, runtime)

    def get_table_design_project_info_with_options(
        self,
        request: dms_enterprise_20181101_models.GetTableDesignProjectInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTableDesignProjectInfoResponse:
        """
        @summary Queries the information about the project and change base database of a schema design ticket, such as the state of the ticket, the ID of the user who created the ticket, and the name and ID of the change base database.
        
        @param request: GetTableDesignProjectInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTableDesignProjectInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTableDesignProjectInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTableDesignProjectInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_table_design_project_info_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetTableDesignProjectInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTableDesignProjectInfoResponse:
        """
        @summary Queries the information about the project and change base database of a schema design ticket, such as the state of the ticket, the ID of the user who created the ticket, and the name and ID of the change base database.
        
        @param request: GetTableDesignProjectInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTableDesignProjectInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTableDesignProjectInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTableDesignProjectInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_table_design_project_info(
        self,
        request: dms_enterprise_20181101_models.GetTableDesignProjectInfoRequest,
    ) -> dms_enterprise_20181101_models.GetTableDesignProjectInfoResponse:
        """
        @summary Queries the information about the project and change base database of a schema design ticket, such as the state of the ticket, the ID of the user who created the ticket, and the name and ID of the change base database.
        
        @param request: GetTableDesignProjectInfoRequest
        @return: GetTableDesignProjectInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_table_design_project_info_with_options(request, runtime)

    async def get_table_design_project_info_async(
        self,
        request: dms_enterprise_20181101_models.GetTableDesignProjectInfoRequest,
    ) -> dms_enterprise_20181101_models.GetTableDesignProjectInfoResponse:
        """
        @summary Queries the information about the project and change base database of a schema design ticket, such as the state of the ticket, the ID of the user who created the ticket, and the name and ID of the change base database.
        
        @param request: GetTableDesignProjectInfoRequest
        @return: GetTableDesignProjectInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_table_design_project_info_with_options_async(request, runtime)

    def get_table_knowledge_info_with_options(
        self,
        request: dms_enterprise_20181101_models.GetTableKnowledgeInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTableKnowledgeInfoResponse:
        """
        @summary 获取指定guid的元数据知识
        
        @param request: GetTableKnowledgeInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTableKnowledgeInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.table_schema_name):
            query['TableSchemaName'] = request.table_schema_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTableKnowledgeInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTableKnowledgeInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_table_knowledge_info_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetTableKnowledgeInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTableKnowledgeInfoResponse:
        """
        @summary 获取指定guid的元数据知识
        
        @param request: GetTableKnowledgeInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTableKnowledgeInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.table_schema_name):
            query['TableSchemaName'] = request.table_schema_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTableKnowledgeInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTableKnowledgeInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_table_knowledge_info(
        self,
        request: dms_enterprise_20181101_models.GetTableKnowledgeInfoRequest,
    ) -> dms_enterprise_20181101_models.GetTableKnowledgeInfoResponse:
        """
        @summary 获取指定guid的元数据知识
        
        @param request: GetTableKnowledgeInfoRequest
        @return: GetTableKnowledgeInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_table_knowledge_info_with_options(request, runtime)

    async def get_table_knowledge_info_async(
        self,
        request: dms_enterprise_20181101_models.GetTableKnowledgeInfoRequest,
    ) -> dms_enterprise_20181101_models.GetTableKnowledgeInfoResponse:
        """
        @summary 获取指定guid的元数据知识
        
        @param request: GetTableKnowledgeInfoRequest
        @return: GetTableKnowledgeInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_table_knowledge_info_with_options_async(request, runtime)

    def get_table_topology_with_options(
        self,
        request: dms_enterprise_20181101_models.GetTableTopologyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTableTopologyResponse:
        """
        @summary Queries the topology of a table.
        
        @param request: GetTableTopologyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTableTopologyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.table_guid):
            query['TableGuid'] = request.table_guid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTableTopology',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTableTopologyResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_table_topology_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetTableTopologyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTableTopologyResponse:
        """
        @summary Queries the topology of a table.
        
        @param request: GetTableTopologyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTableTopologyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.table_guid):
            query['TableGuid'] = request.table_guid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTableTopology',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTableTopologyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_table_topology(
        self,
        request: dms_enterprise_20181101_models.GetTableTopologyRequest,
    ) -> dms_enterprise_20181101_models.GetTableTopologyResponse:
        """
        @summary Queries the topology of a table.
        
        @param request: GetTableTopologyRequest
        @return: GetTableTopologyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_table_topology_with_options(request, runtime)

    async def get_table_topology_async(
        self,
        request: dms_enterprise_20181101_models.GetTableTopologyRequest,
    ) -> dms_enterprise_20181101_models.GetTableTopologyResponse:
        """
        @summary Queries the topology of a table.
        
        @param request: GetTableTopologyRequest
        @return: GetTableTopologyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_table_topology_with_options_async(request, runtime)

    def get_task_with_options(
        self,
        request: dms_enterprise_20181101_models.GetTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTaskResponse:
        """
        @summary Queries the configurations, including time variables, of a specified task node based on the task node ID.
        
        @param request: GetTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTask',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTaskResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_task_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetTaskRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTaskResponse:
        """
        @summary Queries the configurations, including time variables, of a specified task node based on the task node ID.
        
        @param request: GetTaskRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTaskResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTask',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTaskResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_task(
        self,
        request: dms_enterprise_20181101_models.GetTaskRequest,
    ) -> dms_enterprise_20181101_models.GetTaskResponse:
        """
        @summary Queries the configurations, including time variables, of a specified task node based on the task node ID.
        
        @param request: GetTaskRequest
        @return: GetTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_task_with_options(request, runtime)

    async def get_task_async(
        self,
        request: dms_enterprise_20181101_models.GetTaskRequest,
    ) -> dms_enterprise_20181101_models.GetTaskResponse:
        """
        @summary Queries the configurations, including time variables, of a specified task node based on the task node ID.
        
        @param request: GetTaskRequest
        @return: GetTaskResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_task_with_options_async(request, runtime)

    def get_task_flow_graph_with_options(
        self,
        request: dms_enterprise_20181101_models.GetTaskFlowGraphRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTaskFlowGraphResponse:
        """
        @summary Queries the Directed Acyclic Graph (DAG) of a task flow.
        
        @param request: GetTaskFlowGraphRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTaskFlowGraphResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTaskFlowGraph',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTaskFlowGraphResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_task_flow_graph_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetTaskFlowGraphRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTaskFlowGraphResponse:
        """
        @summary Queries the Directed Acyclic Graph (DAG) of a task flow.
        
        @param request: GetTaskFlowGraphRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTaskFlowGraphResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTaskFlowGraph',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTaskFlowGraphResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_task_flow_graph(
        self,
        request: dms_enterprise_20181101_models.GetTaskFlowGraphRequest,
    ) -> dms_enterprise_20181101_models.GetTaskFlowGraphResponse:
        """
        @summary Queries the Directed Acyclic Graph (DAG) of a task flow.
        
        @param request: GetTaskFlowGraphRequest
        @return: GetTaskFlowGraphResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_task_flow_graph_with_options(request, runtime)

    async def get_task_flow_graph_async(
        self,
        request: dms_enterprise_20181101_models.GetTaskFlowGraphRequest,
    ) -> dms_enterprise_20181101_models.GetTaskFlowGraphResponse:
        """
        @summary Queries the Directed Acyclic Graph (DAG) of a task flow.
        
        @param request: GetTaskFlowGraphRequest
        @return: GetTaskFlowGraphResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_task_flow_graph_with_options_async(request, runtime)

    def get_task_flow_notification_with_options(
        self,
        request: dms_enterprise_20181101_models.GetTaskFlowNotificationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTaskFlowNotificationResponse:
        """
        @summary Queries the notification settings for task flows.
        
        @param request: GetTaskFlowNotificationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTaskFlowNotificationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTaskFlowNotification',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTaskFlowNotificationResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_task_flow_notification_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetTaskFlowNotificationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTaskFlowNotificationResponse:
        """
        @summary Queries the notification settings for task flows.
        
        @param request: GetTaskFlowNotificationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTaskFlowNotificationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTaskFlowNotification',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTaskFlowNotificationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_task_flow_notification(
        self,
        request: dms_enterprise_20181101_models.GetTaskFlowNotificationRequest,
    ) -> dms_enterprise_20181101_models.GetTaskFlowNotificationResponse:
        """
        @summary Queries the notification settings for task flows.
        
        @param request: GetTaskFlowNotificationRequest
        @return: GetTaskFlowNotificationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_task_flow_notification_with_options(request, runtime)

    async def get_task_flow_notification_async(
        self,
        request: dms_enterprise_20181101_models.GetTaskFlowNotificationRequest,
    ) -> dms_enterprise_20181101_models.GetTaskFlowNotificationResponse:
        """
        @summary Queries the notification settings for task flows.
        
        @param request: GetTaskFlowNotificationRequest
        @return: GetTaskFlowNotificationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_task_flow_notification_with_options_async(request, runtime)

    def get_task_instance_relation_with_options(
        self,
        request: dms_enterprise_20181101_models.GetTaskInstanceRelationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTaskInstanceRelationResponse:
        """
        @summary Queries the information about the nodes in an execution record of a task flow.
        
        @param request: GetTaskInstanceRelationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTaskInstanceRelationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_instance_id):
            query['DagInstanceId'] = request.dag_instance_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTaskInstanceRelation',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTaskInstanceRelationResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_task_instance_relation_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetTaskInstanceRelationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetTaskInstanceRelationResponse:
        """
        @summary Queries the information about the nodes in an execution record of a task flow.
        
        @param request: GetTaskInstanceRelationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTaskInstanceRelationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_instance_id):
            query['DagInstanceId'] = request.dag_instance_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTaskInstanceRelation',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetTaskInstanceRelationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_task_instance_relation(
        self,
        request: dms_enterprise_20181101_models.GetTaskInstanceRelationRequest,
    ) -> dms_enterprise_20181101_models.GetTaskInstanceRelationResponse:
        """
        @summary Queries the information about the nodes in an execution record of a task flow.
        
        @param request: GetTaskInstanceRelationRequest
        @return: GetTaskInstanceRelationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_task_instance_relation_with_options(request, runtime)

    async def get_task_instance_relation_async(
        self,
        request: dms_enterprise_20181101_models.GetTaskInstanceRelationRequest,
    ) -> dms_enterprise_20181101_models.GetTaskInstanceRelationResponse:
        """
        @summary Queries the information about the nodes in an execution record of a task flow.
        
        @param request: GetTaskInstanceRelationRequest
        @return: GetTaskInstanceRelationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_task_instance_relation_with_options_async(request, runtime)

    def get_user_with_options(
        self,
        request: dms_enterprise_20181101_models.GetUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetUserResponse:
        """
        @summary Queries the information about a user.
        
        @param request: GetUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.uid):
            query['Uid'] = request.uid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_user_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetUserResponse:
        """
        @summary Queries the information about a user.
        
        @param request: GetUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.uid):
            query['Uid'] = request.uid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_user(
        self,
        request: dms_enterprise_20181101_models.GetUserRequest,
    ) -> dms_enterprise_20181101_models.GetUserResponse:
        """
        @summary Queries the information about a user.
        
        @param request: GetUserRequest
        @return: GetUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_user_with_options(request, runtime)

    async def get_user_async(
        self,
        request: dms_enterprise_20181101_models.GetUserRequest,
    ) -> dms_enterprise_20181101_models.GetUserResponse:
        """
        @summary Queries the information about a user.
        
        @param request: GetUserRequest
        @return: GetUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_user_with_options_async(request, runtime)

    def get_user_active_tenant_with_options(
        self,
        request: dms_enterprise_20181101_models.GetUserActiveTenantRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetUserActiveTenantResponse:
        """
        @summary Queries details of the active tenant.
        
        @param request: GetUserActiveTenantRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUserActiveTenantResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetUserActiveTenant',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetUserActiveTenantResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_user_active_tenant_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetUserActiveTenantRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetUserActiveTenantResponse:
        """
        @summary Queries details of the active tenant.
        
        @param request: GetUserActiveTenantRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUserActiveTenantResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetUserActiveTenant',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetUserActiveTenantResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_user_active_tenant(
        self,
        request: dms_enterprise_20181101_models.GetUserActiveTenantRequest,
    ) -> dms_enterprise_20181101_models.GetUserActiveTenantResponse:
        """
        @summary Queries details of the active tenant.
        
        @param request: GetUserActiveTenantRequest
        @return: GetUserActiveTenantResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_user_active_tenant_with_options(request, runtime)

    async def get_user_active_tenant_async(
        self,
        request: dms_enterprise_20181101_models.GetUserActiveTenantRequest,
    ) -> dms_enterprise_20181101_models.GetUserActiveTenantResponse:
        """
        @summary Queries details of the active tenant.
        
        @param request: GetUserActiveTenantRequest
        @return: GetUserActiveTenantResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_user_active_tenant_with_options_async(request, runtime)

    def get_user_upload_file_job_with_options(
        self,
        request: dms_enterprise_20181101_models.GetUserUploadFileJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetUserUploadFileJobResponse:
        """
        @summary Obtains the information of a file upload task.
        
        @param request: GetUserUploadFileJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUserUploadFileJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_key):
            query['JobKey'] = request.job_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetUserUploadFileJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetUserUploadFileJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def get_user_upload_file_job_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GetUserUploadFileJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GetUserUploadFileJobResponse:
        """
        @summary Obtains the information of a file upload task.
        
        @param request: GetUserUploadFileJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUserUploadFileJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_key):
            query['JobKey'] = request.job_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetUserUploadFileJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GetUserUploadFileJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def get_user_upload_file_job(
        self,
        request: dms_enterprise_20181101_models.GetUserUploadFileJobRequest,
    ) -> dms_enterprise_20181101_models.GetUserUploadFileJobResponse:
        """
        @summary Obtains the information of a file upload task.
        
        @param request: GetUserUploadFileJobRequest
        @return: GetUserUploadFileJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.get_user_upload_file_job_with_options(request, runtime)

    async def get_user_upload_file_job_async(
        self,
        request: dms_enterprise_20181101_models.GetUserUploadFileJobRequest,
    ) -> dms_enterprise_20181101_models.GetUserUploadFileJobResponse:
        """
        @summary Obtains the information of a file upload task.
        
        @param request: GetUserUploadFileJobRequest
        @return: GetUserUploadFileJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.get_user_upload_file_job_with_options_async(request, runtime)

    def grant_template_authority_with_options(
        self,
        request: dms_enterprise_20181101_models.GrantTemplateAuthorityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GrantTemplateAuthorityResponse:
        """
        @summary Grants permissions on resources to users by using a permission template.
        
        @description You must be a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: GrantTemplateAuthorityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GrantTemplateAuthorityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.expire_date):
            query['ExpireDate'] = request.expire_date
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_ids):
            query['UserIds'] = request.user_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GrantTemplateAuthority',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GrantTemplateAuthorityResponse(),
            self.call_api(params, req, runtime)
        )

    async def grant_template_authority_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GrantTemplateAuthorityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GrantTemplateAuthorityResponse:
        """
        @summary Grants permissions on resources to users by using a permission template.
        
        @description You must be a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: GrantTemplateAuthorityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GrantTemplateAuthorityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.comment):
            query['Comment'] = request.comment
        if not UtilClient.is_unset(request.expire_date):
            query['ExpireDate'] = request.expire_date
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_ids):
            query['UserIds'] = request.user_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GrantTemplateAuthority',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GrantTemplateAuthorityResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def grant_template_authority(
        self,
        request: dms_enterprise_20181101_models.GrantTemplateAuthorityRequest,
    ) -> dms_enterprise_20181101_models.GrantTemplateAuthorityResponse:
        """
        @summary Grants permissions on resources to users by using a permission template.
        
        @description You must be a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: GrantTemplateAuthorityRequest
        @return: GrantTemplateAuthorityResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.grant_template_authority_with_options(request, runtime)

    async def grant_template_authority_async(
        self,
        request: dms_enterprise_20181101_models.GrantTemplateAuthorityRequest,
    ) -> dms_enterprise_20181101_models.GrantTemplateAuthorityResponse:
        """
        @summary Grants permissions on resources to users by using a permission template.
        
        @description You must be a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: GrantTemplateAuthorityRequest
        @return: GrantTemplateAuthorityResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.grant_template_authority_with_options_async(request, runtime)

    def grant_user_permission_with_options(
        self,
        request: dms_enterprise_20181101_models.GrantUserPermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GrantUserPermissionResponse:
        """
        @summary Grants permissions on an instance, a database, or a table to a user.
        
        @param request: GrantUserPermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GrantUserPermissionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.ds_type):
            query['DsType'] = request.ds_type
        if not UtilClient.is_unset(request.expire_date):
            query['ExpireDate'] = request.expire_date
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.perm_types):
            query['PermTypes'] = request.perm_types
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GrantUserPermission',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GrantUserPermissionResponse(),
            self.call_api(params, req, runtime)
        )

    async def grant_user_permission_with_options_async(
        self,
        request: dms_enterprise_20181101_models.GrantUserPermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.GrantUserPermissionResponse:
        """
        @summary Grants permissions on an instance, a database, or a table to a user.
        
        @param request: GrantUserPermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: GrantUserPermissionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.ds_type):
            query['DsType'] = request.ds_type
        if not UtilClient.is_unset(request.expire_date):
            query['ExpireDate'] = request.expire_date
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.perm_types):
            query['PermTypes'] = request.perm_types
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GrantUserPermission',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.GrantUserPermissionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def grant_user_permission(
        self,
        request: dms_enterprise_20181101_models.GrantUserPermissionRequest,
    ) -> dms_enterprise_20181101_models.GrantUserPermissionResponse:
        """
        @summary Grants permissions on an instance, a database, or a table to a user.
        
        @param request: GrantUserPermissionRequest
        @return: GrantUserPermissionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.grant_user_permission_with_options(request, runtime)

    async def grant_user_permission_async(
        self,
        request: dms_enterprise_20181101_models.GrantUserPermissionRequest,
    ) -> dms_enterprise_20181101_models.GrantUserPermissionResponse:
        """
        @summary Grants permissions on an instance, a database, or a table to a user.
        
        @param request: GrantUserPermissionRequest
        @return: GrantUserPermissionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.grant_user_permission_with_options_async(request, runtime)

    def inspect_proxy_access_secret_with_options(
        self,
        request: dms_enterprise_20181101_models.InspectProxyAccessSecretRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.InspectProxyAccessSecretResponse:
        """
        @summary You can call this operation to obtain the authorization password of the security protection agent InspectProxyAccessSecret.
        
        @param request: InspectProxyAccessSecretRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: InspectProxyAccessSecretResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.proxy_access_id):
            query['ProxyAccessId'] = request.proxy_access_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InspectProxyAccessSecret',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.InspectProxyAccessSecretResponse(),
            self.call_api(params, req, runtime)
        )

    async def inspect_proxy_access_secret_with_options_async(
        self,
        request: dms_enterprise_20181101_models.InspectProxyAccessSecretRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.InspectProxyAccessSecretResponse:
        """
        @summary You can call this operation to obtain the authorization password of the security protection agent InspectProxyAccessSecret.
        
        @param request: InspectProxyAccessSecretRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: InspectProxyAccessSecretResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.proxy_access_id):
            query['ProxyAccessId'] = request.proxy_access_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InspectProxyAccessSecret',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.InspectProxyAccessSecretResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def inspect_proxy_access_secret(
        self,
        request: dms_enterprise_20181101_models.InspectProxyAccessSecretRequest,
    ) -> dms_enterprise_20181101_models.InspectProxyAccessSecretResponse:
        """
        @summary You can call this operation to obtain the authorization password of the security protection agent InspectProxyAccessSecret.
        
        @param request: InspectProxyAccessSecretRequest
        @return: InspectProxyAccessSecretResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.inspect_proxy_access_secret_with_options(request, runtime)

    async def inspect_proxy_access_secret_async(
        self,
        request: dms_enterprise_20181101_models.InspectProxyAccessSecretRequest,
    ) -> dms_enterprise_20181101_models.InspectProxyAccessSecretResponse:
        """
        @summary You can call this operation to obtain the authorization password of the security protection agent InspectProxyAccessSecret.
        
        @param request: InspectProxyAccessSecretRequest
        @return: InspectProxyAccessSecretResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.inspect_proxy_access_secret_with_options_async(request, runtime)

    def list_abac_authorizations_with_options(
        self,
        request: dms_enterprise_20181101_models.ListAbacAuthorizationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAbacAuthorizationsResponse:
        """
        @summary 获取权限策略授权列表
        
        @param request: ListAbacAuthorizationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAbacAuthorizationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.policy_id):
            query['PolicyId'] = request.policy_id
        if not UtilClient.is_unset(request.policy_source):
            query['PolicySource'] = request.policy_source
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAbacAuthorizations',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAbacAuthorizationsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_abac_authorizations_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListAbacAuthorizationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAbacAuthorizationsResponse:
        """
        @summary 获取权限策略授权列表
        
        @param request: ListAbacAuthorizationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAbacAuthorizationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.policy_id):
            query['PolicyId'] = request.policy_id
        if not UtilClient.is_unset(request.policy_source):
            query['PolicySource'] = request.policy_source
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAbacAuthorizations',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAbacAuthorizationsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_abac_authorizations(
        self,
        request: dms_enterprise_20181101_models.ListAbacAuthorizationsRequest,
    ) -> dms_enterprise_20181101_models.ListAbacAuthorizationsResponse:
        """
        @summary 获取权限策略授权列表
        
        @param request: ListAbacAuthorizationsRequest
        @return: ListAbacAuthorizationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_abac_authorizations_with_options(request, runtime)

    async def list_abac_authorizations_async(
        self,
        request: dms_enterprise_20181101_models.ListAbacAuthorizationsRequest,
    ) -> dms_enterprise_20181101_models.ListAbacAuthorizationsResponse:
        """
        @summary 获取权限策略授权列表
        
        @param request: ListAbacAuthorizationsRequest
        @return: ListAbacAuthorizationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_abac_authorizations_with_options_async(request, runtime)

    def list_abac_policies_with_options(
        self,
        request: dms_enterprise_20181101_models.ListAbacPoliciesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAbacPoliciesResponse:
        """
        @summary 获取权限策略列表
        
        @param request: ListAbacPoliciesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAbacPoliciesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAbacPolicies',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAbacPoliciesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_abac_policies_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListAbacPoliciesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAbacPoliciesResponse:
        """
        @summary 获取权限策略列表
        
        @param request: ListAbacPoliciesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAbacPoliciesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAbacPolicies',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAbacPoliciesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_abac_policies(
        self,
        request: dms_enterprise_20181101_models.ListAbacPoliciesRequest,
    ) -> dms_enterprise_20181101_models.ListAbacPoliciesResponse:
        """
        @summary 获取权限策略列表
        
        @param request: ListAbacPoliciesRequest
        @return: ListAbacPoliciesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_abac_policies_with_options(request, runtime)

    async def list_abac_policies_async(
        self,
        request: dms_enterprise_20181101_models.ListAbacPoliciesRequest,
    ) -> dms_enterprise_20181101_models.ListAbacPoliciesResponse:
        """
        @summary 获取权限策略列表
        
        @param request: ListAbacPoliciesRequest
        @return: ListAbacPoliciesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_abac_policies_with_options_async(request, runtime)

    def list_authority_template_with_options(
        self,
        request: dms_enterprise_20181101_models.ListAuthorityTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAuthorityTemplateResponse:
        """
        @summary 获取权限模版列表
        
        @param request: ListAuthorityTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAuthorityTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAuthorityTemplate',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAuthorityTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_authority_template_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListAuthorityTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAuthorityTemplateResponse:
        """
        @summary 获取权限模版列表
        
        @param request: ListAuthorityTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAuthorityTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAuthorityTemplate',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAuthorityTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_authority_template(
        self,
        request: dms_enterprise_20181101_models.ListAuthorityTemplateRequest,
    ) -> dms_enterprise_20181101_models.ListAuthorityTemplateResponse:
        """
        @summary 获取权限模版列表
        
        @param request: ListAuthorityTemplateRequest
        @return: ListAuthorityTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_authority_template_with_options(request, runtime)

    async def list_authority_template_async(
        self,
        request: dms_enterprise_20181101_models.ListAuthorityTemplateRequest,
    ) -> dms_enterprise_20181101_models.ListAuthorityTemplateResponse:
        """
        @summary 获取权限模版列表
        
        @param request: ListAuthorityTemplateRequest
        @return: ListAuthorityTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_authority_template_with_options_async(request, runtime)

    def list_authorized_databases_for_user_with_options(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedDatabasesForUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAuthorizedDatabasesForUserResponse:
        """
        @summary 获取用户有权限的数据库
        
        @param request: ListAuthorizedDatabasesForUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAuthorizedDatabasesForUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAuthorizedDatabasesForUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAuthorizedDatabasesForUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_authorized_databases_for_user_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedDatabasesForUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAuthorizedDatabasesForUserResponse:
        """
        @summary 获取用户有权限的数据库
        
        @param request: ListAuthorizedDatabasesForUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAuthorizedDatabasesForUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAuthorizedDatabasesForUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAuthorizedDatabasesForUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_authorized_databases_for_user(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedDatabasesForUserRequest,
    ) -> dms_enterprise_20181101_models.ListAuthorizedDatabasesForUserResponse:
        """
        @summary 获取用户有权限的数据库
        
        @param request: ListAuthorizedDatabasesForUserRequest
        @return: ListAuthorizedDatabasesForUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_authorized_databases_for_user_with_options(request, runtime)

    async def list_authorized_databases_for_user_async(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedDatabasesForUserRequest,
    ) -> dms_enterprise_20181101_models.ListAuthorizedDatabasesForUserResponse:
        """
        @summary 获取用户有权限的数据库
        
        @param request: ListAuthorizedDatabasesForUserRequest
        @return: ListAuthorizedDatabasesForUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_authorized_databases_for_user_with_options_async(request, runtime)

    def list_authorized_instances_for_user_with_options(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedInstancesForUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAuthorizedInstancesForUserResponse:
        """
        @summary 获取用户有权限的实例
        
        @param request: ListAuthorizedInstancesForUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAuthorizedInstancesForUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAuthorizedInstancesForUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAuthorizedInstancesForUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_authorized_instances_for_user_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedInstancesForUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAuthorizedInstancesForUserResponse:
        """
        @summary 获取用户有权限的实例
        
        @param request: ListAuthorizedInstancesForUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAuthorizedInstancesForUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAuthorizedInstancesForUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAuthorizedInstancesForUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_authorized_instances_for_user(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedInstancesForUserRequest,
    ) -> dms_enterprise_20181101_models.ListAuthorizedInstancesForUserResponse:
        """
        @summary 获取用户有权限的实例
        
        @param request: ListAuthorizedInstancesForUserRequest
        @return: ListAuthorizedInstancesForUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_authorized_instances_for_user_with_options(request, runtime)

    async def list_authorized_instances_for_user_async(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedInstancesForUserRequest,
    ) -> dms_enterprise_20181101_models.ListAuthorizedInstancesForUserResponse:
        """
        @summary 获取用户有权限的实例
        
        @param request: ListAuthorizedInstancesForUserRequest
        @return: ListAuthorizedInstancesForUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_authorized_instances_for_user_with_options_async(request, runtime)

    def list_authorized_users_for_database_with_options(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedUsersForDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAuthorizedUsersForDatabaseResponse:
        """
        @summary 查询有数据库权限的用户
        
        @param request: ListAuthorizedUsersForDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAuthorizedUsersForDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAuthorizedUsersForDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAuthorizedUsersForDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_authorized_users_for_database_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedUsersForDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAuthorizedUsersForDatabaseResponse:
        """
        @summary 查询有数据库权限的用户
        
        @param request: ListAuthorizedUsersForDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAuthorizedUsersForDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAuthorizedUsersForDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAuthorizedUsersForDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_authorized_users_for_database(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedUsersForDatabaseRequest,
    ) -> dms_enterprise_20181101_models.ListAuthorizedUsersForDatabaseResponse:
        """
        @summary 查询有数据库权限的用户
        
        @param request: ListAuthorizedUsersForDatabaseRequest
        @return: ListAuthorizedUsersForDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_authorized_users_for_database_with_options(request, runtime)

    async def list_authorized_users_for_database_async(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedUsersForDatabaseRequest,
    ) -> dms_enterprise_20181101_models.ListAuthorizedUsersForDatabaseResponse:
        """
        @summary 查询有数据库权限的用户
        
        @param request: ListAuthorizedUsersForDatabaseRequest
        @return: ListAuthorizedUsersForDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_authorized_users_for_database_with_options_async(request, runtime)

    def list_authorized_users_for_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedUsersForInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAuthorizedUsersForInstanceResponse:
        """
        @summary 查询有实例权限的用户
        
        @param request: ListAuthorizedUsersForInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAuthorizedUsersForInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAuthorizedUsersForInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAuthorizedUsersForInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_authorized_users_for_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedUsersForInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListAuthorizedUsersForInstanceResponse:
        """
        @summary 查询有实例权限的用户
        
        @param request: ListAuthorizedUsersForInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAuthorizedUsersForInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAuthorizedUsersForInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListAuthorizedUsersForInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_authorized_users_for_instance(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedUsersForInstanceRequest,
    ) -> dms_enterprise_20181101_models.ListAuthorizedUsersForInstanceResponse:
        """
        @summary 查询有实例权限的用户
        
        @param request: ListAuthorizedUsersForInstanceRequest
        @return: ListAuthorizedUsersForInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_authorized_users_for_instance_with_options(request, runtime)

    async def list_authorized_users_for_instance_async(
        self,
        request: dms_enterprise_20181101_models.ListAuthorizedUsersForInstanceRequest,
    ) -> dms_enterprise_20181101_models.ListAuthorizedUsersForInstanceResponse:
        """
        @summary 查询有实例权限的用户
        
        @param request: ListAuthorizedUsersForInstanceRequest
        @return: ListAuthorizedUsersForInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_authorized_users_for_instance_with_options_async(request, runtime)

    def list_classification_templates_with_options(
        self,
        request: dms_enterprise_20181101_models.ListClassificationTemplatesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListClassificationTemplatesResponse:
        """
        @summary Queries the classification templates.
        
        @param request: ListClassificationTemplatesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListClassificationTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListClassificationTemplates',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListClassificationTemplatesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_classification_templates_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListClassificationTemplatesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListClassificationTemplatesResponse:
        """
        @summary Queries the classification templates.
        
        @param request: ListClassificationTemplatesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListClassificationTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListClassificationTemplates',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListClassificationTemplatesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_classification_templates(
        self,
        request: dms_enterprise_20181101_models.ListClassificationTemplatesRequest,
    ) -> dms_enterprise_20181101_models.ListClassificationTemplatesResponse:
        """
        @summary Queries the classification templates.
        
        @param request: ListClassificationTemplatesRequest
        @return: ListClassificationTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_classification_templates_with_options(request, runtime)

    async def list_classification_templates_async(
        self,
        request: dms_enterprise_20181101_models.ListClassificationTemplatesRequest,
    ) -> dms_enterprise_20181101_models.ListClassificationTemplatesResponse:
        """
        @summary Queries the classification templates.
        
        @param request: ListClassificationTemplatesRequest
        @return: ListClassificationTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_classification_templates_with_options_async(request, runtime)

    def list_columns_with_options(
        self,
        request: dms_enterprise_20181101_models.ListColumnsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListColumnsResponse:
        """
        @summary Returns the column information of a table.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: ListColumnsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListColumnsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListColumns',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListColumnsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_columns_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListColumnsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListColumnsResponse:
        """
        @summary Returns the column information of a table.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: ListColumnsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListColumnsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListColumns',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListColumnsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_columns(
        self,
        request: dms_enterprise_20181101_models.ListColumnsRequest,
    ) -> dms_enterprise_20181101_models.ListColumnsResponse:
        """
        @summary Returns the column information of a table.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: ListColumnsRequest
        @return: ListColumnsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_columns_with_options(request, runtime)

    async def list_columns_async(
        self,
        request: dms_enterprise_20181101_models.ListColumnsRequest,
    ) -> dms_enterprise_20181101_models.ListColumnsResponse:
        """
        @summary Returns the column information of a table.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: ListColumnsRequest
        @return: ListColumnsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_columns_with_options_async(request, runtime)

    def list_dagversions_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDAGVersionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDAGVersionsResponse:
        """
        @summary Queries the published versions of a task flow.
        
        @param request: ListDAGVersionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDAGVersionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.page_index):
            query['PageIndex'] = request.page_index
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDAGVersions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDAGVersionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_dagversions_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDAGVersionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDAGVersionsResponse:
        """
        @summary Queries the published versions of a task flow.
        
        @param request: ListDAGVersionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDAGVersionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.page_index):
            query['PageIndex'] = request.page_index
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDAGVersions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDAGVersionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_dagversions(
        self,
        request: dms_enterprise_20181101_models.ListDAGVersionsRequest,
    ) -> dms_enterprise_20181101_models.ListDAGVersionsResponse:
        """
        @summary Queries the published versions of a task flow.
        
        @param request: ListDAGVersionsRequest
        @return: ListDAGVersionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_dagversions_with_options(request, runtime)

    async def list_dagversions_async(
        self,
        request: dms_enterprise_20181101_models.ListDAGVersionsRequest,
    ) -> dms_enterprise_20181101_models.ListDAGVersionsResponse:
        """
        @summary Queries the published versions of a task flow.
        
        @param request: ListDAGVersionsRequest
        @return: ListDAGVersionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_dagversions_with_options_async(request, runtime)

    def list_dbtask_sqljob_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDBTaskSQLJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDBTaskSQLJobResponse:
        """
        @summary Queries a list of SQL tasks.
        
        @param request: ListDBTaskSQLJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDBTaskSQLJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dbtask_group_id):
            query['DBTaskGroupId'] = request.dbtask_group_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDBTaskSQLJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDBTaskSQLJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_dbtask_sqljob_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDBTaskSQLJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDBTaskSQLJobResponse:
        """
        @summary Queries a list of SQL tasks.
        
        @param request: ListDBTaskSQLJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDBTaskSQLJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dbtask_group_id):
            query['DBTaskGroupId'] = request.dbtask_group_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDBTaskSQLJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDBTaskSQLJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_dbtask_sqljob(
        self,
        request: dms_enterprise_20181101_models.ListDBTaskSQLJobRequest,
    ) -> dms_enterprise_20181101_models.ListDBTaskSQLJobResponse:
        """
        @summary Queries a list of SQL tasks.
        
        @param request: ListDBTaskSQLJobRequest
        @return: ListDBTaskSQLJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_dbtask_sqljob_with_options(request, runtime)

    async def list_dbtask_sqljob_async(
        self,
        request: dms_enterprise_20181101_models.ListDBTaskSQLJobRequest,
    ) -> dms_enterprise_20181101_models.ListDBTaskSQLJobResponse:
        """
        @summary Queries a list of SQL tasks.
        
        @param request: ListDBTaskSQLJobRequest
        @return: ListDBTaskSQLJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_dbtask_sqljob_with_options_async(request, runtime)

    def list_dbtask_sqljob_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDBTaskSQLJobDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDBTaskSQLJobDetailResponse:
        """
        @summary Queries the details of an SQL task.
        
        @param request: ListDBTaskSQLJobDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDBTaskSQLJobDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDBTaskSQLJobDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDBTaskSQLJobDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_dbtask_sqljob_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDBTaskSQLJobDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDBTaskSQLJobDetailResponse:
        """
        @summary Queries the details of an SQL task.
        
        @param request: ListDBTaskSQLJobDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDBTaskSQLJobDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDBTaskSQLJobDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDBTaskSQLJobDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_dbtask_sqljob_detail(
        self,
        request: dms_enterprise_20181101_models.ListDBTaskSQLJobDetailRequest,
    ) -> dms_enterprise_20181101_models.ListDBTaskSQLJobDetailResponse:
        """
        @summary Queries the details of an SQL task.
        
        @param request: ListDBTaskSQLJobDetailRequest
        @return: ListDBTaskSQLJobDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_dbtask_sqljob_detail_with_options(request, runtime)

    async def list_dbtask_sqljob_detail_async(
        self,
        request: dms_enterprise_20181101_models.ListDBTaskSQLJobDetailRequest,
    ) -> dms_enterprise_20181101_models.ListDBTaskSQLJobDetailResponse:
        """
        @summary Queries the details of an SQL task.
        
        @param request: ListDBTaskSQLJobDetailRequest
        @return: ListDBTaskSQLJobDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_dbtask_sqljob_detail_with_options_async(request, runtime)

    def list_ddlpublish_records_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDDLPublishRecordsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDDLPublishRecordsResponse:
        """
        @summary Queries the publishing details of a schema design ticket.
        
        @param request: ListDDLPublishRecordsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDDLPublishRecordsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDDLPublishRecords',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDDLPublishRecordsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_ddlpublish_records_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDDLPublishRecordsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDDLPublishRecordsResponse:
        """
        @summary Queries the publishing details of a schema design ticket.
        
        @param request: ListDDLPublishRecordsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDDLPublishRecordsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDDLPublishRecords',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDDLPublishRecordsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_ddlpublish_records(
        self,
        request: dms_enterprise_20181101_models.ListDDLPublishRecordsRequest,
    ) -> dms_enterprise_20181101_models.ListDDLPublishRecordsResponse:
        """
        @summary Queries the publishing details of a schema design ticket.
        
        @param request: ListDDLPublishRecordsRequest
        @return: ListDDLPublishRecordsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_ddlpublish_records_with_options(request, runtime)

    async def list_ddlpublish_records_async(
        self,
        request: dms_enterprise_20181101_models.ListDDLPublishRecordsRequest,
    ) -> dms_enterprise_20181101_models.ListDDLPublishRecordsResponse:
        """
        @summary Queries the publishing details of a schema design ticket.
        
        @param request: ListDDLPublishRecordsRequest
        @return: ListDDLPublishRecordsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_ddlpublish_records_with_options_async(request, runtime)

    def list_data_correct_pre_check_dbwith_options(
        self,
        request: dms_enterprise_20181101_models.ListDataCorrectPreCheckDBRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataCorrectPreCheckDBResponse:
        """
        @summary Queries the databases that are involved in the precheck of a data change ticket.
        
        @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
        
        @param request: ListDataCorrectPreCheckDBRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataCorrectPreCheckDBResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataCorrectPreCheckDB',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataCorrectPreCheckDBResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_correct_pre_check_dbwith_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataCorrectPreCheckDBRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataCorrectPreCheckDBResponse:
        """
        @summary Queries the databases that are involved in the precheck of a data change ticket.
        
        @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
        
        @param request: ListDataCorrectPreCheckDBRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataCorrectPreCheckDBResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataCorrectPreCheckDB',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataCorrectPreCheckDBResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_correct_pre_check_db(
        self,
        request: dms_enterprise_20181101_models.ListDataCorrectPreCheckDBRequest,
    ) -> dms_enterprise_20181101_models.ListDataCorrectPreCheckDBResponse:
        """
        @summary Queries the databases that are involved in the precheck of a data change ticket.
        
        @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
        
        @param request: ListDataCorrectPreCheckDBRequest
        @return: ListDataCorrectPreCheckDBResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_correct_pre_check_dbwith_options(request, runtime)

    async def list_data_correct_pre_check_db_async(
        self,
        request: dms_enterprise_20181101_models.ListDataCorrectPreCheckDBRequest,
    ) -> dms_enterprise_20181101_models.ListDataCorrectPreCheckDBResponse:
        """
        @summary Queries the databases that are involved in the precheck of a data change ticket.
        
        @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
        
        @param request: ListDataCorrectPreCheckDBRequest
        @return: ListDataCorrectPreCheckDBResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_correct_pre_check_dbwith_options_async(request, runtime)

    def list_data_correct_pre_check_sqlwith_options(
        self,
        request: dms_enterprise_20181101_models.ListDataCorrectPreCheckSQLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataCorrectPreCheckSQLResponse:
        """
        @summary Queries the precheck information about an SQL statement that is specified in a data change ticket.
        
        @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
        
        @param request: ListDataCorrectPreCheckSQLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataCorrectPreCheckSQLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataCorrectPreCheckSQL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataCorrectPreCheckSQLResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_correct_pre_check_sqlwith_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataCorrectPreCheckSQLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataCorrectPreCheckSQLResponse:
        """
        @summary Queries the precheck information about an SQL statement that is specified in a data change ticket.
        
        @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
        
        @param request: ListDataCorrectPreCheckSQLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataCorrectPreCheckSQLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataCorrectPreCheckSQL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataCorrectPreCheckSQLResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_correct_pre_check_sql(
        self,
        request: dms_enterprise_20181101_models.ListDataCorrectPreCheckSQLRequest,
    ) -> dms_enterprise_20181101_models.ListDataCorrectPreCheckSQLResponse:
        """
        @summary Queries the precheck information about an SQL statement that is specified in a data change ticket.
        
        @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
        
        @param request: ListDataCorrectPreCheckSQLRequest
        @return: ListDataCorrectPreCheckSQLResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_correct_pre_check_sqlwith_options(request, runtime)

    async def list_data_correct_pre_check_sql_async(
        self,
        request: dms_enterprise_20181101_models.ListDataCorrectPreCheckSQLRequest,
    ) -> dms_enterprise_20181101_models.ListDataCorrectPreCheckSQLResponse:
        """
        @summary Queries the precheck information about an SQL statement that is specified in a data change ticket.
        
        @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
        
        @param request: ListDataCorrectPreCheckSQLRequest
        @return: ListDataCorrectPreCheckSQLResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_correct_pre_check_sqlwith_options_async(request, runtime)

    def list_data_import_sqlpre_check_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDataImportSQLPreCheckDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataImportSQLPreCheckDetailResponse:
        """
        @summary Queries the precheck information of SQL statements used for data import in a ticket.
        
        @description You can call this operation only if the data is imported in security mode in your data import ticket.
        
        @param request: ListDataImportSQLPreCheckDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataImportSQLPreCheckDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.page_numer):
            query['PageNumer'] = request.page_numer
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sql_type):
            query['SqlType'] = request.sql_type
        if not UtilClient.is_unset(request.status_code):
            query['StatusCode'] = request.status_code
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataImportSQLPreCheckDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataImportSQLPreCheckDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_import_sqlpre_check_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataImportSQLPreCheckDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataImportSQLPreCheckDetailResponse:
        """
        @summary Queries the precheck information of SQL statements used for data import in a ticket.
        
        @description You can call this operation only if the data is imported in security mode in your data import ticket.
        
        @param request: ListDataImportSQLPreCheckDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataImportSQLPreCheckDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.page_numer):
            query['PageNumer'] = request.page_numer
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sql_type):
            query['SqlType'] = request.sql_type
        if not UtilClient.is_unset(request.status_code):
            query['StatusCode'] = request.status_code
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataImportSQLPreCheckDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataImportSQLPreCheckDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_import_sqlpre_check_detail(
        self,
        request: dms_enterprise_20181101_models.ListDataImportSQLPreCheckDetailRequest,
    ) -> dms_enterprise_20181101_models.ListDataImportSQLPreCheckDetailResponse:
        """
        @summary Queries the precheck information of SQL statements used for data import in a ticket.
        
        @description You can call this operation only if the data is imported in security mode in your data import ticket.
        
        @param request: ListDataImportSQLPreCheckDetailRequest
        @return: ListDataImportSQLPreCheckDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_import_sqlpre_check_detail_with_options(request, runtime)

    async def list_data_import_sqlpre_check_detail_async(
        self,
        request: dms_enterprise_20181101_models.ListDataImportSQLPreCheckDetailRequest,
    ) -> dms_enterprise_20181101_models.ListDataImportSQLPreCheckDetailResponse:
        """
        @summary Queries the precheck information of SQL statements used for data import in a ticket.
        
        @description You can call this operation only if the data is imported in security mode in your data import ticket.
        
        @param request: ListDataImportSQLPreCheckDetailRequest
        @return: ListDataImportSQLPreCheckDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_import_sqlpre_check_detail_with_options_async(request, runtime)

    def list_data_import_sqltype_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDataImportSQLTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataImportSQLTypeResponse:
        """
        @summary Queries the types of SQL statements used for data import in a ticket.
        
        @description You can call this operation only if the data is imported in security mode in your data import ticket.
        
        @param request: ListDataImportSQLTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataImportSQLTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataImportSQLType',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataImportSQLTypeResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_import_sqltype_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataImportSQLTypeRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataImportSQLTypeResponse:
        """
        @summary Queries the types of SQL statements used for data import in a ticket.
        
        @description You can call this operation only if the data is imported in security mode in your data import ticket.
        
        @param request: ListDataImportSQLTypeRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataImportSQLTypeResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataImportSQLType',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataImportSQLTypeResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_import_sqltype(
        self,
        request: dms_enterprise_20181101_models.ListDataImportSQLTypeRequest,
    ) -> dms_enterprise_20181101_models.ListDataImportSQLTypeResponse:
        """
        @summary Queries the types of SQL statements used for data import in a ticket.
        
        @description You can call this operation only if the data is imported in security mode in your data import ticket.
        
        @param request: ListDataImportSQLTypeRequest
        @return: ListDataImportSQLTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_import_sqltype_with_options(request, runtime)

    async def list_data_import_sqltype_async(
        self,
        request: dms_enterprise_20181101_models.ListDataImportSQLTypeRequest,
    ) -> dms_enterprise_20181101_models.ListDataImportSQLTypeResponse:
        """
        @summary Queries the types of SQL statements used for data import in a ticket.
        
        @description You can call this operation only if the data is imported in security mode in your data import ticket.
        
        @param request: ListDataImportSQLTypeRequest
        @return: ListDataImportSQLTypeResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_import_sqltype_with_options_async(request, runtime)

    def list_data_lake_catalog_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeCatalogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeCatalogResponse:
        """
        @summary 获取uc的数据库目录列表
        
        @param request: ListDataLakeCatalogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeCatalogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeCatalog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeCatalogResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_lake_catalog_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeCatalogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeCatalogResponse:
        """
        @summary 获取uc的数据库目录列表
        
        @param request: ListDataLakeCatalogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeCatalogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeCatalog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeCatalogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_lake_catalog(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeCatalogRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeCatalogResponse:
        """
        @summary 获取uc的数据库目录列表
        
        @param request: ListDataLakeCatalogRequest
        @return: ListDataLakeCatalogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_lake_catalog_with_options(request, runtime)

    async def list_data_lake_catalog_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeCatalogRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeCatalogResponse:
        """
        @summary 获取uc的数据库目录列表
        
        @param request: ListDataLakeCatalogRequest
        @return: ListDataLakeCatalogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_lake_catalog_with_options_async(request, runtime)

    def list_data_lake_database_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeDatabaseResponse:
        """
        @summary 获取数据库列表
        
        @param request: ListDataLakeDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_lake_database_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeDatabaseResponse:
        """
        @summary 获取数据库列表
        
        @param request: ListDataLakeDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_lake_database(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeDatabaseRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeDatabaseResponse:
        """
        @summary 获取数据库列表
        
        @param request: ListDataLakeDatabaseRequest
        @return: ListDataLakeDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_lake_database_with_options(request, runtime)

    async def list_data_lake_database_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeDatabaseRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeDatabaseResponse:
        """
        @summary 获取数据库列表
        
        @param request: ListDataLakeDatabaseRequest
        @return: ListDataLakeDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_lake_database_with_options_async(request, runtime)

    def list_data_lake_function_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeFunctionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeFunctionResponse:
        """
        @summary 获取数据湖函数列表
        
        @param request: ListDataLakeFunctionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeFunctionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.function_name_pattern):
            query['FunctionNamePattern'] = request.function_name_pattern
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeFunction',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeFunctionResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_lake_function_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeFunctionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeFunctionResponse:
        """
        @summary 获取数据湖函数列表
        
        @param request: ListDataLakeFunctionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeFunctionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.function_name_pattern):
            query['FunctionNamePattern'] = request.function_name_pattern
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeFunction',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeFunctionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_lake_function(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeFunctionRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeFunctionResponse:
        """
        @summary 获取数据湖函数列表
        
        @param request: ListDataLakeFunctionRequest
        @return: ListDataLakeFunctionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_lake_function_with_options(request, runtime)

    async def list_data_lake_function_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeFunctionRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeFunctionResponse:
        """
        @summary 获取数据湖函数列表
        
        @param request: ListDataLakeFunctionRequest
        @return: ListDataLakeFunctionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_lake_function_with_options_async(request, runtime)

    def list_data_lake_function_name_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeFunctionNameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeFunctionNameResponse:
        """
        @summary 获取数据湖函数名列表
        
        @param request: ListDataLakeFunctionNameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeFunctionNameResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.function_name_pattern):
            query['FunctionNamePattern'] = request.function_name_pattern
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeFunctionName',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeFunctionNameResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_lake_function_name_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeFunctionNameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeFunctionNameResponse:
        """
        @summary 获取数据湖函数名列表
        
        @param request: ListDataLakeFunctionNameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeFunctionNameResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.function_name_pattern):
            query['FunctionNamePattern'] = request.function_name_pattern
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeFunctionName',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeFunctionNameResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_lake_function_name(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeFunctionNameRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeFunctionNameResponse:
        """
        @summary 获取数据湖函数名列表
        
        @param request: ListDataLakeFunctionNameRequest
        @return: ListDataLakeFunctionNameResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_lake_function_name_with_options(request, runtime)

    async def list_data_lake_function_name_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeFunctionNameRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeFunctionNameResponse:
        """
        @summary 获取数据湖函数名列表
        
        @param request: ListDataLakeFunctionNameRequest
        @return: ListDataLakeFunctionNameResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_lake_function_name_with_options_async(request, runtime)

    def list_data_lake_partition_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.ListDataLakePartitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakePartitionResponse:
        """
        @summary 获取数据湖表分区列表
        
        @param tmp_req: ListDataLakePartitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakePartitionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.ListDataLakePartitionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.part_names):
            request.part_names_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.part_names, 'PartNames', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.part_names_shrink):
            body['PartNames'] = request.part_names_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListDataLakePartition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakePartitionResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_lake_partition_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.ListDataLakePartitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakePartitionResponse:
        """
        @summary 获取数据湖表分区列表
        
        @param tmp_req: ListDataLakePartitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakePartitionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.ListDataLakePartitionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.part_names):
            request.part_names_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.part_names, 'PartNames', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.part_names_shrink):
            body['PartNames'] = request.part_names_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListDataLakePartition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakePartitionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_lake_partition(
        self,
        request: dms_enterprise_20181101_models.ListDataLakePartitionRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakePartitionResponse:
        """
        @summary 获取数据湖表分区列表
        
        @param request: ListDataLakePartitionRequest
        @return: ListDataLakePartitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_lake_partition_with_options(request, runtime)

    async def list_data_lake_partition_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakePartitionRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakePartitionResponse:
        """
        @summary 获取数据湖表分区列表
        
        @param request: ListDataLakePartitionRequest
        @return: ListDataLakePartitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_lake_partition_with_options_async(request, runtime)

    def list_data_lake_partition_by_filter_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDataLakePartitionByFilterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakePartitionByFilterResponse:
        """
        @summary 根据筛选条件获取数据湖表分区列表
        
        @param request: ListDataLakePartitionByFilterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakePartitionByFilterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.filter):
            body['Filter'] = request.filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListDataLakePartitionByFilter',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakePartitionByFilterResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_lake_partition_by_filter_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakePartitionByFilterRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakePartitionByFilterResponse:
        """
        @summary 根据筛选条件获取数据湖表分区列表
        
        @param request: ListDataLakePartitionByFilterRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakePartitionByFilterResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.filter):
            body['Filter'] = request.filter
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ListDataLakePartitionByFilter',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakePartitionByFilterResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_lake_partition_by_filter(
        self,
        request: dms_enterprise_20181101_models.ListDataLakePartitionByFilterRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakePartitionByFilterResponse:
        """
        @summary 根据筛选条件获取数据湖表分区列表
        
        @param request: ListDataLakePartitionByFilterRequest
        @return: ListDataLakePartitionByFilterResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_lake_partition_by_filter_with_options(request, runtime)

    async def list_data_lake_partition_by_filter_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakePartitionByFilterRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakePartitionByFilterResponse:
        """
        @summary 根据筛选条件获取数据湖表分区列表
        
        @param request: ListDataLakePartitionByFilterRequest
        @return: ListDataLakePartitionByFilterResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_lake_partition_by_filter_with_options_async(request, runtime)

    def list_data_lake_partition_name_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDataLakePartitionNameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakePartitionNameResponse:
        """
        @summary 获取数据湖表分区名列表
        
        @param request: ListDataLakePartitionNameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakePartitionNameResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakePartitionName',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakePartitionNameResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_lake_partition_name_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakePartitionNameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakePartitionNameResponse:
        """
        @summary 获取数据湖表分区名列表
        
        @param request: ListDataLakePartitionNameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakePartitionNameResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakePartitionName',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakePartitionNameResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_lake_partition_name(
        self,
        request: dms_enterprise_20181101_models.ListDataLakePartitionNameRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakePartitionNameResponse:
        """
        @summary 获取数据湖表分区名列表
        
        @param request: ListDataLakePartitionNameRequest
        @return: ListDataLakePartitionNameResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_lake_partition_name_with_options(request, runtime)

    async def list_data_lake_partition_name_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakePartitionNameRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakePartitionNameResponse:
        """
        @summary 获取数据湖表分区名列表
        
        @param request: ListDataLakePartitionNameRequest
        @return: ListDataLakePartitionNameResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_lake_partition_name_with_options_async(request, runtime)

    def list_data_lake_table_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeTableResponse:
        """
        @summary 获取数据湖表列表
        
        @param request: ListDataLakeTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.table_name_pattern):
            query['TableNamePattern'] = request.table_name_pattern
        if not UtilClient.is_unset(request.table_type):
            query['TableType'] = request.table_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeTable',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeTableResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_lake_table_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeTableResponse:
        """
        @summary 获取数据湖表列表
        
        @param request: ListDataLakeTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.table_name_pattern):
            query['TableNamePattern'] = request.table_name_pattern
        if not UtilClient.is_unset(request.table_type):
            query['TableType'] = request.table_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeTable',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeTableResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_lake_table(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeTableRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeTableResponse:
        """
        @summary 获取数据湖表列表
        
        @param request: ListDataLakeTableRequest
        @return: ListDataLakeTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_lake_table_with_options(request, runtime)

    async def list_data_lake_table_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeTableRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeTableResponse:
        """
        @summary 获取数据湖表列表
        
        @param request: ListDataLakeTableRequest
        @return: ListDataLakeTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_lake_table_with_options_async(request, runtime)

    def list_data_lake_table_name_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeTableNameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeTableNameResponse:
        """
        @summary 获取数据湖表名列表
        
        @param request: ListDataLakeTableNameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeTableNameResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.table_name_pattern):
            query['TableNamePattern'] = request.table_name_pattern
        if not UtilClient.is_unset(request.table_type):
            query['TableType'] = request.table_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeTableName',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeTableNameResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_lake_table_name_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeTableNameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeTableNameResponse:
        """
        @summary 获取数据湖表名列表
        
        @param request: ListDataLakeTableNameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeTableNameResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        if not UtilClient.is_unset(request.table_name_pattern):
            query['TableNamePattern'] = request.table_name_pattern
        if not UtilClient.is_unset(request.table_type):
            query['TableType'] = request.table_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeTableName',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeTableNameResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_lake_table_name(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeTableNameRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeTableNameResponse:
        """
        @summary 获取数据湖表名列表
        
        @param request: ListDataLakeTableNameRequest
        @return: ListDataLakeTableNameResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_lake_table_name_with_options(request, runtime)

    async def list_data_lake_table_name_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeTableNameRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeTableNameResponse:
        """
        @summary 获取数据湖表名列表
        
        @param request: ListDataLakeTableNameRequest
        @return: ListDataLakeTableNameResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_lake_table_name_with_options_async(request, runtime)

    def list_data_lake_tablebase_info_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeTablebaseInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeTablebaseInfoResponse:
        """
        @summary 获取表信息
        
        @param request: ListDataLakeTablebaseInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeTablebaseInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.page):
            query['Page'] = request.page
        if not UtilClient.is_unset(request.rows):
            query['Rows'] = request.rows
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeTablebaseInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeTablebaseInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_data_lake_tablebase_info_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeTablebaseInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDataLakeTablebaseInfoResponse:
        """
        @summary 获取表信息
        
        @param request: ListDataLakeTablebaseInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDataLakeTablebaseInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.page):
            query['Page'] = request.page
        if not UtilClient.is_unset(request.rows):
            query['Rows'] = request.rows
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDataLakeTablebaseInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDataLakeTablebaseInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_data_lake_tablebase_info(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeTablebaseInfoRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeTablebaseInfoResponse:
        """
        @summary 获取表信息
        
        @param request: ListDataLakeTablebaseInfoRequest
        @return: ListDataLakeTablebaseInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_data_lake_tablebase_info_with_options(request, runtime)

    async def list_data_lake_tablebase_info_async(
        self,
        request: dms_enterprise_20181101_models.ListDataLakeTablebaseInfoRequest,
    ) -> dms_enterprise_20181101_models.ListDataLakeTablebaseInfoResponse:
        """
        @summary 获取表信息
        
        @param request: ListDataLakeTablebaseInfoRequest
        @return: ListDataLakeTablebaseInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_data_lake_tablebase_info_with_options_async(request, runtime)

    def list_database_user_permssions_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDatabaseUserPermssionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDatabaseUserPermssionsResponse:
        """
        @summary Queries the permissions of users on a database.
        
        @param request: ListDatabaseUserPermssionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDatabaseUserPermssionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.perm_type):
            query['PermType'] = request.perm_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_name):
            query['UserName'] = request.user_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDatabaseUserPermssions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDatabaseUserPermssionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_database_user_permssions_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDatabaseUserPermssionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDatabaseUserPermssionsResponse:
        """
        @summary Queries the permissions of users on a database.
        
        @param request: ListDatabaseUserPermssionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDatabaseUserPermssionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.perm_type):
            query['PermType'] = request.perm_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_name):
            query['UserName'] = request.user_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDatabaseUserPermssions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDatabaseUserPermssionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_database_user_permssions(
        self,
        request: dms_enterprise_20181101_models.ListDatabaseUserPermssionsRequest,
    ) -> dms_enterprise_20181101_models.ListDatabaseUserPermssionsResponse:
        """
        @summary Queries the permissions of users on a database.
        
        @param request: ListDatabaseUserPermssionsRequest
        @return: ListDatabaseUserPermssionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_database_user_permssions_with_options(request, runtime)

    async def list_database_user_permssions_async(
        self,
        request: dms_enterprise_20181101_models.ListDatabaseUserPermssionsRequest,
    ) -> dms_enterprise_20181101_models.ListDatabaseUserPermssionsResponse:
        """
        @summary Queries the permissions of users on a database.
        
        @param request: ListDatabaseUserPermssionsRequest
        @return: ListDatabaseUserPermssionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_database_user_permssions_with_options_async(request, runtime)

    def list_databases_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDatabasesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDatabasesResponse:
        """
        @summary Queries the databases in a database instance.
        
        @param request: ListDatabasesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDatabasesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDatabases',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDatabasesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_databases_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDatabasesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDatabasesResponse:
        """
        @summary Queries the databases in a database instance.
        
        @param request: ListDatabasesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDatabasesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDatabases',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDatabasesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_databases(
        self,
        request: dms_enterprise_20181101_models.ListDatabasesRequest,
    ) -> dms_enterprise_20181101_models.ListDatabasesResponse:
        """
        @summary Queries the databases in a database instance.
        
        @param request: ListDatabasesRequest
        @return: ListDatabasesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_databases_with_options(request, runtime)

    async def list_databases_async(
        self,
        request: dms_enterprise_20181101_models.ListDatabasesRequest,
    ) -> dms_enterprise_20181101_models.ListDatabasesResponse:
        """
        @summary Queries the databases in a database instance.
        
        @param request: ListDatabasesRequest
        @return: ListDatabasesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_databases_with_options_async(request, runtime)

    def list_default_slarules_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDefaultSLARulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDefaultSLARulesResponse:
        """
        @summary Queries the default service level agreement (SLA) timeout rules.
        
        @param request: ListDefaultSLARulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDefaultSLARulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDefaultSLARules',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDefaultSLARulesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_default_slarules_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDefaultSLARulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDefaultSLARulesResponse:
        """
        @summary Queries the default service level agreement (SLA) timeout rules.
        
        @param request: ListDefaultSLARulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDefaultSLARulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDefaultSLARules',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDefaultSLARulesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_default_slarules(
        self,
        request: dms_enterprise_20181101_models.ListDefaultSLARulesRequest,
    ) -> dms_enterprise_20181101_models.ListDefaultSLARulesResponse:
        """
        @summary Queries the default service level agreement (SLA) timeout rules.
        
        @param request: ListDefaultSLARulesRequest
        @return: ListDefaultSLARulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_default_slarules_with_options(request, runtime)

    async def list_default_slarules_async(
        self,
        request: dms_enterprise_20181101_models.ListDefaultSLARulesRequest,
    ) -> dms_enterprise_20181101_models.ListDefaultSLARulesResponse:
        """
        @summary Queries the default service level agreement (SLA) timeout rules.
        
        @param request: ListDefaultSLARulesRequest
        @return: ListDefaultSLARulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_default_slarules_with_options_async(request, runtime)

    def list_desensitization_rule_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDesensitizationRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDesensitizationRuleResponse:
        """
        @summary Queries masking rules.
        
        @param request: ListDesensitizationRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDesensitizationRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.func_type):
            query['FuncType'] = request.func_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.rule_id):
            query['RuleId'] = request.rule_id
        if not UtilClient.is_unset(request.rule_name):
            query['RuleName'] = request.rule_name
        if not UtilClient.is_unset(request.rule_type):
            query['RuleType'] = request.rule_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDesensitizationRule',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDesensitizationRuleResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_desensitization_rule_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDesensitizationRuleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDesensitizationRuleResponse:
        """
        @summary Queries masking rules.
        
        @param request: ListDesensitizationRuleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDesensitizationRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.func_type):
            query['FuncType'] = request.func_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.rule_id):
            query['RuleId'] = request.rule_id
        if not UtilClient.is_unset(request.rule_name):
            query['RuleName'] = request.rule_name
        if not UtilClient.is_unset(request.rule_type):
            query['RuleType'] = request.rule_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDesensitizationRule',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDesensitizationRuleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_desensitization_rule(
        self,
        request: dms_enterprise_20181101_models.ListDesensitizationRuleRequest,
    ) -> dms_enterprise_20181101_models.ListDesensitizationRuleResponse:
        """
        @summary Queries masking rules.
        
        @param request: ListDesensitizationRuleRequest
        @return: ListDesensitizationRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_desensitization_rule_with_options(request, runtime)

    async def list_desensitization_rule_async(
        self,
        request: dms_enterprise_20181101_models.ListDesensitizationRuleRequest,
    ) -> dms_enterprise_20181101_models.ListDesensitizationRuleResponse:
        """
        @summary Queries masking rules.
        
        @param request: ListDesensitizationRuleRequest
        @return: ListDesensitizationRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_desensitization_rule_with_options_async(request, runtime)

    def list_dify_instances_with_options(
        self,
        request: dms_enterprise_20181101_models.ListDifyInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDifyInstancesResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: ListDifyInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDifyInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDifyInstances',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDifyInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_dify_instances_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListDifyInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListDifyInstancesResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: ListDifyInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListDifyInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.max_results):
            query['MaxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['NextToken'] = request.next_token
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListDifyInstances',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListDifyInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_dify_instances(
        self,
        request: dms_enterprise_20181101_models.ListDifyInstancesRequest,
    ) -> dms_enterprise_20181101_models.ListDifyInstancesResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: ListDifyInstancesRequest
        @return: ListDifyInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_dify_instances_with_options(request, runtime)

    async def list_dify_instances_async(
        self,
        request: dms_enterprise_20181101_models.ListDifyInstancesRequest,
    ) -> dms_enterprise_20181101_models.ListDifyInstancesResponse:
        """
        @summary 用于创建DIFY实例及相关资源，支持自定义配置。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: ListDifyInstancesRequest
        @return: ListDifyInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_dify_instances_with_options_async(request, runtime)

    def list_effective_orders_with_options(
        self,
        request: dms_enterprise_20181101_models.ListEffectiveOrdersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListEffectiveOrdersResponse:
        """
        @summary Queries valid orders.
        
        @param request: ListEffectiveOrdersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEffectiveOrdersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEffectiveOrders',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListEffectiveOrdersResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_effective_orders_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListEffectiveOrdersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListEffectiveOrdersResponse:
        """
        @summary Queries valid orders.
        
        @param request: ListEffectiveOrdersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEffectiveOrdersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEffectiveOrders',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListEffectiveOrdersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_effective_orders(
        self,
        request: dms_enterprise_20181101_models.ListEffectiveOrdersRequest,
    ) -> dms_enterprise_20181101_models.ListEffectiveOrdersResponse:
        """
        @summary Queries valid orders.
        
        @param request: ListEffectiveOrdersRequest
        @return: ListEffectiveOrdersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_effective_orders_with_options(request, runtime)

    async def list_effective_orders_async(
        self,
        request: dms_enterprise_20181101_models.ListEffectiveOrdersRequest,
    ) -> dms_enterprise_20181101_models.ListEffectiveOrdersResponse:
        """
        @summary Queries valid orders.
        
        @param request: ListEffectiveOrdersRequest
        @return: ListEffectiveOrdersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_effective_orders_with_options_async(request, runtime)

    def list_indexes_with_options(
        self,
        request: dms_enterprise_20181101_models.ListIndexesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListIndexesResponse:
        """
        @summary Queries the indexes of a table.
        
        @param request: ListIndexesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIndexesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIndexes',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListIndexesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_indexes_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListIndexesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListIndexesResponse:
        """
        @summary Queries the indexes of a table.
        
        @param request: ListIndexesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIndexesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIndexes',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListIndexesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_indexes(
        self,
        request: dms_enterprise_20181101_models.ListIndexesRequest,
    ) -> dms_enterprise_20181101_models.ListIndexesResponse:
        """
        @summary Queries the indexes of a table.
        
        @param request: ListIndexesRequest
        @return: ListIndexesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_indexes_with_options(request, runtime)

    async def list_indexes_async(
        self,
        request: dms_enterprise_20181101_models.ListIndexesRequest,
    ) -> dms_enterprise_20181101_models.ListIndexesResponse:
        """
        @summary Queries the indexes of a table.
        
        @param request: ListIndexesRequest
        @return: ListIndexesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_indexes_with_options_async(request, runtime)

    def list_instance_login_audit_log_with_options(
        self,
        request: dms_enterprise_20181101_models.ListInstanceLoginAuditLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListInstanceLoginAuditLogResponse:
        """
        @summary Queries the logon records of an instance.
        
        @param request: ListInstanceLoginAuditLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListInstanceLoginAuditLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.op_user_name):
            query['OpUserName'] = request.op_user_name
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListInstanceLoginAuditLog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListInstanceLoginAuditLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_instance_login_audit_log_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListInstanceLoginAuditLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListInstanceLoginAuditLogResponse:
        """
        @summary Queries the logon records of an instance.
        
        @param request: ListInstanceLoginAuditLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListInstanceLoginAuditLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.op_user_name):
            query['OpUserName'] = request.op_user_name
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListInstanceLoginAuditLog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListInstanceLoginAuditLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_instance_login_audit_log(
        self,
        request: dms_enterprise_20181101_models.ListInstanceLoginAuditLogRequest,
    ) -> dms_enterprise_20181101_models.ListInstanceLoginAuditLogResponse:
        """
        @summary Queries the logon records of an instance.
        
        @param request: ListInstanceLoginAuditLogRequest
        @return: ListInstanceLoginAuditLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_instance_login_audit_log_with_options(request, runtime)

    async def list_instance_login_audit_log_async(
        self,
        request: dms_enterprise_20181101_models.ListInstanceLoginAuditLogRequest,
    ) -> dms_enterprise_20181101_models.ListInstanceLoginAuditLogResponse:
        """
        @summary Queries the logon records of an instance.
        
        @param request: ListInstanceLoginAuditLogRequest
        @return: ListInstanceLoginAuditLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_instance_login_audit_log_with_options_async(request, runtime)

    def list_instance_user_permissions_with_options(
        self,
        request: dms_enterprise_20181101_models.ListInstanceUserPermissionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListInstanceUserPermissionsResponse:
        """
        @summary Queries the permissions of a user on a specific instance.
        
        @param request: ListInstanceUserPermissionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListInstanceUserPermissionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_name):
            query['UserName'] = request.user_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListInstanceUserPermissions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListInstanceUserPermissionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_instance_user_permissions_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListInstanceUserPermissionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListInstanceUserPermissionsResponse:
        """
        @summary Queries the permissions of a user on a specific instance.
        
        @param request: ListInstanceUserPermissionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListInstanceUserPermissionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_name):
            query['UserName'] = request.user_name
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListInstanceUserPermissions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListInstanceUserPermissionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_instance_user_permissions(
        self,
        request: dms_enterprise_20181101_models.ListInstanceUserPermissionsRequest,
    ) -> dms_enterprise_20181101_models.ListInstanceUserPermissionsResponse:
        """
        @summary Queries the permissions of a user on a specific instance.
        
        @param request: ListInstanceUserPermissionsRequest
        @return: ListInstanceUserPermissionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_instance_user_permissions_with_options(request, runtime)

    async def list_instance_user_permissions_async(
        self,
        request: dms_enterprise_20181101_models.ListInstanceUserPermissionsRequest,
    ) -> dms_enterprise_20181101_models.ListInstanceUserPermissionsResponse:
        """
        @summary Queries the permissions of a user on a specific instance.
        
        @param request: ListInstanceUserPermissionsRequest
        @return: ListInstanceUserPermissionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_instance_user_permissions_with_options_async(request, runtime)

    def list_instances_with_options(
        self,
        request: dms_enterprise_20181101_models.ListInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListInstancesResponse:
        """
        @summary Queries the information about database instances.
        
        @param request: ListInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.instance_source):
            query['InstanceSource'] = request.instance_source
        if not UtilClient.is_unset(request.instance_state):
            query['InstanceState'] = request.instance_state
        if not UtilClient.is_unset(request.net_type):
            query['NetType'] = request.net_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListInstances',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListInstancesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_instances_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListInstancesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListInstancesResponse:
        """
        @summary Queries the information about database instances.
        
        @param request: ListInstancesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.instance_source):
            query['InstanceSource'] = request.instance_source
        if not UtilClient.is_unset(request.instance_state):
            query['InstanceState'] = request.instance_state
        if not UtilClient.is_unset(request.net_type):
            query['NetType'] = request.net_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListInstances',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListInstancesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_instances(
        self,
        request: dms_enterprise_20181101_models.ListInstancesRequest,
    ) -> dms_enterprise_20181101_models.ListInstancesResponse:
        """
        @summary Queries the information about database instances.
        
        @param request: ListInstancesRequest
        @return: ListInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_instances_with_options(request, runtime)

    async def list_instances_async(
        self,
        request: dms_enterprise_20181101_models.ListInstancesRequest,
    ) -> dms_enterprise_20181101_models.ListInstancesResponse:
        """
        @summary Queries the information about database instances.
        
        @param request: ListInstancesRequest
        @return: ListInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_instances_with_options_async(request, runtime)

    def list_lh_task_flow_and_scenario_with_options(
        self,
        request: dms_enterprise_20181101_models.ListLhTaskFlowAndScenarioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListLhTaskFlowAndScenarioResponse:
        """
        @summary Queries the task flows corresponding to a specific business scenario in a workspace in Data Management (DMS).
        
        @description    Before you call this operation, make sure that you have the access permissions on the workspace. If you do not have the access permissions on the workspace, you can contact a DMS administrator, database administrator (DBA), or workspace administrator to add you as a member of the workspace. The [AddLhMembers](https://help.aliyun.com/document_detail/424759.html) operation can be called to add a workspace member.
        If you are a DMS administrator or a workspace administrator, you can query the business scenarios and task flows related to a user in a workspace based on the user ID.
        
        @param request: ListLhTaskFlowAndScenarioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLhTaskFlowAndScenarioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.space_id):
            query['SpaceId'] = request.space_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLhTaskFlowAndScenario',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListLhTaskFlowAndScenarioResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_lh_task_flow_and_scenario_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListLhTaskFlowAndScenarioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListLhTaskFlowAndScenarioResponse:
        """
        @summary Queries the task flows corresponding to a specific business scenario in a workspace in Data Management (DMS).
        
        @description    Before you call this operation, make sure that you have the access permissions on the workspace. If you do not have the access permissions on the workspace, you can contact a DMS administrator, database administrator (DBA), or workspace administrator to add you as a member of the workspace. The [AddLhMembers](https://help.aliyun.com/document_detail/424759.html) operation can be called to add a workspace member.
        If you are a DMS administrator or a workspace administrator, you can query the business scenarios and task flows related to a user in a workspace based on the user ID.
        
        @param request: ListLhTaskFlowAndScenarioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLhTaskFlowAndScenarioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.space_id):
            query['SpaceId'] = request.space_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLhTaskFlowAndScenario',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListLhTaskFlowAndScenarioResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_lh_task_flow_and_scenario(
        self,
        request: dms_enterprise_20181101_models.ListLhTaskFlowAndScenarioRequest,
    ) -> dms_enterprise_20181101_models.ListLhTaskFlowAndScenarioResponse:
        """
        @summary Queries the task flows corresponding to a specific business scenario in a workspace in Data Management (DMS).
        
        @description    Before you call this operation, make sure that you have the access permissions on the workspace. If you do not have the access permissions on the workspace, you can contact a DMS administrator, database administrator (DBA), or workspace administrator to add you as a member of the workspace. The [AddLhMembers](https://help.aliyun.com/document_detail/424759.html) operation can be called to add a workspace member.
        If you are a DMS administrator or a workspace administrator, you can query the business scenarios and task flows related to a user in a workspace based on the user ID.
        
        @param request: ListLhTaskFlowAndScenarioRequest
        @return: ListLhTaskFlowAndScenarioResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_lh_task_flow_and_scenario_with_options(request, runtime)

    async def list_lh_task_flow_and_scenario_async(
        self,
        request: dms_enterprise_20181101_models.ListLhTaskFlowAndScenarioRequest,
    ) -> dms_enterprise_20181101_models.ListLhTaskFlowAndScenarioResponse:
        """
        @summary Queries the task flows corresponding to a specific business scenario in a workspace in Data Management (DMS).
        
        @description    Before you call this operation, make sure that you have the access permissions on the workspace. If you do not have the access permissions on the workspace, you can contact a DMS administrator, database administrator (DBA), or workspace administrator to add you as a member of the workspace. The [AddLhMembers](https://help.aliyun.com/document_detail/424759.html) operation can be called to add a workspace member.
        If you are a DMS administrator or a workspace administrator, you can query the business scenarios and task flows related to a user in a workspace based on the user ID.
        
        @param request: ListLhTaskFlowAndScenarioRequest
        @return: ListLhTaskFlowAndScenarioResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_lh_task_flow_and_scenario_with_options_async(request, runtime)

    def list_logic_databases_with_options(
        self,
        request: dms_enterprise_20181101_models.ListLogicDatabasesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListLogicDatabasesResponse:
        """
        @summary Queries the details of logical databases.
        
        @param request: ListLogicDatabasesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLogicDatabasesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLogicDatabases',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListLogicDatabasesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_logic_databases_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListLogicDatabasesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListLogicDatabasesResponse:
        """
        @summary Queries the details of logical databases.
        
        @param request: ListLogicDatabasesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLogicDatabasesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLogicDatabases',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListLogicDatabasesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_logic_databases(
        self,
        request: dms_enterprise_20181101_models.ListLogicDatabasesRequest,
    ) -> dms_enterprise_20181101_models.ListLogicDatabasesResponse:
        """
        @summary Queries the details of logical databases.
        
        @param request: ListLogicDatabasesRequest
        @return: ListLogicDatabasesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_logic_databases_with_options(request, runtime)

    async def list_logic_databases_async(
        self,
        request: dms_enterprise_20181101_models.ListLogicDatabasesRequest,
    ) -> dms_enterprise_20181101_models.ListLogicDatabasesResponse:
        """
        @summary Queries the details of logical databases.
        
        @param request: ListLogicDatabasesRequest
        @return: ListLogicDatabasesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_logic_databases_with_options_async(request, runtime)

    def list_logic_table_route_config_with_options(
        self,
        request: dms_enterprise_20181101_models.ListLogicTableRouteConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListLogicTableRouteConfigResponse:
        """
        @summary Queries the routing algorithms of a logical table.
        
        @param request: ListLogicTableRouteConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLogicTableRouteConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLogicTableRouteConfig',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListLogicTableRouteConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_logic_table_route_config_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListLogicTableRouteConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListLogicTableRouteConfigResponse:
        """
        @summary Queries the routing algorithms of a logical table.
        
        @param request: ListLogicTableRouteConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLogicTableRouteConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLogicTableRouteConfig',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListLogicTableRouteConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_logic_table_route_config(
        self,
        request: dms_enterprise_20181101_models.ListLogicTableRouteConfigRequest,
    ) -> dms_enterprise_20181101_models.ListLogicTableRouteConfigResponse:
        """
        @summary Queries the routing algorithms of a logical table.
        
        @param request: ListLogicTableRouteConfigRequest
        @return: ListLogicTableRouteConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_logic_table_route_config_with_options(request, runtime)

    async def list_logic_table_route_config_async(
        self,
        request: dms_enterprise_20181101_models.ListLogicTableRouteConfigRequest,
    ) -> dms_enterprise_20181101_models.ListLogicTableRouteConfigResponse:
        """
        @summary Queries the routing algorithms of a logical table.
        
        @param request: ListLogicTableRouteConfigRequest
        @return: ListLogicTableRouteConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_logic_table_route_config_with_options_async(request, runtime)

    def list_logic_tables_with_options(
        self,
        request: dms_enterprise_20181101_models.ListLogicTablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListLogicTablesResponse:
        """
        @summary Queries the details of the logical tables in a logical database.
        
        @param request: ListLogicTablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLogicTablesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.database_id):
            query['DatabaseId'] = request.database_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.return_guid):
            query['ReturnGuid'] = request.return_guid
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLogicTables',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListLogicTablesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_logic_tables_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListLogicTablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListLogicTablesResponse:
        """
        @summary Queries the details of the logical tables in a logical database.
        
        @param request: ListLogicTablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListLogicTablesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.database_id):
            query['DatabaseId'] = request.database_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.return_guid):
            query['ReturnGuid'] = request.return_guid
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListLogicTables',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListLogicTablesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_logic_tables(
        self,
        request: dms_enterprise_20181101_models.ListLogicTablesRequest,
    ) -> dms_enterprise_20181101_models.ListLogicTablesResponse:
        """
        @summary Queries the details of the logical tables in a logical database.
        
        @param request: ListLogicTablesRequest
        @return: ListLogicTablesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_logic_tables_with_options(request, runtime)

    async def list_logic_tables_async(
        self,
        request: dms_enterprise_20181101_models.ListLogicTablesRequest,
    ) -> dms_enterprise_20181101_models.ListLogicTablesResponse:
        """
        @summary Queries the details of the logical tables in a logical database.
        
        @param request: ListLogicTablesRequest
        @return: ListLogicTablesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_logic_tables_with_options_async(request, runtime)

    def list_meta_category_with_options(
        self,
        request: dms_enterprise_20181101_models.ListMetaCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListMetaCategoryResponse:
        """
        @summary 获取资产类目列表
        
        @param request: ListMetaCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMetaCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.parent_category_id):
            query['ParentCategoryId'] = request.parent_category_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMetaCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListMetaCategoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_meta_category_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListMetaCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListMetaCategoryResponse:
        """
        @summary 获取资产类目列表
        
        @param request: ListMetaCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMetaCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.parent_category_id):
            query['ParentCategoryId'] = request.parent_category_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMetaCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListMetaCategoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_meta_category(
        self,
        request: dms_enterprise_20181101_models.ListMetaCategoryRequest,
    ) -> dms_enterprise_20181101_models.ListMetaCategoryResponse:
        """
        @summary 获取资产类目列表
        
        @param request: ListMetaCategoryRequest
        @return: ListMetaCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_meta_category_with_options(request, runtime)

    async def list_meta_category_async(
        self,
        request: dms_enterprise_20181101_models.ListMetaCategoryRequest,
    ) -> dms_enterprise_20181101_models.ListMetaCategoryResponse:
        """
        @summary 获取资产类目列表
        
        @param request: ListMetaCategoryRequest
        @return: ListMetaCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_meta_category_with_options_async(request, runtime)

    def list_orders_with_options(
        self,
        request: dms_enterprise_20181101_models.ListOrdersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListOrdersResponse:
        """
        @summary Queries tickets in Data Management (DMS).
        
        @param request: ListOrdersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListOrdersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.order_result_type):
            query['OrderResultType'] = request.order_result_type
        if not UtilClient.is_unset(request.order_status):
            query['OrderStatus'] = request.order_status
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.plugin_type):
            query['PluginType'] = request.plugin_type
        if not UtilClient.is_unset(request.search_content):
            query['SearchContent'] = request.search_content
        if not UtilClient.is_unset(request.search_date_type):
            query['SearchDateType'] = request.search_date_type
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListOrders',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListOrdersResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_orders_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListOrdersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListOrdersResponse:
        """
        @summary Queries tickets in Data Management (DMS).
        
        @param request: ListOrdersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListOrdersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.order_result_type):
            query['OrderResultType'] = request.order_result_type
        if not UtilClient.is_unset(request.order_status):
            query['OrderStatus'] = request.order_status
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.plugin_type):
            query['PluginType'] = request.plugin_type
        if not UtilClient.is_unset(request.search_content):
            query['SearchContent'] = request.search_content
        if not UtilClient.is_unset(request.search_date_type):
            query['SearchDateType'] = request.search_date_type
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListOrders',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListOrdersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_orders(
        self,
        request: dms_enterprise_20181101_models.ListOrdersRequest,
    ) -> dms_enterprise_20181101_models.ListOrdersResponse:
        """
        @summary Queries tickets in Data Management (DMS).
        
        @param request: ListOrdersRequest
        @return: ListOrdersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_orders_with_options(request, runtime)

    async def list_orders_async(
        self,
        request: dms_enterprise_20181101_models.ListOrdersRequest,
    ) -> dms_enterprise_20181101_models.ListOrdersResponse:
        """
        @summary Queries tickets in Data Management (DMS).
        
        @param request: ListOrdersRequest
        @return: ListOrdersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_orders_with_options_async(request, runtime)

    def list_proxies_with_options(
        self,
        request: dms_enterprise_20181101_models.ListProxiesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListProxiesResponse:
        """
        @summary Queries the proxies that are generated by the secure access proxy feature.
        
        @param request: ListProxiesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListProxiesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListProxies',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListProxiesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_proxies_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListProxiesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListProxiesResponse:
        """
        @summary Queries the proxies that are generated by the secure access proxy feature.
        
        @param request: ListProxiesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListProxiesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListProxies',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListProxiesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_proxies(
        self,
        request: dms_enterprise_20181101_models.ListProxiesRequest,
    ) -> dms_enterprise_20181101_models.ListProxiesResponse:
        """
        @summary Queries the proxies that are generated by the secure access proxy feature.
        
        @param request: ListProxiesRequest
        @return: ListProxiesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_proxies_with_options(request, runtime)

    async def list_proxies_async(
        self,
        request: dms_enterprise_20181101_models.ListProxiesRequest,
    ) -> dms_enterprise_20181101_models.ListProxiesResponse:
        """
        @summary Queries the proxies that are generated by the secure access proxy feature.
        
        @param request: ListProxiesRequest
        @return: ListProxiesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_proxies_with_options_async(request, runtime)

    def list_proxy_accesses_with_options(
        self,
        request: dms_enterprise_20181101_models.ListProxyAccessesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListProxyAccessesResponse:
        """
        @summary Queries information about users that are authorized to access a database instance by using the secure access proxy feature.
        
        @param request: ListProxyAccessesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListProxyAccessesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.proxy_id):
            query['ProxyId'] = request.proxy_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListProxyAccesses',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListProxyAccessesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_proxy_accesses_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListProxyAccessesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListProxyAccessesResponse:
        """
        @summary Queries information about users that are authorized to access a database instance by using the secure access proxy feature.
        
        @param request: ListProxyAccessesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListProxyAccessesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.proxy_id):
            query['ProxyId'] = request.proxy_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListProxyAccesses',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListProxyAccessesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_proxy_accesses(
        self,
        request: dms_enterprise_20181101_models.ListProxyAccessesRequest,
    ) -> dms_enterprise_20181101_models.ListProxyAccessesResponse:
        """
        @summary Queries information about users that are authorized to access a database instance by using the secure access proxy feature.
        
        @param request: ListProxyAccessesRequest
        @return: ListProxyAccessesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_proxy_accesses_with_options(request, runtime)

    async def list_proxy_accesses_async(
        self,
        request: dms_enterprise_20181101_models.ListProxyAccessesRequest,
    ) -> dms_enterprise_20181101_models.ListProxyAccessesResponse:
        """
        @summary Queries information about users that are authorized to access a database instance by using the secure access proxy feature.
        
        @param request: ListProxyAccessesRequest
        @return: ListProxyAccessesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_proxy_accesses_with_options_async(request, runtime)

    def list_proxy_sqlexec_audit_log_with_options(
        self,
        request: dms_enterprise_20181101_models.ListProxySQLExecAuditLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListProxySQLExecAuditLogResponse:
        """
        @summary 操作审计-数据安全代理SQL执行列表
        
        @param request: ListProxySQLExecAuditLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListProxySQLExecAuditLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.exec_state):
            query['ExecState'] = request.exec_state
        if not UtilClient.is_unset(request.op_user_name):
            query['OpUserName'] = request.op_user_name
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sqltype):
            query['SQLType'] = request.sqltype
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListProxySQLExecAuditLog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListProxySQLExecAuditLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_proxy_sqlexec_audit_log_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListProxySQLExecAuditLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListProxySQLExecAuditLogResponse:
        """
        @summary 操作审计-数据安全代理SQL执行列表
        
        @param request: ListProxySQLExecAuditLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListProxySQLExecAuditLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.exec_state):
            query['ExecState'] = request.exec_state
        if not UtilClient.is_unset(request.op_user_name):
            query['OpUserName'] = request.op_user_name
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.sqltype):
            query['SQLType'] = request.sqltype
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListProxySQLExecAuditLog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListProxySQLExecAuditLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_proxy_sqlexec_audit_log(
        self,
        request: dms_enterprise_20181101_models.ListProxySQLExecAuditLogRequest,
    ) -> dms_enterprise_20181101_models.ListProxySQLExecAuditLogResponse:
        """
        @summary 操作审计-数据安全代理SQL执行列表
        
        @param request: ListProxySQLExecAuditLogRequest
        @return: ListProxySQLExecAuditLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_proxy_sqlexec_audit_log_with_options(request, runtime)

    async def list_proxy_sqlexec_audit_log_async(
        self,
        request: dms_enterprise_20181101_models.ListProxySQLExecAuditLogRequest,
    ) -> dms_enterprise_20181101_models.ListProxySQLExecAuditLogResponse:
        """
        @summary 操作审计-数据安全代理SQL执行列表
        
        @param request: ListProxySQLExecAuditLogRequest
        @return: ListProxySQLExecAuditLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_proxy_sqlexec_audit_log_with_options_async(request, runtime)

    def list_slarules_with_options(
        self,
        request: dms_enterprise_20181101_models.ListSLARulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSLARulesResponse:
        """
        @summary Queries the custom service level agreement (SLA) rules.
        
        @param request: ListSLARulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSLARulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSLARules',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSLARulesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_slarules_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListSLARulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSLARulesResponse:
        """
        @summary Queries the custom service level agreement (SLA) rules.
        
        @param request: ListSLARulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSLARulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSLARules',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSLARulesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_slarules(
        self,
        request: dms_enterprise_20181101_models.ListSLARulesRequest,
    ) -> dms_enterprise_20181101_models.ListSLARulesResponse:
        """
        @summary Queries the custom service level agreement (SLA) rules.
        
        @param request: ListSLARulesRequest
        @return: ListSLARulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_slarules_with_options(request, runtime)

    async def list_slarules_async(
        self,
        request: dms_enterprise_20181101_models.ListSLARulesRequest,
    ) -> dms_enterprise_20181101_models.ListSLARulesResponse:
        """
        @summary Queries the custom service level agreement (SLA) rules.
        
        @param request: ListSLARulesRequest
        @return: ListSLARulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_slarules_with_options_async(request, runtime)

    def list_sqlexec_audit_log_with_options(
        self,
        request: dms_enterprise_20181101_models.ListSQLExecAuditLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSQLExecAuditLogResponse:
        """
        @summary Queries SQL statements that were written on the SQLConsole tab.
        
        @param request: ListSQLExecAuditLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSQLExecAuditLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.exec_state):
            query['ExecState'] = request.exec_state
        if not UtilClient.is_unset(request.op_user_name):
            query['OpUserName'] = request.op_user_name
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.sql_type):
            query['SqlType'] = request.sql_type
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSQLExecAuditLog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSQLExecAuditLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_sqlexec_audit_log_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListSQLExecAuditLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSQLExecAuditLogResponse:
        """
        @summary Queries SQL statements that were written on the SQLConsole tab.
        
        @param request: ListSQLExecAuditLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSQLExecAuditLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.exec_state):
            query['ExecState'] = request.exec_state
        if not UtilClient.is_unset(request.op_user_name):
            query['OpUserName'] = request.op_user_name
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.sql_type):
            query['SqlType'] = request.sql_type
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSQLExecAuditLog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSQLExecAuditLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_sqlexec_audit_log(
        self,
        request: dms_enterprise_20181101_models.ListSQLExecAuditLogRequest,
    ) -> dms_enterprise_20181101_models.ListSQLExecAuditLogResponse:
        """
        @summary Queries SQL statements that were written on the SQLConsole tab.
        
        @param request: ListSQLExecAuditLogRequest
        @return: ListSQLExecAuditLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_sqlexec_audit_log_with_options(request, runtime)

    async def list_sqlexec_audit_log_async(
        self,
        request: dms_enterprise_20181101_models.ListSQLExecAuditLogRequest,
    ) -> dms_enterprise_20181101_models.ListSQLExecAuditLogResponse:
        """
        @summary Queries SQL statements that were written on the SQLConsole tab.
        
        @param request: ListSQLExecAuditLogRequest
        @return: ListSQLExecAuditLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_sqlexec_audit_log_with_options_async(request, runtime)

    def list_sqlreview_origin_sqlwith_options(
        self,
        tmp_req: dms_enterprise_20181101_models.ListSQLReviewOriginSQLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSQLReviewOriginSQLResponse:
        """
        @summary Queries the details of the SQL statements that are involved in an SQL review ticket.
        
        @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param tmp_req: ListSQLReviewOriginSQLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSQLReviewOriginSQLResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.ListSQLReviewOriginSQLShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.order_action_detail):
            request.order_action_detail_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.order_action_detail, 'OrderActionDetail', 'json')
        query = {}
        if not UtilClient.is_unset(request.order_action_detail_shrink):
            query['OrderActionDetail'] = request.order_action_detail_shrink
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSQLReviewOriginSQL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSQLReviewOriginSQLResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_sqlreview_origin_sqlwith_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.ListSQLReviewOriginSQLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSQLReviewOriginSQLResponse:
        """
        @summary Queries the details of the SQL statements that are involved in an SQL review ticket.
        
        @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param tmp_req: ListSQLReviewOriginSQLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSQLReviewOriginSQLResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.ListSQLReviewOriginSQLShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.order_action_detail):
            request.order_action_detail_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.order_action_detail, 'OrderActionDetail', 'json')
        query = {}
        if not UtilClient.is_unset(request.order_action_detail_shrink):
            query['OrderActionDetail'] = request.order_action_detail_shrink
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSQLReviewOriginSQL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSQLReviewOriginSQLResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_sqlreview_origin_sql(
        self,
        request: dms_enterprise_20181101_models.ListSQLReviewOriginSQLRequest,
    ) -> dms_enterprise_20181101_models.ListSQLReviewOriginSQLResponse:
        """
        @summary Queries the details of the SQL statements that are involved in an SQL review ticket.
        
        @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param request: ListSQLReviewOriginSQLRequest
        @return: ListSQLReviewOriginSQLResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_sqlreview_origin_sqlwith_options(request, runtime)

    async def list_sqlreview_origin_sql_async(
        self,
        request: dms_enterprise_20181101_models.ListSQLReviewOriginSQLRequest,
    ) -> dms_enterprise_20181101_models.ListSQLReviewOriginSQLResponse:
        """
        @summary Queries the details of the SQL statements that are involved in an SQL review ticket.
        
        @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
        
        @param request: ListSQLReviewOriginSQLRequest
        @return: ListSQLReviewOriginSQLResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_sqlreview_origin_sqlwith_options_async(request, runtime)

    def list_scenarios_with_options(
        self,
        request: dms_enterprise_20181101_models.ListScenariosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListScenariosResponse:
        """
        @summary Queries business scenarios.
        
        @param request: ListScenariosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListScenariosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListScenarios',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListScenariosResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_scenarios_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListScenariosRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListScenariosResponse:
        """
        @summary Queries business scenarios.
        
        @param request: ListScenariosRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListScenariosResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListScenarios',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListScenariosResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_scenarios(
        self,
        request: dms_enterprise_20181101_models.ListScenariosRequest,
    ) -> dms_enterprise_20181101_models.ListScenariosResponse:
        """
        @summary Queries business scenarios.
        
        @param request: ListScenariosRequest
        @return: ListScenariosResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_scenarios_with_options(request, runtime)

    async def list_scenarios_async(
        self,
        request: dms_enterprise_20181101_models.ListScenariosRequest,
    ) -> dms_enterprise_20181101_models.ListScenariosResponse:
        """
        @summary Queries business scenarios.
        
        @param request: ListScenariosRequest
        @return: ListScenariosResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_scenarios_with_options_async(request, runtime)

    def list_sensitive_column_info_with_options(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveColumnInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSensitiveColumnInfoResponse:
        """
        @summary 获取敏感字段信息
        
        @param request: ListSensitiveColumnInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSensitiveColumnInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSensitiveColumnInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSensitiveColumnInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_sensitive_column_info_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveColumnInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSensitiveColumnInfoResponse:
        """
        @summary 获取敏感字段信息
        
        @param request: ListSensitiveColumnInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSensitiveColumnInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSensitiveColumnInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSensitiveColumnInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_sensitive_column_info(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveColumnInfoRequest,
    ) -> dms_enterprise_20181101_models.ListSensitiveColumnInfoResponse:
        """
        @summary 获取敏感字段信息
        
        @param request: ListSensitiveColumnInfoRequest
        @return: ListSensitiveColumnInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_sensitive_column_info_with_options(request, runtime)

    async def list_sensitive_column_info_async(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveColumnInfoRequest,
    ) -> dms_enterprise_20181101_models.ListSensitiveColumnInfoResponse:
        """
        @summary 获取敏感字段信息
        
        @param request: ListSensitiveColumnInfoRequest
        @return: ListSensitiveColumnInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_sensitive_column_info_with_options_async(request, runtime)

    def list_sensitive_columns_with_options(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveColumnsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSensitiveColumnsResponse:
        """
        @summary Queries sensitive fields in a table of a database.
        
        @param request: ListSensitiveColumnsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSensitiveColumnsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.security_level):
            query['SecurityLevel'] = request.security_level
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSensitiveColumns',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSensitiveColumnsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_sensitive_columns_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveColumnsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSensitiveColumnsResponse:
        """
        @summary Queries sensitive fields in a table of a database.
        
        @param request: ListSensitiveColumnsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSensitiveColumnsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.security_level):
            query['SecurityLevel'] = request.security_level
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSensitiveColumns',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSensitiveColumnsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_sensitive_columns(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveColumnsRequest,
    ) -> dms_enterprise_20181101_models.ListSensitiveColumnsResponse:
        """
        @summary Queries sensitive fields in a table of a database.
        
        @param request: ListSensitiveColumnsRequest
        @return: ListSensitiveColumnsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_sensitive_columns_with_options(request, runtime)

    async def list_sensitive_columns_async(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveColumnsRequest,
    ) -> dms_enterprise_20181101_models.ListSensitiveColumnsResponse:
        """
        @summary Queries sensitive fields in a table of a database.
        
        @param request: ListSensitiveColumnsRequest
        @return: ListSensitiveColumnsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_sensitive_columns_with_options_async(request, runtime)

    def list_sensitive_columns_detail_with_options(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveColumnsDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSensitiveColumnsDetailResponse:
        """
        @summary Queries the details of a sensitive field.
        
        @param request: ListSensitiveColumnsDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSensitiveColumnsDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSensitiveColumnsDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSensitiveColumnsDetailResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_sensitive_columns_detail_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveColumnsDetailRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSensitiveColumnsDetailResponse:
        """
        @summary Queries the details of a sensitive field.
        
        @param request: ListSensitiveColumnsDetailRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSensitiveColumnsDetailResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSensitiveColumnsDetail',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSensitiveColumnsDetailResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_sensitive_columns_detail(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveColumnsDetailRequest,
    ) -> dms_enterprise_20181101_models.ListSensitiveColumnsDetailResponse:
        """
        @summary Queries the details of a sensitive field.
        
        @param request: ListSensitiveColumnsDetailRequest
        @return: ListSensitiveColumnsDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_sensitive_columns_detail_with_options(request, runtime)

    async def list_sensitive_columns_detail_async(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveColumnsDetailRequest,
    ) -> dms_enterprise_20181101_models.ListSensitiveColumnsDetailResponse:
        """
        @summary Queries the details of a sensitive field.
        
        @param request: ListSensitiveColumnsDetailRequest
        @return: ListSensitiveColumnsDetailResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_sensitive_columns_detail_with_options_async(request, runtime)

    def list_sensitive_data_audit_log_with_options(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveDataAuditLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSensitiveDataAuditLogResponse:
        """
        @summary Queries the audit logs for sensitive information.
        
        @param request: ListSensitiveDataAuditLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSensitiveDataAuditLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.module_name):
            query['ModuleName'] = request.module_name
        if not UtilClient.is_unset(request.op_user_name):
            query['OpUserName'] = request.op_user_name
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSensitiveDataAuditLog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSensitiveDataAuditLogResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_sensitive_data_audit_log_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveDataAuditLogRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSensitiveDataAuditLogResponse:
        """
        @summary Queries the audit logs for sensitive information.
        
        @param request: ListSensitiveDataAuditLogRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSensitiveDataAuditLogResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.end_time):
            query['EndTime'] = request.end_time
        if not UtilClient.is_unset(request.module_name):
            query['ModuleName'] = request.module_name
        if not UtilClient.is_unset(request.op_user_name):
            query['OpUserName'] = request.op_user_name
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time):
            query['StartTime'] = request.start_time
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSensitiveDataAuditLog',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSensitiveDataAuditLogResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_sensitive_data_audit_log(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveDataAuditLogRequest,
    ) -> dms_enterprise_20181101_models.ListSensitiveDataAuditLogResponse:
        """
        @summary Queries the audit logs for sensitive information.
        
        @param request: ListSensitiveDataAuditLogRequest
        @return: ListSensitiveDataAuditLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_sensitive_data_audit_log_with_options(request, runtime)

    async def list_sensitive_data_audit_log_async(
        self,
        request: dms_enterprise_20181101_models.ListSensitiveDataAuditLogRequest,
    ) -> dms_enterprise_20181101_models.ListSensitiveDataAuditLogResponse:
        """
        @summary Queries the audit logs for sensitive information.
        
        @param request: ListSensitiveDataAuditLogRequest
        @return: ListSensitiveDataAuditLogResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_sensitive_data_audit_log_with_options_async(request, runtime)

    def list_sensitivity_level_with_options(
        self,
        request: dms_enterprise_20181101_models.ListSensitivityLevelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSensitivityLevelResponse:
        """
        @summary Queries the sensitivity levels of a classification template.
        
        @param request: ListSensitivityLevelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSensitivityLevelResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSensitivityLevel',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSensitivityLevelResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_sensitivity_level_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListSensitivityLevelRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListSensitivityLevelResponse:
        """
        @summary Queries the sensitivity levels of a classification template.
        
        @param request: ListSensitivityLevelRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSensitivityLevelResponse
        """
        UtilClient.validate_model(request)
        query = OpenApiUtilClient.query(UtilClient.to_map(request))
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSensitivityLevel',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='GET',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListSensitivityLevelResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_sensitivity_level(
        self,
        request: dms_enterprise_20181101_models.ListSensitivityLevelRequest,
    ) -> dms_enterprise_20181101_models.ListSensitivityLevelResponse:
        """
        @summary Queries the sensitivity levels of a classification template.
        
        @param request: ListSensitivityLevelRequest
        @return: ListSensitivityLevelResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_sensitivity_level_with_options(request, runtime)

    async def list_sensitivity_level_async(
        self,
        request: dms_enterprise_20181101_models.ListSensitivityLevelRequest,
    ) -> dms_enterprise_20181101_models.ListSensitivityLevelResponse:
        """
        @summary Queries the sensitivity levels of a classification template.
        
        @param request: ListSensitivityLevelRequest
        @return: ListSensitivityLevelResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_sensitivity_level_with_options_async(request, runtime)

    def list_standard_groups_with_options(
        self,
        request: dms_enterprise_20181101_models.ListStandardGroupsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListStandardGroupsResponse:
        """
        @summary Queries security rule sets.
        
        @param request: ListStandardGroupsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListStandardGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListStandardGroups',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListStandardGroupsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_standard_groups_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListStandardGroupsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListStandardGroupsResponse:
        """
        @summary Queries security rule sets.
        
        @param request: ListStandardGroupsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListStandardGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListStandardGroups',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListStandardGroupsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_standard_groups(
        self,
        request: dms_enterprise_20181101_models.ListStandardGroupsRequest,
    ) -> dms_enterprise_20181101_models.ListStandardGroupsResponse:
        """
        @summary Queries security rule sets.
        
        @param request: ListStandardGroupsRequest
        @return: ListStandardGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_standard_groups_with_options(request, runtime)

    async def list_standard_groups_async(
        self,
        request: dms_enterprise_20181101_models.ListStandardGroupsRequest,
    ) -> dms_enterprise_20181101_models.ListStandardGroupsResponse:
        """
        @summary Queries security rule sets.
        
        @param request: ListStandardGroupsRequest
        @return: ListStandardGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_standard_groups_with_options_async(request, runtime)

    def list_table_columns_with_options(
        self,
        request: dms_enterprise_20181101_models.ListTableColumnsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTableColumnsResponse:
        """
        @summary 获取表字段信息
        
        @param request: ListTableColumnsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTableColumnsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.table_schema_name):
            query['TableSchemaName'] = request.table_schema_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTableColumns',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTableColumnsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_table_columns_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListTableColumnsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTableColumnsResponse:
        """
        @summary 获取表字段信息
        
        @param request: ListTableColumnsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTableColumnsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.table_schema_name):
            query['TableSchemaName'] = request.table_schema_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTableColumns',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTableColumnsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_table_columns(
        self,
        request: dms_enterprise_20181101_models.ListTableColumnsRequest,
    ) -> dms_enterprise_20181101_models.ListTableColumnsResponse:
        """
        @summary 获取表字段信息
        
        @param request: ListTableColumnsRequest
        @return: ListTableColumnsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_table_columns_with_options(request, runtime)

    async def list_table_columns_async(
        self,
        request: dms_enterprise_20181101_models.ListTableColumnsRequest,
    ) -> dms_enterprise_20181101_models.ListTableColumnsResponse:
        """
        @summary 获取表字段信息
        
        @param request: ListTableColumnsRequest
        @return: ListTableColumnsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_table_columns_with_options_async(request, runtime)

    def list_tables_with_options(
        self,
        request: dms_enterprise_20181101_models.ListTablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTablesResponse:
        """
        @summary Queries the tables in a database.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: ListTablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTablesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.database_id):
            query['DatabaseId'] = request.database_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.return_guid):
            query['ReturnGuid'] = request.return_guid
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTables',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTablesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_tables_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListTablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTablesResponse:
        """
        @summary Queries the tables in a database.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: ListTablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTablesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.database_id):
            query['DatabaseId'] = request.database_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.return_guid):
            query['ReturnGuid'] = request.return_guid
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTables',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTablesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_tables(
        self,
        request: dms_enterprise_20181101_models.ListTablesRequest,
    ) -> dms_enterprise_20181101_models.ListTablesResponse:
        """
        @summary Queries the tables in a database.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: ListTablesRequest
        @return: ListTablesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_tables_with_options(request, runtime)

    async def list_tables_async(
        self,
        request: dms_enterprise_20181101_models.ListTablesRequest,
    ) -> dms_enterprise_20181101_models.ListTablesResponse:
        """
        @summary Queries the tables in a database.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: ListTablesRequest
        @return: ListTablesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_tables_with_options_async(request, runtime)

    def list_tables_in_category_with_options(
        self,
        request: dms_enterprise_20181101_models.ListTablesInCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTablesInCategoryResponse:
        """
        @summary 获取类目下的表列表
        
        @param request: ListTablesInCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTablesInCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category_id):
            query['CategoryId'] = request.category_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTablesInCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTablesInCategoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_tables_in_category_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListTablesInCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTablesInCategoryResponse:
        """
        @summary 获取类目下的表列表
        
        @param request: ListTablesInCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTablesInCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category_id):
            query['CategoryId'] = request.category_id
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTablesInCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTablesInCategoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_tables_in_category(
        self,
        request: dms_enterprise_20181101_models.ListTablesInCategoryRequest,
    ) -> dms_enterprise_20181101_models.ListTablesInCategoryResponse:
        """
        @summary 获取类目下的表列表
        
        @param request: ListTablesInCategoryRequest
        @return: ListTablesInCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_tables_in_category_with_options(request, runtime)

    async def list_tables_in_category_async(
        self,
        request: dms_enterprise_20181101_models.ListTablesInCategoryRequest,
    ) -> dms_enterprise_20181101_models.ListTablesInCategoryResponse:
        """
        @summary 获取类目下的表列表
        
        @param request: ListTablesInCategoryRequest
        @return: ListTablesInCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_tables_in_category_with_options_async(request, runtime)

    def list_task_flow_with_options(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowResponse:
        """
        @summary 任务编排获取任务流列表
        
        @param request: ListTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_task_flow_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowResponse:
        """
        @summary 任务编排获取任务流列表
        
        @param request: ListTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_task_flow(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowResponse:
        """
        @summary 任务编排获取任务流列表
        
        @param request: ListTaskFlowRequest
        @return: ListTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_task_flow_with_options(request, runtime)

    async def list_task_flow_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowResponse:
        """
        @summary 任务编排获取任务流列表
        
        @param request: ListTaskFlowRequest
        @return: ListTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_task_flow_with_options_async(request, runtime)

    def list_task_flow_constants_with_options(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowConstantsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowConstantsResponse:
        """
        @summary Queries the constants for a task flow.
        
        @param request: ListTaskFlowConstantsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowConstantsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlowConstants',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowConstantsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_task_flow_constants_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowConstantsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowConstantsResponse:
        """
        @summary Queries the constants for a task flow.
        
        @param request: ListTaskFlowConstantsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowConstantsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlowConstants',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowConstantsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_task_flow_constants(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowConstantsRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowConstantsResponse:
        """
        @summary Queries the constants for a task flow.
        
        @param request: ListTaskFlowConstantsRequest
        @return: ListTaskFlowConstantsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_task_flow_constants_with_options(request, runtime)

    async def list_task_flow_constants_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowConstantsRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowConstantsResponse:
        """
        @summary Queries the constants for a task flow.
        
        @param request: ListTaskFlowConstantsRequest
        @return: ListTaskFlowConstantsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_task_flow_constants_with_options_async(request, runtime)

    def list_task_flow_cooperators_with_options(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowCooperatorsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowCooperatorsResponse:
        """
        @summary Queries the users that are involved in a specified task flow.
        
        @param request: ListTaskFlowCooperatorsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowCooperatorsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlowCooperators',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowCooperatorsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_task_flow_cooperators_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowCooperatorsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowCooperatorsResponse:
        """
        @summary Queries the users that are involved in a specified task flow.
        
        @param request: ListTaskFlowCooperatorsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowCooperatorsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlowCooperators',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowCooperatorsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_task_flow_cooperators(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowCooperatorsRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowCooperatorsResponse:
        """
        @summary Queries the users that are involved in a specified task flow.
        
        @param request: ListTaskFlowCooperatorsRequest
        @return: ListTaskFlowCooperatorsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_task_flow_cooperators_with_options(request, runtime)

    async def list_task_flow_cooperators_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowCooperatorsRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowCooperatorsResponse:
        """
        @summary Queries the users that are involved in a specified task flow.
        
        @param request: ListTaskFlowCooperatorsRequest
        @return: ListTaskFlowCooperatorsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_task_flow_cooperators_with_options_async(request, runtime)

    def list_task_flow_edges_by_condition_with_options(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowEdgesByConditionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowEdgesByConditionResponse:
        """
        @summary Queries the edges of the directed acyclic graph (DAG) for a specified task flow based on multiple conditions.
        
        @description This operation is used for multi-condition query. You can call this operation to query the edges of a specified task flow that meet all specified conditions.
        
        @param request: ListTaskFlowEdgesByConditionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowEdgesByConditionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.id):
            query['Id'] = request.id
        if not UtilClient.is_unset(request.node_end):
            query['NodeEnd'] = request.node_end
        if not UtilClient.is_unset(request.node_from):
            query['NodeFrom'] = request.node_from
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlowEdgesByCondition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowEdgesByConditionResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_task_flow_edges_by_condition_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowEdgesByConditionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowEdgesByConditionResponse:
        """
        @summary Queries the edges of the directed acyclic graph (DAG) for a specified task flow based on multiple conditions.
        
        @description This operation is used for multi-condition query. You can call this operation to query the edges of a specified task flow that meet all specified conditions.
        
        @param request: ListTaskFlowEdgesByConditionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowEdgesByConditionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.id):
            query['Id'] = request.id
        if not UtilClient.is_unset(request.node_end):
            query['NodeEnd'] = request.node_end
        if not UtilClient.is_unset(request.node_from):
            query['NodeFrom'] = request.node_from
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlowEdgesByCondition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowEdgesByConditionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_task_flow_edges_by_condition(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowEdgesByConditionRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowEdgesByConditionResponse:
        """
        @summary Queries the edges of the directed acyclic graph (DAG) for a specified task flow based on multiple conditions.
        
        @description This operation is used for multi-condition query. You can call this operation to query the edges of a specified task flow that meet all specified conditions.
        
        @param request: ListTaskFlowEdgesByConditionRequest
        @return: ListTaskFlowEdgesByConditionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_task_flow_edges_by_condition_with_options(request, runtime)

    async def list_task_flow_edges_by_condition_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowEdgesByConditionRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowEdgesByConditionResponse:
        """
        @summary Queries the edges of the directed acyclic graph (DAG) for a specified task flow based on multiple conditions.
        
        @description This operation is used for multi-condition query. You can call this operation to query the edges of a specified task flow that meet all specified conditions.
        
        @param request: ListTaskFlowEdgesByConditionRequest
        @return: ListTaskFlowEdgesByConditionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_task_flow_edges_by_condition_with_options_async(request, runtime)

    def list_task_flow_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowInstanceResponse:
        """
        @summary Queries the execution records of a task flow.
        
        @param request: ListTaskFlowInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.page_index):
            query['PageIndex'] = request.page_index
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time_begin):
            query['StartTimeBegin'] = request.start_time_begin
        if not UtilClient.is_unset(request.start_time_end):
            query['StartTimeEnd'] = request.start_time_end
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.trigger_type):
            query['TriggerType'] = request.trigger_type
        if not UtilClient.is_unset(request.use_biz_date):
            query['UseBizDate'] = request.use_biz_date
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlowInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_task_flow_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowInstanceResponse:
        """
        @summary Queries the execution records of a task flow.
        
        @param request: ListTaskFlowInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.page_index):
            query['PageIndex'] = request.page_index
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time_begin):
            query['StartTimeBegin'] = request.start_time_begin
        if not UtilClient.is_unset(request.start_time_end):
            query['StartTimeEnd'] = request.start_time_end
        if not UtilClient.is_unset(request.status):
            query['Status'] = request.status
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.trigger_type):
            query['TriggerType'] = request.trigger_type
        if not UtilClient.is_unset(request.use_biz_date):
            query['UseBizDate'] = request.use_biz_date
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlowInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_task_flow_instance(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowInstanceRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowInstanceResponse:
        """
        @summary Queries the execution records of a task flow.
        
        @param request: ListTaskFlowInstanceRequest
        @return: ListTaskFlowInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_task_flow_instance_with_options(request, runtime)

    async def list_task_flow_instance_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowInstanceRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowInstanceResponse:
        """
        @summary Queries the execution records of a task flow.
        
        @param request: ListTaskFlowInstanceRequest
        @return: ListTaskFlowInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_task_flow_instance_with_options_async(request, runtime)

    def list_task_flow_time_variables_with_options(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowTimeVariablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowTimeVariablesResponse:
        """
        @summary Queries the time variables for a task flow.
        
        @param request: ListTaskFlowTimeVariablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowTimeVariablesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlowTimeVariables',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowTimeVariablesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_task_flow_time_variables_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowTimeVariablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowTimeVariablesResponse:
        """
        @summary Queries the time variables for a task flow.
        
        @param request: ListTaskFlowTimeVariablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowTimeVariablesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlowTimeVariables',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowTimeVariablesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_task_flow_time_variables(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowTimeVariablesRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowTimeVariablesResponse:
        """
        @summary Queries the time variables for a task flow.
        
        @param request: ListTaskFlowTimeVariablesRequest
        @return: ListTaskFlowTimeVariablesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_task_flow_time_variables_with_options(request, runtime)

    async def list_task_flow_time_variables_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowTimeVariablesRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowTimeVariablesResponse:
        """
        @summary Queries the time variables for a task flow.
        
        @param request: ListTaskFlowTimeVariablesRequest
        @return: ListTaskFlowTimeVariablesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_task_flow_time_variables_with_options_async(request, runtime)

    def list_task_flows_by_page_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.ListTaskFlowsByPageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowsByPageResponse:
        """
        @summary Queries task flows by page.
        
        @param tmp_req: ListTaskFlowsByPageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowsByPageResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.ListTaskFlowsByPageShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.dag_id_list):
            request.dag_id_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.dag_id_list, 'DagIdList', 'json')
        query = {}
        if not UtilClient.is_unset(request.dag_id_list_shrink):
            query['DagIdList'] = request.dag_id_list_shrink
        if not UtilClient.is_unset(request.page_index):
            query['PageIndex'] = request.page_index
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.scenario_id):
            query['ScenarioId'] = request.scenario_id
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlowsByPage',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowsByPageResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_task_flows_by_page_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.ListTaskFlowsByPageRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTaskFlowsByPageResponse:
        """
        @summary Queries task flows by page.
        
        @param tmp_req: ListTaskFlowsByPageRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTaskFlowsByPageResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.ListTaskFlowsByPageShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.dag_id_list):
            request.dag_id_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.dag_id_list, 'DagIdList', 'json')
        query = {}
        if not UtilClient.is_unset(request.dag_id_list_shrink):
            query['DagIdList'] = request.dag_id_list_shrink
        if not UtilClient.is_unset(request.page_index):
            query['PageIndex'] = request.page_index
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.scenario_id):
            query['ScenarioId'] = request.scenario_id
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTaskFlowsByPage',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTaskFlowsByPageResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_task_flows_by_page(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowsByPageRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowsByPageResponse:
        """
        @summary Queries task flows by page.
        
        @param request: ListTaskFlowsByPageRequest
        @return: ListTaskFlowsByPageResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_task_flows_by_page_with_options(request, runtime)

    async def list_task_flows_by_page_async(
        self,
        request: dms_enterprise_20181101_models.ListTaskFlowsByPageRequest,
    ) -> dms_enterprise_20181101_models.ListTaskFlowsByPageResponse:
        """
        @summary Queries task flows by page.
        
        @param request: ListTaskFlowsByPageRequest
        @return: ListTaskFlowsByPageResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_task_flows_by_page_with_options_async(request, runtime)

    def list_tasks_in_task_flow_with_options(
        self,
        request: dms_enterprise_20181101_models.ListTasksInTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTasksInTaskFlowResponse:
        """
        @summary Queries the tasks in a specified task flow.
        
        @param request: ListTasksInTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTasksInTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTasksInTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTasksInTaskFlowResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_tasks_in_task_flow_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListTasksInTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListTasksInTaskFlowResponse:
        """
        @summary Queries the tasks in a specified task flow.
        
        @param request: ListTasksInTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTasksInTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTasksInTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListTasksInTaskFlowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_tasks_in_task_flow(
        self,
        request: dms_enterprise_20181101_models.ListTasksInTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.ListTasksInTaskFlowResponse:
        """
        @summary Queries the tasks in a specified task flow.
        
        @param request: ListTasksInTaskFlowRequest
        @return: ListTasksInTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_tasks_in_task_flow_with_options(request, runtime)

    async def list_tasks_in_task_flow_async(
        self,
        request: dms_enterprise_20181101_models.ListTasksInTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.ListTasksInTaskFlowResponse:
        """
        @summary Queries the tasks in a specified task flow.
        
        @param request: ListTasksInTaskFlowRequest
        @return: ListTasksInTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_tasks_in_task_flow_with_options_async(request, runtime)

    def list_user_permissions_with_options(
        self,
        request: dms_enterprise_20181101_models.ListUserPermissionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListUserPermissionsResponse:
        """
        @summary Queries the permissions of a specific user on a database or a table.
        
        @param request: ListUserPermissionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListUserPermissionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.database_name):
            query['DatabaseName'] = request.database_name
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.perm_type):
            query['PermType'] = request.perm_type
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListUserPermissions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListUserPermissionsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_user_permissions_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListUserPermissionsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListUserPermissionsResponse:
        """
        @summary Queries the permissions of a specific user on a database or a table.
        
        @param request: ListUserPermissionsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListUserPermissionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.database_name):
            query['DatabaseName'] = request.database_name
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.perm_type):
            query['PermType'] = request.perm_type
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListUserPermissions',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListUserPermissionsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_user_permissions(
        self,
        request: dms_enterprise_20181101_models.ListUserPermissionsRequest,
    ) -> dms_enterprise_20181101_models.ListUserPermissionsResponse:
        """
        @summary Queries the permissions of a specific user on a database or a table.
        
        @param request: ListUserPermissionsRequest
        @return: ListUserPermissionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_user_permissions_with_options(request, runtime)

    async def list_user_permissions_async(
        self,
        request: dms_enterprise_20181101_models.ListUserPermissionsRequest,
    ) -> dms_enterprise_20181101_models.ListUserPermissionsResponse:
        """
        @summary Queries the permissions of a specific user on a database or a table.
        
        @param request: ListUserPermissionsRequest
        @return: ListUserPermissionsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_user_permissions_with_options_async(request, runtime)

    def list_user_tenants_with_options(
        self,
        request: dms_enterprise_20181101_models.ListUserTenantsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListUserTenantsResponse:
        """
        @summary 获取用户租户列表
        
        @param request: ListUserTenantsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListUserTenantsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListUserTenants',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListUserTenantsResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_user_tenants_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListUserTenantsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListUserTenantsResponse:
        """
        @summary 获取用户租户列表
        
        @param request: ListUserTenantsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListUserTenantsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListUserTenants',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListUserTenantsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_user_tenants(
        self,
        request: dms_enterprise_20181101_models.ListUserTenantsRequest,
    ) -> dms_enterprise_20181101_models.ListUserTenantsResponse:
        """
        @summary 获取用户租户列表
        
        @param request: ListUserTenantsRequest
        @return: ListUserTenantsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_user_tenants_with_options(request, runtime)

    async def list_user_tenants_async(
        self,
        request: dms_enterprise_20181101_models.ListUserTenantsRequest,
    ) -> dms_enterprise_20181101_models.ListUserTenantsResponse:
        """
        @summary 获取用户租户列表
        
        @param request: ListUserTenantsRequest
        @return: ListUserTenantsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_user_tenants_with_options_async(request, runtime)

    def list_users_with_options(
        self,
        request: dms_enterprise_20181101_models.ListUsersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListUsersResponse:
        """
        @summary Queries the details of users.
        
        @param request: ListUsersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListUsersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.role):
            query['Role'] = request.role
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_state):
            query['UserState'] = request.user_state
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListUsers',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListUsersResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_users_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListUsersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListUsersResponse:
        """
        @summary Queries the details of users.
        
        @param request: ListUsersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListUsersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.role):
            query['Role'] = request.role
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_state):
            query['UserState'] = request.user_state
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListUsers',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListUsersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_users(
        self,
        request: dms_enterprise_20181101_models.ListUsersRequest,
    ) -> dms_enterprise_20181101_models.ListUsersResponse:
        """
        @summary Queries the details of users.
        
        @param request: ListUsersRequest
        @return: ListUsersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_users_with_options(request, runtime)

    async def list_users_async(
        self,
        request: dms_enterprise_20181101_models.ListUsersRequest,
    ) -> dms_enterprise_20181101_models.ListUsersResponse:
        """
        @summary Queries the details of users.
        
        @param request: ListUsersRequest
        @return: ListUsersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_users_with_options_async(request, runtime)

    def list_work_flow_nodes_with_options(
        self,
        request: dms_enterprise_20181101_models.ListWorkFlowNodesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListWorkFlowNodesResponse:
        """
        @summary Queries approval nodes.
        
        @param request: ListWorkFlowNodesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListWorkFlowNodesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListWorkFlowNodes',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListWorkFlowNodesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_work_flow_nodes_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListWorkFlowNodesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListWorkFlowNodesResponse:
        """
        @summary Queries approval nodes.
        
        @param request: ListWorkFlowNodesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListWorkFlowNodesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListWorkFlowNodes',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListWorkFlowNodesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_work_flow_nodes(
        self,
        request: dms_enterprise_20181101_models.ListWorkFlowNodesRequest,
    ) -> dms_enterprise_20181101_models.ListWorkFlowNodesResponse:
        """
        @summary Queries approval nodes.
        
        @param request: ListWorkFlowNodesRequest
        @return: ListWorkFlowNodesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_work_flow_nodes_with_options(request, runtime)

    async def list_work_flow_nodes_async(
        self,
        request: dms_enterprise_20181101_models.ListWorkFlowNodesRequest,
    ) -> dms_enterprise_20181101_models.ListWorkFlowNodesResponse:
        """
        @summary Queries approval nodes.
        
        @param request: ListWorkFlowNodesRequest
        @return: ListWorkFlowNodesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_work_flow_nodes_with_options_async(request, runtime)

    def list_work_flow_templates_with_options(
        self,
        request: dms_enterprise_20181101_models.ListWorkFlowTemplatesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListWorkFlowTemplatesResponse:
        """
        @summary Queries approval templates.
        
        @param request: ListWorkFlowTemplatesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListWorkFlowTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListWorkFlowTemplates',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListWorkFlowTemplatesResponse(),
            self.call_api(params, req, runtime)
        )

    async def list_work_flow_templates_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ListWorkFlowTemplatesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ListWorkFlowTemplatesResponse:
        """
        @summary Queries approval templates.
        
        @param request: ListWorkFlowTemplatesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListWorkFlowTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.search_name):
            query['SearchName'] = request.search_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListWorkFlowTemplates',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ListWorkFlowTemplatesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def list_work_flow_templates(
        self,
        request: dms_enterprise_20181101_models.ListWorkFlowTemplatesRequest,
    ) -> dms_enterprise_20181101_models.ListWorkFlowTemplatesResponse:
        """
        @summary Queries approval templates.
        
        @param request: ListWorkFlowTemplatesRequest
        @return: ListWorkFlowTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.list_work_flow_templates_with_options(request, runtime)

    async def list_work_flow_templates_async(
        self,
        request: dms_enterprise_20181101_models.ListWorkFlowTemplatesRequest,
    ) -> dms_enterprise_20181101_models.ListWorkFlowTemplatesResponse:
        """
        @summary Queries approval templates.
        
        @param request: ListWorkFlowTemplatesRequest
        @return: ListWorkFlowTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.list_work_flow_templates_with_options_async(request, runtime)

    def make_task_flow_instance_success_with_options(
        self,
        request: dms_enterprise_20181101_models.MakeTaskFlowInstanceSuccessRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.MakeTaskFlowInstanceSuccessResponse:
        """
        @summary Sets the status of a task flow to "Successful".
        
        @param request: MakeTaskFlowInstanceSuccessRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MakeTaskFlowInstanceSuccessResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_instance_id):
            query['DagInstanceId'] = request.dag_instance_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MakeTaskFlowInstanceSuccess',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.MakeTaskFlowInstanceSuccessResponse(),
            self.call_api(params, req, runtime)
        )

    async def make_task_flow_instance_success_with_options_async(
        self,
        request: dms_enterprise_20181101_models.MakeTaskFlowInstanceSuccessRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.MakeTaskFlowInstanceSuccessResponse:
        """
        @summary Sets the status of a task flow to "Successful".
        
        @param request: MakeTaskFlowInstanceSuccessRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MakeTaskFlowInstanceSuccessResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_instance_id):
            query['DagInstanceId'] = request.dag_instance_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MakeTaskFlowInstanceSuccess',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.MakeTaskFlowInstanceSuccessResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def make_task_flow_instance_success(
        self,
        request: dms_enterprise_20181101_models.MakeTaskFlowInstanceSuccessRequest,
    ) -> dms_enterprise_20181101_models.MakeTaskFlowInstanceSuccessResponse:
        """
        @summary Sets the status of a task flow to "Successful".
        
        @param request: MakeTaskFlowInstanceSuccessRequest
        @return: MakeTaskFlowInstanceSuccessResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.make_task_flow_instance_success_with_options(request, runtime)

    async def make_task_flow_instance_success_async(
        self,
        request: dms_enterprise_20181101_models.MakeTaskFlowInstanceSuccessRequest,
    ) -> dms_enterprise_20181101_models.MakeTaskFlowInstanceSuccessResponse:
        """
        @summary Sets the status of a task flow to "Successful".
        
        @param request: MakeTaskFlowInstanceSuccessRequest
        @return: MakeTaskFlowInstanceSuccessResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.make_task_flow_instance_success_with_options_async(request, runtime)

    def modify_data_correct_exec_sqlwith_options(
        self,
        request: dms_enterprise_20181101_models.ModifyDataCorrectExecSQLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ModifyDataCorrectExecSQLResponse:
        """
        @summary Modifies the SQL script that is submitted by using a data change ticket.
        
        @param request: ModifyDataCorrectExecSQLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDataCorrectExecSQLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.exec_sql):
            query['ExecSQL'] = request.exec_sql
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDataCorrectExecSQL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ModifyDataCorrectExecSQLResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_data_correct_exec_sqlwith_options_async(
        self,
        request: dms_enterprise_20181101_models.ModifyDataCorrectExecSQLRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ModifyDataCorrectExecSQLResponse:
        """
        @summary Modifies the SQL script that is submitted by using a data change ticket.
        
        @param request: ModifyDataCorrectExecSQLRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDataCorrectExecSQLResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.exec_sql):
            query['ExecSQL'] = request.exec_sql
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDataCorrectExecSQL',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ModifyDataCorrectExecSQLResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_data_correct_exec_sql(
        self,
        request: dms_enterprise_20181101_models.ModifyDataCorrectExecSQLRequest,
    ) -> dms_enterprise_20181101_models.ModifyDataCorrectExecSQLResponse:
        """
        @summary Modifies the SQL script that is submitted by using a data change ticket.
        
        @param request: ModifyDataCorrectExecSQLRequest
        @return: ModifyDataCorrectExecSQLResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_data_correct_exec_sqlwith_options(request, runtime)

    async def modify_data_correct_exec_sql_async(
        self,
        request: dms_enterprise_20181101_models.ModifyDataCorrectExecSQLRequest,
    ) -> dms_enterprise_20181101_models.ModifyDataCorrectExecSQLResponse:
        """
        @summary Modifies the SQL script that is submitted by using a data change ticket.
        
        @param request: ModifyDataCorrectExecSQLRequest
        @return: ModifyDataCorrectExecSQLResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_data_correct_exec_sqlwith_options_async(request, runtime)

    def modify_desensitization_strategy_with_options(
        self,
        request: dms_enterprise_20181101_models.ModifyDesensitizationStrategyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ModifyDesensitizationStrategyResponse:
        """
        @summary Modifies the masking rule bound to a specified field.
        
        @param request: ModifyDesensitizationStrategyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDesensitizationStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.is_logic):
            query['IsLogic'] = request.is_logic
        if not UtilClient.is_unset(request.is_reset):
            query['IsReset'] = request.is_reset
        if not UtilClient.is_unset(request.rule_id):
            query['RuleId'] = request.rule_id
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDesensitizationStrategy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ModifyDesensitizationStrategyResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_desensitization_strategy_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ModifyDesensitizationStrategyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ModifyDesensitizationStrategyResponse:
        """
        @summary Modifies the masking rule bound to a specified field.
        
        @param request: ModifyDesensitizationStrategyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyDesensitizationStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.column_name):
            query['ColumnName'] = request.column_name
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.is_default):
            query['IsDefault'] = request.is_default
        if not UtilClient.is_unset(request.is_logic):
            query['IsLogic'] = request.is_logic
        if not UtilClient.is_unset(request.is_reset):
            query['IsReset'] = request.is_reset
        if not UtilClient.is_unset(request.rule_id):
            query['RuleId'] = request.rule_id
        if not UtilClient.is_unset(request.schema_name):
            query['SchemaName'] = request.schema_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyDesensitizationStrategy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ModifyDesensitizationStrategyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_desensitization_strategy(
        self,
        request: dms_enterprise_20181101_models.ModifyDesensitizationStrategyRequest,
    ) -> dms_enterprise_20181101_models.ModifyDesensitizationStrategyResponse:
        """
        @summary Modifies the masking rule bound to a specified field.
        
        @param request: ModifyDesensitizationStrategyRequest
        @return: ModifyDesensitizationStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_desensitization_strategy_with_options(request, runtime)

    async def modify_desensitization_strategy_async(
        self,
        request: dms_enterprise_20181101_models.ModifyDesensitizationStrategyRequest,
    ) -> dms_enterprise_20181101_models.ModifyDesensitizationStrategyResponse:
        """
        @summary Modifies the masking rule bound to a specified field.
        
        @param request: ModifyDesensitizationStrategyRequest
        @return: ModifyDesensitizationStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_desensitization_strategy_with_options_async(request, runtime)

    def modify_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.ModifyInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ModifyInstanceResponse:
        """
        @summary 修改实例信息，同时检查该实例连通性
        
        @param request: ModifyInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_link_name):
            query['DataLinkName'] = request.data_link_name
        if not UtilClient.is_unset(request.database_password):
            query['DatabasePassword'] = request.database_password
        if not UtilClient.is_unset(request.database_user):
            query['DatabaseUser'] = request.database_user
        if not UtilClient.is_unset(request.dba_id):
            query['DbaId'] = request.dba_id
        if not UtilClient.is_unset(request.ddl_online):
            query['DdlOnline'] = request.ddl_online
        if not UtilClient.is_unset(request.ecs_instance_id):
            query['EcsInstanceId'] = request.ecs_instance_id
        if not UtilClient.is_unset(request.ecs_region):
            query['EcsRegion'] = request.ecs_region
        if not UtilClient.is_unset(request.enable_sell_common):
            query['EnableSellCommon'] = request.enable_sell_common
        if not UtilClient.is_unset(request.enable_sell_sitd):
            query['EnableSellSitd'] = request.enable_sell_sitd
        if not UtilClient.is_unset(request.enable_sell_stable):
            query['EnableSellStable'] = request.enable_sell_stable
        if not UtilClient.is_unset(request.enable_sell_trust):
            query['EnableSellTrust'] = request.enable_sell_trust
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.export_timeout):
            query['ExportTimeout'] = request.export_timeout
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.instance_alias):
            query['InstanceAlias'] = request.instance_alias
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_source):
            query['InstanceSource'] = request.instance_source
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.query_timeout):
            query['QueryTimeout'] = request.query_timeout
        if not UtilClient.is_unset(request.safe_rule):
            query['SafeRule'] = request.safe_rule
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.skip_test):
            query['SkipTest'] = request.skip_test
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.use_dsql):
            query['UseDsql'] = request.use_dsql
        if not UtilClient.is_unset(request.use_ssl):
            query['UseSsl'] = request.use_ssl
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ModifyInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def modify_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ModifyInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ModifyInstanceResponse:
        """
        @summary 修改实例信息，同时检查该实例连通性
        
        @param request: ModifyInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ModifyInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_link_name):
            query['DataLinkName'] = request.data_link_name
        if not UtilClient.is_unset(request.database_password):
            query['DatabasePassword'] = request.database_password
        if not UtilClient.is_unset(request.database_user):
            query['DatabaseUser'] = request.database_user
        if not UtilClient.is_unset(request.dba_id):
            query['DbaId'] = request.dba_id
        if not UtilClient.is_unset(request.ddl_online):
            query['DdlOnline'] = request.ddl_online
        if not UtilClient.is_unset(request.ecs_instance_id):
            query['EcsInstanceId'] = request.ecs_instance_id
        if not UtilClient.is_unset(request.ecs_region):
            query['EcsRegion'] = request.ecs_region
        if not UtilClient.is_unset(request.enable_sell_common):
            query['EnableSellCommon'] = request.enable_sell_common
        if not UtilClient.is_unset(request.enable_sell_sitd):
            query['EnableSellSitd'] = request.enable_sell_sitd
        if not UtilClient.is_unset(request.enable_sell_stable):
            query['EnableSellStable'] = request.enable_sell_stable
        if not UtilClient.is_unset(request.enable_sell_trust):
            query['EnableSellTrust'] = request.enable_sell_trust
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.export_timeout):
            query['ExportTimeout'] = request.export_timeout
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.instance_alias):
            query['InstanceAlias'] = request.instance_alias
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_source):
            query['InstanceSource'] = request.instance_source
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.query_timeout):
            query['QueryTimeout'] = request.query_timeout
        if not UtilClient.is_unset(request.safe_rule):
            query['SafeRule'] = request.safe_rule
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.skip_test):
            query['SkipTest'] = request.skip_test
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.use_dsql):
            query['UseDsql'] = request.use_dsql
        if not UtilClient.is_unset(request.use_ssl):
            query['UseSsl'] = request.use_ssl
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ModifyInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ModifyInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def modify_instance(
        self,
        request: dms_enterprise_20181101_models.ModifyInstanceRequest,
    ) -> dms_enterprise_20181101_models.ModifyInstanceResponse:
        """
        @summary 修改实例信息，同时检查该实例连通性
        
        @param request: ModifyInstanceRequest
        @return: ModifyInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.modify_instance_with_options(request, runtime)

    async def modify_instance_async(
        self,
        request: dms_enterprise_20181101_models.ModifyInstanceRequest,
    ) -> dms_enterprise_20181101_models.ModifyInstanceResponse:
        """
        @summary 修改实例信息，同时检查该实例连通性
        
        @param request: ModifyInstanceRequest
        @return: ModifyInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.modify_instance_with_options_async(request, runtime)

    def move_task_flow_to_scenario_with_options(
        self,
        request: dms_enterprise_20181101_models.MoveTaskFlowToScenarioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.MoveTaskFlowToScenarioResponse:
        """
        @summary Migrates a task flow to a specified business scenario.
        
        @param request: MoveTaskFlowToScenarioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MoveTaskFlowToScenarioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.scenario_id):
            query['ScenarioId'] = request.scenario_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MoveTaskFlowToScenario',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.MoveTaskFlowToScenarioResponse(),
            self.call_api(params, req, runtime)
        )

    async def move_task_flow_to_scenario_with_options_async(
        self,
        request: dms_enterprise_20181101_models.MoveTaskFlowToScenarioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.MoveTaskFlowToScenarioResponse:
        """
        @summary Migrates a task flow to a specified business scenario.
        
        @param request: MoveTaskFlowToScenarioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: MoveTaskFlowToScenarioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.scenario_id):
            query['ScenarioId'] = request.scenario_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='MoveTaskFlowToScenario',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.MoveTaskFlowToScenarioResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def move_task_flow_to_scenario(
        self,
        request: dms_enterprise_20181101_models.MoveTaskFlowToScenarioRequest,
    ) -> dms_enterprise_20181101_models.MoveTaskFlowToScenarioResponse:
        """
        @summary Migrates a task flow to a specified business scenario.
        
        @param request: MoveTaskFlowToScenarioRequest
        @return: MoveTaskFlowToScenarioResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.move_task_flow_to_scenario_with_options(request, runtime)

    async def move_task_flow_to_scenario_async(
        self,
        request: dms_enterprise_20181101_models.MoveTaskFlowToScenarioRequest,
    ) -> dms_enterprise_20181101_models.MoveTaskFlowToScenarioResponse:
        """
        @summary Migrates a task flow to a specified business scenario.
        
        @param request: MoveTaskFlowToScenarioRequest
        @return: MoveTaskFlowToScenarioResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.move_task_flow_to_scenario_with_options_async(request, runtime)

    def offline_task_flow_with_options(
        self,
        request: dms_enterprise_20181101_models.OfflineTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.OfflineTaskFlowResponse:
        """
        @summary Unpublishes a published task flow.
        
        @param request: OfflineTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OfflineTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OfflineTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.OfflineTaskFlowResponse(),
            self.call_api(params, req, runtime)
        )

    async def offline_task_flow_with_options_async(
        self,
        request: dms_enterprise_20181101_models.OfflineTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.OfflineTaskFlowResponse:
        """
        @summary Unpublishes a published task flow.
        
        @param request: OfflineTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: OfflineTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='OfflineTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.OfflineTaskFlowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def offline_task_flow(
        self,
        request: dms_enterprise_20181101_models.OfflineTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.OfflineTaskFlowResponse:
        """
        @summary Unpublishes a published task flow.
        
        @param request: OfflineTaskFlowRequest
        @return: OfflineTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.offline_task_flow_with_options(request, runtime)

    async def offline_task_flow_async(
        self,
        request: dms_enterprise_20181101_models.OfflineTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.OfflineTaskFlowResponse:
        """
        @summary Unpublishes a published task flow.
        
        @param request: OfflineTaskFlowRequest
        @return: OfflineTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.offline_task_flow_with_options_async(request, runtime)

    def pause_data_correct_sqljob_with_options(
        self,
        request: dms_enterprise_20181101_models.PauseDataCorrectSQLJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.PauseDataCorrectSQLJobResponse:
        """
        @summary Pauses a SQL task for data change.
        
        @description You can call this operation only for database instances that are managed in Security Collaboration mode.
        
        @param request: PauseDataCorrectSQLJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PauseDataCorrectSQLJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PauseDataCorrectSQLJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.PauseDataCorrectSQLJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def pause_data_correct_sqljob_with_options_async(
        self,
        request: dms_enterprise_20181101_models.PauseDataCorrectSQLJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.PauseDataCorrectSQLJobResponse:
        """
        @summary Pauses a SQL task for data change.
        
        @description You can call this operation only for database instances that are managed in Security Collaboration mode.
        
        @param request: PauseDataCorrectSQLJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PauseDataCorrectSQLJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PauseDataCorrectSQLJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.PauseDataCorrectSQLJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def pause_data_correct_sqljob(
        self,
        request: dms_enterprise_20181101_models.PauseDataCorrectSQLJobRequest,
    ) -> dms_enterprise_20181101_models.PauseDataCorrectSQLJobResponse:
        """
        @summary Pauses a SQL task for data change.
        
        @description You can call this operation only for database instances that are managed in Security Collaboration mode.
        
        @param request: PauseDataCorrectSQLJobRequest
        @return: PauseDataCorrectSQLJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.pause_data_correct_sqljob_with_options(request, runtime)

    async def pause_data_correct_sqljob_async(
        self,
        request: dms_enterprise_20181101_models.PauseDataCorrectSQLJobRequest,
    ) -> dms_enterprise_20181101_models.PauseDataCorrectSQLJobResponse:
        """
        @summary Pauses a SQL task for data change.
        
        @description You can call this operation only for database instances that are managed in Security Collaboration mode.
        
        @param request: PauseDataCorrectSQLJobRequest
        @return: PauseDataCorrectSQLJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.pause_data_correct_sqljob_with_options_async(request, runtime)

    def pause_data_export_job_with_options(
        self,
        request: dms_enterprise_20181101_models.PauseDataExportJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.PauseDataExportJobResponse:
        """
        @summary 终止数据导出任务
        
        @param request: PauseDataExportJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PauseDataExportJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PauseDataExportJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.PauseDataExportJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def pause_data_export_job_with_options_async(
        self,
        request: dms_enterprise_20181101_models.PauseDataExportJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.PauseDataExportJobResponse:
        """
        @summary 终止数据导出任务
        
        @param request: PauseDataExportJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PauseDataExportJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PauseDataExportJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.PauseDataExportJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def pause_data_export_job(
        self,
        request: dms_enterprise_20181101_models.PauseDataExportJobRequest,
    ) -> dms_enterprise_20181101_models.PauseDataExportJobResponse:
        """
        @summary 终止数据导出任务
        
        @param request: PauseDataExportJobRequest
        @return: PauseDataExportJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.pause_data_export_job_with_options(request, runtime)

    async def pause_data_export_job_async(
        self,
        request: dms_enterprise_20181101_models.PauseDataExportJobRequest,
    ) -> dms_enterprise_20181101_models.PauseDataExportJobResponse:
        """
        @summary 终止数据导出任务
        
        @param request: PauseDataExportJobRequest
        @return: PauseDataExportJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.pause_data_export_job_with_options_async(request, runtime)

    def preview_workflow_with_options(
        self,
        request: dms_enterprise_20181101_models.PreviewWorkflowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.PreviewWorkflowResponse:
        """
        @summary 创建工单审批流
        
        @param request: PreviewWorkflowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PreviewWorkflowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PreviewWorkflow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.PreviewWorkflowResponse(),
            self.call_api(params, req, runtime)
        )

    async def preview_workflow_with_options_async(
        self,
        request: dms_enterprise_20181101_models.PreviewWorkflowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.PreviewWorkflowResponse:
        """
        @summary 创建工单审批流
        
        @param request: PreviewWorkflowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PreviewWorkflowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PreviewWorkflow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.PreviewWorkflowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def preview_workflow(
        self,
        request: dms_enterprise_20181101_models.PreviewWorkflowRequest,
    ) -> dms_enterprise_20181101_models.PreviewWorkflowResponse:
        """
        @summary 创建工单审批流
        
        @param request: PreviewWorkflowRequest
        @return: PreviewWorkflowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.preview_workflow_with_options(request, runtime)

    async def preview_workflow_async(
        self,
        request: dms_enterprise_20181101_models.PreviewWorkflowRequest,
    ) -> dms_enterprise_20181101_models.PreviewWorkflowResponse:
        """
        @summary 创建工单审批流
        
        @param request: PreviewWorkflowRequest
        @return: PreviewWorkflowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.preview_workflow_with_options_async(request, runtime)

    def publish_and_deploy_task_flow_with_options(
        self,
        request: dms_enterprise_20181101_models.PublishAndDeployTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.PublishAndDeployTaskFlowResponse:
        """
        @summary Publishes and deploys a task flow.
        
        @param request: PublishAndDeployTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PublishAndDeployTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.version_comments):
            query['VersionComments'] = request.version_comments
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PublishAndDeployTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.PublishAndDeployTaskFlowResponse(),
            self.call_api(params, req, runtime)
        )

    async def publish_and_deploy_task_flow_with_options_async(
        self,
        request: dms_enterprise_20181101_models.PublishAndDeployTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.PublishAndDeployTaskFlowResponse:
        """
        @summary Publishes and deploys a task flow.
        
        @param request: PublishAndDeployTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: PublishAndDeployTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.version_comments):
            query['VersionComments'] = request.version_comments
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PublishAndDeployTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.PublishAndDeployTaskFlowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def publish_and_deploy_task_flow(
        self,
        request: dms_enterprise_20181101_models.PublishAndDeployTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.PublishAndDeployTaskFlowResponse:
        """
        @summary Publishes and deploys a task flow.
        
        @param request: PublishAndDeployTaskFlowRequest
        @return: PublishAndDeployTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.publish_and_deploy_task_flow_with_options(request, runtime)

    async def publish_and_deploy_task_flow_async(
        self,
        request: dms_enterprise_20181101_models.PublishAndDeployTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.PublishAndDeployTaskFlowResponse:
        """
        @summary Publishes and deploys a task flow.
        
        @param request: PublishAndDeployTaskFlowRequest
        @return: PublishAndDeployTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.publish_and_deploy_task_flow_with_options_async(request, runtime)

    def query_data_track_result_download_status_with_options(
        self,
        request: dms_enterprise_20181101_models.QueryDataTrackResultDownloadStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.QueryDataTrackResultDownloadStatusResponse:
        """
        @summary Queries the download and parsing progress of data tracking logs.
        
        @param request: QueryDataTrackResultDownloadStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: QueryDataTrackResultDownloadStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.download_key_id):
            query['DownloadKeyId'] = request.download_key_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='QueryDataTrackResultDownloadStatus',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.QueryDataTrackResultDownloadStatusResponse(),
            self.call_api(params, req, runtime)
        )

    async def query_data_track_result_download_status_with_options_async(
        self,
        request: dms_enterprise_20181101_models.QueryDataTrackResultDownloadStatusRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.QueryDataTrackResultDownloadStatusResponse:
        """
        @summary Queries the download and parsing progress of data tracking logs.
        
        @param request: QueryDataTrackResultDownloadStatusRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: QueryDataTrackResultDownloadStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.download_key_id):
            query['DownloadKeyId'] = request.download_key_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='QueryDataTrackResultDownloadStatus',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.QueryDataTrackResultDownloadStatusResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def query_data_track_result_download_status(
        self,
        request: dms_enterprise_20181101_models.QueryDataTrackResultDownloadStatusRequest,
    ) -> dms_enterprise_20181101_models.QueryDataTrackResultDownloadStatusResponse:
        """
        @summary Queries the download and parsing progress of data tracking logs.
        
        @param request: QueryDataTrackResultDownloadStatusRequest
        @return: QueryDataTrackResultDownloadStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.query_data_track_result_download_status_with_options(request, runtime)

    async def query_data_track_result_download_status_async(
        self,
        request: dms_enterprise_20181101_models.QueryDataTrackResultDownloadStatusRequest,
    ) -> dms_enterprise_20181101_models.QueryDataTrackResultDownloadStatusResponse:
        """
        @summary Queries the download and parsing progress of data tracking logs.
        
        @param request: QueryDataTrackResultDownloadStatusRequest
        @return: QueryDataTrackResultDownloadStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.query_data_track_result_download_status_with_options_async(request, runtime)

    def re_deploy_lh_dag_version_with_options(
        self,
        request: dms_enterprise_20181101_models.ReDeployLhDagVersionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ReDeployLhDagVersionResponse:
        """
        @summary 部署任务流的历史版本
        
        @param request: ReDeployLhDagVersionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReDeployLhDagVersionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_version):
            query['DagVersion'] = request.dag_version
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReDeployLhDagVersion',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ReDeployLhDagVersionResponse(),
            self.call_api(params, req, runtime)
        )

    async def re_deploy_lh_dag_version_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ReDeployLhDagVersionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ReDeployLhDagVersionResponse:
        """
        @summary 部署任务流的历史版本
        
        @param request: ReDeployLhDagVersionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReDeployLhDagVersionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_version):
            query['DagVersion'] = request.dag_version
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReDeployLhDagVersion',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ReDeployLhDagVersionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def re_deploy_lh_dag_version(
        self,
        request: dms_enterprise_20181101_models.ReDeployLhDagVersionRequest,
    ) -> dms_enterprise_20181101_models.ReDeployLhDagVersionResponse:
        """
        @summary 部署任务流的历史版本
        
        @param request: ReDeployLhDagVersionRequest
        @return: ReDeployLhDagVersionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.re_deploy_lh_dag_version_with_options(request, runtime)

    async def re_deploy_lh_dag_version_async(
        self,
        request: dms_enterprise_20181101_models.ReDeployLhDagVersionRequest,
    ) -> dms_enterprise_20181101_models.ReDeployLhDagVersionResponse:
        """
        @summary 部署任务流的历史版本
        
        @param request: ReDeployLhDagVersionRequest
        @return: ReDeployLhDagVersionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.re_deploy_lh_dag_version_with_options_async(request, runtime)

    def re_run_task_flow_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.ReRunTaskFlowInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ReRunTaskFlowInstanceResponse:
        """
        @summary Reruns a task flow instance.
        
        @param request: ReRunTaskFlowInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReRunTaskFlowInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_instance_id):
            query['DagInstanceId'] = request.dag_instance_id
        if not UtilClient.is_unset(request.dag_version):
            query['DagVersion'] = request.dag_version
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReRunTaskFlowInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ReRunTaskFlowInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def re_run_task_flow_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ReRunTaskFlowInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ReRunTaskFlowInstanceResponse:
        """
        @summary Reruns a task flow instance.
        
        @param request: ReRunTaskFlowInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ReRunTaskFlowInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_instance_id):
            query['DagInstanceId'] = request.dag_instance_id
        if not UtilClient.is_unset(request.dag_version):
            query['DagVersion'] = request.dag_version
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ReRunTaskFlowInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ReRunTaskFlowInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def re_run_task_flow_instance(
        self,
        request: dms_enterprise_20181101_models.ReRunTaskFlowInstanceRequest,
    ) -> dms_enterprise_20181101_models.ReRunTaskFlowInstanceResponse:
        """
        @summary Reruns a task flow instance.
        
        @param request: ReRunTaskFlowInstanceRequest
        @return: ReRunTaskFlowInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.re_run_task_flow_instance_with_options(request, runtime)

    async def re_run_task_flow_instance_async(
        self,
        request: dms_enterprise_20181101_models.ReRunTaskFlowInstanceRequest,
    ) -> dms_enterprise_20181101_models.ReRunTaskFlowInstanceResponse:
        """
        @summary Reruns a task flow instance.
        
        @param request: ReRunTaskFlowInstanceRequest
        @return: ReRunTaskFlowInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.re_run_task_flow_instance_with_options_async(request, runtime)

    def redeploy_dify_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.RedeployDifyInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RedeployDifyInstanceResponse:
        """
        @summary 用于重新部署DIFY实例。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: RedeployDifyInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RedeployDifyInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RedeployDifyInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RedeployDifyInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def redeploy_dify_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.RedeployDifyInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RedeployDifyInstanceResponse:
        """
        @summary 用于重新部署DIFY实例。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: RedeployDifyInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RedeployDifyInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['ClientToken'] = request.client_token
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.dry_run):
            query['DryRun'] = request.dry_run
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RedeployDifyInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RedeployDifyInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def redeploy_dify_instance(
        self,
        request: dms_enterprise_20181101_models.RedeployDifyInstanceRequest,
    ) -> dms_enterprise_20181101_models.RedeployDifyInstanceResponse:
        """
        @summary 用于重新部署DIFY实例。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: RedeployDifyInstanceRequest
        @return: RedeployDifyInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.redeploy_dify_instance_with_options(request, runtime)

    async def redeploy_dify_instance_async(
        self,
        request: dms_enterprise_20181101_models.RedeployDifyInstanceRequest,
    ) -> dms_enterprise_20181101_models.RedeployDifyInstanceResponse:
        """
        @summary 用于重新部署DIFY实例。
        
        @description ## 请求说明
        - `workspaceOption` 参数指示是否新建工作空间，默认使用已有工作空间。
        - 如果选择新建工作空间 (`CreateNewInstance`)，则必须提供 `workspaceName` 和 `workspaceDescription`。
        - `vpcId`, `VSwitchID`, `zoneId`, `regionCode`, `ResourceQuota`, `Replicas`, `storageType`, `dbInstanceClass`, `dbEngineVersion`, `kvstoreEngineVersion` 是必填项。
        - 当 `storageType` 为 `oss` 时，需要指定 `ossBucketResourceId` 和 `ossPath`。
        - 如果需要新建数据库实例，则必须提供 `instanceAccount` 和 `instancePassword`。
        - 预付费模式下，`PayPeriodType` 和 `PayPeriod` 必须填写。
        - 可以通过设置 `dryRun` 为 `true` 来执行预检查而不实际创建实例。
        
        @param request: RedeployDifyInstanceRequest
        @return: RedeployDifyInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.redeploy_dify_instance_with_options_async(request, runtime)

    def refund_pay_as_you_go_order_with_options(
        self,
        request: dms_enterprise_20181101_models.RefundPayAsYouGoOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RefundPayAsYouGoOrderResponse:
        """
        @summary Unsubscribes from a pay-as-you-go Data Management (DMS) resource.
        
        @param request: RefundPayAsYouGoOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RefundPayAsYouGoOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RefundPayAsYouGoOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RefundPayAsYouGoOrderResponse(),
            self.call_api(params, req, runtime)
        )

    async def refund_pay_as_you_go_order_with_options_async(
        self,
        request: dms_enterprise_20181101_models.RefundPayAsYouGoOrderRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RefundPayAsYouGoOrderResponse:
        """
        @summary Unsubscribes from a pay-as-you-go Data Management (DMS) resource.
        
        @param request: RefundPayAsYouGoOrderRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RefundPayAsYouGoOrderResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RefundPayAsYouGoOrder',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RefundPayAsYouGoOrderResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def refund_pay_as_you_go_order(
        self,
        request: dms_enterprise_20181101_models.RefundPayAsYouGoOrderRequest,
    ) -> dms_enterprise_20181101_models.RefundPayAsYouGoOrderResponse:
        """
        @summary Unsubscribes from a pay-as-you-go Data Management (DMS) resource.
        
        @param request: RefundPayAsYouGoOrderRequest
        @return: RefundPayAsYouGoOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.refund_pay_as_you_go_order_with_options(request, runtime)

    async def refund_pay_as_you_go_order_async(
        self,
        request: dms_enterprise_20181101_models.RefundPayAsYouGoOrderRequest,
    ) -> dms_enterprise_20181101_models.RefundPayAsYouGoOrderResponse:
        """
        @summary Unsubscribes from a pay-as-you-go Data Management (DMS) resource.
        
        @param request: RefundPayAsYouGoOrderRequest
        @return: RefundPayAsYouGoOrderResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.refund_pay_as_you_go_order_with_options_async(request, runtime)

    def register_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.RegisterInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RegisterInstanceResponse:
        """
        @summary Registers a database instance in Data Management (DMS).
        
        @description Prerequisites: You are a DMS administrator or a database administrator (DBA). You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to query your user role from the RoleIdList parameter that is returned.
        
        @param request: RegisterInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RegisterInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_link_name):
            query['DataLinkName'] = request.data_link_name
        if not UtilClient.is_unset(request.database_password):
            query['DatabasePassword'] = request.database_password
        if not UtilClient.is_unset(request.database_user):
            query['DatabaseUser'] = request.database_user
        if not UtilClient.is_unset(request.dba_uid):
            query['DbaUid'] = request.dba_uid
        if not UtilClient.is_unset(request.dba_uid_by_string):
            query['DbaUidByString'] = request.dba_uid_by_string
        if not UtilClient.is_unset(request.ddl_online):
            query['DdlOnline'] = request.ddl_online
        if not UtilClient.is_unset(request.ecs_instance_id):
            query['EcsInstanceId'] = request.ecs_instance_id
        if not UtilClient.is_unset(request.ecs_region):
            query['EcsRegion'] = request.ecs_region
        if not UtilClient.is_unset(request.enable_sell_sitd):
            query['EnableSellSitd'] = request.enable_sell_sitd
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.export_timeout):
            query['ExportTimeout'] = request.export_timeout
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.instance_alias):
            query['InstanceAlias'] = request.instance_alias
        if not UtilClient.is_unset(request.instance_source):
            query['InstanceSource'] = request.instance_source
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.query_timeout):
            query['QueryTimeout'] = request.query_timeout
        if not UtilClient.is_unset(request.resource_group):
            query['ResourceGroup'] = request.resource_group
        if not UtilClient.is_unset(request.safe_rule):
            query['SafeRule'] = request.safe_rule
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.skip_test):
            query['SkipTest'] = request.skip_test
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.use_dsql):
            query['UseDsql'] = request.use_dsql
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RegisterInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RegisterInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def register_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.RegisterInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RegisterInstanceResponse:
        """
        @summary Registers a database instance in Data Management (DMS).
        
        @description Prerequisites: You are a DMS administrator or a database administrator (DBA). You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to query your user role from the RoleIdList parameter that is returned.
        
        @param request: RegisterInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RegisterInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_link_name):
            query['DataLinkName'] = request.data_link_name
        if not UtilClient.is_unset(request.database_password):
            query['DatabasePassword'] = request.database_password
        if not UtilClient.is_unset(request.database_user):
            query['DatabaseUser'] = request.database_user
        if not UtilClient.is_unset(request.dba_uid):
            query['DbaUid'] = request.dba_uid
        if not UtilClient.is_unset(request.dba_uid_by_string):
            query['DbaUidByString'] = request.dba_uid_by_string
        if not UtilClient.is_unset(request.ddl_online):
            query['DdlOnline'] = request.ddl_online
        if not UtilClient.is_unset(request.ecs_instance_id):
            query['EcsInstanceId'] = request.ecs_instance_id
        if not UtilClient.is_unset(request.ecs_region):
            query['EcsRegion'] = request.ecs_region
        if not UtilClient.is_unset(request.enable_sell_sitd):
            query['EnableSellSitd'] = request.enable_sell_sitd
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.export_timeout):
            query['ExportTimeout'] = request.export_timeout
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.instance_alias):
            query['InstanceAlias'] = request.instance_alias
        if not UtilClient.is_unset(request.instance_source):
            query['InstanceSource'] = request.instance_source
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.network_type):
            query['NetworkType'] = request.network_type
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.query_timeout):
            query['QueryTimeout'] = request.query_timeout
        if not UtilClient.is_unset(request.resource_group):
            query['ResourceGroup'] = request.resource_group
        if not UtilClient.is_unset(request.safe_rule):
            query['SafeRule'] = request.safe_rule
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.skip_test):
            query['SkipTest'] = request.skip_test
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.use_dsql):
            query['UseDsql'] = request.use_dsql
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RegisterInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RegisterInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def register_instance(
        self,
        request: dms_enterprise_20181101_models.RegisterInstanceRequest,
    ) -> dms_enterprise_20181101_models.RegisterInstanceResponse:
        """
        @summary Registers a database instance in Data Management (DMS).
        
        @description Prerequisites: You are a DMS administrator or a database administrator (DBA). You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to query your user role from the RoleIdList parameter that is returned.
        
        @param request: RegisterInstanceRequest
        @return: RegisterInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.register_instance_with_options(request, runtime)

    async def register_instance_async(
        self,
        request: dms_enterprise_20181101_models.RegisterInstanceRequest,
    ) -> dms_enterprise_20181101_models.RegisterInstanceResponse:
        """
        @summary Registers a database instance in Data Management (DMS).
        
        @description Prerequisites: You are a DMS administrator or a database administrator (DBA). You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to query your user role from the RoleIdList parameter that is returned.
        
        @param request: RegisterInstanceRequest
        @return: RegisterInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.register_instance_with_options_async(request, runtime)

    def register_user_with_options(
        self,
        request: dms_enterprise_20181101_models.RegisterUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RegisterUserResponse:
        """
        @summary Registers a user for your enterprise.
        
        @description If you are an *administrator** in Data Management (DMS), you can call this operation to register a user for your enterprise. To view users that are assigned the administrator role, perform the following steps: Log on to the DMS console. In the top navigation bar, click O&M. In the left-side navigation pane, click User.
        
        @param request: RegisterUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RegisterUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.mobile):
            query['Mobile'] = request.mobile
        if not UtilClient.is_unset(request.role_names):
            query['RoleNames'] = request.role_names
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.uid):
            query['Uid'] = request.uid
        if not UtilClient.is_unset(request.user_nick):
            query['UserNick'] = request.user_nick
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RegisterUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RegisterUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def register_user_with_options_async(
        self,
        request: dms_enterprise_20181101_models.RegisterUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RegisterUserResponse:
        """
        @summary Registers a user for your enterprise.
        
        @description If you are an *administrator** in Data Management (DMS), you can call this operation to register a user for your enterprise. To view users that are assigned the administrator role, perform the following steps: Log on to the DMS console. In the top navigation bar, click O&M. In the left-side navigation pane, click User.
        
        @param request: RegisterUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RegisterUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.mobile):
            query['Mobile'] = request.mobile
        if not UtilClient.is_unset(request.role_names):
            query['RoleNames'] = request.role_names
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.uid):
            query['Uid'] = request.uid
        if not UtilClient.is_unset(request.user_nick):
            query['UserNick'] = request.user_nick
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RegisterUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RegisterUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def register_user(
        self,
        request: dms_enterprise_20181101_models.RegisterUserRequest,
    ) -> dms_enterprise_20181101_models.RegisterUserResponse:
        """
        @summary Registers a user for your enterprise.
        
        @description If you are an *administrator** in Data Management (DMS), you can call this operation to register a user for your enterprise. To view users that are assigned the administrator role, perform the following steps: Log on to the DMS console. In the top navigation bar, click O&M. In the left-side navigation pane, click User.
        
        @param request: RegisterUserRequest
        @return: RegisterUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.register_user_with_options(request, runtime)

    async def register_user_async(
        self,
        request: dms_enterprise_20181101_models.RegisterUserRequest,
    ) -> dms_enterprise_20181101_models.RegisterUserResponse:
        """
        @summary Registers a user for your enterprise.
        
        @description If you are an *administrator** in Data Management (DMS), you can call this operation to register a user for your enterprise. To view users that are assigned the administrator role, perform the following steps: Log on to the DMS console. In the top navigation bar, click O&M. In the left-side navigation pane, click User.
        
        @param request: RegisterUserRequest
        @return: RegisterUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.register_user_with_options_async(request, runtime)

    def remove_data_export_job_with_options(
        self,
        request: dms_enterprise_20181101_models.RemoveDataExportJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RemoveDataExportJobResponse:
        """
        @summary 删除数据导出任务
        
        @param request: RemoveDataExportJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveDataExportJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveDataExportJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RemoveDataExportJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def remove_data_export_job_with_options_async(
        self,
        request: dms_enterprise_20181101_models.RemoveDataExportJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RemoveDataExportJobResponse:
        """
        @summary 删除数据导出任务
        
        @param request: RemoveDataExportJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveDataExportJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveDataExportJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RemoveDataExportJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def remove_data_export_job(
        self,
        request: dms_enterprise_20181101_models.RemoveDataExportJobRequest,
    ) -> dms_enterprise_20181101_models.RemoveDataExportJobResponse:
        """
        @summary 删除数据导出任务
        
        @param request: RemoveDataExportJobRequest
        @return: RemoveDataExportJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.remove_data_export_job_with_options(request, runtime)

    async def remove_data_export_job_async(
        self,
        request: dms_enterprise_20181101_models.RemoveDataExportJobRequest,
    ) -> dms_enterprise_20181101_models.RemoveDataExportJobResponse:
        """
        @summary 删除数据导出任务
        
        @param request: RemoveDataExportJobRequest
        @return: RemoveDataExportJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.remove_data_export_job_with_options_async(request, runtime)

    def remove_table_from_category_with_options(
        self,
        request: dms_enterprise_20181101_models.RemoveTableFromCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RemoveTableFromCategoryResponse:
        """
        @summary 从资产类目移除表
        
        @param request: RemoveTableFromCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveTableFromCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category_id):
            query['CategoryId'] = request.category_id
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.table_schema_name):
            query['TableSchemaName'] = request.table_schema_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveTableFromCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RemoveTableFromCategoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def remove_table_from_category_with_options_async(
        self,
        request: dms_enterprise_20181101_models.RemoveTableFromCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RemoveTableFromCategoryResponse:
        """
        @summary 从资产类目移除表
        
        @param request: RemoveTableFromCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RemoveTableFromCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category_id):
            query['CategoryId'] = request.category_id
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.table_schema_name):
            query['TableSchemaName'] = request.table_schema_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RemoveTableFromCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RemoveTableFromCategoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def remove_table_from_category(
        self,
        request: dms_enterprise_20181101_models.RemoveTableFromCategoryRequest,
    ) -> dms_enterprise_20181101_models.RemoveTableFromCategoryResponse:
        """
        @summary 从资产类目移除表
        
        @param request: RemoveTableFromCategoryRequest
        @return: RemoveTableFromCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.remove_table_from_category_with_options(request, runtime)

    async def remove_table_from_category_async(
        self,
        request: dms_enterprise_20181101_models.RemoveTableFromCategoryRequest,
    ) -> dms_enterprise_20181101_models.RemoveTableFromCategoryResponse:
        """
        @summary 从资产类目移除表
        
        @param request: RemoveTableFromCategoryRequest
        @return: RemoveTableFromCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.remove_table_from_category_with_options_async(request, runtime)

    def restart_data_correct_sqljob_with_options(
        self,
        request: dms_enterprise_20181101_models.RestartDataCorrectSQLJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RestartDataCorrectSQLJobResponse:
        """
        @summary Reruns a failed SQL task for data change.
        
        @param request: RestartDataCorrectSQLJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RestartDataCorrectSQLJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RestartDataCorrectSQLJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RestartDataCorrectSQLJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def restart_data_correct_sqljob_with_options_async(
        self,
        request: dms_enterprise_20181101_models.RestartDataCorrectSQLJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RestartDataCorrectSQLJobResponse:
        """
        @summary Reruns a failed SQL task for data change.
        
        @param request: RestartDataCorrectSQLJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RestartDataCorrectSQLJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.type):
            query['Type'] = request.type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RestartDataCorrectSQLJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RestartDataCorrectSQLJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def restart_data_correct_sqljob(
        self,
        request: dms_enterprise_20181101_models.RestartDataCorrectSQLJobRequest,
    ) -> dms_enterprise_20181101_models.RestartDataCorrectSQLJobResponse:
        """
        @summary Reruns a failed SQL task for data change.
        
        @param request: RestartDataCorrectSQLJobRequest
        @return: RestartDataCorrectSQLJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.restart_data_correct_sqljob_with_options(request, runtime)

    async def restart_data_correct_sqljob_async(
        self,
        request: dms_enterprise_20181101_models.RestartDataCorrectSQLJobRequest,
    ) -> dms_enterprise_20181101_models.RestartDataCorrectSQLJobResponse:
        """
        @summary Reruns a failed SQL task for data change.
        
        @param request: RestartDataCorrectSQLJobRequest
        @return: RestartDataCorrectSQLJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.restart_data_correct_sqljob_with_options_async(request, runtime)

    def restart_data_export_job_with_options(
        self,
        request: dms_enterprise_20181101_models.RestartDataExportJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RestartDataExportJobResponse:
        """
        @summary 重启数据导出任务
        
        @param request: RestartDataExportJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RestartDataExportJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RestartDataExportJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RestartDataExportJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def restart_data_export_job_with_options_async(
        self,
        request: dms_enterprise_20181101_models.RestartDataExportJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RestartDataExportJobResponse:
        """
        @summary 重启数据导出任务
        
        @param request: RestartDataExportJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RestartDataExportJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RestartDataExportJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RestartDataExportJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def restart_data_export_job(
        self,
        request: dms_enterprise_20181101_models.RestartDataExportJobRequest,
    ) -> dms_enterprise_20181101_models.RestartDataExportJobResponse:
        """
        @summary 重启数据导出任务
        
        @param request: RestartDataExportJobRequest
        @return: RestartDataExportJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.restart_data_export_job_with_options(request, runtime)

    async def restart_data_export_job_async(
        self,
        request: dms_enterprise_20181101_models.RestartDataExportJobRequest,
    ) -> dms_enterprise_20181101_models.RestartDataExportJobResponse:
        """
        @summary 重启数据导出任务
        
        @param request: RestartDataExportJobRequest
        @return: RestartDataExportJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.restart_data_export_job_with_options_async(request, runtime)

    def resume_task_flow_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.ResumeTaskFlowInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ResumeTaskFlowInstanceResponse:
        """
        @summary Resumes a suspended task flow.
        
        @description You can call this operation only for task flows that are suspended.
        
        @param request: ResumeTaskFlowInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResumeTaskFlowInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_instance_id):
            query['DagInstanceId'] = request.dag_instance_id
        if not UtilClient.is_unset(request.dag_version):
            query['DagVersion'] = request.dag_version
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResumeTaskFlowInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ResumeTaskFlowInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def resume_task_flow_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.ResumeTaskFlowInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.ResumeTaskFlowInstanceResponse:
        """
        @summary Resumes a suspended task flow.
        
        @description You can call this operation only for task flows that are suspended.
        
        @param request: ResumeTaskFlowInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResumeTaskFlowInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_instance_id):
            query['DagInstanceId'] = request.dag_instance_id
        if not UtilClient.is_unset(request.dag_version):
            query['DagVersion'] = request.dag_version
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResumeTaskFlowInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.ResumeTaskFlowInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def resume_task_flow_instance(
        self,
        request: dms_enterprise_20181101_models.ResumeTaskFlowInstanceRequest,
    ) -> dms_enterprise_20181101_models.ResumeTaskFlowInstanceResponse:
        """
        @summary Resumes a suspended task flow.
        
        @description You can call this operation only for task flows that are suspended.
        
        @param request: ResumeTaskFlowInstanceRequest
        @return: ResumeTaskFlowInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.resume_task_flow_instance_with_options(request, runtime)

    async def resume_task_flow_instance_async(
        self,
        request: dms_enterprise_20181101_models.ResumeTaskFlowInstanceRequest,
    ) -> dms_enterprise_20181101_models.ResumeTaskFlowInstanceResponse:
        """
        @summary Resumes a suspended task flow.
        
        @description You can call this operation only for task flows that are suspended.
        
        @param request: ResumeTaskFlowInstanceRequest
        @return: ResumeTaskFlowInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.resume_task_flow_instance_with_options_async(request, runtime)

    def retry_data_correct_pre_check_with_options(
        self,
        request: dms_enterprise_20181101_models.RetryDataCorrectPreCheckRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RetryDataCorrectPreCheckResponse:
        """
        @summary Reruns the precheck for a data change ticket.
        
        @param request: RetryDataCorrectPreCheckRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RetryDataCorrectPreCheckResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RetryDataCorrectPreCheck',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RetryDataCorrectPreCheckResponse(),
            self.call_api(params, req, runtime)
        )

    async def retry_data_correct_pre_check_with_options_async(
        self,
        request: dms_enterprise_20181101_models.RetryDataCorrectPreCheckRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RetryDataCorrectPreCheckResponse:
        """
        @summary Reruns the precheck for a data change ticket.
        
        @param request: RetryDataCorrectPreCheckRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RetryDataCorrectPreCheckResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RetryDataCorrectPreCheck',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RetryDataCorrectPreCheckResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def retry_data_correct_pre_check(
        self,
        request: dms_enterprise_20181101_models.RetryDataCorrectPreCheckRequest,
    ) -> dms_enterprise_20181101_models.RetryDataCorrectPreCheckResponse:
        """
        @summary Reruns the precheck for a data change ticket.
        
        @param request: RetryDataCorrectPreCheckRequest
        @return: RetryDataCorrectPreCheckResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.retry_data_correct_pre_check_with_options(request, runtime)

    async def retry_data_correct_pre_check_async(
        self,
        request: dms_enterprise_20181101_models.RetryDataCorrectPreCheckRequest,
    ) -> dms_enterprise_20181101_models.RetryDataCorrectPreCheckResponse:
        """
        @summary Reruns the precheck for a data change ticket.
        
        @param request: RetryDataCorrectPreCheckRequest
        @return: RetryDataCorrectPreCheckResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.retry_data_correct_pre_check_with_options_async(request, runtime)

    def revoke_template_authority_with_options(
        self,
        request: dms_enterprise_20181101_models.RevokeTemplateAuthorityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RevokeTemplateAuthorityResponse:
        """
        @summary Revokes permissions on resources from Data Management (DMS) users by using a permission template.
        
        @description You must be a database administrator (DBA) or a DMS administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: RevokeTemplateAuthorityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RevokeTemplateAuthorityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_ids):
            query['UserIds'] = request.user_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RevokeTemplateAuthority',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RevokeTemplateAuthorityResponse(),
            self.call_api(params, req, runtime)
        )

    async def revoke_template_authority_with_options_async(
        self,
        request: dms_enterprise_20181101_models.RevokeTemplateAuthorityRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RevokeTemplateAuthorityResponse:
        """
        @summary Revokes permissions on resources from Data Management (DMS) users by using a permission template.
        
        @description You must be a database administrator (DBA) or a DMS administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: RevokeTemplateAuthorityRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RevokeTemplateAuthorityResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_ids):
            query['UserIds'] = request.user_ids
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RevokeTemplateAuthority',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RevokeTemplateAuthorityResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def revoke_template_authority(
        self,
        request: dms_enterprise_20181101_models.RevokeTemplateAuthorityRequest,
    ) -> dms_enterprise_20181101_models.RevokeTemplateAuthorityResponse:
        """
        @summary Revokes permissions on resources from Data Management (DMS) users by using a permission template.
        
        @description You must be a database administrator (DBA) or a DMS administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: RevokeTemplateAuthorityRequest
        @return: RevokeTemplateAuthorityResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.revoke_template_authority_with_options(request, runtime)

    async def revoke_template_authority_async(
        self,
        request: dms_enterprise_20181101_models.RevokeTemplateAuthorityRequest,
    ) -> dms_enterprise_20181101_models.RevokeTemplateAuthorityResponse:
        """
        @summary Revokes permissions on resources from Data Management (DMS) users by using a permission template.
        
        @description You must be a database administrator (DBA) or a DMS administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: RevokeTemplateAuthorityRequest
        @return: RevokeTemplateAuthorityResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.revoke_template_authority_with_options_async(request, runtime)

    def revoke_user_permission_with_options(
        self,
        request: dms_enterprise_20181101_models.RevokeUserPermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RevokeUserPermissionResponse:
        """
        @summary Revokes the permissions on instances, databases, and tables from a user.
        
        @param request: RevokeUserPermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RevokeUserPermissionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.ds_type):
            query['DsType'] = request.ds_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.perm_types):
            query['PermTypes'] = request.perm_types
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_access_id):
            query['UserAccessId'] = request.user_access_id
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RevokeUserPermission',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RevokeUserPermissionResponse(),
            self.call_api(params, req, runtime)
        )

    async def revoke_user_permission_with_options_async(
        self,
        request: dms_enterprise_20181101_models.RevokeUserPermissionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.RevokeUserPermissionResponse:
        """
        @summary Revokes the permissions on instances, databases, and tables from a user.
        
        @param request: RevokeUserPermissionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: RevokeUserPermissionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.ds_type):
            query['DsType'] = request.ds_type
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.perm_types):
            query['PermTypes'] = request.perm_types
        if not UtilClient.is_unset(request.table_id):
            query['TableId'] = request.table_id
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.user_access_id):
            query['UserAccessId'] = request.user_access_id
        if not UtilClient.is_unset(request.user_id):
            query['UserId'] = request.user_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RevokeUserPermission',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.RevokeUserPermissionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def revoke_user_permission(
        self,
        request: dms_enterprise_20181101_models.RevokeUserPermissionRequest,
    ) -> dms_enterprise_20181101_models.RevokeUserPermissionResponse:
        """
        @summary Revokes the permissions on instances, databases, and tables from a user.
        
        @param request: RevokeUserPermissionRequest
        @return: RevokeUserPermissionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.revoke_user_permission_with_options(request, runtime)

    async def revoke_user_permission_async(
        self,
        request: dms_enterprise_20181101_models.RevokeUserPermissionRequest,
    ) -> dms_enterprise_20181101_models.RevokeUserPermissionResponse:
        """
        @summary Revokes the permissions on instances, databases, and tables from a user.
        
        @param request: RevokeUserPermissionRequest
        @return: RevokeUserPermissionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.revoke_user_permission_with_options_async(request, runtime)

    def search_data_track_result_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.SearchDataTrackResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SearchDataTrackResultResponse:
        """
        @summary Searches for the parsing result of a data tracking task.
        
        @param tmp_req: SearchDataTrackResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SearchDataTrackResultResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.SearchDataTrackResultShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.column_filter):
            request.column_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.column_filter, 'ColumnFilter', 'json')
        if not UtilClient.is_unset(tmp_req.filter_table_list):
            request.filter_table_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.filter_table_list, 'FilterTableList', 'json')
        if not UtilClient.is_unset(tmp_req.filter_type_list):
            request.filter_type_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.filter_type_list, 'FilterTypeList', 'json')
        query = {}
        if not UtilClient.is_unset(request.column_filter_shrink):
            query['ColumnFilter'] = request.column_filter_shrink
        if not UtilClient.is_unset(request.filter_end_time):
            query['FilterEndTime'] = request.filter_end_time
        if not UtilClient.is_unset(request.filter_start_time):
            query['FilterStartTime'] = request.filter_start_time
        if not UtilClient.is_unset(request.filter_table_list_shrink):
            query['FilterTableList'] = request.filter_table_list_shrink
        if not UtilClient.is_unset(request.filter_type_list_shrink):
            query['FilterTypeList'] = request.filter_type_list_shrink
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SearchDataTrackResult',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SearchDataTrackResultResponse(),
            self.call_api(params, req, runtime)
        )

    async def search_data_track_result_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.SearchDataTrackResultRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SearchDataTrackResultResponse:
        """
        @summary Searches for the parsing result of a data tracking task.
        
        @param tmp_req: SearchDataTrackResultRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SearchDataTrackResultResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.SearchDataTrackResultShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.column_filter):
            request.column_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.column_filter, 'ColumnFilter', 'json')
        if not UtilClient.is_unset(tmp_req.filter_table_list):
            request.filter_table_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.filter_table_list, 'FilterTableList', 'json')
        if not UtilClient.is_unset(tmp_req.filter_type_list):
            request.filter_type_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.filter_type_list, 'FilterTypeList', 'json')
        query = {}
        if not UtilClient.is_unset(request.column_filter_shrink):
            query['ColumnFilter'] = request.column_filter_shrink
        if not UtilClient.is_unset(request.filter_end_time):
            query['FilterEndTime'] = request.filter_end_time
        if not UtilClient.is_unset(request.filter_start_time):
            query['FilterStartTime'] = request.filter_start_time
        if not UtilClient.is_unset(request.filter_table_list_shrink):
            query['FilterTableList'] = request.filter_table_list_shrink
        if not UtilClient.is_unset(request.filter_type_list_shrink):
            query['FilterTypeList'] = request.filter_type_list_shrink
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SearchDataTrackResult',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SearchDataTrackResultResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def search_data_track_result(
        self,
        request: dms_enterprise_20181101_models.SearchDataTrackResultRequest,
    ) -> dms_enterprise_20181101_models.SearchDataTrackResultResponse:
        """
        @summary Searches for the parsing result of a data tracking task.
        
        @param request: SearchDataTrackResultRequest
        @return: SearchDataTrackResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.search_data_track_result_with_options(request, runtime)

    async def search_data_track_result_async(
        self,
        request: dms_enterprise_20181101_models.SearchDataTrackResultRequest,
    ) -> dms_enterprise_20181101_models.SearchDataTrackResultResponse:
        """
        @summary Searches for the parsing result of a data tracking task.
        
        @param request: SearchDataTrackResultRequest
        @return: SearchDataTrackResultResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.search_data_track_result_with_options_async(request, runtime)

    def search_database_with_options(
        self,
        request: dms_enterprise_20181101_models.SearchDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SearchDatabaseResponse:
        """
        @summary Queries the details of the databases.
        
        @param request: SearchDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SearchDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.search_range):
            query['SearchRange'] = request.search_range
        if not UtilClient.is_unset(request.search_target):
            query['SearchTarget'] = request.search_target
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SearchDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SearchDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def search_database_with_options_async(
        self,
        request: dms_enterprise_20181101_models.SearchDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SearchDatabaseResponse:
        """
        @summary Queries the details of the databases.
        
        @param request: SearchDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SearchDatabaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.search_range):
            query['SearchRange'] = request.search_range
        if not UtilClient.is_unset(request.search_target):
            query['SearchTarget'] = request.search_target
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SearchDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SearchDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def search_database(
        self,
        request: dms_enterprise_20181101_models.SearchDatabaseRequest,
    ) -> dms_enterprise_20181101_models.SearchDatabaseResponse:
        """
        @summary Queries the details of the databases.
        
        @param request: SearchDatabaseRequest
        @return: SearchDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.search_database_with_options(request, runtime)

    async def search_database_async(
        self,
        request: dms_enterprise_20181101_models.SearchDatabaseRequest,
    ) -> dms_enterprise_20181101_models.SearchDatabaseResponse:
        """
        @summary Queries the details of the databases.
        
        @param request: SearchDatabaseRequest
        @return: SearchDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.search_database_with_options_async(request, runtime)

    def search_table_with_options(
        self,
        request: dms_enterprise_20181101_models.SearchTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SearchTableResponse:
        """
        @summary Queries detailed information about tables.
        
        @description You can call this operation only for database instances that are managed in Security Collaboration mode.
        
        @param request: SearchTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SearchTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.return_guid):
            query['ReturnGuid'] = request.return_guid
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.search_range):
            query['SearchRange'] = request.search_range
        if not UtilClient.is_unset(request.search_target):
            query['SearchTarget'] = request.search_target
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SearchTable',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SearchTableResponse(),
            self.call_api(params, req, runtime)
        )

    async def search_table_with_options_async(
        self,
        request: dms_enterprise_20181101_models.SearchTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SearchTableResponse:
        """
        @summary Queries detailed information about tables.
        
        @description You can call this operation only for database instances that are managed in Security Collaboration mode.
        
        @param request: SearchTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SearchTableResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_type):
            query['DbType'] = request.db_type
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.return_guid):
            query['ReturnGuid'] = request.return_guid
        if not UtilClient.is_unset(request.search_key):
            query['SearchKey'] = request.search_key
        if not UtilClient.is_unset(request.search_range):
            query['SearchRange'] = request.search_range
        if not UtilClient.is_unset(request.search_target):
            query['SearchTarget'] = request.search_target
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SearchTable',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SearchTableResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def search_table(
        self,
        request: dms_enterprise_20181101_models.SearchTableRequest,
    ) -> dms_enterprise_20181101_models.SearchTableResponse:
        """
        @summary Queries detailed information about tables.
        
        @description You can call this operation only for database instances that are managed in Security Collaboration mode.
        
        @param request: SearchTableRequest
        @return: SearchTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.search_table_with_options(request, runtime)

    async def search_table_async(
        self,
        request: dms_enterprise_20181101_models.SearchTableRequest,
    ) -> dms_enterprise_20181101_models.SearchTableResponse:
        """
        @summary Queries detailed information about tables.
        
        @description You can call this operation only for database instances that are managed in Security Collaboration mode.
        
        @param request: SearchTableRequest
        @return: SearchTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.search_table_with_options_async(request, runtime)

    def set_owners_with_options(
        self,
        request: dms_enterprise_20181101_models.SetOwnersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SetOwnersResponse:
        """
        @summary Configures the owner of an instance, a database, or a table.
        
        @param request: SetOwnersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetOwnersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_ids):
            query['OwnerIds'] = request.owner_ids
        if not UtilClient.is_unset(request.owner_type):
            query['OwnerType'] = request.owner_type
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetOwners',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SetOwnersResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_owners_with_options_async(
        self,
        request: dms_enterprise_20181101_models.SetOwnersRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SetOwnersResponse:
        """
        @summary Configures the owner of an instance, a database, or a table.
        
        @param request: SetOwnersRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetOwnersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.owner_ids):
            query['OwnerIds'] = request.owner_ids
        if not UtilClient.is_unset(request.owner_type):
            query['OwnerType'] = request.owner_type
        if not UtilClient.is_unset(request.resource_id):
            query['ResourceId'] = request.resource_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetOwners',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SetOwnersResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_owners(
        self,
        request: dms_enterprise_20181101_models.SetOwnersRequest,
    ) -> dms_enterprise_20181101_models.SetOwnersResponse:
        """
        @summary Configures the owner of an instance, a database, or a table.
        
        @param request: SetOwnersRequest
        @return: SetOwnersResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_owners_with_options(request, runtime)

    async def set_owners_async(
        self,
        request: dms_enterprise_20181101_models.SetOwnersRequest,
    ) -> dms_enterprise_20181101_models.SetOwnersResponse:
        """
        @summary Configures the owner of an instance, a database, or a table.
        
        @param request: SetOwnersRequest
        @return: SetOwnersResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_owners_with_options_async(request, runtime)

    def set_workflow_extra_info_with_options(
        self,
        request: dms_enterprise_20181101_models.SetWorkflowExtraInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SetWorkflowExtraInfoResponse:
        """
        @summary 修改审批流额外信息
        
        @param request: SetWorkflowExtraInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetWorkflowExtraInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.render_add_approval_node):
            query['RenderAddApprovalNode'] = request.render_add_approval_node
        if not UtilClient.is_unset(request.render_agree):
            query['RenderAgree'] = request.render_agree
        if not UtilClient.is_unset(request.render_cancel):
            query['RenderCancel'] = request.render_cancel
        if not UtilClient.is_unset(request.render_reject):
            query['RenderReject'] = request.render_reject
        if not UtilClient.is_unset(request.render_transfer):
            query['RenderTransfer'] = request.render_transfer
        if not UtilClient.is_unset(request.thirdparty_workflow_comment):
            query['ThirdpartyWorkflowComment'] = request.thirdparty_workflow_comment
        if not UtilClient.is_unset(request.thirdparty_workflow_url):
            query['ThirdpartyWorkflowUrl'] = request.thirdparty_workflow_url
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workflow_instance_id):
            query['WorkflowInstanceId'] = request.workflow_instance_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetWorkflowExtraInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SetWorkflowExtraInfoResponse(),
            self.call_api(params, req, runtime)
        )

    async def set_workflow_extra_info_with_options_async(
        self,
        request: dms_enterprise_20181101_models.SetWorkflowExtraInfoRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SetWorkflowExtraInfoResponse:
        """
        @summary 修改审批流额外信息
        
        @param request: SetWorkflowExtraInfoRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SetWorkflowExtraInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.render_add_approval_node):
            query['RenderAddApprovalNode'] = request.render_add_approval_node
        if not UtilClient.is_unset(request.render_agree):
            query['RenderAgree'] = request.render_agree
        if not UtilClient.is_unset(request.render_cancel):
            query['RenderCancel'] = request.render_cancel
        if not UtilClient.is_unset(request.render_reject):
            query['RenderReject'] = request.render_reject
        if not UtilClient.is_unset(request.render_transfer):
            query['RenderTransfer'] = request.render_transfer
        if not UtilClient.is_unset(request.thirdparty_workflow_comment):
            query['ThirdpartyWorkflowComment'] = request.thirdparty_workflow_comment
        if not UtilClient.is_unset(request.thirdparty_workflow_url):
            query['ThirdpartyWorkflowUrl'] = request.thirdparty_workflow_url
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workflow_instance_id):
            query['WorkflowInstanceId'] = request.workflow_instance_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SetWorkflowExtraInfo',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SetWorkflowExtraInfoResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def set_workflow_extra_info(
        self,
        request: dms_enterprise_20181101_models.SetWorkflowExtraInfoRequest,
    ) -> dms_enterprise_20181101_models.SetWorkflowExtraInfoResponse:
        """
        @summary 修改审批流额外信息
        
        @param request: SetWorkflowExtraInfoRequest
        @return: SetWorkflowExtraInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.set_workflow_extra_info_with_options(request, runtime)

    async def set_workflow_extra_info_async(
        self,
        request: dms_enterprise_20181101_models.SetWorkflowExtraInfoRequest,
    ) -> dms_enterprise_20181101_models.SetWorkflowExtraInfoResponse:
        """
        @summary 修改审批流额外信息
        
        @param request: SetWorkflowExtraInfoRequest
        @return: SetWorkflowExtraInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.set_workflow_extra_info_with_options_async(request, runtime)

    def simply_add_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.SimplyAddInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SimplyAddInstanceResponse:
        """
        @summary 添加实例
        
        @param request: SimplyAddInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SimplyAddInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.database_password):
            query['DatabasePassword'] = request.database_password
        if not UtilClient.is_unset(request.database_user):
            query['DatabaseUser'] = request.database_user
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_region):
            query['InstanceRegion'] = request.instance_region
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SimplyAddInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SimplyAddInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def simply_add_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.SimplyAddInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SimplyAddInstanceResponse:
        """
        @summary 添加实例
        
        @param request: SimplyAddInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SimplyAddInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.database_password):
            query['DatabasePassword'] = request.database_password
        if not UtilClient.is_unset(request.database_user):
            query['DatabaseUser'] = request.database_user
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_region):
            query['InstanceRegion'] = request.instance_region
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SimplyAddInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SimplyAddInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def simply_add_instance(
        self,
        request: dms_enterprise_20181101_models.SimplyAddInstanceRequest,
    ) -> dms_enterprise_20181101_models.SimplyAddInstanceResponse:
        """
        @summary 添加实例
        
        @param request: SimplyAddInstanceRequest
        @return: SimplyAddInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.simply_add_instance_with_options(request, runtime)

    async def simply_add_instance_async(
        self,
        request: dms_enterprise_20181101_models.SimplyAddInstanceRequest,
    ) -> dms_enterprise_20181101_models.SimplyAddInstanceResponse:
        """
        @summary 添加实例
        
        @param request: SimplyAddInstanceRequest
        @return: SimplyAddInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.simply_add_instance_with_options_async(request, runtime)

    def skip_data_correct_row_check_with_options(
        self,
        request: dms_enterprise_20181101_models.SkipDataCorrectRowCheckRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SkipDataCorrectRowCheckResponse:
        """
        @summary Skips the verification on the number of rows in the precheck for data change.
        
        @param request: SkipDataCorrectRowCheckRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SkipDataCorrectRowCheckResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.reason):
            query['Reason'] = request.reason
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SkipDataCorrectRowCheck',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SkipDataCorrectRowCheckResponse(),
            self.call_api(params, req, runtime)
        )

    async def skip_data_correct_row_check_with_options_async(
        self,
        request: dms_enterprise_20181101_models.SkipDataCorrectRowCheckRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SkipDataCorrectRowCheckResponse:
        """
        @summary Skips the verification on the number of rows in the precheck for data change.
        
        @param request: SkipDataCorrectRowCheckRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SkipDataCorrectRowCheckResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.reason):
            query['Reason'] = request.reason
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SkipDataCorrectRowCheck',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SkipDataCorrectRowCheckResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def skip_data_correct_row_check(
        self,
        request: dms_enterprise_20181101_models.SkipDataCorrectRowCheckRequest,
    ) -> dms_enterprise_20181101_models.SkipDataCorrectRowCheckResponse:
        """
        @summary Skips the verification on the number of rows in the precheck for data change.
        
        @param request: SkipDataCorrectRowCheckRequest
        @return: SkipDataCorrectRowCheckResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.skip_data_correct_row_check_with_options(request, runtime)

    async def skip_data_correct_row_check_async(
        self,
        request: dms_enterprise_20181101_models.SkipDataCorrectRowCheckRequest,
    ) -> dms_enterprise_20181101_models.SkipDataCorrectRowCheckResponse:
        """
        @summary Skips the verification on the number of rows in the precheck for data change.
        
        @param request: SkipDataCorrectRowCheckRequest
        @return: SkipDataCorrectRowCheckResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.skip_data_correct_row_check_with_options_async(request, runtime)

    def stop_task_flow_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.StopTaskFlowInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.StopTaskFlowInstanceResponse:
        """
        @summary Stops a task flow instance.
        
        @param request: StopTaskFlowInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopTaskFlowInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_instance_id):
            query['DagInstanceId'] = request.dag_instance_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopTaskFlowInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.StopTaskFlowInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def stop_task_flow_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.StopTaskFlowInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.StopTaskFlowInstanceResponse:
        """
        @summary Stops a task flow instance.
        
        @param request: StopTaskFlowInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: StopTaskFlowInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_instance_id):
            query['DagInstanceId'] = request.dag_instance_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='StopTaskFlowInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.StopTaskFlowInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def stop_task_flow_instance(
        self,
        request: dms_enterprise_20181101_models.StopTaskFlowInstanceRequest,
    ) -> dms_enterprise_20181101_models.StopTaskFlowInstanceResponse:
        """
        @summary Stops a task flow instance.
        
        @param request: StopTaskFlowInstanceRequest
        @return: StopTaskFlowInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.stop_task_flow_instance_with_options(request, runtime)

    async def stop_task_flow_instance_async(
        self,
        request: dms_enterprise_20181101_models.StopTaskFlowInstanceRequest,
    ) -> dms_enterprise_20181101_models.StopTaskFlowInstanceResponse:
        """
        @summary Stops a task flow instance.
        
        @param request: StopTaskFlowInstanceRequest
        @return: StopTaskFlowInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.stop_task_flow_instance_with_options_async(request, runtime)

    def submit_order_approval_with_options(
        self,
        request: dms_enterprise_20181101_models.SubmitOrderApprovalRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SubmitOrderApprovalResponse:
        """
        @summary Submits a ticket for approval.
        
        @param request: SubmitOrderApprovalRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitOrderApprovalResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitOrderApproval',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SubmitOrderApprovalResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_order_approval_with_options_async(
        self,
        request: dms_enterprise_20181101_models.SubmitOrderApprovalRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SubmitOrderApprovalResponse:
        """
        @summary Submits a ticket for approval.
        
        @param request: SubmitOrderApprovalRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitOrderApprovalResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.real_login_user_uid):
            query['RealLoginUserUid'] = request.real_login_user_uid
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitOrderApproval',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SubmitOrderApprovalResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_order_approval(
        self,
        request: dms_enterprise_20181101_models.SubmitOrderApprovalRequest,
    ) -> dms_enterprise_20181101_models.SubmitOrderApprovalResponse:
        """
        @summary Submits a ticket for approval.
        
        @param request: SubmitOrderApprovalRequest
        @return: SubmitOrderApprovalResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_order_approval_with_options(request, runtime)

    async def submit_order_approval_async(
        self,
        request: dms_enterprise_20181101_models.SubmitOrderApprovalRequest,
    ) -> dms_enterprise_20181101_models.SubmitOrderApprovalResponse:
        """
        @summary Submits a ticket for approval.
        
        @param request: SubmitOrderApprovalRequest
        @return: SubmitOrderApprovalResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_order_approval_with_options_async(request, runtime)

    def submit_struct_sync_order_approval_with_options(
        self,
        request: dms_enterprise_20181101_models.SubmitStructSyncOrderApprovalRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SubmitStructSyncOrderApprovalResponse:
        """
        @summary Submits a schema synchronization ticket for approval.
        
        @param request: SubmitStructSyncOrderApprovalRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitStructSyncOrderApprovalResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitStructSyncOrderApproval',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SubmitStructSyncOrderApprovalResponse(),
            self.call_api(params, req, runtime)
        )

    async def submit_struct_sync_order_approval_with_options_async(
        self,
        request: dms_enterprise_20181101_models.SubmitStructSyncOrderApprovalRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SubmitStructSyncOrderApprovalResponse:
        """
        @summary Submits a schema synchronization ticket for approval.
        
        @param request: SubmitStructSyncOrderApprovalRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SubmitStructSyncOrderApprovalResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SubmitStructSyncOrderApproval',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SubmitStructSyncOrderApprovalResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def submit_struct_sync_order_approval(
        self,
        request: dms_enterprise_20181101_models.SubmitStructSyncOrderApprovalRequest,
    ) -> dms_enterprise_20181101_models.SubmitStructSyncOrderApprovalResponse:
        """
        @summary Submits a schema synchronization ticket for approval.
        
        @param request: SubmitStructSyncOrderApprovalRequest
        @return: SubmitStructSyncOrderApprovalResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.submit_struct_sync_order_approval_with_options(request, runtime)

    async def submit_struct_sync_order_approval_async(
        self,
        request: dms_enterprise_20181101_models.SubmitStructSyncOrderApprovalRequest,
    ) -> dms_enterprise_20181101_models.SubmitStructSyncOrderApprovalResponse:
        """
        @summary Submits a schema synchronization ticket for approval.
        
        @param request: SubmitStructSyncOrderApprovalRequest
        @return: SubmitStructSyncOrderApprovalResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.submit_struct_sync_order_approval_with_options_async(request, runtime)

    def suspend_data_export_job_with_options(
        self,
        request: dms_enterprise_20181101_models.SuspendDataExportJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SuspendDataExportJobResponse:
        """
        @summary 中断数据导出任务
        
        @param request: SuspendDataExportJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SuspendDataExportJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SuspendDataExportJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SuspendDataExportJobResponse(),
            self.call_api(params, req, runtime)
        )

    async def suspend_data_export_job_with_options_async(
        self,
        request: dms_enterprise_20181101_models.SuspendDataExportJobRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SuspendDataExportJobResponse:
        """
        @summary 中断数据导出任务
        
        @param request: SuspendDataExportJobRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SuspendDataExportJobResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_id):
            query['JobId'] = request.job_id
        if not UtilClient.is_unset(request.order_id):
            query['OrderId'] = request.order_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SuspendDataExportJob',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SuspendDataExportJobResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def suspend_data_export_job(
        self,
        request: dms_enterprise_20181101_models.SuspendDataExportJobRequest,
    ) -> dms_enterprise_20181101_models.SuspendDataExportJobResponse:
        """
        @summary 中断数据导出任务
        
        @param request: SuspendDataExportJobRequest
        @return: SuspendDataExportJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.suspend_data_export_job_with_options(request, runtime)

    async def suspend_data_export_job_async(
        self,
        request: dms_enterprise_20181101_models.SuspendDataExportJobRequest,
    ) -> dms_enterprise_20181101_models.SuspendDataExportJobResponse:
        """
        @summary 中断数据导出任务
        
        @param request: SuspendDataExportJobRequest
        @return: SuspendDataExportJobResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.suspend_data_export_job_with_options_async(request, runtime)

    def suspend_task_flow_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.SuspendTaskFlowInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SuspendTaskFlowInstanceResponse:
        """
        @summary Suspends a task flow instance.
        
        @param request: SuspendTaskFlowInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SuspendTaskFlowInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_instance_id):
            query['DagInstanceId'] = request.dag_instance_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SuspendTaskFlowInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SuspendTaskFlowInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def suspend_task_flow_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.SuspendTaskFlowInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SuspendTaskFlowInstanceResponse:
        """
        @summary Suspends a task flow instance.
        
        @param request: SuspendTaskFlowInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SuspendTaskFlowInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_instance_id):
            query['DagInstanceId'] = request.dag_instance_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SuspendTaskFlowInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SuspendTaskFlowInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def suspend_task_flow_instance(
        self,
        request: dms_enterprise_20181101_models.SuspendTaskFlowInstanceRequest,
    ) -> dms_enterprise_20181101_models.SuspendTaskFlowInstanceResponse:
        """
        @summary Suspends a task flow instance.
        
        @param request: SuspendTaskFlowInstanceRequest
        @return: SuspendTaskFlowInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.suspend_task_flow_instance_with_options(request, runtime)

    async def suspend_task_flow_instance_async(
        self,
        request: dms_enterprise_20181101_models.SuspendTaskFlowInstanceRequest,
    ) -> dms_enterprise_20181101_models.SuspendTaskFlowInstanceResponse:
        """
        @summary Suspends a task flow instance.
        
        @param request: SuspendTaskFlowInstanceRequest
        @return: SuspendTaskFlowInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.suspend_task_flow_instance_with_options_async(request, runtime)

    def sync_database_meta_with_options(
        self,
        request: dms_enterprise_20181101_models.SyncDatabaseMetaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SyncDatabaseMetaResponse:
        """
        @summary Synchronizes the metadata of a database.
        
        @param request: SyncDatabaseMetaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SyncDatabaseMetaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SyncDatabaseMeta',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SyncDatabaseMetaResponse(),
            self.call_api(params, req, runtime)
        )

    async def sync_database_meta_with_options_async(
        self,
        request: dms_enterprise_20181101_models.SyncDatabaseMetaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SyncDatabaseMetaResponse:
        """
        @summary Synchronizes the metadata of a database.
        
        @param request: SyncDatabaseMetaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SyncDatabaseMetaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.db_id):
            query['DbId'] = request.db_id
        if not UtilClient.is_unset(request.logic):
            query['Logic'] = request.logic
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SyncDatabaseMeta',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SyncDatabaseMetaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def sync_database_meta(
        self,
        request: dms_enterprise_20181101_models.SyncDatabaseMetaRequest,
    ) -> dms_enterprise_20181101_models.SyncDatabaseMetaResponse:
        """
        @summary Synchronizes the metadata of a database.
        
        @param request: SyncDatabaseMetaRequest
        @return: SyncDatabaseMetaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.sync_database_meta_with_options(request, runtime)

    async def sync_database_meta_async(
        self,
        request: dms_enterprise_20181101_models.SyncDatabaseMetaRequest,
    ) -> dms_enterprise_20181101_models.SyncDatabaseMetaResponse:
        """
        @summary Synchronizes the metadata of a database.
        
        @param request: SyncDatabaseMetaRequest
        @return: SyncDatabaseMetaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.sync_database_meta_with_options_async(request, runtime)

    def sync_instance_meta_with_options(
        self,
        request: dms_enterprise_20181101_models.SyncInstanceMetaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SyncInstanceMetaResponse:
        """
        @summary Synchronizes the metadata of all databases in a database instance.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: SyncInstanceMetaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SyncInstanceMetaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ignore_table):
            query['IgnoreTable'] = request.ignore_table
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SyncInstanceMeta',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SyncInstanceMetaResponse(),
            self.call_api(params, req, runtime)
        )

    async def sync_instance_meta_with_options_async(
        self,
        request: dms_enterprise_20181101_models.SyncInstanceMetaRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.SyncInstanceMetaResponse:
        """
        @summary Synchronizes the metadata of all databases in a database instance.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: SyncInstanceMetaRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: SyncInstanceMetaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.ignore_table):
            query['IgnoreTable'] = request.ignore_table
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='SyncInstanceMeta',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.SyncInstanceMetaResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def sync_instance_meta(
        self,
        request: dms_enterprise_20181101_models.SyncInstanceMetaRequest,
    ) -> dms_enterprise_20181101_models.SyncInstanceMetaResponse:
        """
        @summary Synchronizes the metadata of all databases in a database instance.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: SyncInstanceMetaRequest
        @return: SyncInstanceMetaResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.sync_instance_meta_with_options(request, runtime)

    async def sync_instance_meta_async(
        self,
        request: dms_enterprise_20181101_models.SyncInstanceMetaRequest,
    ) -> dms_enterprise_20181101_models.SyncInstanceMetaResponse:
        """
        @summary Synchronizes the metadata of all databases in a database instance.
        
        @description You can call this operation only for database instances whose control mode is Security Collaboration.
        
        @param request: SyncInstanceMetaRequest
        @return: SyncInstanceMetaResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.sync_instance_meta_with_options_async(request, runtime)

    def try_run_task_flow_with_options(
        self,
        request: dms_enterprise_20181101_models.TryRunTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.TryRunTaskFlowResponse:
        """
        @summary 任务编排试运行
        
        @param request: TryRunTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TryRunTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TryRunTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.TryRunTaskFlowResponse(),
            self.call_api(params, req, runtime)
        )

    async def try_run_task_flow_with_options_async(
        self,
        request: dms_enterprise_20181101_models.TryRunTaskFlowRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.TryRunTaskFlowResponse:
        """
        @summary 任务编排试运行
        
        @param request: TryRunTaskFlowRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: TryRunTaskFlowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TryRunTaskFlow',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.TryRunTaskFlowResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def try_run_task_flow(
        self,
        request: dms_enterprise_20181101_models.TryRunTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.TryRunTaskFlowResponse:
        """
        @summary 任务编排试运行
        
        @param request: TryRunTaskFlowRequest
        @return: TryRunTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.try_run_task_flow_with_options(request, runtime)

    async def try_run_task_flow_async(
        self,
        request: dms_enterprise_20181101_models.TryRunTaskFlowRequest,
    ) -> dms_enterprise_20181101_models.TryRunTaskFlowResponse:
        """
        @summary 任务编排试运行
        
        @param request: TryRunTaskFlowRequest
        @return: TryRunTaskFlowResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.try_run_task_flow_with_options_async(request, runtime)

    def update_abac_policy_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateAbacPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateAbacPolicyResponse:
        """
        @summary 更新权限策略
        
        @param request: UpdateAbacPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAbacPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.abac_policy_content):
            query['AbacPolicyContent'] = request.abac_policy_content
        if not UtilClient.is_unset(request.abac_policy_desc):
            query['AbacPolicyDesc'] = request.abac_policy_desc
        if not UtilClient.is_unset(request.abac_policy_id):
            query['AbacPolicyId'] = request.abac_policy_id
        if not UtilClient.is_unset(request.abac_policy_name):
            query['AbacPolicyName'] = request.abac_policy_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateAbacPolicy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateAbacPolicyResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_abac_policy_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateAbacPolicyRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateAbacPolicyResponse:
        """
        @summary 更新权限策略
        
        @param request: UpdateAbacPolicyRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAbacPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.abac_policy_content):
            query['AbacPolicyContent'] = request.abac_policy_content
        if not UtilClient.is_unset(request.abac_policy_desc):
            query['AbacPolicyDesc'] = request.abac_policy_desc
        if not UtilClient.is_unset(request.abac_policy_id):
            query['AbacPolicyId'] = request.abac_policy_id
        if not UtilClient.is_unset(request.abac_policy_name):
            query['AbacPolicyName'] = request.abac_policy_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateAbacPolicy',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateAbacPolicyResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_abac_policy(
        self,
        request: dms_enterprise_20181101_models.UpdateAbacPolicyRequest,
    ) -> dms_enterprise_20181101_models.UpdateAbacPolicyResponse:
        """
        @summary 更新权限策略
        
        @param request: UpdateAbacPolicyRequest
        @return: UpdateAbacPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_abac_policy_with_options(request, runtime)

    async def update_abac_policy_async(
        self,
        request: dms_enterprise_20181101_models.UpdateAbacPolicyRequest,
    ) -> dms_enterprise_20181101_models.UpdateAbacPolicyResponse:
        """
        @summary 更新权限策略
        
        @param request: UpdateAbacPolicyRequest
        @return: UpdateAbacPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_abac_policy_with_options_async(request, runtime)

    def update_authority_template_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateAuthorityTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateAuthorityTemplateResponse:
        """
        @summary Modifies a permission template.
        
        @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: UpdateAuthorityTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAuthorityTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateAuthorityTemplate',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateAuthorityTemplateResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_authority_template_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateAuthorityTemplateRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateAuthorityTemplateResponse:
        """
        @summary Modifies a permission template.
        
        @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: UpdateAuthorityTemplateRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAuthorityTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateAuthorityTemplate',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateAuthorityTemplateResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_authority_template(
        self,
        request: dms_enterprise_20181101_models.UpdateAuthorityTemplateRequest,
    ) -> dms_enterprise_20181101_models.UpdateAuthorityTemplateResponse:
        """
        @summary Modifies a permission template.
        
        @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: UpdateAuthorityTemplateRequest
        @return: UpdateAuthorityTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_authority_template_with_options(request, runtime)

    async def update_authority_template_async(
        self,
        request: dms_enterprise_20181101_models.UpdateAuthorityTemplateRequest,
    ) -> dms_enterprise_20181101_models.UpdateAuthorityTemplateResponse:
        """
        @summary Modifies a permission template.
        
        @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
        
        @param request: UpdateAuthorityTemplateRequest
        @return: UpdateAuthorityTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_authority_template_with_options_async(request, runtime)

    def update_data_lake_database_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateDataLakeDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateDataLakeDatabaseResponse:
        """
        @summary 更新湖仓数据库
        
        @param tmp_req: UpdateDataLakeDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateDataLakeDatabaseResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateDataLakeDatabaseShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.parameters):
            request.parameters_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.parameters, 'Parameters', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.location):
            query['Location'] = request.location
        if not UtilClient.is_unset(request.parameters_shrink):
            query['Parameters'] = request.parameters_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateDataLakeDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateDataLakeDatabaseResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_data_lake_database_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateDataLakeDatabaseRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateDataLakeDatabaseResponse:
        """
        @summary 更新湖仓数据库
        
        @param tmp_req: UpdateDataLakeDatabaseRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateDataLakeDatabaseResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateDataLakeDatabaseShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.parameters):
            request.parameters_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.parameters, 'Parameters', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.location):
            query['Location'] = request.location
        if not UtilClient.is_unset(request.parameters_shrink):
            query['Parameters'] = request.parameters_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateDataLakeDatabase',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateDataLakeDatabaseResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_data_lake_database(
        self,
        request: dms_enterprise_20181101_models.UpdateDataLakeDatabaseRequest,
    ) -> dms_enterprise_20181101_models.UpdateDataLakeDatabaseResponse:
        """
        @summary 更新湖仓数据库
        
        @param request: UpdateDataLakeDatabaseRequest
        @return: UpdateDataLakeDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_data_lake_database_with_options(request, runtime)

    async def update_data_lake_database_async(
        self,
        request: dms_enterprise_20181101_models.UpdateDataLakeDatabaseRequest,
    ) -> dms_enterprise_20181101_models.UpdateDataLakeDatabaseResponse:
        """
        @summary 更新湖仓数据库
        
        @param request: UpdateDataLakeDatabaseRequest
        @return: UpdateDataLakeDatabaseResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_data_lake_database_with_options_async(request, runtime)

    def update_data_lake_function_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateDataLakeFunctionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateDataLakeFunctionResponse:
        """
        @summary 更新湖仓自定义函数
        
        @param tmp_req: UpdateDataLakeFunctionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateDataLakeFunctionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateDataLakeFunctionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.function_input):
            request.function_input_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.function_input, 'FunctionInput', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.function_name):
            query['FunctionName'] = request.function_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.function_input_shrink):
            body['FunctionInput'] = request.function_input_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateDataLakeFunction',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateDataLakeFunctionResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_data_lake_function_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateDataLakeFunctionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateDataLakeFunctionResponse:
        """
        @summary 更新湖仓自定义函数
        
        @param tmp_req: UpdateDataLakeFunctionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateDataLakeFunctionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateDataLakeFunctionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.function_input):
            request.function_input_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.function_input, 'FunctionInput', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.function_name):
            query['FunctionName'] = request.function_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.function_input_shrink):
            body['FunctionInput'] = request.function_input_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateDataLakeFunction',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateDataLakeFunctionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_data_lake_function(
        self,
        request: dms_enterprise_20181101_models.UpdateDataLakeFunctionRequest,
    ) -> dms_enterprise_20181101_models.UpdateDataLakeFunctionResponse:
        """
        @summary 更新湖仓自定义函数
        
        @param request: UpdateDataLakeFunctionRequest
        @return: UpdateDataLakeFunctionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_data_lake_function_with_options(request, runtime)

    async def update_data_lake_function_async(
        self,
        request: dms_enterprise_20181101_models.UpdateDataLakeFunctionRequest,
    ) -> dms_enterprise_20181101_models.UpdateDataLakeFunctionResponse:
        """
        @summary 更新湖仓自定义函数
        
        @param request: UpdateDataLakeFunctionRequest
        @return: UpdateDataLakeFunctionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_data_lake_function_with_options_async(request, runtime)

    def update_data_lake_partition_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateDataLakePartitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateDataLakePartitionResponse:
        """
        @summary 更新湖仓表分区
        
        @param tmp_req: UpdateDataLakePartitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateDataLakePartitionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateDataLakePartitionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.partition_input):
            request.partition_input_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.partition_input, 'PartitionInput', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.partition_input_shrink):
            body['PartitionInput'] = request.partition_input_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateDataLakePartition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateDataLakePartitionResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_data_lake_partition_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateDataLakePartitionRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateDataLakePartitionResponse:
        """
        @summary 更新湖仓表分区
        
        @param tmp_req: UpdateDataLakePartitionRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateDataLakePartitionResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateDataLakePartitionShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.partition_input):
            request.partition_input_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.partition_input, 'PartitionInput', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.partition_input_shrink):
            body['PartitionInput'] = request.partition_input_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateDataLakePartition',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateDataLakePartitionResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_data_lake_partition(
        self,
        request: dms_enterprise_20181101_models.UpdateDataLakePartitionRequest,
    ) -> dms_enterprise_20181101_models.UpdateDataLakePartitionResponse:
        """
        @summary 更新湖仓表分区
        
        @param request: UpdateDataLakePartitionRequest
        @return: UpdateDataLakePartitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_data_lake_partition_with_options(request, runtime)

    async def update_data_lake_partition_async(
        self,
        request: dms_enterprise_20181101_models.UpdateDataLakePartitionRequest,
    ) -> dms_enterprise_20181101_models.UpdateDataLakePartitionResponse:
        """
        @summary 更新湖仓表分区
        
        @param request: UpdateDataLakePartitionRequest
        @return: UpdateDataLakePartitionResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_data_lake_partition_with_options_async(request, runtime)

    def update_data_lake_table_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateDataLakeTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateDataLakeTableResponse:
        """
        @summary 更新湖仓表信息
        
        @param tmp_req: UpdateDataLakeTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateDataLakeTableResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateDataLakeTableShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.table_input):
            request.table_input_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.table_input, 'TableInput', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.table_input_shrink):
            body['TableInput'] = request.table_input_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateDataLakeTable',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateDataLakeTableResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_data_lake_table_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateDataLakeTableRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateDataLakeTableResponse:
        """
        @summary 更新湖仓表信息
        
        @param tmp_req: UpdateDataLakeTableRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateDataLakeTableResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateDataLakeTableShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.table_input):
            request.table_input_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.table_input, 'TableInput', 'json')
        query = {}
        if not UtilClient.is_unset(request.catalog_name):
            query['CatalogName'] = request.catalog_name
        if not UtilClient.is_unset(request.data_region):
            query['DataRegion'] = request.data_region
        if not UtilClient.is_unset(request.db_name):
            query['DbName'] = request.db_name
        if not UtilClient.is_unset(request.table_name):
            query['TableName'] = request.table_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.workspace_id):
            query['WorkspaceId'] = request.workspace_id
        body = {}
        if not UtilClient.is_unset(request.table_input_shrink):
            body['TableInput'] = request.table_input_shrink
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateDataLakeTable',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateDataLakeTableResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_data_lake_table(
        self,
        request: dms_enterprise_20181101_models.UpdateDataLakeTableRequest,
    ) -> dms_enterprise_20181101_models.UpdateDataLakeTableResponse:
        """
        @summary 更新湖仓表信息
        
        @param request: UpdateDataLakeTableRequest
        @return: UpdateDataLakeTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_data_lake_table_with_options(request, runtime)

    async def update_data_lake_table_async(
        self,
        request: dms_enterprise_20181101_models.UpdateDataLakeTableRequest,
    ) -> dms_enterprise_20181101_models.UpdateDataLakeTableResponse:
        """
        @summary 更新湖仓表信息
        
        @param request: UpdateDataLakeTableRequest
        @return: UpdateDataLakeTableResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_data_lake_table_with_options_async(request, runtime)

    def update_instance_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateInstanceResponse:
        """
        @summary Updates the information about a database instance and checks the connectivity of the database instance.
        
        @description Before you call the UpdateInstance operation, call the [GetInstance](https://help.aliyun.com/document_detail/141567.html) or [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the complete information about the instance.
        
        @param request: UpdateInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_link_name):
            query['DataLinkName'] = request.data_link_name
        if not UtilClient.is_unset(request.database_password):
            query['DatabasePassword'] = request.database_password
        if not UtilClient.is_unset(request.database_user):
            query['DatabaseUser'] = request.database_user
        if not UtilClient.is_unset(request.dba_id):
            query['DbaId'] = request.dba_id
        if not UtilClient.is_unset(request.ddl_online):
            query['DdlOnline'] = request.ddl_online
        if not UtilClient.is_unset(request.ecs_instance_id):
            query['EcsInstanceId'] = request.ecs_instance_id
        if not UtilClient.is_unset(request.ecs_region):
            query['EcsRegion'] = request.ecs_region
        if not UtilClient.is_unset(request.enable_sell_sitd):
            query['EnableSellSitd'] = request.enable_sell_sitd
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.export_timeout):
            query['ExportTimeout'] = request.export_timeout
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.instance_alias):
            query['InstanceAlias'] = request.instance_alias
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_source):
            query['InstanceSource'] = request.instance_source
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.query_timeout):
            query['QueryTimeout'] = request.query_timeout
        if not UtilClient.is_unset(request.safe_rule_id):
            query['SafeRuleId'] = request.safe_rule_id
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.skip_test):
            query['SkipTest'] = request.skip_test
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.use_dsql):
            query['UseDsql'] = request.use_dsql
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateInstanceResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_instance_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateInstanceRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateInstanceResponse:
        """
        @summary Updates the information about a database instance and checks the connectivity of the database instance.
        
        @description Before you call the UpdateInstance operation, call the [GetInstance](https://help.aliyun.com/document_detail/141567.html) or [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the complete information about the instance.
        
        @param request: UpdateInstanceRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.data_link_name):
            query['DataLinkName'] = request.data_link_name
        if not UtilClient.is_unset(request.database_password):
            query['DatabasePassword'] = request.database_password
        if not UtilClient.is_unset(request.database_user):
            query['DatabaseUser'] = request.database_user
        if not UtilClient.is_unset(request.dba_id):
            query['DbaId'] = request.dba_id
        if not UtilClient.is_unset(request.ddl_online):
            query['DdlOnline'] = request.ddl_online
        if not UtilClient.is_unset(request.ecs_instance_id):
            query['EcsInstanceId'] = request.ecs_instance_id
        if not UtilClient.is_unset(request.ecs_region):
            query['EcsRegion'] = request.ecs_region
        if not UtilClient.is_unset(request.enable_sell_sitd):
            query['EnableSellSitd'] = request.enable_sell_sitd
        if not UtilClient.is_unset(request.env_type):
            query['EnvType'] = request.env_type
        if not UtilClient.is_unset(request.export_timeout):
            query['ExportTimeout'] = request.export_timeout
        if not UtilClient.is_unset(request.host):
            query['Host'] = request.host
        if not UtilClient.is_unset(request.instance_alias):
            query['InstanceAlias'] = request.instance_alias
        if not UtilClient.is_unset(request.instance_id):
            query['InstanceId'] = request.instance_id
        if not UtilClient.is_unset(request.instance_source):
            query['InstanceSource'] = request.instance_source
        if not UtilClient.is_unset(request.instance_type):
            query['InstanceType'] = request.instance_type
        if not UtilClient.is_unset(request.port):
            query['Port'] = request.port
        if not UtilClient.is_unset(request.query_timeout):
            query['QueryTimeout'] = request.query_timeout
        if not UtilClient.is_unset(request.safe_rule_id):
            query['SafeRuleId'] = request.safe_rule_id
        if not UtilClient.is_unset(request.sid):
            query['Sid'] = request.sid
        if not UtilClient.is_unset(request.skip_test):
            query['SkipTest'] = request.skip_test
        if not UtilClient.is_unset(request.template_id):
            query['TemplateId'] = request.template_id
        if not UtilClient.is_unset(request.template_type):
            query['TemplateType'] = request.template_type
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.use_dsql):
            query['UseDsql'] = request.use_dsql
        if not UtilClient.is_unset(request.vpc_id):
            query['VpcId'] = request.vpc_id
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateInstance',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateInstanceResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_instance(
        self,
        request: dms_enterprise_20181101_models.UpdateInstanceRequest,
    ) -> dms_enterprise_20181101_models.UpdateInstanceResponse:
        """
        @summary Updates the information about a database instance and checks the connectivity of the database instance.
        
        @description Before you call the UpdateInstance operation, call the [GetInstance](https://help.aliyun.com/document_detail/141567.html) or [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the complete information about the instance.
        
        @param request: UpdateInstanceRequest
        @return: UpdateInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_instance_with_options(request, runtime)

    async def update_instance_async(
        self,
        request: dms_enterprise_20181101_models.UpdateInstanceRequest,
    ) -> dms_enterprise_20181101_models.UpdateInstanceResponse:
        """
        @summary Updates the information about a database instance and checks the connectivity of the database instance.
        
        @description Before you call the UpdateInstance operation, call the [GetInstance](https://help.aliyun.com/document_detail/141567.html) or [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the complete information about the instance.
        
        @param request: UpdateInstanceRequest
        @return: UpdateInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_instance_with_options_async(request, runtime)

    def update_meta_category_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateMetaCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateMetaCategoryResponse:
        """
        @summary 更新资产类目信息
        
        @param request: UpdateMetaCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMetaCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category_id):
            query['CategoryId'] = request.category_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateMetaCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateMetaCategoryResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_meta_category_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateMetaCategoryRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateMetaCategoryResponse:
        """
        @summary 更新资产类目信息
        
        @param request: UpdateMetaCategoryRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMetaCategoryResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.category_id):
            query['CategoryId'] = request.category_id
        if not UtilClient.is_unset(request.name):
            query['Name'] = request.name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateMetaCategory',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateMetaCategoryResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_meta_category(
        self,
        request: dms_enterprise_20181101_models.UpdateMetaCategoryRequest,
    ) -> dms_enterprise_20181101_models.UpdateMetaCategoryResponse:
        """
        @summary 更新资产类目信息
        
        @param request: UpdateMetaCategoryRequest
        @return: UpdateMetaCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_meta_category_with_options(request, runtime)

    async def update_meta_category_async(
        self,
        request: dms_enterprise_20181101_models.UpdateMetaCategoryRequest,
    ) -> dms_enterprise_20181101_models.UpdateMetaCategoryResponse:
        """
        @summary 更新资产类目信息
        
        @param request: UpdateMetaCategoryRequest
        @return: UpdateMetaCategoryResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_meta_category_with_options_async(request, runtime)

    def update_slarules_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateSLARulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateSLARulesResponse:
        """
        @summary Updates the service level agreement (SLA) timeout reminder for a task flow.
        
        @description SLA rules take effect after task flows are deployed and published.
        
        @param tmp_req: UpdateSLARulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateSLARulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateSLARulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.sla_rule_list):
            request.sla_rule_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.sla_rule_list, 'SlaRuleList', 'json')
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.sla_rule_list_shrink):
            query['SlaRuleList'] = request.sla_rule_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateSLARules',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateSLARulesResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_slarules_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateSLARulesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateSLARulesResponse:
        """
        @summary Updates the service level agreement (SLA) timeout reminder for a task flow.
        
        @description SLA rules take effect after task flows are deployed and published.
        
        @param tmp_req: UpdateSLARulesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateSLARulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateSLARulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.sla_rule_list):
            request.sla_rule_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.sla_rule_list, 'SlaRuleList', 'json')
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.sla_rule_list_shrink):
            query['SlaRuleList'] = request.sla_rule_list_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateSLARules',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateSLARulesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_slarules(
        self,
        request: dms_enterprise_20181101_models.UpdateSLARulesRequest,
    ) -> dms_enterprise_20181101_models.UpdateSLARulesResponse:
        """
        @summary Updates the service level agreement (SLA) timeout reminder for a task flow.
        
        @description SLA rules take effect after task flows are deployed and published.
        
        @param request: UpdateSLARulesRequest
        @return: UpdateSLARulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_slarules_with_options(request, runtime)

    async def update_slarules_async(
        self,
        request: dms_enterprise_20181101_models.UpdateSLARulesRequest,
    ) -> dms_enterprise_20181101_models.UpdateSLARulesResponse:
        """
        @summary Updates the service level agreement (SLA) timeout reminder for a task flow.
        
        @description SLA rules take effect after task flows are deployed and published.
        
        @param request: UpdateSLARulesRequest
        @return: UpdateSLARulesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_slarules_with_options_async(request, runtime)

    def update_scenario_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateScenarioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateScenarioResponse:
        """
        @summary Updates the name and description of the business scenario for a specified task flow.
        
        @param request: UpdateScenarioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateScenarioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.scenario_id):
            query['ScenarioId'] = request.scenario_id
        if not UtilClient.is_unset(request.scenario_name):
            query['ScenarioName'] = request.scenario_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateScenario',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateScenarioResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_scenario_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateScenarioRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateScenarioResponse:
        """
        @summary Updates the name and description of the business scenario for a specified task flow.
        
        @param request: UpdateScenarioRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateScenarioResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.scenario_id):
            query['ScenarioId'] = request.scenario_id
        if not UtilClient.is_unset(request.scenario_name):
            query['ScenarioName'] = request.scenario_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateScenario',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateScenarioResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_scenario(
        self,
        request: dms_enterprise_20181101_models.UpdateScenarioRequest,
    ) -> dms_enterprise_20181101_models.UpdateScenarioResponse:
        """
        @summary Updates the name and description of the business scenario for a specified task flow.
        
        @param request: UpdateScenarioRequest
        @return: UpdateScenarioResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_scenario_with_options(request, runtime)

    async def update_scenario_async(
        self,
        request: dms_enterprise_20181101_models.UpdateScenarioRequest,
    ) -> dms_enterprise_20181101_models.UpdateScenarioResponse:
        """
        @summary Updates the name and description of the business scenario for a specified task flow.
        
        @param request: UpdateScenarioRequest
        @return: UpdateScenarioResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_scenario_with_options_async(request, runtime)

    def update_standard_group_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateStandardGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateStandardGroupResponse:
        """
        @summary Modifies the name and description of a specific security rule set.
        
        @param request: UpdateStandardGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateStandardGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.group_name):
            query['GroupName'] = request.group_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateStandardGroup',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateStandardGroupResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_standard_group_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateStandardGroupRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateStandardGroupResponse:
        """
        @summary Modifies the name and description of a specific security rule set.
        
        @param request: UpdateStandardGroupRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateStandardGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.group_id):
            query['GroupId'] = request.group_id
        if not UtilClient.is_unset(request.group_name):
            query['GroupName'] = request.group_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateStandardGroup',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateStandardGroupResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_standard_group(
        self,
        request: dms_enterprise_20181101_models.UpdateStandardGroupRequest,
    ) -> dms_enterprise_20181101_models.UpdateStandardGroupResponse:
        """
        @summary Modifies the name and description of a specific security rule set.
        
        @param request: UpdateStandardGroupRequest
        @return: UpdateStandardGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_standard_group_with_options(request, runtime)

    async def update_standard_group_async(
        self,
        request: dms_enterprise_20181101_models.UpdateStandardGroupRequest,
    ) -> dms_enterprise_20181101_models.UpdateStandardGroupResponse:
        """
        @summary Modifies the name and description of a specific security rule set.
        
        @param request: UpdateStandardGroupRequest
        @return: UpdateStandardGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_standard_group_with_options_async(request, runtime)

    def update_task_config_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskConfigResponse:
        """
        @summary Updates the advanced configuration of a task node.
        
        @description You can call this operation to configure a failed task or rerun a task.
        
        @param request: UpdateTaskConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_config):
            query['NodeConfig'] = request.node_config
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskConfig',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskConfigResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_config_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskConfigRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskConfigResponse:
        """
        @summary Updates the advanced configuration of a task node.
        
        @description You can call this operation to configure a failed task or rerun a task.
        
        @param request: UpdateTaskConfigRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskConfigResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_config):
            query['NodeConfig'] = request.node_config
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskConfig',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskConfigResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_config(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskConfigRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskConfigResponse:
        """
        @summary Updates the advanced configuration of a task node.
        
        @description You can call this operation to configure a failed task or rerun a task.
        
        @param request: UpdateTaskConfigRequest
        @return: UpdateTaskConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_config_with_options(request, runtime)

    async def update_task_config_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskConfigRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskConfigResponse:
        """
        @summary Updates the advanced configuration of a task node.
        
        @description You can call this operation to configure a failed task or rerun a task.
        
        @param request: UpdateTaskConfigRequest
        @return: UpdateTaskConfigResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_config_with_options_async(request, runtime)

    def update_task_content_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskContentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskContentResponse:
        """
        @summary Updates tasks in a task flow.
        
        @description You can call this operation to modify node configurations.
        
        @param request: UpdateTaskContentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskContentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_content):
            query['NodeContent'] = request.node_content
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskContent',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskContentResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_content_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskContentRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskContentResponse:
        """
        @summary Updates tasks in a task flow.
        
        @description You can call this operation to modify node configurations.
        
        @param request: UpdateTaskContentRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskContentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_content):
            query['NodeContent'] = request.node_content
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskContent',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskContentResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_content(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskContentRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskContentResponse:
        """
        @summary Updates tasks in a task flow.
        
        @description You can call this operation to modify node configurations.
        
        @param request: UpdateTaskContentRequest
        @return: UpdateTaskContentResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_content_with_options(request, runtime)

    async def update_task_content_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskContentRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskContentResponse:
        """
        @summary Updates tasks in a task flow.
        
        @description You can call this operation to modify node configurations.
        
        @param request: UpdateTaskContentRequest
        @return: UpdateTaskContentResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_content_with_options_async(request, runtime)

    def update_task_content_v2with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskContentV2Request,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskContentV2Response:
        """
        @summary 大sql更新节点专用
        
        @param request: UpdateTaskContentV2Request
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskContentV2Response
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        body = {}
        if not UtilClient.is_unset(request.node_content):
            body['NodeContent'] = request.node_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateTaskContentV2',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskContentV2Response(),
            self.call_api(params, req, runtime)
        )

    async def update_task_content_v2with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskContentV2Request,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskContentV2Response:
        """
        @summary 大sql更新节点专用
        
        @param request: UpdateTaskContentV2Request
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskContentV2Response
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        body = {}
        if not UtilClient.is_unset(request.node_content):
            body['NodeContent'] = request.node_content
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateTaskContentV2',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskContentV2Response(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_content_v2(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskContentV2Request,
    ) -> dms_enterprise_20181101_models.UpdateTaskContentV2Response:
        """
        @summary 大sql更新节点专用
        
        @param request: UpdateTaskContentV2Request
        @return: UpdateTaskContentV2Response
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_content_v2with_options(request, runtime)

    async def update_task_content_v2_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskContentV2Request,
    ) -> dms_enterprise_20181101_models.UpdateTaskContentV2Response:
        """
        @summary 大sql更新节点专用
        
        @param request: UpdateTaskContentV2Request
        @return: UpdateTaskContentV2Response
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_content_v2with_options_async(request, runtime)

    def update_task_flow_constants_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateTaskFlowConstantsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowConstantsResponse:
        """
        @summary Updates the constants for a specified task flow.
        
        @param tmp_req: UpdateTaskFlowConstantsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowConstantsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateTaskFlowConstantsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.dag_constants):
            request.dag_constants_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.dag_constants, 'DagConstants', 'json')
        query = {}
        if not UtilClient.is_unset(request.dag_constants_shrink):
            query['DagConstants'] = request.dag_constants_shrink
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowConstants',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowConstantsResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_flow_constants_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateTaskFlowConstantsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowConstantsResponse:
        """
        @summary Updates the constants for a specified task flow.
        
        @param tmp_req: UpdateTaskFlowConstantsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowConstantsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateTaskFlowConstantsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.dag_constants):
            request.dag_constants_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.dag_constants, 'DagConstants', 'json')
        query = {}
        if not UtilClient.is_unset(request.dag_constants_shrink):
            query['DagConstants'] = request.dag_constants_shrink
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowConstants',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowConstantsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_flow_constants(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowConstantsRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowConstantsResponse:
        """
        @summary Updates the constants for a specified task flow.
        
        @param request: UpdateTaskFlowConstantsRequest
        @return: UpdateTaskFlowConstantsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_flow_constants_with_options(request, runtime)

    async def update_task_flow_constants_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowConstantsRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowConstantsResponse:
        """
        @summary Updates the constants for a specified task flow.
        
        @param request: UpdateTaskFlowConstantsRequest
        @return: UpdateTaskFlowConstantsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_flow_constants_with_options_async(request, runtime)

    def update_task_flow_cooperators_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateTaskFlowCooperatorsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowCooperatorsResponse:
        """
        @summary Updates the IDs of the users who are involved in the task flow.
        
        @param tmp_req: UpdateTaskFlowCooperatorsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowCooperatorsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateTaskFlowCooperatorsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.cooperator_ids):
            request.cooperator_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.cooperator_ids, 'CooperatorIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.cooperator_ids_shrink):
            query['CooperatorIds'] = request.cooperator_ids_shrink
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowCooperators',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowCooperatorsResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_flow_cooperators_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateTaskFlowCooperatorsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowCooperatorsResponse:
        """
        @summary Updates the IDs of the users who are involved in the task flow.
        
        @param tmp_req: UpdateTaskFlowCooperatorsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowCooperatorsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateTaskFlowCooperatorsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.cooperator_ids):
            request.cooperator_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.cooperator_ids, 'CooperatorIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.cooperator_ids_shrink):
            query['CooperatorIds'] = request.cooperator_ids_shrink
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowCooperators',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowCooperatorsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_flow_cooperators(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowCooperatorsRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowCooperatorsResponse:
        """
        @summary Updates the IDs of the users who are involved in the task flow.
        
        @param request: UpdateTaskFlowCooperatorsRequest
        @return: UpdateTaskFlowCooperatorsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_flow_cooperators_with_options(request, runtime)

    async def update_task_flow_cooperators_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowCooperatorsRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowCooperatorsResponse:
        """
        @summary Updates the IDs of the users who are involved in the task flow.
        
        @param request: UpdateTaskFlowCooperatorsRequest
        @return: UpdateTaskFlowCooperatorsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_flow_cooperators_with_options_async(request, runtime)

    def update_task_flow_edges_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateTaskFlowEdgesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowEdgesResponse:
        """
        @summary Updates the start node and end node of multiple edges at a time for a task flow.
        
        @description ###
        The edges can be updated only when the following conditions are met:
        1.  The specified edge exists in the directed acyclic graph (DAG) of the task flow specified by DagId.
        2.  The specified edge nodes exist in the DAG of the task flow specified by DagId.
        3.  After the update, rings do not exist in the DAG.
        
        @param tmp_req: UpdateTaskFlowEdgesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowEdgesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateTaskFlowEdgesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.edges):
            request.edges_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.edges, 'Edges', 'json')
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.edges_shrink):
            query['Edges'] = request.edges_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowEdges',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowEdgesResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_flow_edges_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateTaskFlowEdgesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowEdgesResponse:
        """
        @summary Updates the start node and end node of multiple edges at a time for a task flow.
        
        @description ###
        The edges can be updated only when the following conditions are met:
        1.  The specified edge exists in the directed acyclic graph (DAG) of the task flow specified by DagId.
        2.  The specified edge nodes exist in the DAG of the task flow specified by DagId.
        3.  After the update, rings do not exist in the DAG.
        
        @param tmp_req: UpdateTaskFlowEdgesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowEdgesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateTaskFlowEdgesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.edges):
            request.edges_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.edges, 'Edges', 'json')
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.edges_shrink):
            query['Edges'] = request.edges_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowEdges',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowEdgesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_flow_edges(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowEdgesRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowEdgesResponse:
        """
        @summary Updates the start node and end node of multiple edges at a time for a task flow.
        
        @description ###
        The edges can be updated only when the following conditions are met:
        1.  The specified edge exists in the directed acyclic graph (DAG) of the task flow specified by DagId.
        2.  The specified edge nodes exist in the DAG of the task flow specified by DagId.
        3.  After the update, rings do not exist in the DAG.
        
        @param request: UpdateTaskFlowEdgesRequest
        @return: UpdateTaskFlowEdgesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_flow_edges_with_options(request, runtime)

    async def update_task_flow_edges_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowEdgesRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowEdgesResponse:
        """
        @summary Updates the start node and end node of multiple edges at a time for a task flow.
        
        @description ###
        The edges can be updated only when the following conditions are met:
        1.  The specified edge exists in the directed acyclic graph (DAG) of the task flow specified by DagId.
        2.  The specified edge nodes exist in the DAG of the task flow specified by DagId.
        3.  After the update, rings do not exist in the DAG.
        
        @param request: UpdateTaskFlowEdgesRequest
        @return: UpdateTaskFlowEdgesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_flow_edges_with_options_async(request, runtime)

    def update_task_flow_name_and_desc_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowNameAndDescRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowNameAndDescResponse:
        """
        @summary Updates the name and description of a task flow.
        
        @param request: UpdateTaskFlowNameAndDescRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowNameAndDescResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_name):
            query['DagName'] = request.dag_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowNameAndDesc',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowNameAndDescResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_flow_name_and_desc_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowNameAndDescRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowNameAndDescResponse:
        """
        @summary Updates the name and description of a task flow.
        
        @param request: UpdateTaskFlowNameAndDescRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowNameAndDescResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_name):
            query['DagName'] = request.dag_name
        if not UtilClient.is_unset(request.description):
            query['Description'] = request.description
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowNameAndDesc',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowNameAndDescResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_flow_name_and_desc(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowNameAndDescRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowNameAndDescResponse:
        """
        @summary Updates the name and description of a task flow.
        
        @param request: UpdateTaskFlowNameAndDescRequest
        @return: UpdateTaskFlowNameAndDescResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_flow_name_and_desc_with_options(request, runtime)

    async def update_task_flow_name_and_desc_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowNameAndDescRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowNameAndDescResponse:
        """
        @summary Updates the name and description of a task flow.
        
        @param request: UpdateTaskFlowNameAndDescRequest
        @return: UpdateTaskFlowNameAndDescResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_flow_name_and_desc_with_options_async(request, runtime)

    def update_task_flow_notification_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowNotificationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowNotificationResponse:
        """
        @summary Updates the notification settings for task flows.
        
        @param request: UpdateTaskFlowNotificationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowNotificationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_notification_fail):
            query['DagNotificationFail'] = request.dag_notification_fail
        if not UtilClient.is_unset(request.dag_notification_sla):
            query['DagNotificationSla'] = request.dag_notification_sla
        if not UtilClient.is_unset(request.dag_notification_success):
            query['DagNotificationSuccess'] = request.dag_notification_success
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowNotification',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowNotificationResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_flow_notification_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowNotificationRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowNotificationResponse:
        """
        @summary Updates the notification settings for task flows.
        
        @param request: UpdateTaskFlowNotificationRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowNotificationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.dag_notification_fail):
            query['DagNotificationFail'] = request.dag_notification_fail
        if not UtilClient.is_unset(request.dag_notification_sla):
            query['DagNotificationSla'] = request.dag_notification_sla
        if not UtilClient.is_unset(request.dag_notification_success):
            query['DagNotificationSuccess'] = request.dag_notification_success
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowNotification',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowNotificationResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_flow_notification(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowNotificationRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowNotificationResponse:
        """
        @summary Updates the notification settings for task flows.
        
        @param request: UpdateTaskFlowNotificationRequest
        @return: UpdateTaskFlowNotificationResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_flow_notification_with_options(request, runtime)

    async def update_task_flow_notification_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowNotificationRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowNotificationResponse:
        """
        @summary Updates the notification settings for task flows.
        
        @param request: UpdateTaskFlowNotificationRequest
        @return: UpdateTaskFlowNotificationResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_flow_notification_with_options_async(request, runtime)

    def update_task_flow_owner_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowOwnerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowOwnerResponse:
        """
        @summary Changes the owner of a task flow.
        
        @description Note: The new owner of the task flow must belong to the same tenant as the previous owner.
        
        @param request: UpdateTaskFlowOwnerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowOwnerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.new_owner_id):
            query['NewOwnerId'] = request.new_owner_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowOwner',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowOwnerResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_flow_owner_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowOwnerRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowOwnerResponse:
        """
        @summary Changes the owner of a task flow.
        
        @description Note: The new owner of the task flow must belong to the same tenant as the previous owner.
        
        @param request: UpdateTaskFlowOwnerRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowOwnerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.new_owner_id):
            query['NewOwnerId'] = request.new_owner_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowOwner',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowOwnerResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_flow_owner(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowOwnerRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowOwnerResponse:
        """
        @summary Changes the owner of a task flow.
        
        @description Note: The new owner of the task flow must belong to the same tenant as the previous owner.
        
        @param request: UpdateTaskFlowOwnerRequest
        @return: UpdateTaskFlowOwnerResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_flow_owner_with_options(request, runtime)

    async def update_task_flow_owner_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowOwnerRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowOwnerResponse:
        """
        @summary Changes the owner of a task flow.
        
        @description Note: The new owner of the task flow must belong to the same tenant as the previous owner.
        
        @param request: UpdateTaskFlowOwnerRequest
        @return: UpdateTaskFlowOwnerResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_flow_owner_with_options_async(request, runtime)

    def update_task_flow_relations_with_options(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateTaskFlowRelationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowRelationsResponse:
        """
        @summary Fully updates the edges of a task flow.
        
        @description You can call this operation to perform a full update. For incremental updates, see AddTaskFlowEdges, UpdateTaskFlowEdges, and DeleteTaskFlowEdgesByMultiCondition.
        
        @param tmp_req: UpdateTaskFlowRelationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowRelationsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateTaskFlowRelationsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.edges):
            request.edges_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.edges, 'Edges', 'json')
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.edges_shrink):
            query['Edges'] = request.edges_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowRelations',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowRelationsResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_flow_relations_with_options_async(
        self,
        tmp_req: dms_enterprise_20181101_models.UpdateTaskFlowRelationsRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowRelationsResponse:
        """
        @summary Fully updates the edges of a task flow.
        
        @description You can call this operation to perform a full update. For incremental updates, see AddTaskFlowEdges, UpdateTaskFlowEdges, and DeleteTaskFlowEdgesByMultiCondition.
        
        @param tmp_req: UpdateTaskFlowRelationsRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowRelationsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = dms_enterprise_20181101_models.UpdateTaskFlowRelationsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.edges):
            request.edges_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.edges, 'Edges', 'json')
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.edges_shrink):
            query['Edges'] = request.edges_shrink
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowRelations',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowRelationsResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_flow_relations(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowRelationsRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowRelationsResponse:
        """
        @summary Fully updates the edges of a task flow.
        
        @description You can call this operation to perform a full update. For incremental updates, see AddTaskFlowEdges, UpdateTaskFlowEdges, and DeleteTaskFlowEdgesByMultiCondition.
        
        @param request: UpdateTaskFlowRelationsRequest
        @return: UpdateTaskFlowRelationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_flow_relations_with_options(request, runtime)

    async def update_task_flow_relations_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowRelationsRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowRelationsResponse:
        """
        @summary Fully updates the edges of a task flow.
        
        @description You can call this operation to perform a full update. For incremental updates, see AddTaskFlowEdges, UpdateTaskFlowEdges, and DeleteTaskFlowEdgesByMultiCondition.
        
        @param request: UpdateTaskFlowRelationsRequest
        @return: UpdateTaskFlowRelationsResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_flow_relations_with_options_async(request, runtime)

    def update_task_flow_schedule_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowScheduleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowScheduleResponse:
        """
        @summary Updates the scheduling properties for a task flow.
        
        @description You can call this operation to update the scheduling properties for a task flow in the editing state. You can configure a *timed scheduling** task flow or an **event scheduling** task flow. When you configure a **timed scheduling** task flow, you can choose from one-time scheduling or periodic scheduling. When you configure an **event scheduling** task flow, you can subscribe to task flows or task flow nodes.****\\
        After you update the scheduling properties, you need to publish and deploy the task flow again. The new task flow instance will run based on the updated scheduling properties.
        
        @param request: UpdateTaskFlowScheduleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowScheduleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cron_begin_date):
            query['CronBeginDate'] = request.cron_begin_date
        if not UtilClient.is_unset(request.cron_end_date):
            query['CronEndDate'] = request.cron_end_date
        if not UtilClient.is_unset(request.cron_str):
            query['CronStr'] = request.cron_str
        if not UtilClient.is_unset(request.cron_type):
            query['CronType'] = request.cron_type
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.schedule_param):
            query['ScheduleParam'] = request.schedule_param
        if not UtilClient.is_unset(request.schedule_switch):
            query['ScheduleSwitch'] = request.schedule_switch
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.time_zone_id):
            query['TimeZoneId'] = request.time_zone_id
        if not UtilClient.is_unset(request.trigger_type):
            query['TriggerType'] = request.trigger_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowSchedule',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowScheduleResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_flow_schedule_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowScheduleRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowScheduleResponse:
        """
        @summary Updates the scheduling properties for a task flow.
        
        @description You can call this operation to update the scheduling properties for a task flow in the editing state. You can configure a *timed scheduling** task flow or an **event scheduling** task flow. When you configure a **timed scheduling** task flow, you can choose from one-time scheduling or periodic scheduling. When you configure an **event scheduling** task flow, you can subscribe to task flows or task flow nodes.****\\
        After you update the scheduling properties, you need to publish and deploy the task flow again. The new task flow instance will run based on the updated scheduling properties.
        
        @param request: UpdateTaskFlowScheduleRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowScheduleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cron_begin_date):
            query['CronBeginDate'] = request.cron_begin_date
        if not UtilClient.is_unset(request.cron_end_date):
            query['CronEndDate'] = request.cron_end_date
        if not UtilClient.is_unset(request.cron_str):
            query['CronStr'] = request.cron_str
        if not UtilClient.is_unset(request.cron_type):
            query['CronType'] = request.cron_type
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.schedule_param):
            query['ScheduleParam'] = request.schedule_param
        if not UtilClient.is_unset(request.schedule_switch):
            query['ScheduleSwitch'] = request.schedule_switch
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.time_zone_id):
            query['TimeZoneId'] = request.time_zone_id
        if not UtilClient.is_unset(request.trigger_type):
            query['TriggerType'] = request.trigger_type
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowSchedule',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowScheduleResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_flow_schedule(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowScheduleRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowScheduleResponse:
        """
        @summary Updates the scheduling properties for a task flow.
        
        @description You can call this operation to update the scheduling properties for a task flow in the editing state. You can configure a *timed scheduling** task flow or an **event scheduling** task flow. When you configure a **timed scheduling** task flow, you can choose from one-time scheduling or periodic scheduling. When you configure an **event scheduling** task flow, you can subscribe to task flows or task flow nodes.****\\
        After you update the scheduling properties, you need to publish and deploy the task flow again. The new task flow instance will run based on the updated scheduling properties.
        
        @param request: UpdateTaskFlowScheduleRequest
        @return: UpdateTaskFlowScheduleResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_flow_schedule_with_options(request, runtime)

    async def update_task_flow_schedule_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowScheduleRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowScheduleResponse:
        """
        @summary Updates the scheduling properties for a task flow.
        
        @description You can call this operation to update the scheduling properties for a task flow in the editing state. You can configure a *timed scheduling** task flow or an **event scheduling** task flow. When you configure a **timed scheduling** task flow, you can choose from one-time scheduling or periodic scheduling. When you configure an **event scheduling** task flow, you can subscribe to task flows or task flow nodes.****\\
        After you update the scheduling properties, you need to publish and deploy the task flow again. The new task flow instance will run based on the updated scheduling properties.
        
        @param request: UpdateTaskFlowScheduleRequest
        @return: UpdateTaskFlowScheduleResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_flow_schedule_with_options_async(request, runtime)

    def update_task_flow_time_variables_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowTimeVariablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowTimeVariablesResponse:
        """
        @summary Updates the time variables for a task flow.
        
        @param request: UpdateTaskFlowTimeVariablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowTimeVariablesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.time_variables):
            query['TimeVariables'] = request.time_variables
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowTimeVariables',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowTimeVariablesResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_flow_time_variables_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowTimeVariablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowTimeVariablesResponse:
        """
        @summary Updates the time variables for a task flow.
        
        @param request: UpdateTaskFlowTimeVariablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskFlowTimeVariablesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.dag_id):
            query['DagId'] = request.dag_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.time_variables):
            query['TimeVariables'] = request.time_variables
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskFlowTimeVariables',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskFlowTimeVariablesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_flow_time_variables(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowTimeVariablesRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowTimeVariablesResponse:
        """
        @summary Updates the time variables for a task flow.
        
        @param request: UpdateTaskFlowTimeVariablesRequest
        @return: UpdateTaskFlowTimeVariablesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_flow_time_variables_with_options(request, runtime)

    async def update_task_flow_time_variables_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskFlowTimeVariablesRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskFlowTimeVariablesResponse:
        """
        @summary Updates the time variables for a task flow.
        
        @param request: UpdateTaskFlowTimeVariablesRequest
        @return: UpdateTaskFlowTimeVariablesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_flow_time_variables_with_options_async(request, runtime)

    def update_task_name_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskNameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskNameResponse:
        """
        @summary Updates the name of a specified task.
        
        @param request: UpdateTaskNameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskNameResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.node_name):
            query['NodeName'] = request.node_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskName',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskNameResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_name_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskNameRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskNameResponse:
        """
        @summary Updates the name of a specified task.
        
        @param request: UpdateTaskNameRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskNameResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.node_name):
            query['NodeName'] = request.node_name
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskName',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskNameResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_name(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskNameRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskNameResponse:
        """
        @summary Updates the name of a specified task.
        
        @param request: UpdateTaskNameRequest
        @return: UpdateTaskNameResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_name_with_options(request, runtime)

    async def update_task_name_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskNameRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskNameResponse:
        """
        @summary Updates the name of a specified task.
        
        @param request: UpdateTaskNameRequest
        @return: UpdateTaskNameResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_name_with_options_async(request, runtime)

    def update_task_output_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskOutputRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskOutputResponse:
        """
        @summary Updates the output variables for a specified task node.
        
        @description Only nodes of single-instance SQL assignment, script code, and ECS remote command have output variables.
        
        @param request: UpdateTaskOutputRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskOutputResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.node_output):
            query['NodeOutput'] = request.node_output
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskOutput',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskOutputResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_output_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskOutputRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskOutputResponse:
        """
        @summary Updates the output variables for a specified task node.
        
        @description Only nodes of single-instance SQL assignment, script code, and ECS remote command have output variables.
        
        @param request: UpdateTaskOutputRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskOutputResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.node_output):
            query['NodeOutput'] = request.node_output
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskOutput',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskOutputResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_output(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskOutputRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskOutputResponse:
        """
        @summary Updates the output variables for a specified task node.
        
        @description Only nodes of single-instance SQL assignment, script code, and ECS remote command have output variables.
        
        @param request: UpdateTaskOutputRequest
        @return: UpdateTaskOutputResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_output_with_options(request, runtime)

    async def update_task_output_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskOutputRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskOutputResponse:
        """
        @summary Updates the output variables for a specified task node.
        
        @description Only nodes of single-instance SQL assignment, script code, and ECS remote command have output variables.
        
        @param request: UpdateTaskOutputRequest
        @return: UpdateTaskOutputResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_output_with_options_async(request, runtime)

    def update_task_time_variables_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskTimeVariablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskTimeVariablesResponse:
        """
        @summary Updates time variables for a task.
        
        @param request: UpdateTaskTimeVariablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskTimeVariablesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.time_variables):
            query['TimeVariables'] = request.time_variables
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskTimeVariables',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskTimeVariablesResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_task_time_variables_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskTimeVariablesRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateTaskTimeVariablesResponse:
        """
        @summary Updates time variables for a task.
        
        @param request: UpdateTaskTimeVariablesRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTaskTimeVariablesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.node_id):
            query['NodeId'] = request.node_id
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.time_variables):
            query['TimeVariables'] = request.time_variables
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTaskTimeVariables',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateTaskTimeVariablesResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_task_time_variables(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskTimeVariablesRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskTimeVariablesResponse:
        """
        @summary Updates time variables for a task.
        
        @param request: UpdateTaskTimeVariablesRequest
        @return: UpdateTaskTimeVariablesResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_task_time_variables_with_options(request, runtime)

    async def update_task_time_variables_async(
        self,
        request: dms_enterprise_20181101_models.UpdateTaskTimeVariablesRequest,
    ) -> dms_enterprise_20181101_models.UpdateTaskTimeVariablesResponse:
        """
        @summary Updates time variables for a task.
        
        @param request: UpdateTaskTimeVariablesRequest
        @return: UpdateTaskTimeVariablesResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_task_time_variables_with_options_async(request, runtime)

    def update_user_with_options(
        self,
        request: dms_enterprise_20181101_models.UpdateUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateUserResponse:
        """
        @summary Updates user information.
        
        @param request: UpdateUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_execute_count):
            query['MaxExecuteCount'] = request.max_execute_count
        if not UtilClient.is_unset(request.max_result_count):
            query['MaxResultCount'] = request.max_result_count
        if not UtilClient.is_unset(request.mobile):
            query['Mobile'] = request.mobile
        if not UtilClient.is_unset(request.role_names):
            query['RoleNames'] = request.role_names
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.uid):
            query['Uid'] = request.uid
        if not UtilClient.is_unset(request.uid_string):
            query['UidString'] = request.uid_string
        if not UtilClient.is_unset(request.user_nick):
            query['UserNick'] = request.user_nick
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateUserResponse(),
            self.call_api(params, req, runtime)
        )

    async def update_user_with_options_async(
        self,
        request: dms_enterprise_20181101_models.UpdateUserRequest,
        runtime: util_models.RuntimeOptions,
    ) -> dms_enterprise_20181101_models.UpdateUserResponse:
        """
        @summary Updates user information.
        
        @param request: UpdateUserRequest
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateUserResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_execute_count):
            query['MaxExecuteCount'] = request.max_execute_count
        if not UtilClient.is_unset(request.max_result_count):
            query['MaxResultCount'] = request.max_result_count
        if not UtilClient.is_unset(request.mobile):
            query['Mobile'] = request.mobile
        if not UtilClient.is_unset(request.role_names):
            query['RoleNames'] = request.role_names
        if not UtilClient.is_unset(request.tid):
            query['Tid'] = request.tid
        if not UtilClient.is_unset(request.uid):
            query['Uid'] = request.uid
        if not UtilClient.is_unset(request.uid_string):
            query['UidString'] = request.uid_string
        if not UtilClient.is_unset(request.user_nick):
            query['UserNick'] = request.user_nick
        req = open_api_models.OpenApiRequest(
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateUser',
            version='2018-11-01',
            protocol='HTTPS',
            pathname='/',
            method='POST',
            auth_type='AK',
            style='RPC',
            req_body_type='formData',
            body_type='json'
        )
        return TeaCore.from_map(
            dms_enterprise_20181101_models.UpdateUserResponse(),
            await self.call_api_async(params, req, runtime)
        )

    def update_user(
        self,
        request: dms_enterprise_20181101_models.UpdateUserRequest,
    ) -> dms_enterprise_20181101_models.UpdateUserResponse:
        """
        @summary Updates user information.
        
        @param request: UpdateUserRequest
        @return: UpdateUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return self.update_user_with_options(request, runtime)

    async def update_user_async(
        self,
        request: dms_enterprise_20181101_models.UpdateUserRequest,
    ) -> dms_enterprise_20181101_models.UpdateUserResponse:
        """
        @summary Updates user information.
        
        @param request: UpdateUserRequest
        @return: UpdateUserResponse
        """
        runtime = util_models.RuntimeOptions()
        return await self.update_user_with_options_async(request, runtime)
