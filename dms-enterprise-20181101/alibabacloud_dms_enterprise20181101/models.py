# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import Dict, Any, List


class AsyncTaskVO(TeaModel):
    def __init__(
        self,
        dataset_id: str = None,
        id: int = None,
        remark: str = None,
        task_name: str = None,
        task_status: int = None,
        task_type: int = None,
        user_id: int = None,
    ):
        self.dataset_id = dataset_id
        self.id = id
        self.remark = remark
        self.task_name = task_name
        self.task_status = task_status
        self.task_type = task_type
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.id is not None:
            result['Id'] = self.id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ColumnKnowledgeInfo(TeaModel):
    def __init__(
        self,
        asset_description: str = None,
        asset_modified_gmt: str = None,
        column_name: str = None,
        column_type: str = None,
        description: str = None,
        position: int = None,
    ):
        self.asset_description = asset_description
        self.asset_modified_gmt = asset_modified_gmt
        self.column_name = column_name
        self.column_type = column_type
        self.description = description
        self.position = position

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_description is not None:
            result['AssetDescription'] = self.asset_description
        if self.asset_modified_gmt is not None:
            result['AssetModifiedGmt'] = self.asset_modified_gmt
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.description is not None:
            result['Description'] = self.description
        if self.position is not None:
            result['Position'] = self.position
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetDescription') is not None:
            self.asset_description = m.get('AssetDescription')
        if m.get('AssetModifiedGmt') is not None:
            self.asset_modified_gmt = m.get('AssetModifiedGmt')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        return self


class DLCatalog(TeaModel):
    def __init__(
        self,
        description: str = None,
        location: str = None,
        name: str = None,
    ):
        self.description = description
        self.location = location
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.location is not None:
            result['Location'] = self.location
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DLColumn(TeaModel):
    def __init__(
        self,
        comment: str = None,
        name: str = None,
        type: str = None,
    ):
        self.comment = comment
        self.name = name
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DLDatabase(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        db_id: int = None,
        description: str = None,
        location: str = None,
        name: str = None,
        parameters: Dict[str, Any] = None,
    ):
        self.catalog_name = catalog_name
        self.db_id = db_id
        self.description = description
        self.location = location
        self.name = name
        self.parameters = parameters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.description is not None:
            result['Description'] = self.description
        if self.location is not None:
            result['Location'] = self.location
        if self.name is not None:
            result['Name'] = self.name
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        return self


class DLResourceUri(TeaModel):
    def __init__(
        self,
        resource_type: str = None,
        uri: str = None,
    ):
        self.resource_type = resource_type
        self.uri = uri

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.uri is not None:
            result['Uri'] = self.uri
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Uri') is not None:
            self.uri = m.get('Uri')
        return self


class DLFunction(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        class_name: str = None,
        create_time: int = None,
        creator_id: int = None,
        db_name: str = None,
        function_name: str = None,
        function_type: str = None,
        modifier_id: int = None,
        owner_name: str = None,
        owner_type: str = None,
        resource_uris: List[DLResourceUri] = None,
    ):
        self.catalog_name = catalog_name
        self.class_name = class_name
        self.create_time = create_time
        self.creator_id = creator_id
        self.db_name = db_name
        self.function_name = function_name
        self.function_type = function_type
        self.modifier_id = modifier_id
        self.owner_name = owner_name
        self.owner_type = owner_type
        self.resource_uris = resource_uris

    def validate(self):
        if self.resource_uris:
            for k in self.resource_uris:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.class_name is not None:
            result['ClassName'] = self.class_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.owner_name is not None:
            result['OwnerName'] = self.owner_name
        if self.owner_type is not None:
            result['OwnerType'] = self.owner_type
        result['ResourceUris'] = []
        if self.resource_uris is not None:
            for k in self.resource_uris:
                result['ResourceUris'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('ClassName') is not None:
            self.class_name = m.get('ClassName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('OwnerName') is not None:
            self.owner_name = m.get('OwnerName')
        if m.get('OwnerType') is not None:
            self.owner_type = m.get('OwnerType')
        self.resource_uris = []
        if m.get('ResourceUris') is not None:
            for k in m.get('ResourceUris'):
                temp_model = DLResourceUri()
                self.resource_uris.append(temp_model.from_map(k))
        return self


class DLFunctionInput(TeaModel):
    def __init__(
        self,
        class_name: str = None,
        create_time: int = None,
        creator_id: int = None,
        function_name: str = None,
        function_type: str = None,
        modifier_id: int = None,
        owner_name: str = None,
        owner_type: str = None,
        resource_uris: List[DLResourceUri] = None,
    ):
        self.class_name = class_name
        self.create_time = create_time
        self.creator_id = creator_id
        self.function_name = function_name
        self.function_type = function_type
        self.modifier_id = modifier_id
        self.owner_name = owner_name
        self.owner_type = owner_type
        self.resource_uris = resource_uris

    def validate(self):
        if self.resource_uris:
            for k in self.resource_uris:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.class_name is not None:
            result['ClassName'] = self.class_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.owner_name is not None:
            result['OwnerName'] = self.owner_name
        if self.owner_type is not None:
            result['OwnerType'] = self.owner_type
        result['ResourceUris'] = []
        if self.resource_uris is not None:
            for k in self.resource_uris:
                result['ResourceUris'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClassName') is not None:
            self.class_name = m.get('ClassName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('OwnerName') is not None:
            self.owner_name = m.get('OwnerName')
        if m.get('OwnerType') is not None:
            self.owner_type = m.get('OwnerType')
        self.resource_uris = []
        if m.get('ResourceUris') is not None:
            for k in m.get('ResourceUris'):
                temp_model = DLResourceUri()
                self.resource_uris.append(temp_model.from_map(k))
        return self


class DLOrder(TeaModel):
    def __init__(
        self,
        col: str = None,
        order: int = None,
    ):
        self.col = col
        self.order = order

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.col is not None:
            result['Col'] = self.col
        if self.order is not None:
            result['Order'] = self.order
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Col') is not None:
            self.col = m.get('Col')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        return self


class DLSerdeInfo(TeaModel):
    def __init__(
        self,
        description: str = None,
        deserializer_class: str = None,
        name: str = None,
        parameters: Dict[str, Any] = None,
        serde_type: int = None,
        serialization_lib: str = None,
        serializer_class: str = None,
    ):
        self.description = description
        self.deserializer_class = deserializer_class
        self.name = name
        self.parameters = parameters
        self.serde_type = serde_type
        self.serialization_lib = serialization_lib
        self.serializer_class = serializer_class

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.deserializer_class is not None:
            result['DeserializerClass'] = self.deserializer_class
        if self.name is not None:
            result['Name'] = self.name
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.serde_type is not None:
            result['SerdeType'] = self.serde_type
        if self.serialization_lib is not None:
            result['SerializationLib'] = self.serialization_lib
        if self.serializer_class is not None:
            result['SerializerClass'] = self.serializer_class
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DeserializerClass') is not None:
            self.deserializer_class = m.get('DeserializerClass')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('SerdeType') is not None:
            self.serde_type = m.get('SerdeType')
        if m.get('SerializationLib') is not None:
            self.serialization_lib = m.get('SerializationLib')
        if m.get('SerializerClass') is not None:
            self.serializer_class = m.get('SerializerClass')
        return self


class DLSkewedInfo(TeaModel):
    def __init__(
        self,
        skewed_col_names: List[str] = None,
        skewed_col_value_location_maps: Dict[str, Any] = None,
        skewed_col_values: List[List[str]] = None,
    ):
        self.skewed_col_names = skewed_col_names
        self.skewed_col_value_location_maps = skewed_col_value_location_maps
        self.skewed_col_values = skewed_col_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.skewed_col_names is not None:
            result['SkewedColNames'] = self.skewed_col_names
        if self.skewed_col_value_location_maps is not None:
            result['SkewedColValueLocationMaps'] = self.skewed_col_value_location_maps
        if self.skewed_col_values is not None:
            result['SkewedColValues'] = self.skewed_col_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SkewedColNames') is not None:
            self.skewed_col_names = m.get('SkewedColNames')
        if m.get('SkewedColValueLocationMaps') is not None:
            self.skewed_col_value_location_maps = m.get('SkewedColValueLocationMaps')
        if m.get('SkewedColValues') is not None:
            self.skewed_col_values = m.get('SkewedColValues')
        return self


class DLStorageDescriptor(TeaModel):
    def __init__(
        self,
        bucket_cols: List[str] = None,
        columns: List[DLColumn] = None,
        input_format: str = None,
        is_compressed: bool = None,
        location: str = None,
        num_buckets: int = None,
        original_columns: List[DLColumn] = None,
        output_format: str = None,
        parameters: Dict[str, Any] = None,
        serde_info: DLSerdeInfo = None,
        skewed_info: DLSkewedInfo = None,
        sort_cols: List[DLOrder] = None,
    ):
        self.bucket_cols = bucket_cols
        self.columns = columns
        self.input_format = input_format
        self.is_compressed = is_compressed
        self.location = location
        self.num_buckets = num_buckets
        self.original_columns = original_columns
        self.output_format = output_format
        self.parameters = parameters
        self.serde_info = serde_info
        self.skewed_info = skewed_info
        self.sort_cols = sort_cols

    def validate(self):
        if self.columns:
            for k in self.columns:
                if k:
                    k.validate()
        if self.original_columns:
            for k in self.original_columns:
                if k:
                    k.validate()
        if self.serde_info:
            self.serde_info.validate()
        if self.skewed_info:
            self.skewed_info.validate()
        if self.sort_cols:
            for k in self.sort_cols:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_cols is not None:
            result['BucketCols'] = self.bucket_cols
        result['Columns'] = []
        if self.columns is not None:
            for k in self.columns:
                result['Columns'].append(k.to_map() if k else None)
        if self.input_format is not None:
            result['InputFormat'] = self.input_format
        if self.is_compressed is not None:
            result['IsCompressed'] = self.is_compressed
        if self.location is not None:
            result['Location'] = self.location
        if self.num_buckets is not None:
            result['NumBuckets'] = self.num_buckets
        result['OriginalColumns'] = []
        if self.original_columns is not None:
            for k in self.original_columns:
                result['OriginalColumns'].append(k.to_map() if k else None)
        if self.output_format is not None:
            result['OutputFormat'] = self.output_format
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.serde_info is not None:
            result['SerdeInfo'] = self.serde_info.to_map()
        if self.skewed_info is not None:
            result['SkewedInfo'] = self.skewed_info.to_map()
        result['SortCols'] = []
        if self.sort_cols is not None:
            for k in self.sort_cols:
                result['SortCols'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketCols') is not None:
            self.bucket_cols = m.get('BucketCols')
        self.columns = []
        if m.get('Columns') is not None:
            for k in m.get('Columns'):
                temp_model = DLColumn()
                self.columns.append(temp_model.from_map(k))
        if m.get('InputFormat') is not None:
            self.input_format = m.get('InputFormat')
        if m.get('IsCompressed') is not None:
            self.is_compressed = m.get('IsCompressed')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('NumBuckets') is not None:
            self.num_buckets = m.get('NumBuckets')
        self.original_columns = []
        if m.get('OriginalColumns') is not None:
            for k in m.get('OriginalColumns'):
                temp_model = DLColumn()
                self.original_columns.append(temp_model.from_map(k))
        if m.get('OutputFormat') is not None:
            self.output_format = m.get('OutputFormat')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('SerdeInfo') is not None:
            temp_model = DLSerdeInfo()
            self.serde_info = temp_model.from_map(m['SerdeInfo'])
        if m.get('SkewedInfo') is not None:
            temp_model = DLSkewedInfo()
            self.skewed_info = temp_model.from_map(m['SkewedInfo'])
        self.sort_cols = []
        if m.get('SortCols') is not None:
            for k in m.get('SortCols'):
                temp_model = DLOrder()
                self.sort_cols.append(temp_model.from_map(k))
        return self


class DLPartition(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        create_time: int = None,
        db_name: str = None,
        last_access_time: int = None,
        parameters: Dict[str, str] = None,
        sd: DLStorageDescriptor = None,
        table_name: str = None,
        values: List[str] = None,
    ):
        self.catalog_name = catalog_name
        self.create_time = create_time
        self.db_name = db_name
        self.last_access_time = last_access_time
        self.parameters = parameters
        self.sd = sd
        self.table_name = table_name
        self.values = values

    def validate(self):
        if self.sd:
            self.sd.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.last_access_time is not None:
            result['LastAccessTime'] = self.last_access_time
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.sd is not None:
            result['Sd'] = self.sd.to_map()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('LastAccessTime') is not None:
            self.last_access_time = m.get('LastAccessTime')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('Sd') is not None:
            temp_model = DLStorageDescriptor()
            self.sd = temp_model.from_map(m['Sd'])
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DLPartitionInput(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        last_access_time: int = None,
        parameters: Dict[str, str] = None,
        storage_descriptor: DLStorageDescriptor = None,
        values: List[str] = None,
    ):
        self.create_time = create_time
        self.last_access_time = last_access_time
        self.parameters = parameters
        self.storage_descriptor = storage_descriptor
        self.values = values

    def validate(self):
        if self.storage_descriptor:
            self.storage_descriptor.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_access_time is not None:
            result['LastAccessTime'] = self.last_access_time
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.storage_descriptor is not None:
            result['StorageDescriptor'] = self.storage_descriptor.to_map()
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastAccessTime') is not None:
            self.last_access_time = m.get('LastAccessTime')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('StorageDescriptor') is not None:
            temp_model = DLStorageDescriptor()
            self.storage_descriptor = temp_model.from_map(m['StorageDescriptor'])
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class DLTable(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        create_time: int = None,
        creator_id: int = None,
        db_id: int = None,
        db_name: str = None,
        description: str = None,
        last_access_time: int = None,
        location: str = None,
        modifier_id: int = None,
        name: str = None,
        owner: str = None,
        owner_type: str = None,
        parameters: Dict[str, Any] = None,
        partition_keys: List[DLColumn] = None,
        retention: int = None,
        storage_descriptor: DLStorageDescriptor = None,
        table_type: str = None,
        view_expanded_text: str = None,
        view_original_text: str = None,
    ):
        self.catalog_name = catalog_name
        self.create_time = create_time
        self.creator_id = creator_id
        self.db_id = db_id
        self.db_name = db_name
        self.description = description
        self.last_access_time = last_access_time
        self.location = location
        self.modifier_id = modifier_id
        self.name = name
        self.owner = owner
        self.owner_type = owner_type
        self.parameters = parameters
        self.partition_keys = partition_keys
        self.retention = retention
        self.storage_descriptor = storage_descriptor
        self.table_type = table_type
        self.view_expanded_text = view_expanded_text
        self.view_original_text = view_original_text

    def validate(self):
        if self.partition_keys:
            for k in self.partition_keys:
                if k:
                    k.validate()
        if self.storage_descriptor:
            self.storage_descriptor.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.description is not None:
            result['Description'] = self.description
        if self.last_access_time is not None:
            result['LastAccessTime'] = self.last_access_time
        if self.location is not None:
            result['Location'] = self.location
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.owner_type is not None:
            result['OwnerType'] = self.owner_type
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        result['PartitionKeys'] = []
        if self.partition_keys is not None:
            for k in self.partition_keys:
                result['PartitionKeys'].append(k.to_map() if k else None)
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.storage_descriptor is not None:
            result['StorageDescriptor'] = self.storage_descriptor.to_map()
        if self.table_type is not None:
            result['TableType'] = self.table_type
        if self.view_expanded_text is not None:
            result['ViewExpandedText'] = self.view_expanded_text
        if self.view_original_text is not None:
            result['ViewOriginalText'] = self.view_original_text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('LastAccessTime') is not None:
            self.last_access_time = m.get('LastAccessTime')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('OwnerType') is not None:
            self.owner_type = m.get('OwnerType')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        self.partition_keys = []
        if m.get('PartitionKeys') is not None:
            for k in m.get('PartitionKeys'):
                temp_model = DLColumn()
                self.partition_keys.append(temp_model.from_map(k))
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('StorageDescriptor') is not None:
            temp_model = DLStorageDescriptor()
            self.storage_descriptor = temp_model.from_map(m['StorageDescriptor'])
        if m.get('TableType') is not None:
            self.table_type = m.get('TableType')
        if m.get('ViewExpandedText') is not None:
            self.view_expanded_text = m.get('ViewExpandedText')
        if m.get('ViewOriginalText') is not None:
            self.view_original_text = m.get('ViewOriginalText')
        return self


class DLTablebaseInfo(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        create_time: int = None,
        creator_id: int = None,
        db_id: int = None,
        db_name: str = None,
        description: str = None,
        last_access_time: int = None,
        location: str = None,
        modifier_id: int = None,
        name: str = None,
        owner: str = None,
        owner_type: str = None,
        parameters: Dict[str, Any] = None,
        partition_keys: List[DLColumn] = None,
        retention: int = None,
        table_type: str = None,
        view_expanded_text: str = None,
        view_original_text: str = None,
    ):
        self.catalog_name = catalog_name
        self.create_time = create_time
        self.creator_id = creator_id
        self.db_id = db_id
        self.db_name = db_name
        self.description = description
        self.last_access_time = last_access_time
        self.location = location
        self.modifier_id = modifier_id
        self.name = name
        self.owner = owner
        self.owner_type = owner_type
        self.parameters = parameters
        self.partition_keys = partition_keys
        self.retention = retention
        self.table_type = table_type
        self.view_expanded_text = view_expanded_text
        self.view_original_text = view_original_text

    def validate(self):
        if self.partition_keys:
            for k in self.partition_keys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.description is not None:
            result['Description'] = self.description
        if self.last_access_time is not None:
            result['LastAccessTime'] = self.last_access_time
        if self.location is not None:
            result['Location'] = self.location
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.owner_type is not None:
            result['OwnerType'] = self.owner_type
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        result['PartitionKeys'] = []
        if self.partition_keys is not None:
            for k in self.partition_keys:
                result['PartitionKeys'].append(k.to_map() if k else None)
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.table_type is not None:
            result['TableType'] = self.table_type
        if self.view_expanded_text is not None:
            result['ViewExpandedText'] = self.view_expanded_text
        if self.view_original_text is not None:
            result['ViewOriginalText'] = self.view_original_text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('LastAccessTime') is not None:
            self.last_access_time = m.get('LastAccessTime')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('OwnerType') is not None:
            self.owner_type = m.get('OwnerType')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        self.partition_keys = []
        if m.get('PartitionKeys') is not None:
            for k in m.get('PartitionKeys'):
                temp_model = DLColumn()
                self.partition_keys.append(temp_model.from_map(k))
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('TableType') is not None:
            self.table_type = m.get('TableType')
        if m.get('ViewExpandedText') is not None:
            self.view_expanded_text = m.get('ViewExpandedText')
        if m.get('ViewOriginalText') is not None:
            self.view_original_text = m.get('ViewOriginalText')
        return self


class ProjectDetailsLiteVO(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_name: str = None,
    ):
        self.id = id
        self.project_name = project_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        return self


class DatasetItemVO(TeaModel):
    def __init__(
        self,
        async_task_list: List[AsyncTaskVO] = None,
        dataset_status: int = None,
        dataset_type: int = None,
        digest: str = None,
        file_system: str = None,
        id: str = None,
        key_name: str = None,
        more_info: str = None,
        path: str = None,
        projects_linked: List[ProjectDetailsLiteVO] = None,
        recent_task_status: int = None,
        remark: str = None,
        schema: str = None,
        table_name: str = None,
        url: str = None,
    ):
        self.async_task_list = async_task_list
        self.dataset_status = dataset_status
        self.dataset_type = dataset_type
        self.digest = digest
        self.file_system = file_system
        self.id = id
        self.key_name = key_name
        self.more_info = more_info
        self.path = path
        self.projects_linked = projects_linked
        self.recent_task_status = recent_task_status
        self.remark = remark
        self.schema = schema
        self.table_name = table_name
        self.url = url

    def validate(self):
        if self.async_task_list:
            for k in self.async_task_list:
                if k:
                    k.validate()
        if self.projects_linked:
            for k in self.projects_linked:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AsyncTaskList'] = []
        if self.async_task_list is not None:
            for k in self.async_task_list:
                result['AsyncTaskList'].append(k.to_map() if k else None)
        if self.dataset_status is not None:
            result['DatasetStatus'] = self.dataset_status
        if self.dataset_type is not None:
            result['DatasetType'] = self.dataset_type
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.file_system is not None:
            result['FileSystem'] = self.file_system
        if self.id is not None:
            result['Id'] = self.id
        if self.key_name is not None:
            result['KeyName'] = self.key_name
        if self.more_info is not None:
            result['MoreInfo'] = self.more_info
        if self.path is not None:
            result['Path'] = self.path
        result['ProjectsLinked'] = []
        if self.projects_linked is not None:
            for k in self.projects_linked:
                result['ProjectsLinked'].append(k.to_map() if k else None)
        if self.recent_task_status is not None:
            result['RecentTaskStatus'] = self.recent_task_status
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.schema is not None:
            result['Schema'] = self.schema
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.async_task_list = []
        if m.get('AsyncTaskList') is not None:
            for k in m.get('AsyncTaskList'):
                temp_model = AsyncTaskVO()
                self.async_task_list.append(temp_model.from_map(k))
        if m.get('DatasetStatus') is not None:
            self.dataset_status = m.get('DatasetStatus')
        if m.get('DatasetType') is not None:
            self.dataset_type = m.get('DatasetType')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('FileSystem') is not None:
            self.file_system = m.get('FileSystem')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('KeyName') is not None:
            self.key_name = m.get('KeyName')
        if m.get('MoreInfo') is not None:
            self.more_info = m.get('MoreInfo')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        self.projects_linked = []
        if m.get('ProjectsLinked') is not None:
            for k in m.get('ProjectsLinked'):
                temp_model = ProjectDetailsLiteVO()
                self.projects_linked.append(temp_model.from_map(k))
        if m.get('RecentTaskStatus') is not None:
            self.recent_task_status = m.get('RecentTaskStatus')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Schema') is not None:
            self.schema = m.get('Schema')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetTableDataKeyVO(TeaModel):
    def __init__(
        self,
        col_name: str = None,
        db_name: str = None,
        mek_id: int = None,
        schema_name: str = None,
        tbl_name: str = None,
        user_name: str = None,
    ):
        self.col_name = col_name
        self.db_name = db_name
        self.mek_id = mek_id
        self.schema_name = schema_name
        self.tbl_name = tbl_name
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.col_name is not None:
            result['ColName'] = self.col_name
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.mek_id is not None:
            result['MekId'] = self.mek_id
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.tbl_name is not None:
            result['TblName'] = self.tbl_name
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColName') is not None:
            self.col_name = m.get('ColName')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('MekId') is not None:
            self.mek_id = m.get('MekId')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TblName') is not None:
            self.tbl_name = m.get('TblName')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ImportMasterKeyVO(TeaModel):
    def __init__(
        self,
        encrypt_mek_data_base_64: str = None,
        mek_id: int = None,
        project_id: List[int] = None,
    ):
        self.encrypt_mek_data_base_64 = encrypt_mek_data_base_64
        self.mek_id = mek_id
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encrypt_mek_data_base_64 is not None:
            result['EncryptMekDataBase64'] = self.encrypt_mek_data_base_64
        if self.mek_id is not None:
            result['MekId'] = self.mek_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EncryptMekDataBase64') is not None:
            self.encrypt_mek_data_base_64 = m.get('EncryptMekDataBase64')
        if m.get('MekId') is not None:
            self.mek_id = m.get('MekId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class MetaCategory(TeaModel):
    def __init__(
        self,
        category_id: int = None,
        create_time: str = None,
        depth: int = None,
        name: str = None,
        parent_category_id: int = None,
    ):
        self.category_id = category_id
        self.create_time = create_time
        self.depth = depth
        self.name = name
        self.parent_category_id = parent_category_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.depth is not None:
            result['Depth'] = self.depth
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_category_id is not None:
            result['ParentCategoryId'] = self.parent_category_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Depth') is not None:
            self.depth = m.get('Depth')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentCategoryId') is not None:
            self.parent_category_id = m.get('ParentCategoryId')
        return self


class MetaCategoryTableEntity(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        category_id: int = None,
        database_search_name: str = None,
        db_id: int = None,
        db_type: str = None,
        description: str = None,
        instance_id: int = None,
        schema_name: str = None,
        table_name: str = None,
        table_schema_name: str = None,
    ):
        self.catalog_name = catalog_name
        self.category_id = category_id
        self.database_search_name = database_search_name
        self.db_id = db_id
        self.db_type = db_type
        self.description = description
        self.instance_id = instance_id
        self.schema_name = schema_name
        self.table_name = table_name
        self.table_schema_name = table_schema_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.database_search_name is not None:
            result['DatabaseSearchName'] = self.database_search_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_schema_name is not None:
            result['TableSchemaName'] = self.table_schema_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('DatabaseSearchName') is not None:
            self.database_search_name = m.get('DatabaseSearchName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableSchemaName') is not None:
            self.table_schema_name = m.get('TableSchemaName')
        return self


class PartitionError(TeaModel):
    def __init__(
        self,
        error_detail: str = None,
        values: List[str] = None,
    ):
        self.error_detail = error_detail
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_detail is not None:
            result['ErrorDetail'] = self.error_detail
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorDetail') is not None:
            self.error_detail = m.get('ErrorDetail')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class StsApplyVO(TeaModel):
    def __init__(
        self,
        aliyun_id: str = None,
        duration: int = None,
    ):
        self.aliyun_id = aliyun_id
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_id is not None:
            result['AliyunId'] = self.aliyun_id
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunId') is not None:
            self.aliyun_id = m.get('AliyunId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class StsTokenVO(TeaModel):
    def __init__(
        self,
        access_key_id: str = None,
        access_key_secret: str = None,
        expiration: str = None,
        security_token: str = None,
    ):
        self.access_key_id = access_key_id
        self.access_key_secret = access_key_secret
        self.expiration = expiration
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key_id is not None:
            result['AccessKeyId'] = self.access_key_id
        if self.access_key_secret is not None:
            result['AccessKeySecret'] = self.access_key_secret
        if self.expiration is not None:
            result['Expiration'] = self.expiration
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKeyId') is not None:
            self.access_key_id = m.get('AccessKeyId')
        if m.get('AccessKeySecret') is not None:
            self.access_key_secret = m.get('AccessKeySecret')
        if m.get('Expiration') is not None:
            self.expiration = m.get('Expiration')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class TableKnowledgeInfo(TeaModel):
    def __init__(
        self,
        asset_description: str = None,
        asset_modified_gmt: str = None,
        column_list: List[ColumnKnowledgeInfo] = None,
        description: str = None,
        summary: str = None,
        table_name: str = None,
    ):
        self.asset_description = asset_description
        self.asset_modified_gmt = asset_modified_gmt
        self.column_list = column_list
        self.description = description
        self.summary = summary
        self.table_name = table_name

    def validate(self):
        if self.column_list:
            for k in self.column_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_description is not None:
            result['AssetDescription'] = self.asset_description
        if self.asset_modified_gmt is not None:
            result['AssetModifiedGmt'] = self.asset_modified_gmt
        result['ColumnList'] = []
        if self.column_list is not None:
            for k in self.column_list:
                result['ColumnList'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetDescription') is not None:
            self.asset_description = m.get('AssetDescription')
        if m.get('AssetModifiedGmt') is not None:
            self.asset_modified_gmt = m.get('AssetModifiedGmt')
        self.column_list = []
        if m.get('ColumnList') is not None:
            for k in m.get('ColumnList'):
                temp_model = ColumnKnowledgeInfo()
                self.column_list.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class TeeEvidenceVO(TeaModel):
    def __init__(
        self,
        cipher_suite: str = None,
        enclave_data: str = None,
        encrypt_public_key_pem: str = None,
        encrypt_public_key_type: str = None,
        modified_date: str = None,
        public_key: str = None,
        public_key_ra_base_64: str = None,
        public_key_ra_type: str = None,
        quote_report: str = None,
        sign_public_key_pem: str = None,
        sign_public_key_type: str = None,
        trusted_mr_enclave: List[str] = None,
    ):
        self.cipher_suite = cipher_suite
        self.enclave_data = enclave_data
        self.encrypt_public_key_pem = encrypt_public_key_pem
        self.encrypt_public_key_type = encrypt_public_key_type
        self.modified_date = modified_date
        self.public_key = public_key
        self.public_key_ra_base_64 = public_key_ra_base_64
        self.public_key_ra_type = public_key_ra_type
        self.quote_report = quote_report
        self.sign_public_key_pem = sign_public_key_pem
        self.sign_public_key_type = sign_public_key_type
        self.trusted_mr_enclave = trusted_mr_enclave

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_suite is not None:
            result['CipherSuite'] = self.cipher_suite
        if self.enclave_data is not None:
            result['EnclaveData'] = self.enclave_data
        if self.encrypt_public_key_pem is not None:
            result['EncryptPublicKeyPem'] = self.encrypt_public_key_pem
        if self.encrypt_public_key_type is not None:
            result['EncryptPublicKeyType'] = self.encrypt_public_key_type
        if self.modified_date is not None:
            result['ModifiedDate'] = self.modified_date
        if self.public_key is not None:
            result['PublicKey'] = self.public_key
        if self.public_key_ra_base_64 is not None:
            result['PublicKeyRaBase64'] = self.public_key_ra_base_64
        if self.public_key_ra_type is not None:
            result['PublicKeyRaType'] = self.public_key_ra_type
        if self.quote_report is not None:
            result['QuoteReport'] = self.quote_report
        if self.sign_public_key_pem is not None:
            result['SignPublicKeyPem'] = self.sign_public_key_pem
        if self.sign_public_key_type is not None:
            result['SignPublicKeyType'] = self.sign_public_key_type
        if self.trusted_mr_enclave is not None:
            result['TrustedMrEnclave'] = self.trusted_mr_enclave
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CipherSuite') is not None:
            self.cipher_suite = m.get('CipherSuite')
        if m.get('EnclaveData') is not None:
            self.enclave_data = m.get('EnclaveData')
        if m.get('EncryptPublicKeyPem') is not None:
            self.encrypt_public_key_pem = m.get('EncryptPublicKeyPem')
        if m.get('EncryptPublicKeyType') is not None:
            self.encrypt_public_key_type = m.get('EncryptPublicKeyType')
        if m.get('ModifiedDate') is not None:
            self.modified_date = m.get('ModifiedDate')
        if m.get('PublicKey') is not None:
            self.public_key = m.get('PublicKey')
        if m.get('PublicKeyRaBase64') is not None:
            self.public_key_ra_base_64 = m.get('PublicKeyRaBase64')
        if m.get('PublicKeyRaType') is not None:
            self.public_key_ra_type = m.get('PublicKeyRaType')
        if m.get('QuoteReport') is not None:
            self.quote_report = m.get('QuoteReport')
        if m.get('SignPublicKeyPem') is not None:
            self.sign_public_key_pem = m.get('SignPublicKeyPem')
        if m.get('SignPublicKeyType') is not None:
            self.sign_public_key_type = m.get('SignPublicKeyType')
        if m.get('TrustedMrEnclave') is not None:
            self.trusted_mr_enclave = m.get('TrustedMrEnclave')
        return self


class UsersDetailsVO(TeaModel):
    def __init__(
        self,
        approval_signature_base_64: str = None,
        approval_sql_template: str = None,
        approval_status: str = None,
        creator: int = None,
        data_ready: int = None,
        id: int = None,
        mekid: int = None,
        path_prefix: str = None,
        result_party: int = None,
        uid: str = None,
        user_confirmed: int = None,
        user_name: str = None,
        user_public_key_pem: str = None,
    ):
        self.approval_signature_base_64 = approval_signature_base_64
        self.approval_sql_template = approval_sql_template
        self.approval_status = approval_status
        self.creator = creator
        self.data_ready = data_ready
        self.id = id
        self.mekid = mekid
        self.path_prefix = path_prefix
        self.result_party = result_party
        self.uid = uid
        self.user_confirmed = user_confirmed
        self.user_name = user_name
        self.user_public_key_pem = user_public_key_pem

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.approval_signature_base_64 is not None:
            result['ApprovalSignatureBase64'] = self.approval_signature_base_64
        if self.approval_sql_template is not None:
            result['ApprovalSqlTemplate'] = self.approval_sql_template
        if self.approval_status is not None:
            result['ApprovalStatus'] = self.approval_status
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.data_ready is not None:
            result['DataReady'] = self.data_ready
        if self.id is not None:
            result['Id'] = self.id
        if self.mekid is not None:
            result['Mekid'] = self.mekid
        if self.path_prefix is not None:
            result['PathPrefix'] = self.path_prefix
        if self.result_party is not None:
            result['ResultParty'] = self.result_party
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_confirmed is not None:
            result['UserConfirmed'] = self.user_confirmed
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_public_key_pem is not None:
            result['UserPublicKeyPem'] = self.user_public_key_pem
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApprovalSignatureBase64') is not None:
            self.approval_signature_base_64 = m.get('ApprovalSignatureBase64')
        if m.get('ApprovalSqlTemplate') is not None:
            self.approval_sql_template = m.get('ApprovalSqlTemplate')
        if m.get('ApprovalStatus') is not None:
            self.approval_status = m.get('ApprovalStatus')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('DataReady') is not None:
            self.data_ready = m.get('DataReady')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Mekid') is not None:
            self.mekid = m.get('Mekid')
        if m.get('PathPrefix') is not None:
            self.path_prefix = m.get('PathPrefix')
        if m.get('ResultParty') is not None:
            self.result_party = m.get('ResultParty')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserConfirmed') is not None:
            self.user_confirmed = m.get('UserConfirmed')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserPublicKeyPem') is not None:
            self.user_public_key_pem = m.get('UserPublicKeyPem')
        return self


class OpenStructDLTableInput(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator_id: int = None,
        description: str = None,
        last_access_time: int = None,
        location: str = None,
        modifier_id: int = None,
        name: str = None,
        owner: str = None,
        owner_type: str = None,
        parameters: Dict[str, str] = None,
        partition_keys: List[DLColumn] = None,
        retention: int = None,
        storage_descriptor: DLStorageDescriptor = None,
        table_type: str = None,
        view_expanded_text: str = None,
        view_original_text: str = None,
    ):
        self.create_time = create_time
        self.creator_id = creator_id
        self.description = description
        self.last_access_time = last_access_time
        self.location = location
        self.modifier_id = modifier_id
        self.name = name
        self.owner = owner
        self.owner_type = owner_type
        self.parameters = parameters
        self.partition_keys = partition_keys
        self.retention = retention
        self.storage_descriptor = storage_descriptor
        self.table_type = table_type
        self.view_expanded_text = view_expanded_text
        self.view_original_text = view_original_text

    def validate(self):
        if self.partition_keys:
            for k in self.partition_keys:
                if k:
                    k.validate()
        if self.storage_descriptor:
            self.storage_descriptor.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.last_access_time is not None:
            result['LastAccessTime'] = self.last_access_time
        if self.location is not None:
            result['Location'] = self.location
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.owner_type is not None:
            result['OwnerType'] = self.owner_type
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        result['PartitionKeys'] = []
        if self.partition_keys is not None:
            for k in self.partition_keys:
                result['PartitionKeys'].append(k.to_map() if k else None)
        if self.retention is not None:
            result['Retention'] = self.retention
        if self.storage_descriptor is not None:
            result['StorageDescriptor'] = self.storage_descriptor.to_map()
        if self.table_type is not None:
            result['TableType'] = self.table_type
        if self.view_expanded_text is not None:
            result['ViewExpandedText'] = self.view_expanded_text
        if self.view_original_text is not None:
            result['ViewOriginalText'] = self.view_original_text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('LastAccessTime') is not None:
            self.last_access_time = m.get('LastAccessTime')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('OwnerType') is not None:
            self.owner_type = m.get('OwnerType')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        self.partition_keys = []
        if m.get('PartitionKeys') is not None:
            for k in m.get('PartitionKeys'):
                temp_model = DLColumn()
                self.partition_keys.append(temp_model.from_map(k))
        if m.get('Retention') is not None:
            self.retention = m.get('Retention')
        if m.get('StorageDescriptor') is not None:
            temp_model = DLStorageDescriptor()
            self.storage_descriptor = temp_model.from_map(m['StorageDescriptor'])
        if m.get('TableType') is not None:
            self.table_type = m.get('TableType')
        if m.get('ViewExpandedText') is not None:
            self.view_expanded_text = m.get('ViewExpandedText')
        if m.get('ViewOriginalText') is not None:
            self.view_original_text = m.get('ViewOriginalText')
        return self


class AddAuthorityTemplateItemsRequestItems(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        instance_id: int = None,
        permission_types: List[str] = None,
        resource_type: str = None,
        table_name: str = None,
    ):
        self.db_id = db_id
        self.instance_id = instance_id
        self.permission_types = permission_types
        # This parameter is required.
        self.resource_type = resource_type
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.permission_types is not None:
            result['PermissionTypes'] = self.permission_types
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PermissionTypes') is not None:
            self.permission_types = m.get('PermissionTypes')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class AddAuthorityTemplateItemsRequest(TeaModel):
    def __init__(
        self,
        items: List[AddAuthorityTemplateItemsRequestItems] = None,
        template_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.items = items
        # This parameter is required.
        self.template_id = template_id
        self.tid = tid

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = AddAuthorityTemplateItemsRequestItems()
                self.items.append(temp_model.from_map(k))
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddAuthorityTemplateItemsShrinkRequest(TeaModel):
    def __init__(
        self,
        items_shrink: str = None,
        template_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.items_shrink = items_shrink
        # This parameter is required.
        self.template_id = template_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.items_shrink is not None:
            result['Items'] = self.items_shrink
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Items') is not None:
            self.items_shrink = m.get('Items')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddAuthorityTemplateItemsResponseBody(TeaModel):
    def __init__(
        self,
        data: bool = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddAuthorityTemplateItemsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddAuthorityTemplateItemsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddAuthorityTemplateItemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDesensitizationRuleRequest(TeaModel):
    def __init__(
        self,
        function_params: List[Dict[str, str]] = None,
        function_type: str = None,
        rule_description: str = None,
        rule_name: str = None,
        rule_type: str = None,
        tid: int = None,
    ):
        # The parameters of the algorithm.
        self.function_params = function_params
        # The type of the masking algorithm.
        # 
        # Valid values:
        # 
        # *   FIX_POS : masks characters in the specified position.
        # *   DATE_ROUNDING: rounds the date.
        # *   PLAINTEXT: does not mask data.
        # *   SHA1: masks characters by using the secure hash algorithm 1 (SHA-1)
        # *   HMAC: masks characters by using the hash-based message authentication code (HMAC).
        # *   STRING_TRANSFORM: shift characters.
        # *   NUMBER_ROUNDING: rounds numbers.
        # *   AES: masks characters by using the advanced encryption standard (AES) algorithm.
        # *   SHA256: masks characters by using SHA-256 algorithm.
        # *   DES: masks characters by using the data encryption standard (DES) algorithm.
        # *   MAP_REPLACE: masks the mapped data.
        # *   FIX_CHAR: masks fixed characters.
        # *   DEFAULT: masks all characters.
        # *   RANDOM_REPLACE: randomly replaces characters.
        # *   MD5: masks characters by using the MD5 algorithm.
        # 
        # This parameter is required.
        self.function_type = function_type
        # The description of the rule.
        self.rule_description = rule_description
        # The name of the rule.
        # 
        # This parameter is required.
        self.rule_name = rule_name
        # The masking algorithm.
        # 
        # Valid values:
        # 
        # *   PLAINTEXT
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   TRANSFORM
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   ENCRYPT
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   REPLACE
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   HASH
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   MASK
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # This parameter is required.
        self.rule_type = rule_type
        # The tenant ID.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_params is not None:
            result['FunctionParams'] = self.function_params
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.rule_description is not None:
            result['RuleDescription'] = self.rule_description
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionParams') is not None:
            self.function_params = m.get('FunctionParams')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('RuleDescription') is not None:
            self.rule_description = m.get('RuleDescription')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddDesensitizationRuleResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        rule_id: int = None,
        success: bool = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # The ID generated for the data masking rule.
        self.rule_id = rule_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddDesensitizationRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDesensitizationRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDesensitizationRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddInstanceRequest(TeaModel):
    def __init__(
        self,
        data_link_name: str = None,
        database_password: str = None,
        database_user: str = None,
        dba_id: int = None,
        ddl_online: int = None,
        ecs_instance_id: str = None,
        ecs_region: str = None,
        enable_sell_common: str = None,
        enable_sell_sitd: str = None,
        enable_sell_stable: str = None,
        enable_sell_trust: str = None,
        env_type: str = None,
        export_timeout: int = None,
        host: str = None,
        instance_alias: str = None,
        instance_source: str = None,
        instance_type: str = None,
        network_type: str = None,
        port: int = None,
        query_timeout: int = None,
        safe_rule: str = None,
        sid: str = None,
        skip_test: bool = None,
        template_id: int = None,
        template_type: str = None,
        tid: int = None,
        use_dsql: int = None,
        use_ssl: int = None,
        vpc_id: str = None,
    ):
        self.data_link_name = data_link_name
        # This parameter is required.
        self.database_password = database_password
        # This parameter is required.
        self.database_user = database_user
        self.dba_id = dba_id
        self.ddl_online = ddl_online
        self.ecs_instance_id = ecs_instance_id
        self.ecs_region = ecs_region
        self.enable_sell_common = enable_sell_common
        self.enable_sell_sitd = enable_sell_sitd
        self.enable_sell_stable = enable_sell_stable
        # This parameter is required.
        self.enable_sell_trust = enable_sell_trust
        # This parameter is required.
        self.env_type = env_type
        # This parameter is required.
        self.export_timeout = export_timeout
        # This parameter is required.
        self.host = host
        # This parameter is required.
        self.instance_alias = instance_alias
        # This parameter is required.
        self.instance_source = instance_source
        # This parameter is required.
        self.instance_type = instance_type
        # This parameter is required.
        self.network_type = network_type
        # This parameter is required.
        self.port = port
        # This parameter is required.
        self.query_timeout = query_timeout
        self.safe_rule = safe_rule
        self.sid = sid
        self.skip_test = skip_test
        self.template_id = template_id
        self.template_type = template_type
        self.tid = tid
        self.use_dsql = use_dsql
        self.use_ssl = use_ssl
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.enable_sell_common is not None:
            result['EnableSellCommon'] = self.enable_sell_common
        if self.enable_sell_sitd is not None:
            result['EnableSellSitd'] = self.enable_sell_sitd
        if self.enable_sell_stable is not None:
            result['EnableSellStable'] = self.enable_sell_stable
        if self.enable_sell_trust is not None:
            result['EnableSellTrust'] = self.enable_sell_trust
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule is not None:
            result['SafeRule'] = self.safe_rule
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.skip_test is not None:
            result['SkipTest'] = self.skip_test
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.use_ssl is not None:
            result['UseSsl'] = self.use_ssl
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnableSellCommon') is not None:
            self.enable_sell_common = m.get('EnableSellCommon')
        if m.get('EnableSellSitd') is not None:
            self.enable_sell_sitd = m.get('EnableSellSitd')
        if m.get('EnableSellStable') is not None:
            self.enable_sell_stable = m.get('EnableSellStable')
        if m.get('EnableSellTrust') is not None:
            self.enable_sell_trust = m.get('EnableSellTrust')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRule') is not None:
            self.safe_rule = m.get('SafeRule')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('SkipTest') is not None:
            self.skip_test = m.get('SkipTest')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('UseSsl') is not None:
            self.use_ssl = m.get('UseSsl')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class AddInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLhMembersRequestMembers(TeaModel):
    def __init__(
        self,
        roles: List[str] = None,
        user_id: int = None,
    ):
        # The role. Valid values:
        # 
        # *   **ADMIN**: workspace administrator. You can add a workspace administrator only as a DMS administrator or a DBA.
        # *   **MEMBER**: workspace member.
        # *   **DEVELOPER**: task flow developer. Only a workspace member can be added as a task flow developer.
        # 
        # This parameter is required.
        self.roles = roles
        # The ID of the user to be added. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain the user ID.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.roles is not None:
            result['Roles'] = self.roles
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Roles') is not None:
            self.roles = m.get('Roles')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class AddLhMembersRequest(TeaModel):
    def __init__(
        self,
        members: List[AddLhMembersRequestMembers] = None,
        object_id: int = None,
        object_type: int = None,
        tid: int = None,
    ):
        # The information about the users to be added.
        # 
        # This parameter is required.
        self.members = members
        # The ID of the object.
        # 
        # *   If the object is a workspace, you can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to obtain the workspace ID.
        # *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the task flow ID.
        # 
        # This parameter is required.
        self.object_id = object_id
        # The type of the object. Valid values:
        # 
        # *   **0**: workspace
        # *   **1**: task flow
        # 
        # This parameter is required.
        self.object_type = object_type
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = AddLhMembersRequestMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddLhMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        members_shrink: str = None,
        object_id: int = None,
        object_type: int = None,
        tid: int = None,
    ):
        # The information about the users to be added.
        # 
        # This parameter is required.
        self.members_shrink = members_shrink
        # The ID of the object.
        # 
        # *   If the object is a workspace, you can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to obtain the workspace ID.
        # *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the task flow ID.
        # 
        # This parameter is required.
        self.object_id = object_id
        # The type of the object. Valid values:
        # 
        # *   **0**: workspace
        # *   **1**: task flow
        # 
        # This parameter is required.
        self.object_type = object_type
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.members_shrink is not None:
            result['Members'] = self.members_shrink
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Members') is not None:
            self.members_shrink = m.get('Members')
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddLhMembersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddLhMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLhMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLhMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLogicTableRouteConfigRequest(TeaModel):
    def __init__(
        self,
        route_expr: str = None,
        route_key: str = None,
        table_id: int = None,
        tid: int = None,
    ):
        # The routing algorithm expression. For more information about how to configure a routing algorithm expression, see [Configure a routing algorithm](https://www.alibabacloud.com/help/en/data-management-service/latest/configure-a-routing-algorithm).
        # 
        # This parameter is required.
        self.route_expr = route_expr
        # The unique key of the routing algorithm. 
        # 
        # > - You can create a custom unique key for the routing algorithm. No requirements are imposed on custom unique keys.
        # > - The unique key of the routing algorithm in the same logical table must be unique.
        # 
        # This parameter is required.
        self.route_key = route_key
        # The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
        # 
        # This parameter is required.
        self.table_id = table_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_expr is not None:
            result['RouteExpr'] = self.route_expr
        if self.route_key is not None:
            result['RouteKey'] = self.route_key
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RouteExpr') is not None:
            self.route_expr = m.get('RouteExpr')
        if m.get('RouteKey') is not None:
            self.route_key = m.get('RouteKey')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddLogicTableRouteConfigResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddLogicTableRouteConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLogicTableRouteConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLogicTableRouteConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTableToCategoryRequest(TeaModel):
    def __init__(
        self,
        category_id: int = None,
        db_id: int = None,
        table_name: str = None,
        table_schema_name: str = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.category_id = category_id
        # This parameter is required.
        self.db_id = db_id
        # This parameter is required.
        self.table_name = table_name
        self.table_schema_name = table_schema_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_schema_name is not None:
            result['TableSchemaName'] = self.table_schema_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableSchemaName') is not None:
            self.table_schema_name = m.get('TableSchemaName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddTableToCategoryResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddTableToCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddTableToCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTableToCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTaskFlowEdgesRequestEdges(TeaModel):
    def __init__(
        self,
        node_end: int = None,
        node_from: int = None,
    ):
        # The ID of the node where the end node of the edge is located.
        # 
        # This parameter is required.
        self.node_end = node_end
        # The ID of the node where the start node of the edge is located.
        # 
        # This parameter is required.
        self.node_from = node_from

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class AddTaskFlowEdgesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        edges: List[AddTaskFlowEdgesRequestEdges] = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The list of edges of the task flow.
        # 
        # This parameter is required.
        self.edges = edges
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        if self.edges:
            for k in self.edges:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        result['Edges'] = []
        if self.edges is not None:
            for k in self.edges:
                result['Edges'].append(k.to_map() if k else None)
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        self.edges = []
        if m.get('Edges') is not None:
            for k in m.get('Edges'):
                temp_model = AddTaskFlowEdgesRequestEdges()
                self.edges.append(temp_model.from_map(k))
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddTaskFlowEdgesShrinkRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        edges_shrink: str = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The list of edges of the task flow.
        # 
        # This parameter is required.
        self.edges_shrink = edges_shrink
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.edges_shrink is not None:
            result['Edges'] = self.edges_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Edges') is not None:
            self.edges_shrink = m.get('Edges')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddTaskFlowEdgesResponseBodyEdgeIds(TeaModel):
    def __init__(
        self,
        edge_id: List[int] = None,
    ):
        self.edge_id = edge_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edge_id is not None:
            result['EdgeId'] = self.edge_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EdgeId') is not None:
            self.edge_id = m.get('EdgeId')
        return self


class AddTaskFlowEdgesResponseBody(TeaModel):
    def __init__(
        self,
        edge_ids: AddTaskFlowEdgesResponseBodyEdgeIds = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The list of task flow edge IDs.
        self.edge_ids = edge_ids
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.edge_ids:
            self.edge_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edge_ids is not None:
            result['EdgeIds'] = self.edge_ids.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EdgeIds') is not None:
            temp_model = AddTaskFlowEdgesResponseBodyEdgeIds()
            self.edge_ids = temp_model.from_map(m['EdgeIds'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddTaskFlowEdgesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddTaskFlowEdgesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTaskFlowEdgesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AnalyzeSQLLineageRequest(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        sql_content: str = None,
        tid: int = None,
    ):
        # The database ID.
        # 
        # >  You can call one of the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html), [ListDatabases](https://help.aliyun.com/document_detail/141873.html), and [GetDatabase](https://help.aliyun.com/document_detail/141869.html) operations to obtain the database ID provided in the DatabaseId response parameter.
        # 
        # This parameter is required.
        self.db_id = db_id
        # The SQL statement.
        # 
        # This parameter is required.
        self.sql_content = sql_content
        # The tenant ID.
        # 
        # >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.sql_content is not None:
            result['SqlContent'] = self.sql_content
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('SqlContent') is not None:
            self.sql_content = m.get('SqlContent')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail(TeaModel):
    def __init__(
        self,
        cal_way: str = None,
        code: str = None,
    ):
        # The calculating method. Valid values:
        # 
        # *   **DIRECT**: No function or expression is used.
        # *   **EXPR**: A function or expression is used.
        self.cal_way = cal_way
        # The SQL code snippet for field processing.
        self.code = code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cal_way is not None:
            result['CalWay'] = self.cal_way
        if self.code is not None:
            result['Code'] = self.code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalWay') is not None:
            self.cal_way = m.get('CalWay')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        return self


class AnalyzeSQLLineageResponseBodyLineageResultLineages(TeaModel):
    def __init__(
        self,
        dst: str = None,
        lineage_type: str = None,
        oper_type: str = None,
        process_detail: AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail = None,
        src: str = None,
    ):
        # The target.
        self.dst = dst
        # The type of the lineage. Valid values:
        # 
        # *   **FIELD_DEPEND_FIELD**: Fields depend on fields.
        # *   **TABLE_DEPEND_TABLE**: Tables depend on tables.
        # *   **FIELD_INFLU_TABLE**: Fields influence tables.
        # *   **FIELD_INFLU_FIELD**: Fields influence fields.
        # *   **FIELD_INFLU_TABLE**: Tables influence fields.
        # *   **FIELD_JOIN_FIELD**: Fields are associated with fields.
        self.lineage_type = lineage_type
        # The operation type of the SQL statement in which the data lineage is generated. For example, if the operation type is SELECT, the data lineage is generated from a SELECT statement.
        # 
        # >  This field is an extended field which has no practical use.
        self.oper_type = oper_type
        # The handling details. This parameter is returned only when LineageType is FIELD_DEPEND_FIELD.
        self.process_detail = process_detail
        # The source.
        self.src = src

    def validate(self):
        if self.process_detail:
            self.process_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst is not None:
            result['Dst'] = self.dst
        if self.lineage_type is not None:
            result['LineageType'] = self.lineage_type
        if self.oper_type is not None:
            result['OperType'] = self.oper_type
        if self.process_detail is not None:
            result['ProcessDetail'] = self.process_detail.to_map()
        if self.src is not None:
            result['Src'] = self.src
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dst') is not None:
            self.dst = m.get('Dst')
        if m.get('LineageType') is not None:
            self.lineage_type = m.get('LineageType')
        if m.get('OperType') is not None:
            self.oper_type = m.get('OperType')
        if m.get('ProcessDetail') is not None:
            temp_model = AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail()
            self.process_detail = temp_model.from_map(m['ProcessDetail'])
        if m.get('Src') is not None:
            self.src = m.get('Src')
        return self


class AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # The name of the field.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata(TeaModel):
    def __init__(
        self,
        fields: List[AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields] = None,
        name: str = None,
        source: str = None,
        type: str = None,
    ):
        # The fields in the metatable.
        self.fields = fields
        # The object name.
        self.name = name
        # The source of metadata. Valid values:
        # 
        # *   **DDL**: The metadata comes from parsed SQL statements or definition of databases and tables collected by DMS.
        # *   **LINEAGE**: The metadata comes from lineage analysis results.
        self.source = source
        # The object type. Valid values:
        # 
        # *   **TABLE**\
        # *   **VIEW**\
        # *   **TMP_TABLE**\
        self.type = type

    def validate(self):
        if self.fields:
            for k in self.fields:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Fields'] = []
        if self.fields is not None:
            for k in self.fields:
                result['Fields'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.source is not None:
            result['Source'] = self.source
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fields = []
        if m.get('Fields') is not None:
            for k in m.get('Fields'):
                temp_model = AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields()
                self.fields.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AnalyzeSQLLineageResponseBodyLineageResult(TeaModel):
    def __init__(
        self,
        lineages: List[AnalyzeSQLLineageResponseBodyLineageResultLineages] = None,
        object_metadata: List[AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata] = None,
    ):
        # The details about the lineage.
        self.lineages = lineages
        # The table and field metadata information.
        self.object_metadata = object_metadata

    def validate(self):
        if self.lineages:
            for k in self.lineages:
                if k:
                    k.validate()
        if self.object_metadata:
            for k in self.object_metadata:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Lineages'] = []
        if self.lineages is not None:
            for k in self.lineages:
                result['Lineages'].append(k.to_map() if k else None)
        result['ObjectMetadata'] = []
        if self.object_metadata is not None:
            for k in self.object_metadata:
                result['ObjectMetadata'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.lineages = []
        if m.get('Lineages') is not None:
            for k in m.get('Lineages'):
                temp_model = AnalyzeSQLLineageResponseBodyLineageResultLineages()
                self.lineages.append(temp_model.from_map(k))
        self.object_metadata = []
        if m.get('ObjectMetadata') is not None:
            for k in m.get('ObjectMetadata'):
                temp_model = AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata()
                self.object_metadata.append(temp_model.from_map(k))
        return self


class AnalyzeSQLLineageResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        lineage_result: AnalyzeSQLLineageResponseBodyLineageResult = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # Returned data set of SQL lineage.
        self.lineage_result = lineage_result
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.lineage_result:
            self.lineage_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.lineage_result is not None:
            result['LineageResult'] = self.lineage_result.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LineageResult') is not None:
            temp_model = AnalyzeSQLLineageResponseBodyLineageResult()
            self.lineage_result = temp_model.from_map(m['LineageResult'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AnalyzeSQLLineageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AnalyzeSQLLineageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AnalyzeSQLLineageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ApproveOrderRequest(TeaModel):
    def __init__(
        self,
        approval_node_id: int = None,
        approval_node_pos: str = None,
        approval_type: str = None,
        comment: str = None,
        new_approver: int = None,
        new_approver_list: str = None,
        old_approver: int = None,
        real_login_user_uid: str = None,
        tid: int = None,
        workflow_instance_id: int = None,
    ):
        # If ApprovalType is set to ADD_APPROVAL_NODE, you need to specify this parameter. The ID of the user that is added as the new approval node. This node must be a user-defined approval node. You can call the ListUserDefineWorkFlowNodes operation to obtain the value of this parameter.
        self.approval_node_id = approval_node_id
        # The position of the new approval node. You must specify this parameter if ApprovalType is set to ADD_APPROVAL_NODE. Valid values:
        # 
        # *   **PRE_ADD_APPROVAL_NODE**: before the current approval node.
        # *   **POST_ADD_APPROVAL_NODE**: after the current approval node.
        self.approval_node_pos = approval_node_pos
        # The action that you want to perform on the ticket. Valid values:
        # 
        # *   **AGREE**\
        # *   **CANCEL**\
        # *   **REJECT**\
        # *   **TRANSFER**\
        # *   **ADD_APPROVAL_NODE**\
        # 
        # This parameter is required.
        self.approval_type = approval_type
        # The description of the ticket.
        self.comment = comment
        # The ID of the user to which the ticket is transferred. If ApprovalType is set to TRANSFER, you need to specify this parameter.
        self.new_approver = new_approver
        # >  You can specify this parameter if ApprovalType is set to TRANSFER. You need to only specify one of NewApproverList and NewApprover.
        # 
        # The IDs of the users to whom the ticket is transferred. Separate multiple IDs with commas (,).
        self.new_approver_list = new_approver_list
        # The ID of the user that transfers the ticket to another user. The default value is the ID of the current user. If the current user is an administrator or a database administrator (DBA), the user can change the value of this parameter to the ID of another user.
        self.old_approver = old_approver
        # The UID of the Alibaba Cloud account that actually calls the API.
        self.real_login_user_uid = real_login_user_uid
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
        self.tid = tid
        # The ID of the approval process. You can call the [GetOrderBaseInfo](https://help.aliyun.com/document_detail/144642.html) operation to obtain the ID of the approval process.
        # 
        # This parameter is required.
        self.workflow_instance_id = workflow_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.approval_node_id is not None:
            result['ApprovalNodeId'] = self.approval_node_id
        if self.approval_node_pos is not None:
            result['ApprovalNodePos'] = self.approval_node_pos
        if self.approval_type is not None:
            result['ApprovalType'] = self.approval_type
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.new_approver is not None:
            result['NewApprover'] = self.new_approver
        if self.new_approver_list is not None:
            result['NewApproverList'] = self.new_approver_list
        if self.old_approver is not None:
            result['OldApprover'] = self.old_approver
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApprovalNodeId') is not None:
            self.approval_node_id = m.get('ApprovalNodeId')
        if m.get('ApprovalNodePos') is not None:
            self.approval_node_pos = m.get('ApprovalNodePos')
        if m.get('ApprovalType') is not None:
            self.approval_type = m.get('ApprovalType')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('NewApprover') is not None:
            self.new_approver = m.get('NewApprover')
        if m.get('NewApproverList') is not None:
            self.new_approver_list = m.get('NewApproverList')
        if m.get('OldApprover') is not None:
            self.old_approver = m.get('OldApprover')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class ApproveOrderResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ApproveOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ApproveOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ApproveOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BackFillRequest(TeaModel):
    def __init__(
        self,
        asc: bool = None,
        back_fill_date: str = None,
        back_fill_date_begin: str = None,
        back_fill_date_end: str = None,
        dag_id: int = None,
        filter_node_ids: List[int] = None,
        history_dag_id: int = None,
        interval: int = None,
        is_trigger_sub_tree: bool = None,
        start_node_ids: List[int] = None,
        tid: int = None,
    ):
        # The running sequence of task flows for data backfill. Valid values:
        # 
        # *   **0**: reverse chronological order.
        # *   **1**: chronological order. This is the default value.
        self.asc = asc
        # The date for the data to be backfilled. This parameter is required if you specify a date for data backfill.
        self.back_fill_date = back_fill_date
        # The start date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
        self.back_fill_date_begin = back_fill_date_begin
        # The end date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
        self.back_fill_date_end = back_fill_date_end
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # Filter condition, which specifies the list of node IDs in the task flow that do not need to supplement data.
        self.filter_node_ids = filter_node_ids
        # The ID of the historical task flow.
        self.history_dag_id = history_dag_id
        # The interval at which data backfill is performed. Unit: hours. Minimum value: 1. Default value: 24.
        self.interval = interval
        # Specifies whether to run descendant nodes. Default value: true.
        self.is_trigger_sub_tree = is_trigger_sub_tree
        # The number of nodes for which you want to backfill data.
        self.start_node_ids = start_node_ids
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.back_fill_date is not None:
            result['BackFillDate'] = self.back_fill_date
        if self.back_fill_date_begin is not None:
            result['BackFillDateBegin'] = self.back_fill_date_begin
        if self.back_fill_date_end is not None:
            result['BackFillDateEnd'] = self.back_fill_date_end
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.filter_node_ids is not None:
            result['FilterNodeIds'] = self.filter_node_ids
        if self.history_dag_id is not None:
            result['HistoryDagId'] = self.history_dag_id
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.is_trigger_sub_tree is not None:
            result['IsTriggerSubTree'] = self.is_trigger_sub_tree
        if self.start_node_ids is not None:
            result['StartNodeIds'] = self.start_node_ids
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('BackFillDate') is not None:
            self.back_fill_date = m.get('BackFillDate')
        if m.get('BackFillDateBegin') is not None:
            self.back_fill_date_begin = m.get('BackFillDateBegin')
        if m.get('BackFillDateEnd') is not None:
            self.back_fill_date_end = m.get('BackFillDateEnd')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('FilterNodeIds') is not None:
            self.filter_node_ids = m.get('FilterNodeIds')
        if m.get('HistoryDagId') is not None:
            self.history_dag_id = m.get('HistoryDagId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IsTriggerSubTree') is not None:
            self.is_trigger_sub_tree = m.get('IsTriggerSubTree')
        if m.get('StartNodeIds') is not None:
            self.start_node_ids = m.get('StartNodeIds')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class BackFillShrinkRequest(TeaModel):
    def __init__(
        self,
        asc: bool = None,
        back_fill_date: str = None,
        back_fill_date_begin: str = None,
        back_fill_date_end: str = None,
        dag_id: int = None,
        filter_node_ids_shrink: str = None,
        history_dag_id: int = None,
        interval: int = None,
        is_trigger_sub_tree: bool = None,
        start_node_ids_shrink: str = None,
        tid: int = None,
    ):
        # The running sequence of task flows for data backfill. Valid values:
        # 
        # *   **0**: reverse chronological order.
        # *   **1**: chronological order. This is the default value.
        self.asc = asc
        # The date for the data to be backfilled. This parameter is required if you specify a date for data backfill.
        self.back_fill_date = back_fill_date
        # The start date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
        self.back_fill_date_begin = back_fill_date_begin
        # The end date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
        self.back_fill_date_end = back_fill_date_end
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # Filter condition, which specifies the list of node IDs in the task flow that do not need to supplement data.
        self.filter_node_ids_shrink = filter_node_ids_shrink
        # The ID of the historical task flow.
        self.history_dag_id = history_dag_id
        # The interval at which data backfill is performed. Unit: hours. Minimum value: 1. Default value: 24.
        self.interval = interval
        # Specifies whether to run descendant nodes. Default value: true.
        self.is_trigger_sub_tree = is_trigger_sub_tree
        # The number of nodes for which you want to backfill data.
        self.start_node_ids_shrink = start_node_ids_shrink
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.back_fill_date is not None:
            result['BackFillDate'] = self.back_fill_date
        if self.back_fill_date_begin is not None:
            result['BackFillDateBegin'] = self.back_fill_date_begin
        if self.back_fill_date_end is not None:
            result['BackFillDateEnd'] = self.back_fill_date_end
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.filter_node_ids_shrink is not None:
            result['FilterNodeIds'] = self.filter_node_ids_shrink
        if self.history_dag_id is not None:
            result['HistoryDagId'] = self.history_dag_id
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.is_trigger_sub_tree is not None:
            result['IsTriggerSubTree'] = self.is_trigger_sub_tree
        if self.start_node_ids_shrink is not None:
            result['StartNodeIds'] = self.start_node_ids_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('BackFillDate') is not None:
            self.back_fill_date = m.get('BackFillDate')
        if m.get('BackFillDateBegin') is not None:
            self.back_fill_date_begin = m.get('BackFillDateBegin')
        if m.get('BackFillDateEnd') is not None:
            self.back_fill_date_end = m.get('BackFillDateEnd')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('FilterNodeIds') is not None:
            self.filter_node_ids_shrink = m.get('FilterNodeIds')
        if m.get('HistoryDagId') is not None:
            self.history_dag_id = m.get('HistoryDagId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IsTriggerSubTree') is not None:
            self.is_trigger_sub_tree = m.get('IsTriggerSubTree')
        if m.get('StartNodeIds') is not None:
            self.start_node_ids_shrink = m.get('StartNodeIds')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class BackFillResponseBody(TeaModel):
    def __init__(
        self,
        dag_instance_id: int = None,
        error_code: str = None,
        error_message: str = None,
        node_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the execution record of the task flow.
        self.dag_instance_id = dag_instance_id
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the node.
        self.node_id = node_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BackFillResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BackFillResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BackFillResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchCreateDataLakePartitionsRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        if_not_exists: bool = None,
        need_result: bool = None,
        partition_inputs: List[DLPartitionInput] = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.if_not_exists = if_not_exists
        self.need_result = need_result
        # This parameter is required.
        self.partition_inputs = partition_inputs
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        if self.partition_inputs:
            for k in self.partition_inputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.if_not_exists is not None:
            result['IfNotExists'] = self.if_not_exists
        if self.need_result is not None:
            result['NeedResult'] = self.need_result
        result['PartitionInputs'] = []
        if self.partition_inputs is not None:
            for k in self.partition_inputs:
                result['PartitionInputs'].append(k.to_map() if k else None)
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('IfNotExists') is not None:
            self.if_not_exists = m.get('IfNotExists')
        if m.get('NeedResult') is not None:
            self.need_result = m.get('NeedResult')
        self.partition_inputs = []
        if m.get('PartitionInputs') is not None:
            for k in m.get('PartitionInputs'):
                temp_model = DLPartitionInput()
                self.partition_inputs.append(temp_model.from_map(k))
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class BatchCreateDataLakePartitionsShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        if_not_exists: bool = None,
        need_result: bool = None,
        partition_inputs_shrink: str = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.if_not_exists = if_not_exists
        self.need_result = need_result
        # This parameter is required.
        self.partition_inputs_shrink = partition_inputs_shrink
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.if_not_exists is not None:
            result['IfNotExists'] = self.if_not_exists
        if self.need_result is not None:
            result['NeedResult'] = self.need_result
        if self.partition_inputs_shrink is not None:
            result['PartitionInputs'] = self.partition_inputs_shrink
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('IfNotExists') is not None:
            self.if_not_exists = m.get('IfNotExists')
        if m.get('NeedResult') is not None:
            self.need_result = m.get('NeedResult')
        if m.get('PartitionInputs') is not None:
            self.partition_inputs_shrink = m.get('PartitionInputs')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class BatchCreateDataLakePartitionsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        partitions: List[DLPartition] = None,
        request_id: str = None,
        success: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.partitions = partitions
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.partitions:
            for k in self.partitions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['Partitions'] = []
        if self.partitions is not None:
            for k in self.partitions:
                result['Partitions'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.partitions = []
        if m.get('Partitions') is not None:
            for k in m.get('Partitions'):
                temp_model = DLPartition()
                self.partitions.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchCreateDataLakePartitionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchCreateDataLakePartitionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchCreateDataLakePartitionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchDeleteDataLakePartitionsRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        if_exists: bool = None,
        partition_values_list: List[List[str]] = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.if_exists = if_exists
        # This parameter is required.
        self.partition_values_list = partition_values_list
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.if_exists is not None:
            result['IfExists'] = self.if_exists
        if self.partition_values_list is not None:
            result['PartitionValuesList'] = self.partition_values_list
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('IfExists') is not None:
            self.if_exists = m.get('IfExists')
        if m.get('PartitionValuesList') is not None:
            self.partition_values_list = m.get('PartitionValuesList')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class BatchDeleteDataLakePartitionsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        partition_errors: List[PartitionError] = None,
        request_id: str = None,
        success: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.partition_errors = partition_errors
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.partition_errors:
            for k in self.partition_errors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['PartitionErrors'] = []
        if self.partition_errors is not None:
            for k in self.partition_errors:
                result['PartitionErrors'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.partition_errors = []
        if m.get('PartitionErrors') is not None:
            for k in m.get('PartitionErrors'):
                temp_model = PartitionError()
                self.partition_errors.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchDeleteDataLakePartitionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchDeleteDataLakePartitionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchDeleteDataLakePartitionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchUpdateDataLakePartitionsRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        partition_inputs: List[DLPartitionInput] = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.partition_inputs = partition_inputs
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        if self.partition_inputs:
            for k in self.partition_inputs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        result['PartitionInputs'] = []
        if self.partition_inputs is not None:
            for k in self.partition_inputs:
                result['PartitionInputs'].append(k.to_map() if k else None)
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        self.partition_inputs = []
        if m.get('PartitionInputs') is not None:
            for k in m.get('PartitionInputs'):
                temp_model = DLPartitionInput()
                self.partition_inputs.append(temp_model.from_map(k))
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class BatchUpdateDataLakePartitionsShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        partition_inputs_shrink: str = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.partition_inputs_shrink = partition_inputs_shrink
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.partition_inputs_shrink is not None:
            result['PartitionInputs'] = self.partition_inputs_shrink
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('PartitionInputs') is not None:
            self.partition_inputs_shrink = m.get('PartitionInputs')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class BatchUpdateDataLakePartitionsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        partition_errors: List[PartitionError] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.partition_errors = partition_errors
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.partition_errors:
            for k in self.partition_errors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['PartitionErrors'] = []
        if self.partition_errors is not None:
            for k in self.partition_errors:
                result['PartitionErrors'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.partition_errors = []
        if m.get('PartitionErrors') is not None:
            for k in m.get('PartitionErrors'):
                temp_model = PartitionError()
                self.partition_errors.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchUpdateDataLakePartitionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchUpdateDataLakePartitionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchUpdateDataLakePartitionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BuyPayAsYouGoOrderRequest(TeaModel):
    def __init__(
        self,
        commodity_type: str = None,
        ins_num: int = None,
        tid: int = None,
        version_type: str = None,
    ):
        # The type of the resource that you want to purchase.
        # 
        # *   **VersionType**: DMS that supports control modes
        # *   **SensitiveDataProtection**: DMS that supports sensitive data protection
        # 
        # This parameter is required.
        self.commodity_type = commodity_type
        # The number of database instances that you want to use DMS to manage.
        # 
        # > A quota can be used for only one database instance.
        # 
        # This parameter is required.
        self.ins_num = ins_num
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid
        # The control mode of DMS. Valid values:
        # 
        # *   **stand**: Stable Change
        # *   **safety**: Security Collaboration
        self.version_type = version_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_type is not None:
            result['CommodityType'] = self.commodity_type
        if self.ins_num is not None:
            result['InsNum'] = self.ins_num
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.version_type is not None:
            result['VersionType'] = self.version_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityType') is not None:
            self.commodity_type = m.get('CommodityType')
        if m.get('InsNum') is not None:
            self.ins_num = m.get('InsNum')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('VersionType') is not None:
            self.version_type = m.get('VersionType')
        return self


class BuyPayAsYouGoOrderResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        instance_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # If the purchase is successful, the ID of the purchased instance is returned.
        self.instance_id = instance_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BuyPayAsYouGoOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BuyPayAsYouGoOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BuyPayAsYouGoOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeColumnSecLevelRequest(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        db_id: int = None,
        is_logic: bool = None,
        new_level: str = None,
        schema_name: str = None,
        table_name: str = None,
        tid: int = None,
    ):
        # The name of the field. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the name of the field.
        # 
        # > You can also call the [ListColumns](https://help.aliyun.com/document_detail/141870.html) operation to obtain the name of the field.
        # 
        # This parameter is required.
        self.column_name = column_name
        # The ID of the database. You can call the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the ID of the database.
        # 
        # > You can also call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to obtain the ID of a physical database and the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to obtain the ID of a logical database.
        # 
        # This parameter is required.
        self.db_id = db_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   true: The database is a physical database.
        # *   false: The database is a logical database.
        # 
        # This parameter is required.
        self.is_logic = is_logic
        # The new sensitivity level of the field that you want to specify. Valid values:
        # 
        # *   INNER: low sensitivity level
        # *   SENSITIVE: medium sensitivity level
        # *   CONFIDENTIAL: high sensitivity level
        # 
        # This parameter is required.
        self.new_level = new_level
        # The name of the database. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the name of the database.
        # 
        # *   You can also call the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the name of the database.
        # *   You can also call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to obtain the name of a physical database and the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to obtain the name of a logical database.
        # 
        # This parameter is required.
        self.schema_name = schema_name
        # The name of the table. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the name of the table.
        # 
        # > You can also call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to obtain the name of the table.
        # 
        # This parameter is required.
        self.table_name = table_name
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.is_logic is not None:
            result['IsLogic'] = self.is_logic
        if self.new_level is not None:
            result['NewLevel'] = self.new_level
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('IsLogic') is not None:
            self.is_logic = m.get('IsLogic')
        if m.get('NewLevel') is not None:
            self.new_level = m.get('NewLevel')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ChangeColumnSecLevelResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ChangeColumnSecLevelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeColumnSecLevelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeColumnSecLevelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeColumnSecurityLevelRequest(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        db_id: int = None,
        is_logic: bool = None,
        new_sensitivity_level: str = None,
        schema_name: str = None,
        table_name: str = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.column_name = column_name
        # This parameter is required.
        self.db_id = db_id
        # This parameter is required.
        self.is_logic = is_logic
        # This parameter is required.
        self.new_sensitivity_level = new_sensitivity_level
        # This parameter is required.
        self.schema_name = schema_name
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.is_logic is not None:
            result['IsLogic'] = self.is_logic
        if self.new_sensitivity_level is not None:
            result['NewSensitivityLevel'] = self.new_sensitivity_level
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('IsLogic') is not None:
            self.is_logic = m.get('IsLogic')
        if m.get('NewSensitivityLevel') is not None:
            self.new_sensitivity_level = m.get('NewSensitivityLevel')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ChangeColumnSecurityLevelResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ChangeColumnSecurityLevelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeColumnSecurityLevelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeColumnSecurityLevelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeLhDagOwnerRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        owner_user_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the user to be specified as the new owner of the task flow. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain the user ID.
        # 
        # This parameter is required.
        self.owner_user_id = owner_user_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.owner_user_id is not None:
            result['OwnerUserId'] = self.owner_user_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('OwnerUserId') is not None:
            self.owner_user_id = m.get('OwnerUserId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ChangeLhDagOwnerResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ChangeLhDagOwnerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeLhDagOwnerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeLhDagOwnerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CloseOrderRequest(TeaModel):
    def __init__(
        self,
        close_reason: str = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The reason why the ticket is closed.
        # 
        # This parameter is required.
        self.close_reason = close_reason
        # The ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.close_reason is not None:
            result['CloseReason'] = self.close_reason
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CloseReason') is not None:
            self.close_reason = m.get('CloseReason')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CloseOrderResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CloseOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CloseOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CloseOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAbacAuthorizationRequest(TeaModel):
    def __init__(
        self,
        identity_type: str = None,
        policy_id: int = None,
        role_id: int = None,
        tid: int = None,
        user_id: int = None,
    ):
        # This parameter is required.
        self.identity_type = identity_type
        # This parameter is required.
        self.policy_id = policy_id
        self.role_id = role_id
        self.tid = tid
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identity_type is not None:
            result['IdentityType'] = self.identity_type
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IdentityType') is not None:
            self.identity_type = m.get('IdentityType')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CreateAbacAuthorizationResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateAbacAuthorizationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAbacAuthorizationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAbacAuthorizationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAbacPolicyRequest(TeaModel):
    def __init__(
        self,
        abac_policy_content: str = None,
        abac_policy_desc: str = None,
        abac_policy_name: str = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.abac_policy_content = abac_policy_content
        self.abac_policy_desc = abac_policy_desc
        # This parameter is required.
        self.abac_policy_name = abac_policy_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abac_policy_content is not None:
            result['AbacPolicyContent'] = self.abac_policy_content
        if self.abac_policy_desc is not None:
            result['AbacPolicyDesc'] = self.abac_policy_desc
        if self.abac_policy_name is not None:
            result['AbacPolicyName'] = self.abac_policy_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbacPolicyContent') is not None:
            self.abac_policy_content = m.get('AbacPolicyContent')
        if m.get('AbacPolicyDesc') is not None:
            self.abac_policy_desc = m.get('AbacPolicyDesc')
        if m.get('AbacPolicyName') is not None:
            self.abac_policy_name = m.get('AbacPolicyName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateAbacPolicyResponseBody(TeaModel):
    def __init__(
        self,
        create_policy_result: int = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.create_policy_result = create_policy_result
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_policy_result is not None:
            result['CreatePolicyResult'] = self.create_policy_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatePolicyResult') is not None:
            self.create_policy_result = m.get('CreatePolicyResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateAbacPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAbacPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAbacPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAuthorityTemplateRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        tid: int = None,
    ):
        # The description of the permission template.
        self.description = description
        # The name of the permission template.
        # 
        # This parameter is required.
        self.name = name
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateAuthorityTemplateResponseBodyAuthorityTemplateView(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        creator_id: int = None,
        description: str = None,
        name: str = None,
        template_id: int = None,
    ):
        # The time when the permission template was created. The time is in the yyyy-MM-DD HH:mm:ss format.
        self.create_time = create_time
        # The ID of the user who created the permission template.
        self.creator_id = creator_id
        # The description of the permission template.
        self.description = description
        # The name of the permission template.
        self.name = name
        # The ID of the permission template.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class CreateAuthorityTemplateResponseBody(TeaModel):
    def __init__(
        self,
        authority_template_view: CreateAuthorityTemplateResponseBodyAuthorityTemplateView = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tid: int = None,
    ):
        # The details of the permission template.
        self.authority_template_view = authority_template_view
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        if self.authority_template_view:
            self.authority_template_view.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authority_template_view is not None:
            result['AuthorityTemplateView'] = self.authority_template_view.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorityTemplateView') is not None:
            temp_model = CreateAuthorityTemplateResponseBodyAuthorityTemplateView()
            self.authority_template_view = temp_model.from_map(m['AuthorityTemplateView'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateAuthorityTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAuthorityTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAuthorityTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataArchiveOrderRequestParamTableIncludes(TeaModel):
    def __init__(
        self,
        table_name: str = None,
        table_where: str = None,
    ):
        # The table name.
        # 
        # This parameter is required.
        self.table_name = table_name
        # The filter condition that is specified by the WHERE clause of the archiving configuration. If a time variable is used in the filter condition, the filter condition is specified in the following format: field name <=\\"${variable name}\\". The variable name in the filter condition must be the same as the time variable name that is specified in the Variables parameter.
        self.table_where = table_where

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_where is not None:
            result['TableWhere'] = self.table_where
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableWhere') is not None:
            self.table_where = m.get('TableWhere')
        return self


class CreateDataArchiveOrderRequestParamVariables(TeaModel):
    def __init__(
        self,
        name: str = None,
        pattern: str = None,
    ):
        self.name = name
        self.pattern = pattern

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        return self


class CreateDataArchiveOrderRequestParam(TeaModel):
    def __init__(
        self,
        archive_method: str = None,
        cron_str: str = None,
        database_id: str = None,
        logic: bool = None,
        order_after: List[str] = None,
        run_method: str = None,
        source_catalog_name: str = None,
        source_instance_name: str = None,
        source_schema_name: str = None,
        table_includes: List[CreateDataArchiveOrderRequestParamTableIncludes] = None,
        table_mapping: List[str] = None,
        target_instance_host: str = None,
        variables: List[CreateDataArchiveOrderRequestParamVariables] = None,
    ):
        # The archiving destination to which you want to archive data. Valid values:
        # 
        # >  If you set ArchiveMethod to a value other than inner_oss, you must register the corresponding destination database with Data Management (DMS) before you create the data archiving ticket. After the database is registered with DMS, the database is displayed in the Instances Connected section of the DMS console.
        # 
        # *   **inner_oss**: dedicated storage, which is a built-in Object Storage Service (OSS) bucket.
        # *   **oss_userself**: OSS bucket of the user.
        # *   **mysql**: ApsaraDB RDS for MySQL instance.
        # *   **polardb**: PolarDB for MySQL cluster.
        # *   **adb_mysql**: AnalyticDB for MySQL V3.0 cluster.
        # *   **lindorm**: Lindorm instance.
        # 
        # This parameter is required.
        self.archive_method = archive_method
        # A crontab expression that specifies the scheduling cycle of the data archiving task. For more information, see the [Crontab expressions](https://help.aliyun.com/document_detail/206581.html) section of the "Create shadow tables for synchronization" topic. You must specify this parameter if you set RunMethod to schedule.
        self.cron_str = cron_str
        # The database ID. If the database is a self-managed database or a third-party cloud database, you can call the [GetDatabase](https://help.aliyun.com/document_detail/465856.html) operation to query the database ID. If the database is an Alibaba Cloud database, ignore this parameter.
        self.database_id = database_id
        # Specifies whether the database is a logical database.
        self.logic = logic
        # The post behaviors.
        self.order_after = order_after
        # The method that is used to run the data archiving task. Valid values:
        # 
        # *   **schedule**: The data archiving task is periodically scheduled.
        # *   **now**: The data archiving task is immediately run.
        # 
        # This parameter is required.
        self.run_method = run_method
        # The catalog of the source database. Valid values:
        # 
        # *   **def**: Set this parameter to def if the source database is of the two-layer logical schema, such as a MySQL database, a PolarDB for MySQL cluster, or an AnalyticDB for MySQL instance.
        # *   **Empty string**: Set this parameter to an empty string if the source database is a Lindorm or ApsaraDB for MongoDB instance.
        # *   **Catalog name**: Set this parameter to the catalog name of the source database if the source database is of the three-layer logical schema, such as a PostgreSQL database.
        # 
        # This parameter is required.
        self.source_catalog_name = source_catalog_name
        # The name of the source instance. If the database instance is a self-managed database or a third-party cloud database, you can call the [GetInstance](https://help.aliyun.com/document_detail/465826.html) operation to query the instance ID.
        # 
        # This parameter is required.
        self.source_instance_name = source_instance_name
        # The schema name of the source database. The schema name of the source database is the same as that of the destination database. If the source database is a MySQL database, this parameter specifies the name of the source database. If the source database is a PostgreSQL database, this parameter specifies the schema name of the source database.
        # 
        # This parameter is required.
        self.source_schema_name = source_schema_name
        # The collection of tables to be archived.
        # 
        # This parameter is required.
        self.table_includes = table_includes
        # The table names mapped to the destination database. This parameter is not required and the default value is used.
        self.table_mapping = table_mapping
        # The host of the destination instance. If the destination instance can be accessed over an internal network or the Internet, preferentially set the value to the internal endpoint of the destination instance.
        # 
        # *   If data is archived in an OSS bucket, set the value to the name of the bucket.
        # *   If data is archived in dedicated storage space, set the value to inner_oss.
        # 
        # This parameter is required.
        self.target_instance_host = target_instance_host
        # The configuration of archiving variables. You can use a time variable as a filter condition for archiving data. Each variable has two attributes: name and pattern.
        self.variables = variables

    def validate(self):
        if self.table_includes:
            for k in self.table_includes:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.archive_method is not None:
            result['ArchiveMethod'] = self.archive_method
        if self.cron_str is not None:
            result['CronStr'] = self.cron_str
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.order_after is not None:
            result['OrderAfter'] = self.order_after
        if self.run_method is not None:
            result['RunMethod'] = self.run_method
        if self.source_catalog_name is not None:
            result['SourceCatalogName'] = self.source_catalog_name
        if self.source_instance_name is not None:
            result['SourceInstanceName'] = self.source_instance_name
        if self.source_schema_name is not None:
            result['SourceSchemaName'] = self.source_schema_name
        result['TableIncludes'] = []
        if self.table_includes is not None:
            for k in self.table_includes:
                result['TableIncludes'].append(k.to_map() if k else None)
        if self.table_mapping is not None:
            result['TableMapping'] = self.table_mapping
        if self.target_instance_host is not None:
            result['TargetInstanceHost'] = self.target_instance_host
        result['Variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['Variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArchiveMethod') is not None:
            self.archive_method = m.get('ArchiveMethod')
        if m.get('CronStr') is not None:
            self.cron_str = m.get('CronStr')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OrderAfter') is not None:
            self.order_after = m.get('OrderAfter')
        if m.get('RunMethod') is not None:
            self.run_method = m.get('RunMethod')
        if m.get('SourceCatalogName') is not None:
            self.source_catalog_name = m.get('SourceCatalogName')
        if m.get('SourceInstanceName') is not None:
            self.source_instance_name = m.get('SourceInstanceName')
        if m.get('SourceSchemaName') is not None:
            self.source_schema_name = m.get('SourceSchemaName')
        self.table_includes = []
        if m.get('TableIncludes') is not None:
            for k in m.get('TableIncludes'):
                temp_model = CreateDataArchiveOrderRequestParamTableIncludes()
                self.table_includes.append(temp_model.from_map(k))
        if m.get('TableMapping') is not None:
            self.table_mapping = m.get('TableMapping')
        if m.get('TargetInstanceHost') is not None:
            self.target_instance_host = m.get('TargetInstanceHost')
        self.variables = []
        if m.get('Variables') is not None:
            for k in m.get('Variables'):
                temp_model = CreateDataArchiveOrderRequestParamVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class CreateDataArchiveOrderRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        param: CreateDataArchiveOrderRequestParam = None,
        parent_id: int = None,
        plugin_type: str = None,
        related_user_list: List[str] = None,
        tid: int = None,
    ):
        # The description of the task.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters for archiving data.
        # 
        # This parameter is required.
        self.param = param
        # The ID of the parent ticket. A parent ticket is generated only when a child ticket is created.
        self.parent_id = parent_id
        # The type of the plug-in. Default value: DATA_ARCHIVE.
        self.plugin_type = plugin_type
        # The list of the related users.
        self.related_user_list = related_user_list
        # The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataArchiveOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataArchiveOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        param_shrink: str = None,
        parent_id: int = None,
        plugin_type: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The description of the task.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters for archiving data.
        # 
        # This parameter is required.
        self.param_shrink = param_shrink
        # The ID of the parent ticket. A parent ticket is generated only when a child ticket is created.
        self.parent_id = parent_id
        # The type of the plug-in. Default value: DATA_ARCHIVE.
        self.plugin_type = plugin_type
        # The list of the related users.
        self.related_user_list_shrink = related_user_list_shrink
        # The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataArchiveOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the data archiving ticket.
        self.create_order_result = create_order_result
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request, which is used to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataArchiveOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataArchiveOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataArchiveOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataCorrectOrderRequestParamDbItemList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        instance_id: int = None,
        logic: bool = None,
    ):
        # The database ID. The database can be a physical database or a logical database.
        # 
        # *   To query the ID of a physical database, call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
        # *   To query the ID of a logical database, call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
        self.db_id = db_id
        # The instance ID. You can call the ListInstances or GetInstance operation to query the instance ID.
        # 
        # > 
        # > The instance change feature is supported only by ApsaraDB RDS for MySQL instances, PolarDB for MySQL clusters, and AnalyticDB for MySQL clusters.
        self.instance_id = instance_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateDataCorrectOrderRequestParam(TeaModel):
    def __init__(
        self,
        attachment_name: str = None,
        classify: str = None,
        db_item_list: List[CreateDataCorrectOrderRequestParamDbItemList] = None,
        estimate_affect_rows: int = None,
        exec_mode: str = None,
        exec_sql: str = None,
        rollback_attachment_name: str = None,
        rollback_sql: str = None,
        rollback_sql_type: str = None,
        sql_type: str = None,
    ):
        # The key of the attachment that contains the SQL statements used to change data. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of AttachmentKey.
        # 
        # >  This parameter is required if you set **SqlType** to **ATTACHMENT**.
        self.attachment_name = attachment_name
        # The reason for the data change.
        self.classify = classify
        # The databases whose data you want to change.
        # 
        # This parameter is required.
        self.db_item_list = db_item_list
        # The estimated number of data rows that may be affected by the data change.
        # 
        # This parameter is required.
        self.estimate_affect_rows = estimate_affect_rows
        # The mode in which the data change ticket is executed after the ticket is approved. Valid values:
        # 
        # *   **COMMITOR**: The ticket is executed by the user who submits the ticket.
        # *   **AUTO**: The ticket is automatically executed after the ticket is approved.
        # *   **LAST_AUDITOR**: The ticket is executed by the last approver of the ticket.
        self.exec_mode = exec_mode
        # The SQL statements for data change.
        # 
        # > 
        # 
        # *   This parameter is required if you set **SqlType** to **TEXT**.
        # 
        # *   The size of the SQL statement cannot exceed 15 MB.
        self.exec_sql = exec_sql
        # The key of the attachment that contains the SQL statements used to roll back the data change. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of AttachmentKey.
        # 
        # >  This parameter is required if you set **RollbackSqlType** to **ATTACHMENT**.
        self.rollback_attachment_name = rollback_attachment_name
        # The SQL statements for rolling back the data change.
        # 
        # >  This parameter is required if you set **RollbackSqlType** to **TEXT**.
        self.rollback_sql = rollback_sql
        # The format of the SQL statements used to roll back the data change. Valid values:
        # 
        # *   **TEXT**\
        # *   **ATTACHMENT**\
        self.rollback_sql_type = rollback_sql_type
        # The format of the SQL statements used to change data. Valid values:
        # 
        # *   **TEXT**\
        # *   **ATTACHMENT**\
        # 
        # This parameter is required.
        self.sql_type = sql_type

    def validate(self):
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_name is not None:
            result['AttachmentName'] = self.attachment_name
        if self.classify is not None:
            result['Classify'] = self.classify
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.estimate_affect_rows is not None:
            result['EstimateAffectRows'] = self.estimate_affect_rows
        if self.exec_mode is not None:
            result['ExecMode'] = self.exec_mode
        if self.exec_sql is not None:
            result['ExecSQL'] = self.exec_sql
        if self.rollback_attachment_name is not None:
            result['RollbackAttachmentName'] = self.rollback_attachment_name
        if self.rollback_sql is not None:
            result['RollbackSQL'] = self.rollback_sql
        if self.rollback_sql_type is not None:
            result['RollbackSqlType'] = self.rollback_sql_type
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentName') is not None:
            self.attachment_name = m.get('AttachmentName')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateDataCorrectOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('EstimateAffectRows') is not None:
            self.estimate_affect_rows = m.get('EstimateAffectRows')
        if m.get('ExecMode') is not None:
            self.exec_mode = m.get('ExecMode')
        if m.get('ExecSQL') is not None:
            self.exec_sql = m.get('ExecSQL')
        if m.get('RollbackAttachmentName') is not None:
            self.rollback_attachment_name = m.get('RollbackAttachmentName')
        if m.get('RollbackSQL') is not None:
            self.rollback_sql = m.get('RollbackSQL')
        if m.get('RollbackSqlType') is not None:
            self.rollback_sql_type = m.get('RollbackSqlType')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        return self


class CreateDataCorrectOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param: CreateDataCorrectOrderRequestParam = None,
        real_login_user_uid: str = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key
        # The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param = param
        # The ID of the Alibaba Cloud account that is used to call the API operation.
        self.real_login_user_uid = real_login_user_uid
        # The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataCorrectOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataCorrectOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param_shrink: str = None,
        real_login_user_uid: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key
        # The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param_shrink = param_shrink
        # The ID of the Alibaba Cloud account that is used to call the API operation.
        self.real_login_user_uid = real_login_user_uid
        # The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataCorrectOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The IDs of the tickets.
        self.create_order_result = create_order_result
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataCorrectOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataCorrectOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataCorrectOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataCronClearOrderRequestParamCronClearItemList(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        filter_sql: str = None,
        remain_days: int = None,
        table_name: str = None,
        time_unit: str = None,
    ):
        # The name of the field.
        # 
        # This parameter is required.
        self.column_name = column_name
        # The filter conditions.
        self.filter_sql = filter_sql
        # The retention period of the historical data. Unit: days. For example, if you set the parameter to 7, DMS deletes the data that is retained for more than seven days.
        # 
        # This parameter is required.
        self.remain_days = remain_days
        # The name of the table. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to query the name of the table.
        # 
        # This parameter is required.
        self.table_name = table_name
        # The type of time granularity. If the ColumnName parameter specifies a field of a time type, this parameter is required. Valid values:
        # 
        # *   **MILLISECONDS**: milliseconds
        # *   **SECONDS**: seconds
        self.time_unit = time_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.filter_sql is not None:
            result['FilterSQL'] = self.filter_sql
        if self.remain_days is not None:
            result['RemainDays'] = self.remain_days
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.time_unit is not None:
            result['TimeUnit'] = self.time_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('FilterSQL') is not None:
            self.filter_sql = m.get('FilterSQL')
        if m.get('RemainDays') is not None:
            self.remain_days = m.get('RemainDays')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TimeUnit') is not None:
            self.time_unit = m.get('TimeUnit')
        return self


class CreateDataCronClearOrderRequestParamDbItemList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
    ):
        # The ID of the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
        # 
        # This parameter is required.
        self.db_id = db_id
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        # 
        # This parameter is required.
        self.logic = logic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateDataCronClearOrderRequestParam(TeaModel):
    def __init__(
        self,
        classify: str = None,
        cron_clear_item_list: List[CreateDataCronClearOrderRequestParamCronClearItemList] = None,
        cron_format: str = None,
        db_item_list: List[CreateDataCronClearOrderRequestParamDbItemList] = None,
        duration_hour: int = None,
        specify_duration: bool = None,
    ):
        # The reason for the data change.
        self.classify = classify
        # The tables for which you want to clear historical data.
        # 
        # This parameter is required.
        self.cron_clear_item_list = cron_clear_item_list
        # The crontab expression that you can use to run the task at a specified time. For more information, see [Crontab expression](https://help.aliyun.com/document_detail/206581.html).
        # 
        # This parameter is required.
        self.cron_format = cron_format
        # The databases for which you want to clear historical data.
        # 
        # This parameter is required.
        self.db_item_list = db_item_list
        # The amount of time taken to run the task. Unit: hours.
        # 
        # >  If the **specifyDuration** parameter is set to **true**, this parameter is required.
        self.duration_hour = duration_hour
        # Specifies whether to specify an end time for the task. Valid values:
        # 
        # *   **true**: specifies an end time for the task. The task is automatically suspended after this end time.
        # *   **false**: does not specify an end time for the task. The task is stopped after the historical data is cleared.
        # 
        # This parameter is required.
        self.specify_duration = specify_duration

    def validate(self):
        if self.cron_clear_item_list:
            for k in self.cron_clear_item_list:
                if k:
                    k.validate()
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['Classify'] = self.classify
        result['CronClearItemList'] = []
        if self.cron_clear_item_list is not None:
            for k in self.cron_clear_item_list:
                result['CronClearItemList'].append(k.to_map() if k else None)
        if self.cron_format is not None:
            result['CronFormat'] = self.cron_format
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.duration_hour is not None:
            result['DurationHour'] = self.duration_hour
        if self.specify_duration is not None:
            result['specifyDuration'] = self.specify_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.cron_clear_item_list = []
        if m.get('CronClearItemList') is not None:
            for k in m.get('CronClearItemList'):
                temp_model = CreateDataCronClearOrderRequestParamCronClearItemList()
                self.cron_clear_item_list.append(temp_model.from_map(k))
        if m.get('CronFormat') is not None:
            self.cron_format = m.get('CronFormat')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateDataCronClearOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('DurationHour') is not None:
            self.duration_hour = m.get('DurationHour')
        if m.get('specifyDuration') is not None:
            self.specify_duration = m.get('specifyDuration')
        return self


class CreateDataCronClearOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param: CreateDataCronClearOrderRequestParam = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        # The key of the attachment for the ticket. The attachment provides more instructions for this operation.
        # 
        # You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the key of the attachment.
        self.attachment_key = attachment_key
        # The purpose or objective of the data change. This reduces unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param = param
        # The stakeholders of this operation. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than Data Management (DMS) administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list
        # The ID of the tenant.
        # 
        # >  The ID of the tenant is displayed when you move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the Manage DMS tenants topic.
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataCronClearOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataCronClearOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param_shrink: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The key of the attachment for the ticket. The attachment provides more instructions for this operation.
        # 
        # You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the key of the attachment.
        self.attachment_key = attachment_key
        # The purpose or objective of the data change. This reduces unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param_shrink = param_shrink
        # The stakeholders of this operation. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than Data Management (DMS) administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink
        # The ID of the tenant.
        # 
        # >  The ID of the tenant is displayed when you move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the Manage DMS tenants topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataCronClearOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the ticket.
        self.create_order_result = create_order_result
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataCronClearOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataCronClearOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataCronClearOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataExportOrderRequestPluginParamWatermark(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        data_watermark: str = None,
        file_watermark: str = None,
        keys: List[str] = None,
        watermark_types: List[str] = None,
    ):
        # The field into which the watermark is to be embedded.
        self.column_name = column_name
        # The information to be embedded as a watermark into data.
        self.data_watermark = data_watermark
        # The information to be embedded as a watermark into files.
        self.file_watermark = file_watermark
        # One or more primary keys or unique keys.
        self.keys = keys
        # The methods in which the watermark is embedded.
        self.watermark_types = watermark_types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.data_watermark is not None:
            result['DataWatermark'] = self.data_watermark
        if self.file_watermark is not None:
            result['FileWatermark'] = self.file_watermark
        if self.keys is not None:
            result['Keys'] = self.keys
        if self.watermark_types is not None:
            result['WatermarkTypes'] = self.watermark_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DataWatermark') is not None:
            self.data_watermark = m.get('DataWatermark')
        if m.get('FileWatermark') is not None:
            self.file_watermark = m.get('FileWatermark')
        if m.get('Keys') is not None:
            self.keys = m.get('Keys')
        if m.get('WatermarkTypes') is not None:
            self.watermark_types = m.get('WatermarkTypes')
        return self


class CreateDataExportOrderRequestPluginParam(TeaModel):
    def __init__(
        self,
        affect_rows: int = None,
        classify: str = None,
        db_id: int = None,
        exe_sql: str = None,
        ignore_affect_rows: bool = None,
        ignore_affect_rows_reason: str = None,
        instance_id: int = None,
        logic: bool = None,
        watermark: CreateDataExportOrderRequestPluginParamWatermark = None,
    ):
        # The estimated number of data rows to be affected.
        # 
        # This parameter is required.
        self.affect_rows = affect_rows
        # The reason for the export ticket.
        # 
        # This parameter is required.
        self.classify = classify
        # The database ID.
        # 
        # This parameter is required.
        self.db_id = db_id
        # The SQL statements that can be executed.
        # 
        # This parameter is required.
        self.exe_sql = exe_sql
        # Specifies whether to skip verification. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # 
        # This parameter is required.
        self.ignore_affect_rows = ignore_affect_rows
        # The reason for skipping verification. This parameter is required if you set IgnoreAffectRows to true.
        self.ignore_affect_rows_reason = ignore_affect_rows_reason
        # The instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # 
        # > If you set this parameter to **true**, the database that you specify must be a logical database.
        # 
        # This parameter is required.
        self.logic = logic
        # The information about the watermarks.
        self.watermark = watermark

    def validate(self):
        if self.watermark:
            self.watermark.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.exe_sql is not None:
            result['ExeSQL'] = self.exe_sql
        if self.ignore_affect_rows is not None:
            result['IgnoreAffectRows'] = self.ignore_affect_rows
        if self.ignore_affect_rows_reason is not None:
            result['IgnoreAffectRowsReason'] = self.ignore_affect_rows_reason
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.watermark is not None:
            result['Watermark'] = self.watermark.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('ExeSQL') is not None:
            self.exe_sql = m.get('ExeSQL')
        if m.get('IgnoreAffectRows') is not None:
            self.ignore_affect_rows = m.get('IgnoreAffectRows')
        if m.get('IgnoreAffectRowsReason') is not None:
            self.ignore_affect_rows_reason = m.get('IgnoreAffectRowsReason')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Watermark') is not None:
            temp_model = CreateDataExportOrderRequestPluginParamWatermark()
            self.watermark = temp_model.from_map(m['Watermark'])
        return self


class CreateDataExportOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        parent_id: int = None,
        plugin_param: CreateDataExportOrderRequestPluginParam = None,
        real_login_user_uid: str = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key.
        self.attachment_key = attachment_key
        # The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The ID of the parent ticket.
        self.parent_id = parent_id
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.plugin_param = plugin_param
        # The UID of the Alibaba Cloud account that actually calls the API.
        self.real_login_user_uid = real_login_user_uid
        # The stakeholders involved in this operation.
        self.related_user_list = related_user_list
        # The tenant ID.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
        self.tid = tid

    def validate(self):
        if self.plugin_param:
            self.plugin_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.plugin_param is not None:
            result['PluginParam'] = self.plugin_param.to_map()
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PluginParam') is not None:
            temp_model = CreateDataExportOrderRequestPluginParam()
            self.plugin_param = temp_model.from_map(m['PluginParam'])
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataExportOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        parent_id: int = None,
        plugin_param_shrink: str = None,
        real_login_user_uid: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key.
        self.attachment_key = attachment_key
        # The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The ID of the parent ticket.
        self.parent_id = parent_id
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.plugin_param_shrink = plugin_param_shrink
        # The UID of the Alibaba Cloud account that actually calls the API.
        self.real_login_user_uid = real_login_user_uid
        # The stakeholders involved in this operation.
        self.related_user_list_shrink = related_user_list_shrink
        # The tenant ID.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.plugin_param_shrink is not None:
            result['PluginParam'] = self.plugin_param_shrink
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PluginParam') is not None:
            self.plugin_param_shrink = m.get('PluginParam')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataExportOrderResponseBodyCreateOrderResult(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
    ):
        self.create_order_result = create_order_result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        return self


class CreateDataExportOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: CreateDataExportOrderResponseBodyCreateOrderResult = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The content of the ticket.
        self.create_order_result = create_order_result
        # The error code.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.create_order_result:
            self.create_order_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            temp_model = CreateDataExportOrderResponseBodyCreateOrderResult()
            self.create_order_result = temp_model.from_map(m['CreateOrderResult'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataExportOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataExportOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataExportOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataImportOrderRequestParamDbItemList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
    ):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To obtain the ID of a physical database, call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
        # *   To obtain the ID of a logical database, call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
        # 
        # This parameter is required.
        self.db_id = db_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        # 
        # >  If you set this parameter to **true**, the database that you specify must be a logical database.
        # 
        # This parameter is required.
        self.logic = logic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateDataImportOrderRequestParam(TeaModel):
    def __init__(
        self,
        attachment_name: str = None,
        classify: str = None,
        csv_first_row_is_column_def: bool = None,
        db_item_list: List[CreateDataImportOrderRequestParamDbItemList] = None,
        exec_mode: str = None,
        file_encoding: str = None,
        file_type: str = None,
        ignore_error: bool = None,
        import_mode: str = None,
        insert_type: str = None,
        rollback_attachment_name: str = None,
        rollback_sql: str = None,
        rollback_sql_type: str = None,
        table_name: str = None,
    ):
        # The key of the attachment that contains the SQL statements used to import data. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to the attachment key from the value of the AttachmentKey parameter.
        # 
        # This parameter is required.
        self.attachment_name = attachment_name
        # The reason for the data import.
        self.classify = classify
        # The type of the CSV file. Valid values:
        # 
        # *   **true**: The first row in the CSV file contains field names.
        # *   **false**: The first row in the CSV file contains data.
        # 
        # >  This parameter is required if you set the **FileType** parameter to **CSV**.
        self.csv_first_row_is_column_def = csv_first_row_is_column_def
        # The database to which you want to import data. You can specify only one database.
        # 
        # This parameter is required.
        self.db_item_list = db_item_list
        self.exec_mode = exec_mode
        # The encoding algorithm to be used by the destination database. Valid values:
        # 
        # *   **AUTO**: automatic identification
        # *   **UTF-8**: UTF-8 encoding
        # *   **GBK**: GBK encoding
        # *   **ISO-8859-1**: ISO-8859-1 encoding
        self.file_encoding = file_encoding
        # The format of the file for the data import. Valid values:
        # 
        # *   **SQL**: an SQL file
        # *   **CSV**: a CSV file
        # 
        # This parameter is required.
        self.file_type = file_type
        # Specifies whether to skip an error that occurs. Valid values:
        # 
        # *   **true**: skips the error and continues to execute SQL statements.
        # *   **false**: stops executing SQL statements.
        self.ignore_error = ignore_error
        # The import mode. Valid values:
        # 
        # *   **FAST_MODE**: In the Execute step, the uploaded file is read and SQL statements are executed to import data to the specified destination database. Compared with the security mode, this mode can be used to import data in a less secure but more efficient manner.
        # *   **SAFE_MODE**: In the Precheck step, the uploaded file is parsed, and SQL statements or CSV file data is cached. In the Execute step, the cached SQL statements are read and executed to import data, or the cached CSV file data is read and imported to the specified destination database. This mode can be used to import data in a more secure but less efficient manner.
        self.import_mode = import_mode
        # The mode in which the data in the CSV format is to be written to the destination table. Valid values:
        # 
        # *   **INSERT**: The database checks the primary key when data is written. If a duplicate primary key value exists, an error message is returned.
        # *   **INSERT_IGNORE**: If the imported data contains data records that are the same as those in the destination table, the new data records are ignored.
        # *   **REPLACE_INTO**: If the imported data contains a row that has the same value for the primary key or unique index as one row in the destination table, the database deletes the existing row and inserts the new row into the destination table.
        # 
        # >  This parameter is required if you set the **FileType** parameter to **CSV**.
        self.insert_type = insert_type
        # The key of the attachment that contains the SQL statements used to roll back the data import. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        # 
        # >  This parameter is required if you set the **RollbackSqlType** parameter to **ATTACHMENT**.
        self.rollback_attachment_name = rollback_attachment_name
        # The SQL statements used to roll back the data import.
        # 
        # >  This parameter is required if you set the **RollbackSqlType** parameter to **TEXT**.
        self.rollback_sql = rollback_sql
        # The format of the SQL statements used to roll back the data import. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment
        self.rollback_sql_type = rollback_sql_type
        # The destination table to which you want to import the data in the CSV format.
        # 
        # >  This parameter is required if you set the **FileType** parameter to **CSV**.
        self.table_name = table_name

    def validate(self):
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_name is not None:
            result['AttachmentName'] = self.attachment_name
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.csv_first_row_is_column_def is not None:
            result['CsvFirstRowIsColumnDef'] = self.csv_first_row_is_column_def
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.exec_mode is not None:
            result['ExecMode'] = self.exec_mode
        if self.file_encoding is not None:
            result['FileEncoding'] = self.file_encoding
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.ignore_error is not None:
            result['IgnoreError'] = self.ignore_error
        if self.import_mode is not None:
            result['ImportMode'] = self.import_mode
        if self.insert_type is not None:
            result['InsertType'] = self.insert_type
        if self.rollback_attachment_name is not None:
            result['RollbackAttachmentName'] = self.rollback_attachment_name
        if self.rollback_sql is not None:
            result['RollbackSQL'] = self.rollback_sql
        if self.rollback_sql_type is not None:
            result['RollbackSqlType'] = self.rollback_sql_type
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentName') is not None:
            self.attachment_name = m.get('AttachmentName')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('CsvFirstRowIsColumnDef') is not None:
            self.csv_first_row_is_column_def = m.get('CsvFirstRowIsColumnDef')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateDataImportOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('ExecMode') is not None:
            self.exec_mode = m.get('ExecMode')
        if m.get('FileEncoding') is not None:
            self.file_encoding = m.get('FileEncoding')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('IgnoreError') is not None:
            self.ignore_error = m.get('IgnoreError')
        if m.get('ImportMode') is not None:
            self.import_mode = m.get('ImportMode')
        if m.get('InsertType') is not None:
            self.insert_type = m.get('InsertType')
        if m.get('RollbackAttachmentName') is not None:
            self.rollback_attachment_name = m.get('RollbackAttachmentName')
        if m.get('RollbackSQL') is not None:
            self.rollback_sql = m.get('RollbackSQL')
        if m.get('RollbackSqlType') is not None:
            self.rollback_sql_type = m.get('RollbackSqlType')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class CreateDataImportOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param: CreateDataImportOrderRequestParam = None,
        real_login_user_uid: str = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key
        # The purpose or objective of the data import. This parameter is used to help reduce unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param = param
        self.real_login_user_uid = real_login_user_uid
        # The stakeholders of the data import. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataImportOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataImportOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param_shrink: str = None,
        real_login_user_uid: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key
        # The purpose or objective of the data import. This parameter is used to help reduce unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param_shrink = param_shrink
        self.real_login_user_uid = real_login_user_uid
        # The stakeholders of the data import. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataImportOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the ticket.
        self.create_order_result = create_order_result
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataImportOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataImportOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataImportOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataLakeDatabaseRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        description: str = None,
        location: str = None,
        parameters: Dict[str, str] = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.description = description
        # This parameter is required.
        self.location = location
        self.parameters = parameters
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.description is not None:
            result['Description'] = self.description
        if self.location is not None:
            result['Location'] = self.location
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CreateDataLakeDatabaseShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        description: str = None,
        location: str = None,
        parameters_shrink: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.description = description
        # This parameter is required.
        self.location = location
        self.parameters_shrink = parameters_shrink
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.description is not None:
            result['Description'] = self.description
        if self.location is not None:
            result['Location'] = self.location
        if self.parameters_shrink is not None:
            result['Parameters'] = self.parameters_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Parameters') is not None:
            self.parameters_shrink = m.get('Parameters')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CreateDataLakeDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataLakeDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataLakeDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataLakeDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataLakeFunctionRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        function_input: DLFunctionInput = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.function_input = function_input
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        if self.function_input:
            self.function_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.function_input is not None:
            result['FunctionInput'] = self.function_input.to_map()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('FunctionInput') is not None:
            temp_model = DLFunctionInput()
            self.function_input = temp_model.from_map(m['FunctionInput'])
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CreateDataLakeFunctionShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        function_input_shrink: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.function_input_shrink = function_input_shrink
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.function_input_shrink is not None:
            result['FunctionInput'] = self.function_input_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('FunctionInput') is not None:
            self.function_input_shrink = m.get('FunctionInput')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CreateDataLakeFunctionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        function: DLFunction = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.function = function
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.function:
            self.function.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.function is not None:
            result['Function'] = self.function.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Function') is not None:
            temp_model = DLFunction()
            self.function = temp_model.from_map(m['Function'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataLakeFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataLakeFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataLakeFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataLakePartitionRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        if_not_exists: bool = None,
        need_result: bool = None,
        partition_input: DLPartitionInput = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.if_not_exists = if_not_exists
        self.need_result = need_result
        # This parameter is required.
        self.partition_input = partition_input
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        if self.partition_input:
            self.partition_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.if_not_exists is not None:
            result['IfNotExists'] = self.if_not_exists
        if self.need_result is not None:
            result['NeedResult'] = self.need_result
        if self.partition_input is not None:
            result['PartitionInput'] = self.partition_input.to_map()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('IfNotExists') is not None:
            self.if_not_exists = m.get('IfNotExists')
        if m.get('NeedResult') is not None:
            self.need_result = m.get('NeedResult')
        if m.get('PartitionInput') is not None:
            temp_model = DLPartitionInput()
            self.partition_input = temp_model.from_map(m['PartitionInput'])
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CreateDataLakePartitionShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        if_not_exists: bool = None,
        need_result: bool = None,
        partition_input_shrink: str = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.if_not_exists = if_not_exists
        self.need_result = need_result
        # This parameter is required.
        self.partition_input_shrink = partition_input_shrink
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.if_not_exists is not None:
            result['IfNotExists'] = self.if_not_exists
        if self.need_result is not None:
            result['NeedResult'] = self.need_result
        if self.partition_input_shrink is not None:
            result['PartitionInput'] = self.partition_input_shrink
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('IfNotExists') is not None:
            self.if_not_exists = m.get('IfNotExists')
        if m.get('NeedResult') is not None:
            self.need_result = m.get('NeedResult')
        if m.get('PartitionInput') is not None:
            self.partition_input_shrink = m.get('PartitionInput')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CreateDataLakePartitionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        partition: DLPartition = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.partition = partition
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.partition:
            self.partition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.partition is not None:
            result['Partition'] = self.partition.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Partition') is not None:
            temp_model = DLPartition()
            self.partition = temp_model.from_map(m['Partition'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataLakePartitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataLakePartitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataLakePartitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataLakeTableRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        table_input: OpenStructDLTableInput = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.table_input = table_input
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        if self.table_input:
            self.table_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.table_input is not None:
            result['TableInput'] = self.table_input.to_map()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('TableInput') is not None:
            temp_model = OpenStructDLTableInput()
            self.table_input = temp_model.from_map(m['TableInput'])
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CreateDataLakeTableShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        table_input_shrink: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.table_input_shrink = table_input_shrink
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.table_input_shrink is not None:
            result['TableInput'] = self.table_input_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('TableInput') is not None:
            self.table_input_shrink = m.get('TableInput')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CreateDataLakeTableResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        table: DLTable = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.table = table

    def validate(self):
        if self.table:
            self.table.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.table is not None:
            result['Table'] = self.table.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Table') is not None:
            temp_model = DLTable()
            self.table = temp_model.from_map(m['Table'])
        return self


class CreateDataLakeTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataLakeTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataLakeTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataTrackOrderRequestParam(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        job_end_time: str = None,
        job_start_time: str = None,
        table_names: List[str] = None,
        track_types: List[str] = None,
    ):
        # The ID of the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
        # 
        # > You can call this operation to create a data tracking ticket for only physical databases. This operation is not applicable to logical databases.
        # 
        # This parameter is required.
        self.db_id = db_id
        # The end time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
        # 
        # This parameter is required.
        self.job_end_time = job_end_time
        # The start time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
        # 
        # This parameter is required.
        self.job_start_time = job_start_time
        # The names of the tables for which you want to track data operations.
        # 
        # This parameter is required.
        self.table_names = table_names
        # The types of data operations that you want to track.
        # 
        # This parameter is required.
        self.track_types = track_types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.job_end_time is not None:
            result['JobEndTime'] = self.job_end_time
        if self.job_start_time is not None:
            result['JobStartTime'] = self.job_start_time
        if self.table_names is not None:
            result['TableNames'] = self.table_names
        if self.track_types is not None:
            result['TrackTypes'] = self.track_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('JobEndTime') is not None:
            self.job_end_time = m.get('JobEndTime')
        if m.get('JobStartTime') is not None:
            self.job_start_time = m.get('JobStartTime')
        if m.get('TableNames') is not None:
            self.table_names = m.get('TableNames')
        if m.get('TrackTypes') is not None:
            self.track_types = m.get('TrackTypes')
        return self


class CreateDataTrackOrderRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        param: CreateDataTrackOrderRequestParam = None,
        related_user_list: List[str] = None,
        tid: int = None,
    ):
        # The purpose or objective of the data tracking ticket. This parameter is used to help reduce unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param = param
        # The IDs of the operators that are related to the ticket.
        self.related_user_list = related_user_list
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataTrackOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataTrackOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        param_shrink: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The purpose or objective of the data tracking ticket. This parameter is used to help reduce unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param_shrink = param_shrink
        # The IDs of the operators that are related to the ticket.
        self.related_user_list_shrink = related_user_list_shrink
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataTrackOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The IDs of the data tracking tickets.
        self.create_order_result = create_order_result
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataTrackOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataTrackOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataTrackOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDatabaseExportOrderRequestPluginParamConfig(TeaModel):
    def __init__(
        self,
        data_option: List[str] = None,
        export_content: str = None,
        export_types: List[str] = None,
        sqlext_option: List[str] = None,
        selected_tables: List[str] = None,
        tables: Dict[str, str] = None,
        target_option: str = None,
    ):
        # The export options for big data. The options are used to filter the big data to be exported. You can leave this parameter empty.
        # 
        # This parameter is required.
        self.data_option = data_option
        # The type of data that you want to export. Valid values:
        # 
        # *   **DATA**: The data of the database is exported.
        # *   **STRUCT**: The schema of the database is exported.
        # *   **DATA_STRUCT**: The data and schema of the database are exported.
        # 
        # This parameter is required.
        self.export_content = export_content
        # The types of schemas that you want to export.
        self.export_types = export_types
        # The extension options of the SQL script. You can leave this parameter empty.
        # 
        # This parameter is required.
        self.sqlext_option = sqlext_option
        # The tables that you want to export.
        self.selected_tables = selected_tables
        # The conditions used to filter the tables to be exported.
        self.tables = tables
        # The format in which the database is exported. Valid values:
        # 
        # *   **SQL**\
        # *   **CSV**\
        # *   **XLSX**\
        # 
        # This parameter is required.
        self.target_option = target_option

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_option is not None:
            result['DataOption'] = self.data_option
        if self.export_content is not None:
            result['ExportContent'] = self.export_content
        if self.export_types is not None:
            result['ExportTypes'] = self.export_types
        if self.sqlext_option is not None:
            result['SQLExtOption'] = self.sqlext_option
        if self.selected_tables is not None:
            result['SelectedTables'] = self.selected_tables
        if self.tables is not None:
            result['Tables'] = self.tables
        if self.target_option is not None:
            result['TargetOption'] = self.target_option
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataOption') is not None:
            self.data_option = m.get('DataOption')
        if m.get('ExportContent') is not None:
            self.export_content = m.get('ExportContent')
        if m.get('ExportTypes') is not None:
            self.export_types = m.get('ExportTypes')
        if m.get('SQLExtOption') is not None:
            self.sqlext_option = m.get('SQLExtOption')
        if m.get('SelectedTables') is not None:
            self.selected_tables = m.get('SelectedTables')
        if m.get('Tables') is not None:
            self.tables = m.get('Tables')
        if m.get('TargetOption') is not None:
            self.target_option = m.get('TargetOption')
        return self


class CreateDatabaseExportOrderRequestPluginParam(TeaModel):
    def __init__(
        self,
        classify: str = None,
        config: CreateDatabaseExportOrderRequestPluginParamConfig = None,
        db_id: int = None,
        instance_id: int = None,
        logic: bool = None,
        search_name: str = None,
    ):
        # The reason for the database export.
        # 
        # This parameter is required.
        self.classify = classify
        # The configurations for database export.
        # 
        # This parameter is required.
        self.config = config
        # The database ID.
        # 
        # This parameter is required.
        self.db_id = db_id
        # The instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        # 
        # This parameter is required.
        self.logic = logic
        # The name that is used to search for the database.
        # 
        # This parameter is required.
        self.search_name = search_name

    def validate(self):
        if self.config:
            self.config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('Config') is not None:
            temp_model = CreateDatabaseExportOrderRequestPluginParamConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class CreateDatabaseExportOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        parent_id: int = None,
        plugin_param: CreateDatabaseExportOrderRequestPluginParam = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key.
        self.attachment_key = attachment_key
        # The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The ID of the parent ticket.
        self.parent_id = parent_id
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.plugin_param = plugin_param
        # The stakeholders involved in this operation.
        self.related_user_list = related_user_list
        # The tenant ID.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
        self.tid = tid

    def validate(self):
        if self.plugin_param:
            self.plugin_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.plugin_param is not None:
            result['PluginParam'] = self.plugin_param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PluginParam') is not None:
            temp_model = CreateDatabaseExportOrderRequestPluginParam()
            self.plugin_param = temp_model.from_map(m['PluginParam'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDatabaseExportOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        parent_id: int = None,
        plugin_param_shrink: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key.
        self.attachment_key = attachment_key
        # The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The ID of the parent ticket.
        self.parent_id = parent_id
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.plugin_param_shrink = plugin_param_shrink
        # The stakeholders involved in this operation.
        self.related_user_list_shrink = related_user_list_shrink
        # The tenant ID.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.plugin_param_shrink is not None:
            result['PluginParam'] = self.plugin_param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('PluginParam') is not None:
            self.plugin_param_shrink = m.get('PluginParam')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDatabaseExportOrderResponseBodyCreateOrderResult(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
    ):
        self.create_order_result = create_order_result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        return self


class CreateDatabaseExportOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: CreateDatabaseExportOrderResponseBodyCreateOrderResult = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The information about the ticket.
        self.create_order_result = create_order_result
        # The error code returned.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.create_order_result:
            self.create_order_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            temp_model = CreateDatabaseExportOrderResponseBodyCreateOrderResult()
            self.create_order_result = temp_model.from_map(m['CreateOrderResult'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDatabaseExportOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDatabaseExportOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDatabaseExportOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDifyInstanceRequest(TeaModel):
    def __init__(
        self,
        adbpg_instance_mode: str = None,
        backup_vswitch_id: str = None,
        client_token: str = None,
        data_region: str = None,
        database_option: str = None,
        db_engine_type: str = None,
        db_engine_version: str = None,
        db_instance_account: str = None,
        db_instance_category: str = None,
        db_instance_class: str = None,
        db_instance_password: str = None,
        db_resource_id: int = None,
        db_storage_size: str = None,
        db_storage_type: str = None,
        dry_run: bool = None,
        edition: str = None,
        enable_extra_endpoint: bool = None,
        gpu_node_spec: str = None,
        kv_store_account: str = None,
        kv_store_engine_version: str = None,
        kv_store_instance_class: str = None,
        kv_store_node_type: str = None,
        kv_store_option: str = None,
        kv_store_password: str = None,
        kv_store_resource_id: int = None,
        kv_store_type: str = None,
        major_version: str = None,
        model_id: str = None,
        model_option: str = None,
        nat_gateway_option: str = None,
        oss_path: str = None,
        oss_resource_id: int = None,
        pay_period: int = None,
        pay_period_type: str = None,
        pay_type: str = None,
        replicas: int = None,
        resource_quota: str = None,
        security_group_id: str = None,
        seg_disk_performance_level: str = None,
        seg_node_num: int = None,
        storage_type: str = None,
        v_switch_id: str = None,
        vectordb_account: str = None,
        vectordb_category: str = None,
        vectordb_engine_version: str = None,
        vectordb_instance_spec: str = None,
        vectordb_option: str = None,
        vectordb_password: str = None,
        vectordb_resource_id: int = None,
        vectordb_storage_size: str = None,
        vectordb_storage_type: str = None,
        vectordb_type: str = None,
        vpc_id: str = None,
        workspace_description: str = None,
        workspace_id: str = None,
        workspace_name: str = None,
        workspace_option: str = None,
        zone_id: str = None,
    ):
        self.adbpg_instance_mode = adbpg_instance_mode
        self.backup_vswitch_id = backup_vswitch_id
        self.client_token = client_token
        # This parameter is required.
        self.data_region = data_region
        self.database_option = database_option
        self.db_engine_type = db_engine_type
        self.db_engine_version = db_engine_version
        self.db_instance_account = db_instance_account
        self.db_instance_category = db_instance_category
        self.db_instance_class = db_instance_class
        self.db_instance_password = db_instance_password
        self.db_resource_id = db_resource_id
        self.db_storage_size = db_storage_size
        self.db_storage_type = db_storage_type
        self.dry_run = dry_run
        self.edition = edition
        self.enable_extra_endpoint = enable_extra_endpoint
        self.gpu_node_spec = gpu_node_spec
        self.kv_store_account = kv_store_account
        self.kv_store_engine_version = kv_store_engine_version
        self.kv_store_instance_class = kv_store_instance_class
        self.kv_store_node_type = kv_store_node_type
        self.kv_store_option = kv_store_option
        self.kv_store_password = kv_store_password
        self.kv_store_resource_id = kv_store_resource_id
        self.kv_store_type = kv_store_type
        self.major_version = major_version
        self.model_id = model_id
        self.model_option = model_option
        self.nat_gateway_option = nat_gateway_option
        self.oss_path = oss_path
        self.oss_resource_id = oss_resource_id
        self.pay_period = pay_period
        self.pay_period_type = pay_period_type
        self.pay_type = pay_type
        self.replicas = replicas
        # This parameter is required.
        self.resource_quota = resource_quota
        # This parameter is required.
        self.security_group_id = security_group_id
        self.seg_disk_performance_level = seg_disk_performance_level
        self.seg_node_num = seg_node_num
        self.storage_type = storage_type
        # This parameter is required.
        self.v_switch_id = v_switch_id
        self.vectordb_account = vectordb_account
        self.vectordb_category = vectordb_category
        self.vectordb_engine_version = vectordb_engine_version
        self.vectordb_instance_spec = vectordb_instance_spec
        self.vectordb_option = vectordb_option
        self.vectordb_password = vectordb_password
        self.vectordb_resource_id = vectordb_resource_id
        self.vectordb_storage_size = vectordb_storage_size
        self.vectordb_storage_type = vectordb_storage_type
        self.vectordb_type = vectordb_type
        # This parameter is required.
        self.vpc_id = vpc_id
        self.workspace_description = workspace_description
        self.workspace_id = workspace_id
        self.workspace_name = workspace_name
        self.workspace_option = workspace_option
        # This parameter is required.
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adbpg_instance_mode is not None:
            result['AdbpgInstanceMode'] = self.adbpg_instance_mode
        if self.backup_vswitch_id is not None:
            result['BackupVSwitchId'] = self.backup_vswitch_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.database_option is not None:
            result['DatabaseOption'] = self.database_option
        if self.db_engine_type is not None:
            result['DbEngineType'] = self.db_engine_type
        if self.db_engine_version is not None:
            result['DbEngineVersion'] = self.db_engine_version
        if self.db_instance_account is not None:
            result['DbInstanceAccount'] = self.db_instance_account
        if self.db_instance_category is not None:
            result['DbInstanceCategory'] = self.db_instance_category
        if self.db_instance_class is not None:
            result['DbInstanceClass'] = self.db_instance_class
        if self.db_instance_password is not None:
            result['DbInstancePassword'] = self.db_instance_password
        if self.db_resource_id is not None:
            result['DbResourceId'] = self.db_resource_id
        if self.db_storage_size is not None:
            result['DbStorageSize'] = self.db_storage_size
        if self.db_storage_type is not None:
            result['DbStorageType'] = self.db_storage_type
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.edition is not None:
            result['Edition'] = self.edition
        if self.enable_extra_endpoint is not None:
            result['EnableExtraEndpoint'] = self.enable_extra_endpoint
        if self.gpu_node_spec is not None:
            result['GpuNodeSpec'] = self.gpu_node_spec
        if self.kv_store_account is not None:
            result['KvStoreAccount'] = self.kv_store_account
        if self.kv_store_engine_version is not None:
            result['KvStoreEngineVersion'] = self.kv_store_engine_version
        if self.kv_store_instance_class is not None:
            result['KvStoreInstanceClass'] = self.kv_store_instance_class
        if self.kv_store_node_type is not None:
            result['KvStoreNodeType'] = self.kv_store_node_type
        if self.kv_store_option is not None:
            result['KvStoreOption'] = self.kv_store_option
        if self.kv_store_password is not None:
            result['KvStorePassword'] = self.kv_store_password
        if self.kv_store_resource_id is not None:
            result['KvStoreResourceId'] = self.kv_store_resource_id
        if self.kv_store_type is not None:
            result['KvStoreType'] = self.kv_store_type
        if self.major_version is not None:
            result['MajorVersion'] = self.major_version
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.model_option is not None:
            result['ModelOption'] = self.model_option
        if self.nat_gateway_option is not None:
            result['NatGatewayOption'] = self.nat_gateway_option
        if self.oss_path is not None:
            result['OssPath'] = self.oss_path
        if self.oss_resource_id is not None:
            result['OssResourceId'] = self.oss_resource_id
        if self.pay_period is not None:
            result['PayPeriod'] = self.pay_period
        if self.pay_period_type is not None:
            result['PayPeriodType'] = self.pay_period_type
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.resource_quota is not None:
            result['ResourceQuota'] = self.resource_quota
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.seg_disk_performance_level is not None:
            result['SegDiskPerformanceLevel'] = self.seg_disk_performance_level
        if self.seg_node_num is not None:
            result['SegNodeNum'] = self.seg_node_num
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vectordb_account is not None:
            result['VectordbAccount'] = self.vectordb_account
        if self.vectordb_category is not None:
            result['VectordbCategory'] = self.vectordb_category
        if self.vectordb_engine_version is not None:
            result['VectordbEngineVersion'] = self.vectordb_engine_version
        if self.vectordb_instance_spec is not None:
            result['VectordbInstanceSpec'] = self.vectordb_instance_spec
        if self.vectordb_option is not None:
            result['VectordbOption'] = self.vectordb_option
        if self.vectordb_password is not None:
            result['VectordbPassword'] = self.vectordb_password
        if self.vectordb_resource_id is not None:
            result['VectordbResourceId'] = self.vectordb_resource_id
        if self.vectordb_storage_size is not None:
            result['VectordbStorageSize'] = self.vectordb_storage_size
        if self.vectordb_storage_type is not None:
            result['VectordbStorageType'] = self.vectordb_storage_type
        if self.vectordb_type is not None:
            result['VectordbType'] = self.vectordb_type
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.workspace_description is not None:
            result['WorkspaceDescription'] = self.workspace_description
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.workspace_name is not None:
            result['WorkspaceName'] = self.workspace_name
        if self.workspace_option is not None:
            result['WorkspaceOption'] = self.workspace_option
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdbpgInstanceMode') is not None:
            self.adbpg_instance_mode = m.get('AdbpgInstanceMode')
        if m.get('BackupVSwitchId') is not None:
            self.backup_vswitch_id = m.get('BackupVSwitchId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DatabaseOption') is not None:
            self.database_option = m.get('DatabaseOption')
        if m.get('DbEngineType') is not None:
            self.db_engine_type = m.get('DbEngineType')
        if m.get('DbEngineVersion') is not None:
            self.db_engine_version = m.get('DbEngineVersion')
        if m.get('DbInstanceAccount') is not None:
            self.db_instance_account = m.get('DbInstanceAccount')
        if m.get('DbInstanceCategory') is not None:
            self.db_instance_category = m.get('DbInstanceCategory')
        if m.get('DbInstanceClass') is not None:
            self.db_instance_class = m.get('DbInstanceClass')
        if m.get('DbInstancePassword') is not None:
            self.db_instance_password = m.get('DbInstancePassword')
        if m.get('DbResourceId') is not None:
            self.db_resource_id = m.get('DbResourceId')
        if m.get('DbStorageSize') is not None:
            self.db_storage_size = m.get('DbStorageSize')
        if m.get('DbStorageType') is not None:
            self.db_storage_type = m.get('DbStorageType')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('Edition') is not None:
            self.edition = m.get('Edition')
        if m.get('EnableExtraEndpoint') is not None:
            self.enable_extra_endpoint = m.get('EnableExtraEndpoint')
        if m.get('GpuNodeSpec') is not None:
            self.gpu_node_spec = m.get('GpuNodeSpec')
        if m.get('KvStoreAccount') is not None:
            self.kv_store_account = m.get('KvStoreAccount')
        if m.get('KvStoreEngineVersion') is not None:
            self.kv_store_engine_version = m.get('KvStoreEngineVersion')
        if m.get('KvStoreInstanceClass') is not None:
            self.kv_store_instance_class = m.get('KvStoreInstanceClass')
        if m.get('KvStoreNodeType') is not None:
            self.kv_store_node_type = m.get('KvStoreNodeType')
        if m.get('KvStoreOption') is not None:
            self.kv_store_option = m.get('KvStoreOption')
        if m.get('KvStorePassword') is not None:
            self.kv_store_password = m.get('KvStorePassword')
        if m.get('KvStoreResourceId') is not None:
            self.kv_store_resource_id = m.get('KvStoreResourceId')
        if m.get('KvStoreType') is not None:
            self.kv_store_type = m.get('KvStoreType')
        if m.get('MajorVersion') is not None:
            self.major_version = m.get('MajorVersion')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('ModelOption') is not None:
            self.model_option = m.get('ModelOption')
        if m.get('NatGatewayOption') is not None:
            self.nat_gateway_option = m.get('NatGatewayOption')
        if m.get('OssPath') is not None:
            self.oss_path = m.get('OssPath')
        if m.get('OssResourceId') is not None:
            self.oss_resource_id = m.get('OssResourceId')
        if m.get('PayPeriod') is not None:
            self.pay_period = m.get('PayPeriod')
        if m.get('PayPeriodType') is not None:
            self.pay_period_type = m.get('PayPeriodType')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('ResourceQuota') is not None:
            self.resource_quota = m.get('ResourceQuota')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SegDiskPerformanceLevel') is not None:
            self.seg_disk_performance_level = m.get('SegDiskPerformanceLevel')
        if m.get('SegNodeNum') is not None:
            self.seg_node_num = m.get('SegNodeNum')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VectordbAccount') is not None:
            self.vectordb_account = m.get('VectordbAccount')
        if m.get('VectordbCategory') is not None:
            self.vectordb_category = m.get('VectordbCategory')
        if m.get('VectordbEngineVersion') is not None:
            self.vectordb_engine_version = m.get('VectordbEngineVersion')
        if m.get('VectordbInstanceSpec') is not None:
            self.vectordb_instance_spec = m.get('VectordbInstanceSpec')
        if m.get('VectordbOption') is not None:
            self.vectordb_option = m.get('VectordbOption')
        if m.get('VectordbPassword') is not None:
            self.vectordb_password = m.get('VectordbPassword')
        if m.get('VectordbResourceId') is not None:
            self.vectordb_resource_id = m.get('VectordbResourceId')
        if m.get('VectordbStorageSize') is not None:
            self.vectordb_storage_size = m.get('VectordbStorageSize')
        if m.get('VectordbStorageType') is not None:
            self.vectordb_storage_type = m.get('VectordbStorageType')
        if m.get('VectordbType') is not None:
            self.vectordb_type = m.get('VectordbType')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WorkspaceDescription') is not None:
            self.workspace_description = m.get('WorkspaceDescription')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('WorkspaceName') is not None:
            self.workspace_name = m.get('WorkspaceName')
        if m.get('WorkspaceOption') is not None:
            self.workspace_option = m.get('WorkspaceOption')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateDifyInstanceResponseBodyData(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        replicas: int = None,
        resource_quota: str = None,
        security_group_id: str = None,
        status: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
        workspace_id: str = None,
        zone_id: str = None,
    ):
        self.instance_id = instance_id
        self.replicas = replicas
        self.resource_quota = resource_quota
        self.security_group_id = security_group_id
        self.status = status
        self.v_switch_id = v_switch_id
        self.vpc_id = vpc_id
        self.workspace_id = workspace_id
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.resource_quota is not None:
            result['ResourceQuota'] = self.resource_quota
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('ResourceQuota') is not None:
            self.resource_quota = m.get('ResourceQuota')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateDifyInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateDifyInstanceResponseBodyData = None,
        error_code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateDifyInstanceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDifyInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDifyInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDifyInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFreeLockCorrectOrderRequestParamDbItemList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
    ):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To obtain the ID of a physical database, call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
        # *   To obtain the ID of a logical database, call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
        # 
        # This parameter is required.
        self.db_id = db_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        # 
        # This parameter is required.
        self.logic = logic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateFreeLockCorrectOrderRequestParam(TeaModel):
    def __init__(
        self,
        attachment_name: str = None,
        classify: str = None,
        db_item_list: List[CreateFreeLockCorrectOrderRequestParamDbItemList] = None,
        exec_mode: str = None,
        exec_sql: str = None,
        rollback_attachment_name: str = None,
        rollback_sql: str = None,
        rollback_sql_type: str = None,
        sql_type: str = None,
    ):
        # The key of the attachment that contains the SQL statements used to change data. This parameter is not supported.
        self.attachment_name = attachment_name
        # The reason for the data change.
        self.classify = classify
        # The databases in which you want to change data.
        # 
        # This parameter is required.
        self.db_item_list = db_item_list
        # The execution mode of the ticket after the ticket is approved. Valid values:
        # 
        # *   **COMMITOR**: The data change is performed by the user who submits the ticket.
        # *   **AUTO**: The data change is automatically performed after the ticket is approved.
        # *   **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
        self.exec_mode = exec_mode
        # The SQL statements that you want to execute to change data.
        # 
        # This parameter is required.
        self.exec_sql = exec_sql
        # The key of the attachment that contains the SQL statements used to roll back the data change.
        self.rollback_attachment_name = rollback_attachment_name
        # The SQL statements used to roll back the data change.
        self.rollback_sql = rollback_sql
        # The format of the SQL statements used to roll back the data change. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment. This value is not supported.
        self.rollback_sql_type = rollback_sql_type
        # The format of the SQL statements used to change data. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment. This value is not supported.
        # 
        # This parameter is required.
        self.sql_type = sql_type

    def validate(self):
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_name is not None:
            result['AttachmentName'] = self.attachment_name
        if self.classify is not None:
            result['Classify'] = self.classify
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.exec_mode is not None:
            result['ExecMode'] = self.exec_mode
        if self.exec_sql is not None:
            result['ExecSQL'] = self.exec_sql
        if self.rollback_attachment_name is not None:
            result['RollbackAttachmentName'] = self.rollback_attachment_name
        if self.rollback_sql is not None:
            result['RollbackSQL'] = self.rollback_sql
        if self.rollback_sql_type is not None:
            result['RollbackSqlType'] = self.rollback_sql_type
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentName') is not None:
            self.attachment_name = m.get('AttachmentName')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateFreeLockCorrectOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('ExecMode') is not None:
            self.exec_mode = m.get('ExecMode')
        if m.get('ExecSQL') is not None:
            self.exec_sql = m.get('ExecSQL')
        if m.get('RollbackAttachmentName') is not None:
            self.rollback_attachment_name = m.get('RollbackAttachmentName')
        if m.get('RollbackSQL') is not None:
            self.rollback_sql = m.get('RollbackSQL')
        if m.get('RollbackSqlType') is not None:
            self.rollback_sql_type = m.get('RollbackSqlType')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        return self


class CreateFreeLockCorrectOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param: CreateFreeLockCorrectOrderRequestParam = None,
        real_login_user_uid: str = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key
        # The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param = param
        self.real_login_user_uid = real_login_user_uid
        # The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateFreeLockCorrectOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateFreeLockCorrectOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param_shrink: str = None,
        real_login_user_uid: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key
        # The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param_shrink = param_shrink
        self.real_login_user_uid = real_login_user_uid
        # The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateFreeLockCorrectOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the ticket.
        self.create_order_result = create_order_result
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateFreeLockCorrectOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFreeLockCorrectOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFreeLockCorrectOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLakeHouseSpaceRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        dev_db_id: str = None,
        dw_db_type: str = None,
        mode: str = None,
        prod_db_id: str = None,
        space_config: str = None,
        space_name: str = None,
        tid: int = None,
    ):
        # The description of the workspace.
        self.description = description
        # The ID of the development database. You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the ID.
        # 
        # This parameter is required.
        self.dev_db_id = dev_db_id
        # The type of the database. Valid values:
        # 
        # *   **14**: AnalyticDB for MySQL
        # *   **18**: AnalyticDB for PostgreSQL
        # 
        # This parameter is required.
        self.dw_db_type = dw_db_type
        # The mode in which the workspace runs. Valid values:
        # 
        # *   **0**: basic mode. This mode is unavailable.
        # *   **1**: standard mode.
        # 
        # This parameter is required.
        self.mode = mode
        # The ID of the production database. You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the ID.
        self.prod_db_id = prod_db_id
        # The configuration of the workspace. Valid values:
        # 
        # *   **skipManualRunCheck**: No security rule check is required in the trial run phase.
        # *   **skipPublishApprove**: No approval is required for publishing and O\\&M.
        # 
        # This parameter is required.
        self.space_config = space_config
        # The name of the workspace.
        # 
        # This parameter is required.
        self.space_name = space_name
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_db_id is not None:
            result['DevDbId'] = self.dev_db_id
        if self.dw_db_type is not None:
            result['DwDbType'] = self.dw_db_type
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.prod_db_id is not None:
            result['ProdDbId'] = self.prod_db_id
        if self.space_config is not None:
            result['SpaceConfig'] = self.space_config
        if self.space_name is not None:
            result['SpaceName'] = self.space_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevDbId') is not None:
            self.dev_db_id = m.get('DevDbId')
        if m.get('DwDbType') is not None:
            self.dw_db_type = m.get('DwDbType')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('ProdDbId') is not None:
            self.prod_db_id = m.get('ProdDbId')
        if m.get('SpaceConfig') is not None:
            self.space_config = m.get('SpaceConfig')
        if m.get('SpaceName') is not None:
            self.space_name = m.get('SpaceName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateLakeHouseSpaceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        space_id: int = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The ID of the workspace.
        self.space_id = space_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateLakeHouseSpaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLakeHouseSpaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLakeHouseSpaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLogicDatabaseRequest(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_ids: List[int] = None,
        tid: int = None,
    ):
        # The alias of the logical database.
        # 
        # This parameter is required.
        self.alias = alias
        # The IDs of the physical databases that compose the logical database. You can specify one or more database IDs. You can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the physical databases.
        # 
        # This parameter is required.
        self.database_ids = database_ids
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseIds') is not None:
            self.database_ids = m.get('DatabaseIds')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateLogicDatabaseShrinkRequest(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_ids_shrink: str = None,
        tid: int = None,
    ):
        # The alias of the logical database.
        # 
        # This parameter is required.
        self.alias = alias
        # The IDs of the physical databases that compose the logical database. You can specify one or more database IDs. You can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the physical databases.
        # 
        # This parameter is required.
        self.database_ids_shrink = database_ids_shrink
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_ids_shrink is not None:
            result['DatabaseIds'] = self.database_ids_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseIds') is not None:
            self.database_ids_shrink = m.get('DatabaseIds')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateLogicDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        logic_db_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the logical database.
        self.logic_db_id = logic_db_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateLogicDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLogicDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLogicDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMetaCategoryRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        parent_category_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.name = name
        self.parent_category_id = parent_category_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.parent_category_id is not None:
            result['ParentCategoryId'] = self.parent_category_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParentCategoryId') is not None:
            self.parent_category_id = m.get('ParentCategoryId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateMetaCategoryResponseBody(TeaModel):
    def __init__(
        self,
        category: MetaCategory = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.category = category
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.category:
            self.category.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            temp_model = MetaCategory()
            self.category = temp_model.from_map(m['Category'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateMetaCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMetaCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMetaCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        plugin_param: Dict[str, Any] = None,
        plugin_type: str = None,
        related_user_list: str = None,
        tid: int = None,
    ):
        # The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the key of the attachment.
        self.attachment_key = attachment_key
        # The description of the ticket to be created.
        # 
        # This parameter is required.
        self.comment = comment
        # The ticket creation parameter. The value is a JSON string. The value of this parameter differs based on the type of the ticket. For more information, see the **PluginParam parameter** section in this topic.
        # 
        # This parameter is required.
        self.plugin_param = plugin_param
        # The type of the ticket. For more information, see [PluginType parameter](https://help.aliyun.com/document_detail/429109.html).
        # 
        # This parameter is required.
        self.plugin_type = plugin_type
        # The IDs of the stakeholders that are involved in the ticket. Separate multiple IDs with commas (,).
        self.related_user_list = related_user_list
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.plugin_param is not None:
            result['PluginParam'] = self.plugin_param
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('PluginParam') is not None:
            self.plugin_param = m.get('PluginParam')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        plugin_param_shrink: str = None,
        plugin_type: str = None,
        related_user_list: str = None,
        tid: int = None,
    ):
        # The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the key of the attachment.
        self.attachment_key = attachment_key
        # The description of the ticket to be created.
        # 
        # This parameter is required.
        self.comment = comment
        # The ticket creation parameter. The value is a JSON string. The value of this parameter differs based on the type of the ticket. For more information, see the **PluginParam parameter** section in this topic.
        # 
        # This parameter is required.
        self.plugin_param_shrink = plugin_param_shrink
        # The type of the ticket. For more information, see [PluginType parameter](https://help.aliyun.com/document_detail/429109.html).
        # 
        # This parameter is required.
        self.plugin_type = plugin_type
        # The IDs of the stakeholders that are involved in the ticket. Separate multiple IDs with commas (,).
        self.related_user_list = related_user_list
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.plugin_param_shrink is not None:
            result['PluginParam'] = self.plugin_param_shrink
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('PluginParam') is not None:
            self.plugin_param_shrink = m.get('PluginParam')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateOrderResponseBodyCreateOrderResult(TeaModel):
    def __init__(
        self,
        order_ids: List[int] = None,
    ):
        self.order_ids = order_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_ids is not None:
            result['OrderIds'] = self.order_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderIds') is not None:
            self.order_ids = m.get('OrderIds')
        return self


class CreateOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: CreateOrderResponseBodyCreateOrderResult = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the ticket.
        self.create_order_result = create_order_result
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.create_order_result:
            self.create_order_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            temp_model = CreateOrderResponseBodyCreateOrderResult()
            self.create_order_result = temp_model.from_map(m['CreateOrderResult'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProcCorrectOrderRequestParamDbItemList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
    ):
        # This parameter is required.
        self.db_id = db_id
        # This parameter is required.
        self.logic = logic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateProcCorrectOrderRequestParam(TeaModel):
    def __init__(
        self,
        classify: str = None,
        db_item_list: List[CreateProcCorrectOrderRequestParamDbItemList] = None,
        exec_mode: str = None,
        exec_sql: str = None,
        rollback_attachment_name: str = None,
        rollback_sql: str = None,
        rollback_sql_type: str = None,
    ):
        self.classify = classify
        # This parameter is required.
        self.db_item_list = db_item_list
        self.exec_mode = exec_mode
        # This parameter is required.
        self.exec_sql = exec_sql
        self.rollback_attachment_name = rollback_attachment_name
        self.rollback_sql = rollback_sql
        self.rollback_sql_type = rollback_sql_type

    def validate(self):
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['Classify'] = self.classify
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.exec_mode is not None:
            result['ExecMode'] = self.exec_mode
        if self.exec_sql is not None:
            result['ExecSQL'] = self.exec_sql
        if self.rollback_attachment_name is not None:
            result['RollbackAttachmentName'] = self.rollback_attachment_name
        if self.rollback_sql is not None:
            result['RollbackSQL'] = self.rollback_sql
        if self.rollback_sql_type is not None:
            result['RollbackSqlType'] = self.rollback_sql_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateProcCorrectOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('ExecMode') is not None:
            self.exec_mode = m.get('ExecMode')
        if m.get('ExecSQL') is not None:
            self.exec_sql = m.get('ExecSQL')
        if m.get('RollbackAttachmentName') is not None:
            self.rollback_attachment_name = m.get('RollbackAttachmentName')
        if m.get('RollbackSQL') is not None:
            self.rollback_sql = m.get('RollbackSQL')
        if m.get('RollbackSqlType') is not None:
            self.rollback_sql_type = m.get('RollbackSqlType')
        return self


class CreateProcCorrectOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param: CreateProcCorrectOrderRequestParam = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        self.attachment_key = attachment_key
        # This parameter is required.
        self.comment = comment
        # This parameter is required.
        self.param = param
        self.related_user_list = related_user_list
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateProcCorrectOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateProcCorrectOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param_shrink: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        self.attachment_key = attachment_key
        # This parameter is required.
        self.comment = comment
        # This parameter is required.
        self.param_shrink = param_shrink
        self.related_user_list_shrink = related_user_list_shrink
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateProcCorrectOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.create_order_result = create_order_result
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateProcCorrectOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProcCorrectOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProcCorrectOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProxyRequest(TeaModel):
    def __init__(
        self,
        instance_id: int = None,
        password: str = None,
        tid: int = None,
        username: str = None,
    ):
        # The ID of the database instance. You can call the [ListInstances](https://www.alibabacloud.com/help/en/data-management-service/latest/listinstances) or [GetInstance](https://www.alibabacloud.com/help/en/data-management-service/latest/getinstance) operation to query the database instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The password of the database account.
        # 
        # This parameter is required.
        self.password = password
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid
        # The username of the database account.
        # 
        # This parameter is required.
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.password is not None:
            result['Password'] = self.password
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class CreateProxyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        proxy_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the secure access proxy.
        self.proxy_id = proxy_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateProxyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProxyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProxyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProxyAccessRequest(TeaModel):
    def __init__(
        self,
        indep_account: str = None,
        indep_password: str = None,
        proxy_id: int = None,
        tid: int = None,
        user_id: int = None,
    ):
        # The database account.
        self.indep_account = indep_account
        # The password that is used to log on to the database.
        self.indep_password = indep_password
        # The ID of the security protection agent. You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) or [GetProxy](https://www.alibabacloud.com/help/en/data-management-service/latest/getproxy) operation to obtain this parameter.
        # 
        # This parameter is required.
        self.proxy_id = proxy_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
        self.tid = tid
        # The ID of the user. You can call the [ListUsers](https://www.alibabacloud.com/help/en/data-management-service/latest/listusers) or [GetUser](https://www.alibabacloud.com/help/en/data-management-service/latest/getuser) operation to obtain this parameter.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.indep_account is not None:
            result['IndepAccount'] = self.indep_account
        if self.indep_password is not None:
            result['IndepPassword'] = self.indep_password
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndepAccount') is not None:
            self.indep_account = m.get('IndepAccount')
        if m.get('IndepPassword') is not None:
            self.indep_password = m.get('IndepPassword')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CreateProxyAccessResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        proxy_access_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned to the query task.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique.
        self.proxy_access_id = proxy_access_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateProxyAccessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProxyAccessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProxyAccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePublishGroupTaskRequest(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
        order_id: int = None,
        plan_time: str = None,
        publish_strategy: str = None,
        tid: int = None,
    ):
        # The ID of the database for which the schema design is executed.
        # 
        # This parameter is required.
        self.db_id = db_id
        # Indicates whether the database is a logical database.
        # 
        # This parameter is required.
        self.logic = logic
        # The ID of the ticket.
        # 
        # > : You can create a schema design ticket in the DMS console. For more information, see [Design schemas](https://help.aliyun.com/document_detail/69711.html). You can also create a schema design ticket by calling the [CreateOrder](https://help.aliyun.com/document_detail/144649.html) operation and obtain the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The time to execute the schema design ticket.
        self.plan_time = plan_time
        # The policy to execute the schema design ticket. Valid values:
        # 
        # *   IMMEDIATELY: immediately executes the schema design ticket.
        # *   REGULARLY: executes the schema design ticket at a scheduled time.
        # 
        # This parameter is required.
        self.publish_strategy = publish_strategy
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.plan_time is not None:
            result['PlanTime'] = self.plan_time
        if self.publish_strategy is not None:
            result['PublishStrategy'] = self.publish_strategy
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PlanTime') is not None:
            self.plan_time = m.get('PlanTime')
        if m.get('PublishStrategy') is not None:
            self.publish_strategy = m.get('PublishStrategy')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreatePublishGroupTaskResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        task_id: int = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success
        # The ID of the job.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CreatePublishGroupTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePublishGroupTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePublishGroupTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSQLReviewOrderRequestParam(TeaModel):
    def __init__(
        self,
        attachment_key_list: List[str] = None,
        db_id: int = None,
        project_name: str = None,
    ):
        # The files to be reviewed. Multiple files can be reviewed at a time.
        # 
        # This parameter is required.
        self.attachment_key_list = attachment_key_list
        # The ID of the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
        # 
        # >  You can call this operation to query only physical databases. This operation is unavailable to query logical databases.
        # 
        # This parameter is required.
        self.db_id = db_id
        # The name of the project.
        # 
        # This parameter is required.
        self.project_name = project_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key_list is not None:
            result['AttachmentKeyList'] = self.attachment_key_list
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKeyList') is not None:
            self.attachment_key_list = m.get('AttachmentKeyList')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        return self


class CreateSQLReviewOrderRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        param: CreateSQLReviewOrderRequestParam = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        # The purpose or objective of the SQL review. This reduces unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param = param
        # The stakeholders involved in this operation. All the specified stakeholders can view the ticket details and take part in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateSQLReviewOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateSQLReviewOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        param_shrink: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The purpose or objective of the SQL review. This reduces unnecessary communication.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param_shrink = param_shrink
        # The stakeholders involved in this operation. All the specified stakeholders can view the ticket details and take part in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateSQLReviewOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The result of the ticket creation task.
        self.create_order_result = create_order_result
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSQLReviewOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSQLReviewOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSQLReviewOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateScenarioRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        scenario_name: str = None,
        tid: int = None,
    ):
        # The description of the business scenario.
        self.description = description
        # The name of the business scenario.
        # 
        # This parameter is required.
        self.scenario_name = scenario_name
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.scenario_name is not None:
            result['ScenarioName'] = self.scenario_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ScenarioName') is not None:
            self.scenario_name = m.get('ScenarioName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateScenarioResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        scenario_id: int = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The ID of the business scenario.
        self.scenario_id = scenario_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateStandardGroupRequest(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        description: str = None,
        group_name: str = None,
        tid: int = None,
    ):
        # The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        # 
        # This parameter is required.
        self.db_type = db_type
        # The description of the security rule set.
        # 
        # This parameter is required.
        self.description = description
        # The name of the security rule set.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateStandardGroupResponseBodyStandardGroup(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        description: str = None,
        group_id: int = None,
        group_mode: str = None,
        group_name: str = None,
        last_mender_id: int = None,
    ):
        # The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        self.db_type = db_type
        # The description of the security rule set.
        self.description = description
        # The security rule set ID.
        self.group_id = group_id
        # The control mode. Valid values:
        # 
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        # *   **COMMON**: Security Collaboration
        self.group_mode = group_mode
        # The name of the security rule set.
        self.group_name = group_name
        # The ID of the user who creates the security rule set.
        self.last_mender_id = last_mender_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.last_mender_id is not None:
            result['LastMenderId'] = self.last_mender_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LastMenderId') is not None:
            self.last_mender_id = m.get('LastMenderId')
        return self


class CreateStandardGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        standard_group: CreateStandardGroupResponseBodyStandardGroup = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The information about the created security rule set.
        self.standard_group = standard_group
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StandardGroup') is not None:
            temp_model = CreateStandardGroupResponseBodyStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateStandardGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateStandardGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateStandardGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateStructSyncOrderRequestParamSource(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_search_name: str = None,
        logic: bool = None,
        version_id: str = None,
    ):
        # The ID of the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
        # 
        # This parameter is required.
        self.db_id = db_id
        # The name that is used to search for the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the name of the database.
        # 
        # This parameter is required.
        self.db_search_name = db_search_name
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        self.logic = logic
        # The version number of the schema. The default value is the latest schema version number. For more information, see [Manage schema versions](https://help.aliyun.com/document_detail/202275.html).
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_search_name is not None:
            result['DbSearchName'] = self.db_search_name
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbSearchName') is not None:
            self.db_search_name = m.get('DbSearchName')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class CreateStructSyncOrderRequestParamTableInfoList(TeaModel):
    def __init__(
        self,
        source_table_name: str = None,
        target_table_name: str = None,
    ):
        # The name of the source table.
        self.source_table_name = source_table_name
        # The name of the destination table.
        self.target_table_name = target_table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        if self.target_table_name is not None:
            result['TargetTableName'] = self.target_table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        if m.get('TargetTableName') is not None:
            self.target_table_name = m.get('TargetTableName')
        return self


class CreateStructSyncOrderRequestParamTarget(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_search_name: str = None,
        logic: bool = None,
        version_id: str = None,
    ):
        # The ID of the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
        # 
        # This parameter is required.
        self.db_id = db_id
        # The name that is used to search for the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the name of the database.
        # 
        # This parameter is required.
        self.db_search_name = db_search_name
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        self.logic = logic
        # The version number. By default, this parameter is left empty.
        # 
        # >  If you specify the schema version number of the destination database, Data Management (DMS) only compares the schemas of the two databases.
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_search_name is not None:
            result['DbSearchName'] = self.db_search_name
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbSearchName') is not None:
            self.db_search_name = m.get('DbSearchName')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class CreateStructSyncOrderRequestParam(TeaModel):
    def __init__(
        self,
        ignore_error: bool = None,
        source: CreateStructSyncOrderRequestParamSource = None,
        table_info_list: List[CreateStructSyncOrderRequestParamTableInfoList] = None,
        target: CreateStructSyncOrderRequestParamTarget = None,
    ):
        # Specifies whether to skip an error that occurs in executing an SQL statement. Valid values:
        # 
        # *   **true**: continues to execute subsequent SQL statements if an error occurs in executing an SQL statement.
        # *   **false**: stops executing subsequent SQL statements if an error occurs in executing an SQL statement.
        self.ignore_error = ignore_error
        # The information about the base database.
        # 
        # This parameter is required.
        self.source = source
        # The information about the table of which you want to synchronize the schema.
        self.table_info_list = table_info_list
        # The information about the database to which you want to synchronize the schema of a table.
        # 
        # This parameter is required.
        self.target = target

    def validate(self):
        if self.source:
            self.source.validate()
        if self.table_info_list:
            for k in self.table_info_list:
                if k:
                    k.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_error is not None:
            result['IgnoreError'] = self.ignore_error
        if self.source is not None:
            result['Source'] = self.source.to_map()
        result['TableInfoList'] = []
        if self.table_info_list is not None:
            for k in self.table_info_list:
                result['TableInfoList'].append(k.to_map() if k else None)
        if self.target is not None:
            result['Target'] = self.target.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IgnoreError') is not None:
            self.ignore_error = m.get('IgnoreError')
        if m.get('Source') is not None:
            temp_model = CreateStructSyncOrderRequestParamSource()
            self.source = temp_model.from_map(m['Source'])
        self.table_info_list = []
        if m.get('TableInfoList') is not None:
            for k in m.get('TableInfoList'):
                temp_model = CreateStructSyncOrderRequestParamTableInfoList()
                self.table_info_list.append(temp_model.from_map(k))
        if m.get('Target') is not None:
            temp_model = CreateStructSyncOrderRequestParamTarget()
            self.target = temp_model.from_map(m['Target'])
        return self


class CreateStructSyncOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param: CreateStructSyncOrderRequestParam = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        # The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the key of the attachment.
        self.attachment_key = attachment_key
        # The remarks of the ticket.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param = param
        # The IDs of the stakeholders.
        self.related_user_list = related_user_list
        # The ID of the tenant.
        # 
        # >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateStructSyncOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateStructSyncOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param_shrink: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the key of the attachment.
        self.attachment_key = attachment_key
        # The remarks of the ticket.
        # 
        # This parameter is required.
        self.comment = comment
        # The parameters of the ticket.
        # 
        # This parameter is required.
        self.param_shrink = param_shrink
        # The IDs of the stakeholders.
        self.related_user_list_shrink = related_user_list_shrink
        # The ID of the tenant.
        # 
        # >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateStructSyncOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The result of creating the ticket.
        self.create_order_result = create_order_result
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateStructSyncOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateStructSyncOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateStructSyncOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTaskRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        graph_param: str = None,
        node_content: str = None,
        node_name: str = None,
        node_output: str = None,
        node_type: str = None,
        tid: int = None,
        time_variables: str = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The position of the node on the Directed Acyclic Graph (DAG).
        self.graph_param = graph_param
        # The configuration of the node.
        self.node_content = node_content
        # The name of the node that you want to create.
        # 
        # This parameter is required.
        self.node_name = node_name
        # The output variables configured for the task.
        self.node_output = node_output
        # The type of the node that you want to create. For more information about the valid values for this parameter, see [NodeType parameter](https://help.aliyun.com/document_detail/424705.html).
        # 
        # This parameter is required.
        self.node_type = node_type
        # The tenant ID.
        # 
        # >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid
        # The time variables configured for the node.
        self.time_variables = time_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.graph_param is not None:
            result['GraphParam'] = self.graph_param
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_output is not None:
            result['NodeOutput'] = self.node_output
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('GraphParam') is not None:
            self.graph_param = m.get('GraphParam')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeOutput') is not None:
            self.node_output = m.get('NodeOutput')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class CreateTaskResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        node_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the task node returned when the task was created.
        self.node_id = node_id
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTaskFlowRequest(TeaModel):
    def __init__(
        self,
        dag_name: str = None,
        description: str = None,
        scenario_id: int = None,
        tid: int = None,
    ):
        # The name of the task flow.
        # 
        # This parameter is required.
        self.dag_name = dag_name
        # The description of the task flow.
        self.description = description
        # The ID of the scenario.
        self.scenario_id = scenario_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.description is not None:
            result['Description'] = self.description
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the task flow.
        self.dag_id = dag_id
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUploadFileJobRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        file_source: str = None,
        tid: int = None,
        upload_url: str = None,
    ):
        # The name of the attachment file.
        # 
        # >  The file name must end with .txt or .sql. For example, the file name can be test.txt or test.sql.
        # 
        # This parameter is required.
        self.file_name = file_name
        # The purpose of the attachment file. Valid values:
        # 
        # *   **datacorrect**: The file is uploaded to change data.
        # *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
        # *   **big-file**: The file is uploaded to import multiple data records at a time.
        # *   **sqlreview**: The file is uploaded for SQL review.
        # 
        # This parameter is required.
        self.file_source = file_source
        # The ID of the tenant.
        # 
        # >  You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid
        # The URL of the attachment file. The URL must be an HTTP URL or an HTTPS URL.
        # 
        # >  You can upload the attachment file to an Object Storage Service (OSS) bucket and obtain the URL of the file in the OSS console. For more information, see [Share objects](https://help.aliyun.com/document_detail/195674.html).
        # 
        # This parameter is required.
        self.upload_url = upload_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_source is not None:
            result['FileSource'] = self.file_source
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.upload_url is not None:
            result['UploadURL'] = self.upload_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSource') is not None:
            self.file_source = m.get('FileSource')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UploadURL') is not None:
            self.upload_url = m.get('UploadURL')
        return self


class CreateUploadFileJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        job_key: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The key of the task.
        # 
        # >  You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the progress and details of the task.
        self.job_key = job_key
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_key is not None:
            result['JobKey'] = self.job_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobKey') is not None:
            self.job_key = m.get('JobKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateUploadFileJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUploadFileJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUploadFileJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUploadOSSFileJobRequestUploadTarget(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        endpoint: str = None,
        object_name: str = None,
    ):
        # The name of the OSS bucket.
        # 
        # This parameter is required.
        self.bucket_name = bucket_name
        # The endpoint of the OSS bucket.
        # 
        # This parameter is required.
        self.endpoint = endpoint
        # The name of the OSS object.
        # 
        # This parameter is required.
        self.object_name = object_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.object_name is not None:
            result['ObjectName'] = self.object_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('ObjectName') is not None:
            self.object_name = m.get('ObjectName')
        return self


class CreateUploadOSSFileJobRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        file_source: str = None,
        tid: int = None,
        upload_target: CreateUploadOSSFileJobRequestUploadTarget = None,
    ):
        # The name of the file.
        # 
        # > The file name must end with .txt or .sql. For example, the file name can be text.txt.
        # 
        # This parameter is required.
        self.file_name = file_name
        # The purpose of the file upload task. Valid values:
        # 
        # *   **datacorrect**: The file is uploaded to change data.
        # *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
        # *   **big-file**: The file is uploaded to import multiple data records at a time.
        # *   **sqlreview**: The file is uploaded for SQL review.
        # 
        # This parameter is required.
        self.file_source = file_source
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid
        # The information about the OSS file to be uploaded.
        # 
        # This parameter is required.
        self.upload_target = upload_target

    def validate(self):
        if self.upload_target:
            self.upload_target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_source is not None:
            result['FileSource'] = self.file_source
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.upload_target is not None:
            result['UploadTarget'] = self.upload_target.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSource') is not None:
            self.file_source = m.get('FileSource')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UploadTarget') is not None:
            temp_model = CreateUploadOSSFileJobRequestUploadTarget()
            self.upload_target = temp_model.from_map(m['UploadTarget'])
        return self


class CreateUploadOSSFileJobShrinkRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        file_source: str = None,
        tid: int = None,
        upload_target_shrink: str = None,
    ):
        # The name of the file.
        # 
        # > The file name must end with .txt or .sql. For example, the file name can be text.txt.
        # 
        # This parameter is required.
        self.file_name = file_name
        # The purpose of the file upload task. Valid values:
        # 
        # *   **datacorrect**: The file is uploaded to change data.
        # *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
        # *   **big-file**: The file is uploaded to import multiple data records at a time.
        # *   **sqlreview**: The file is uploaded for SQL review.
        # 
        # This parameter is required.
        self.file_source = file_source
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid
        # The information about the OSS file to be uploaded.
        # 
        # This parameter is required.
        self.upload_target_shrink = upload_target_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_source is not None:
            result['FileSource'] = self.file_source
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.upload_target_shrink is not None:
            result['UploadTarget'] = self.upload_target_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSource') is not None:
            self.file_source = m.get('FileSource')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UploadTarget') is not None:
            self.upload_target_shrink = m.get('UploadTarget')
        return self


class CreateUploadOSSFileJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        job_key: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The key of the file upload task. You can query the upload progress and task details. For more information, see [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html).
        self.job_key = job_key
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_key is not None:
            result['JobKey'] = self.job_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobKey') is not None:
            self.job_key = m.get('JobKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateUploadOSSFileJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUploadOSSFileJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUploadOSSFileJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAbacAuthorizationRequest(TeaModel):
    def __init__(
        self,
        authorization_id: int = None,
        identity_type: str = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.authorization_id = authorization_id
        # This parameter is required.
        self.identity_type = identity_type
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorization_id is not None:
            result['AuthorizationId'] = self.authorization_id
        if self.identity_type is not None:
            result['IdentityType'] = self.identity_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorizationId') is not None:
            self.authorization_id = m.get('AuthorizationId')
        if m.get('IdentityType') is not None:
            self.identity_type = m.get('IdentityType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteAbacAuthorizationResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteAbacAuthorizationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAbacAuthorizationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAbacAuthorizationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAbacPolicyRequest(TeaModel):
    def __init__(
        self,
        abac_policy_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.abac_policy_id = abac_policy_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abac_policy_id is not None:
            result['AbacPolicyId'] = self.abac_policy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbacPolicyId') is not None:
            self.abac_policy_id = m.get('AbacPolicyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteAbacPolicyResponseBody(TeaModel):
    def __init__(
        self,
        delete_policy_result: bool = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.delete_policy_result = delete_policy_result
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_policy_result is not None:
            result['DeletePolicyResult'] = self.delete_policy_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeletePolicyResult') is not None:
            self.delete_policy_result = m.get('DeletePolicyResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteAbacPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAbacPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAbacPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAuthorityTemplateRequest(TeaModel):
    def __init__(
        self,
        template_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.template_id = template_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteAuthorityTemplateResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tid: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteAuthorityTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAuthorityTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAuthorityTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataLakeDatabaseRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteDataLakeDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataLakeDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataLakeDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataLakeDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataLakeFunctionRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        function_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.function_name = function_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteDataLakeFunctionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataLakeFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataLakeFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataLakeFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataLakePartitionRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        if_exists: bool = None,
        partition_values: List[str] = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.if_exists = if_exists
        # This parameter is required.
        self.partition_values = partition_values
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.if_exists is not None:
            result['IfExists'] = self.if_exists
        if self.partition_values is not None:
            result['PartitionValues'] = self.partition_values
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('IfExists') is not None:
            self.if_exists = m.get('IfExists')
        if m.get('PartitionValues') is not None:
            self.partition_values = m.get('PartitionValues')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteDataLakePartitionShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        if_exists: bool = None,
        partition_values_shrink: str = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.if_exists = if_exists
        # This parameter is required.
        self.partition_values_shrink = partition_values_shrink
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.if_exists is not None:
            result['IfExists'] = self.if_exists
        if self.partition_values_shrink is not None:
            result['PartitionValues'] = self.partition_values_shrink
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('IfExists') is not None:
            self.if_exists = m.get('IfExists')
        if m.get('PartitionValues') is not None:
            self.partition_values_shrink = m.get('PartitionValues')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteDataLakePartitionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataLakePartitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataLakePartitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataLakePartitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataLakeTableRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteDataLakeTableResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataLakeTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataLakeTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataLakeTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInstanceRequest(TeaModel):
    def __init__(
        self,
        host: str = None,
        port: int = None,
        sid: str = None,
        tid: int = None,
    ):
        # The endpoint of the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to obtain the endpoint.
        # 
        # This parameter is required.
        self.host = host
        # The port number that is used to connect to the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to obtain the port number.
        # 
        # This parameter is required.
        self.port = port
        # The system ID (SID) of the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to obtain the SID.
        self.sid = sid
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLakeHouseSpaceRequest(TeaModel):
    def __init__(
        self,
        space_id: int = None,
        tid: int = None,
    ):
        # The ID of the workspace. You can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to obtain the workspace ID.
        # 
        # This parameter is required.
        self.space_id = space_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLakeHouseSpaceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   true: The request is successful.
        # *   false: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLakeHouseSpaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLakeHouseSpaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLakeHouseSpaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLhMembersRequest(TeaModel):
    def __init__(
        self,
        member_ids: List[int] = None,
        object_id: int = None,
        object_type: int = None,
        tid: int = None,
    ):
        # The ID of the user to be removed. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain the user ID.
        # 
        # This parameter is required.
        self.member_ids = member_ids
        # The ID of the object.
        # 
        # *   If the object is a workspace, you can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to obtain the workspace ID.
        # *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the task flow ID.
        # 
        # This parameter is required.
        self.object_id = object_id
        # The type of the object. Valid values:
        # 
        # *   **0**: workspace
        # *   **1**: task flow
        # 
        # This parameter is required.
        self.object_type = object_type
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_ids is not None:
            result['MemberIds'] = self.member_ids
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberIds') is not None:
            self.member_ids = m.get('MemberIds')
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLhMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        member_ids_shrink: str = None,
        object_id: int = None,
        object_type: int = None,
        tid: int = None,
    ):
        # The ID of the user to be removed. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain the user ID.
        # 
        # This parameter is required.
        self.member_ids_shrink = member_ids_shrink
        # The ID of the object.
        # 
        # *   If the object is a workspace, you can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to obtain the workspace ID.
        # *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the task flow ID.
        # 
        # This parameter is required.
        self.object_id = object_id
        # The type of the object. Valid values:
        # 
        # *   **0**: workspace
        # *   **1**: task flow
        # 
        # This parameter is required.
        self.object_type = object_type
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_ids_shrink is not None:
            result['MemberIds'] = self.member_ids_shrink
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberIds') is not None:
            self.member_ids_shrink = m.get('MemberIds')
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLhMembersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLhMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLhMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLhMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLogicDatabaseRequest(TeaModel):
    def __init__(
        self,
        logic_db_id: int = None,
        tid: int = None,
    ):
        # The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the ID of the logical database.
        # 
        # This parameter is required.
        self.logic_db_id = logic_db_id
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLogicDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLogicDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLogicDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLogicDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLogicTableRouteConfigRequest(TeaModel):
    def __init__(
        self,
        route_key: str = None,
        table_id: int = None,
        tid: int = None,
    ):
        # The unique key of the routing algorithm. You can call the [ListLogicTableRouteConfig](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictablerouteconfig) operation to query the unique key.
        # 
        # This parameter is required.
        self.route_key = route_key
        # The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
        # 
        # This parameter is required.
        self.table_id = table_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_key is not None:
            result['RouteKey'] = self.route_key
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RouteKey') is not None:
            self.route_key = m.get('RouteKey')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLogicTableRouteConfigResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLogicTableRouteConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLogicTableRouteConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLogicTableRouteConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMetaCategoryRequest(TeaModel):
    def __init__(
        self,
        category_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.category_id = category_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteMetaCategoryResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMetaCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMetaCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMetaCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProxyRequest(TeaModel):
    def __init__(
        self,
        proxy_id: int = None,
        tid: int = None,
    ):
        # The ID of the security protection agent. You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) or [GetProxy](https://www.alibabacloud.com/help/en/data-management-service/latest/getproxy) operation to obtain this parameter.
        # 
        # This parameter is required.
        self.proxy_id = proxy_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteProxyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned to the query task.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteProxyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProxyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProxyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProxyAccessRequest(TeaModel):
    def __init__(
        self,
        proxy_access_id: int = None,
        tid: int = None,
    ):
        # The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique. You can call the [ListProxyAccesses](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxyaccesses) operation to obtain this parameter.
        # 
        # This parameter is required.
        self.proxy_access_id = proxy_access_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteProxyAccessResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned to the query task.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteProxyAccessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProxyAccessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProxyAccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteScenarioRequest(TeaModel):
    def __init__(
        self,
        scenario_id: int = None,
        tid: int = None,
    ):
        # The ID of the business scenario.
        # 
        # This parameter is required.
        self.scenario_id = scenario_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteScenarioResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteStandardGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.group_id = group_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteStandardGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteStandardGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteStandardGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteStandardGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTaskRequest(TeaModel):
    def __init__(
        self,
        node_id: str = None,
        tid: int = None,
    ):
        # The ID of the node you want to delete.
        # 
        # This parameter is required.
        self.node_id = node_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteTaskResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTaskFlowRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the ID of the task flow.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTaskFlowEdgesByConditionRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        id: int = None,
        node_end: int = None,
        node_from: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the task flow edge to delete.
        self.id = id
        # The ID of the end node of the edge to delete.
        self.node_end = node_end
        # The ID of the start node on the edge to delete.
        self.node_from = node_from
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteTaskFlowEdgesByConditionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTaskFlowEdgesByConditionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTaskFlowEdgesByConditionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTaskFlowEdgesByConditionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUserRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
        uid: str = None,
    ):
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid
        # The unique ID (UID) of Alibaba Cloud account to delete.
        # 
        # This parameter is required.
        self.uid = uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        return self


class DeleteUserResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDifyAttributeRequest(TeaModel):
    def __init__(
        self,
        app_uuid: str = None,
        client_token: str = None,
        data_region: str = None,
        workspace_id: str = None,
    ):
        self.app_uuid = app_uuid
        self.client_token = client_token
        self.data_region = data_region
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_uuid is not None:
            result['AppUuid'] = self.app_uuid
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppUuid') is not None:
            self.app_uuid = m.get('AppUuid')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DescribeDifyAttributeResponseBodyRoot(TeaModel):
    def __init__(
        self,
        app_uuid: str = None,
        replicas: str = None,
        resource_quota: str = None,
        security_group_id: str = None,
        status: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
        workspace_id: str = None,
        zone_id: str = None,
    ):
        self.app_uuid = app_uuid
        self.replicas = replicas
        self.resource_quota = resource_quota
        self.security_group_id = security_group_id
        self.status = status
        self.v_switch_id = v_switch_id
        self.vpc_id = vpc_id
        self.workspace_id = workspace_id
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_uuid is not None:
            result['AppUuid'] = self.app_uuid
        if self.replicas is not None:
            result['Replicas'] = self.replicas
        if self.resource_quota is not None:
            result['ResourceQuota'] = self.resource_quota
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppUuid') is not None:
            self.app_uuid = m.get('AppUuid')
        if m.get('Replicas') is not None:
            self.replicas = m.get('Replicas')
        if m.get('ResourceQuota') is not None:
            self.resource_quota = m.get('ResourceQuota')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeDifyAttributeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        root: DescribeDifyAttributeResponseBodyRoot = None,
        success: bool = None,
    ):
        self.code = code
        self.error_code = error_code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.root = root
        self.success = success

    def validate(self):
        if self.root:
            self.root.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.root is not None:
            result['Root'] = self.root.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Root') is not None:
            temp_model = DescribeDifyAttributeResponseBodyRoot()
            self.root = temp_model.from_map(m['Root'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeDifyAttributeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDifyAttributeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDifyAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDifyDefaultVpcRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        data_region: str = None,
        workspace_id: str = None,
    ):
        self.client_token = client_token
        self.data_region = data_region
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DescribeDifyDefaultVpcResponseBodyData(TeaModel):
    def __init__(
        self,
        default_vpc_id: str = None,
        workspace_id: str = None,
    ):
        self.default_vpc_id = default_vpc_id
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_vpc_id is not None:
            result['DefaultVpcId'] = self.default_vpc_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DefaultVpcId') is not None:
            self.default_vpc_id = m.get('DefaultVpcId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DescribeDifyDefaultVpcResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeDifyDefaultVpcResponseBodyData = None,
        error_code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeDifyDefaultVpcResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeDifyDefaultVpcResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDifyDefaultVpcResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDifyDefaultVpcResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDifyEditionsRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        data_region: str = None,
    ):
        self.client_token = client_token
        self.data_region = data_region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        return self


class DescribeDifyEditionsResponseBodyData(TeaModel):
    def __init__(
        self,
        community: List[str] = None,
        enterprise: List[str] = None,
    ):
        self.community = community
        self.enterprise = enterprise

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.community is not None:
            result['Community'] = self.community
        if self.enterprise is not None:
            result['Enterprise'] = self.enterprise
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Community') is not None:
            self.community = m.get('Community')
        if m.get('Enterprise') is not None:
            self.enterprise = m.get('Enterprise')
        return self


class DescribeDifyEditionsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeDifyEditionsResponseBodyData = None,
        error_code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeDifyEditionsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeDifyEditionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDifyEditionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDifyEditionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDifyRegionsRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        data_region: str = None,
    ):
        self.client_token = client_token
        self.data_region = data_region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        return self


class DescribeDifyRegionsResponseBodyData(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeDifyRegionsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[DescribeDifyRegionsResponseBodyData] = None,
        error_code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeDifyRegionsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeDifyRegionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDifyRegionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDifyRegionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableUserRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
        uid: str = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid
        # The UID of the Alibaba Cloud account.
        # 
        # This parameter is required.
        self.uid = uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        return self


class DisableUserResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DisableUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DownloadDataTrackResultRequestColumnFilter(TeaModel):
    def __init__(
        self,
        between_end: str = None,
        between_start: str = None,
        column_name: str = None,
        in_list: List[str] = None,
        operator: str = None,
        value: str = None,
    ):
        # The end value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
        self.between_end = between_end
        # The start value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
        self.between_start = between_start
        # The name of the column.
        self.column_name = column_name
        # The IN list used in the filter condition.
        self.in_list = in_list
        # The type of the operator used to configure the filter condition. Valid values:
        # 
        # *   **EQUAL**: retrieves the column whose value is equal to the specified value.
        # *   **NOT_EQUAL**: retrieves the column whose value is not equal to the specified value.
        # *   **IN**: retrieves the column whose value is in the IN list.
        # *   **BETWEEN**: retrieves the column whose value is in the specified range.
        # *   **LESS**: retrieves the column whose value is less than the specified value.
        # *   **MORE**: retrieves the column whose value is greater than the specified value.
        # *   **NOT_IN**: retrieves the column whose value is not in the IN list.
        self.operator = operator
        # The value used in the filter condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.between_end is not None:
            result['BetweenEnd'] = self.between_end
        if self.between_start is not None:
            result['BetweenStart'] = self.between_start
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.in_list is not None:
            result['InList'] = self.in_list
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BetweenEnd') is not None:
            self.between_end = m.get('BetweenEnd')
        if m.get('BetweenStart') is not None:
            self.between_start = m.get('BetweenStart')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('InList') is not None:
            self.in_list = m.get('InList')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DownloadDataTrackResultRequest(TeaModel):
    def __init__(
        self,
        column_filter: DownloadDataTrackResultRequestColumnFilter = None,
        event_id_list: List[int] = None,
        filter_end_time: str = None,
        filter_start_time: str = None,
        filter_table_list: List[str] = None,
        filter_type_list: List[str] = None,
        order_id: int = None,
        rollback_sqltype: str = None,
        tid: int = None,
    ):
        # The condition to filter columns.
        self.column_filter = column_filter
        # The IDs of the events.
        self.event_id_list = event_id_list
        # The end time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
        self.filter_end_time = filter_end_time
        # The start time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
        self.filter_start_time = filter_start_time
        # The names of the tables for which you want to track data operations.
        self.filter_table_list = filter_table_list
        # The types of data operations that you want to track.
        self.filter_type_list = filter_type_list
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The type of the SQL statement.
        # 
        # *   **REVERSE**: undoes or rolls back an executed SQL statement, which is equivalent to the UNDO SQL statement.
        # *   **FORWARD**: redoes or re-executes an SQL statement that failed to be executed, which is equivalent to the REDO SQL statement.
        # 
        # This parameter is required.
        self.rollback_sqltype = rollback_sqltype
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        if self.column_filter:
            self.column_filter.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_filter is not None:
            result['ColumnFilter'] = self.column_filter.to_map()
        if self.event_id_list is not None:
            result['EventIdList'] = self.event_id_list
        if self.filter_end_time is not None:
            result['FilterEndTime'] = self.filter_end_time
        if self.filter_start_time is not None:
            result['FilterStartTime'] = self.filter_start_time
        if self.filter_table_list is not None:
            result['FilterTableList'] = self.filter_table_list
        if self.filter_type_list is not None:
            result['FilterTypeList'] = self.filter_type_list
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.rollback_sqltype is not None:
            result['RollbackSQLType'] = self.rollback_sqltype
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnFilter') is not None:
            temp_model = DownloadDataTrackResultRequestColumnFilter()
            self.column_filter = temp_model.from_map(m['ColumnFilter'])
        if m.get('EventIdList') is not None:
            self.event_id_list = m.get('EventIdList')
        if m.get('FilterEndTime') is not None:
            self.filter_end_time = m.get('FilterEndTime')
        if m.get('FilterStartTime') is not None:
            self.filter_start_time = m.get('FilterStartTime')
        if m.get('FilterTableList') is not None:
            self.filter_table_list = m.get('FilterTableList')
        if m.get('FilterTypeList') is not None:
            self.filter_type_list = m.get('FilterTypeList')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RollbackSQLType') is not None:
            self.rollback_sqltype = m.get('RollbackSQLType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DownloadDataTrackResultShrinkRequest(TeaModel):
    def __init__(
        self,
        column_filter_shrink: str = None,
        event_id_list_shrink: str = None,
        filter_end_time: str = None,
        filter_start_time: str = None,
        filter_table_list_shrink: str = None,
        filter_type_list_shrink: str = None,
        order_id: int = None,
        rollback_sqltype: str = None,
        tid: int = None,
    ):
        # The condition to filter columns.
        self.column_filter_shrink = column_filter_shrink
        # The IDs of the events.
        self.event_id_list_shrink = event_id_list_shrink
        # The end time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
        self.filter_end_time = filter_end_time
        # The start time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
        self.filter_start_time = filter_start_time
        # The names of the tables for which you want to track data operations.
        self.filter_table_list_shrink = filter_table_list_shrink
        # The types of data operations that you want to track.
        self.filter_type_list_shrink = filter_type_list_shrink
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The type of the SQL statement.
        # 
        # *   **REVERSE**: undoes or rolls back an executed SQL statement, which is equivalent to the UNDO SQL statement.
        # *   **FORWARD**: redoes or re-executes an SQL statement that failed to be executed, which is equivalent to the REDO SQL statement.
        # 
        # This parameter is required.
        self.rollback_sqltype = rollback_sqltype
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_filter_shrink is not None:
            result['ColumnFilter'] = self.column_filter_shrink
        if self.event_id_list_shrink is not None:
            result['EventIdList'] = self.event_id_list_shrink
        if self.filter_end_time is not None:
            result['FilterEndTime'] = self.filter_end_time
        if self.filter_start_time is not None:
            result['FilterStartTime'] = self.filter_start_time
        if self.filter_table_list_shrink is not None:
            result['FilterTableList'] = self.filter_table_list_shrink
        if self.filter_type_list_shrink is not None:
            result['FilterTypeList'] = self.filter_type_list_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.rollback_sqltype is not None:
            result['RollbackSQLType'] = self.rollback_sqltype
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnFilter') is not None:
            self.column_filter_shrink = m.get('ColumnFilter')
        if m.get('EventIdList') is not None:
            self.event_id_list_shrink = m.get('EventIdList')
        if m.get('FilterEndTime') is not None:
            self.filter_end_time = m.get('FilterEndTime')
        if m.get('FilterStartTime') is not None:
            self.filter_start_time = m.get('FilterStartTime')
        if m.get('FilterTableList') is not None:
            self.filter_table_list_shrink = m.get('FilterTableList')
        if m.get('FilterTypeList') is not None:
            self.filter_type_list_shrink = m.get('FilterTypeList')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RollbackSQLType') is not None:
            self.rollback_sqltype = m.get('RollbackSQLType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DownloadDataTrackResultResponseBody(TeaModel):
    def __init__(
        self,
        download_key_id: str = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the download key, which is used to download the parsing result of the data tracking task.
        self.download_key_id = download_key_id
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_key_id is not None:
            result['DownloadKeyId'] = self.download_key_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadKeyId') is not None:
            self.download_key_id = m.get('DownloadKeyId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DownloadDataTrackResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DownloadDataTrackResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DownloadDataTrackResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EditLogicDatabaseRequest(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_ids: List[int] = None,
        logic_db_id: int = None,
        tid: int = None,
    ):
        # - The alias of the logical database. If you want to change the alias, specify a new alias.
        # - If you do not need to change the alias of the logical database, call the [GetLogicDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/getlogicdatabase) or [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the alias of the logical database.
        # 
        # This parameter is required.
        self.alias = alias
        # - The IDs of the physical databases that compose the logical database. If you want to change the physical databases, you can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the new physical databases that you want to specify.
        # - If you do not want to change the physical databases, you can call the [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the IDs of the physical databases that compose the logical database.
        # 
        # This parameter is required.
        self.database_ids = database_ids
        # The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) operation to query the ID of the logical database.
        # 
        # This parameter is required.
        self.logic_db_id = logic_db_id
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseIds') is not None:
            self.database_ids = m.get('DatabaseIds')
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class EditLogicDatabaseShrinkRequest(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_ids_shrink: str = None,
        logic_db_id: int = None,
        tid: int = None,
    ):
        # - The alias of the logical database. If you want to change the alias, specify a new alias.
        # - If you do not need to change the alias of the logical database, call the [GetLogicDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/getlogicdatabase) or [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the alias of the logical database.
        # 
        # This parameter is required.
        self.alias = alias
        # - The IDs of the physical databases that compose the logical database. If you want to change the physical databases, you can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the new physical databases that you want to specify.
        # - If you do not want to change the physical databases, you can call the [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the IDs of the physical databases that compose the logical database.
        # 
        # This parameter is required.
        self.database_ids_shrink = database_ids_shrink
        # The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) operation to query the ID of the logical database.
        # 
        # This parameter is required.
        self.logic_db_id = logic_db_id
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_ids_shrink is not None:
            result['DatabaseIds'] = self.database_ids_shrink
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseIds') is not None:
            self.database_ids_shrink = m.get('DatabaseIds')
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class EditLogicDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EditLogicDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EditLogicDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EditLogicDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EditMetaKnowledgeAssetRequest(TeaModel):
    def __init__(
        self,
        asset_description: str = None,
        column_name: str = None,
        db_id: int = None,
        table_name: str = None,
        table_schema_name: str = None,
    ):
        # This parameter is required.
        self.asset_description = asset_description
        self.column_name = column_name
        # This parameter is required.
        self.db_id = db_id
        # This parameter is required.
        self.table_name = table_name
        self.table_schema_name = table_schema_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asset_description is not None:
            result['AssetDescription'] = self.asset_description
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_schema_name is not None:
            result['TableSchemaName'] = self.table_schema_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AssetDescription') is not None:
            self.asset_description = m.get('AssetDescription')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableSchemaName') is not None:
            self.table_schema_name = m.get('TableSchemaName')
        return self


class EditMetaKnowledgeAssetResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EditMetaKnowledgeAssetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EditMetaKnowledgeAssetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EditMetaKnowledgeAssetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableUserRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
        uid: str = None,
    ):
        # The ID of the tenant.
        # 
        # >  To obtain the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Tenant information](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid
        # The UID of the Alibaba Cloud account.
        # 
        # This parameter is required.
        self.uid = uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        return self


class EnableUserResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteDataCorrectRequest(TeaModel):
    def __init__(
        self,
        action_detail: Dict[str, Any] = None,
        order_id: int = None,
        real_login_user_uid: str = None,
        tid: str = None,
    ):
        # The parameters that are required to perform the data change.
        # 
        # ```
        # 
        # json
        # "actionDetail" : {
        #     "startTime" :"2021-07-01 00:00:00", // Specify the start time to change data. If you want to immediately change data, you do not need to set this parameter. 
        #     "endTime" : "2021-07-01 01:00:00", // Specify the end time to change data. If you want to immediately change data, you do not need to set this parameter. 
        #     "transaction" : false, // Specify whether to change data as a transaction. 
        #     "backupData" : true // Specify whether to back up data. 
        #   }
        # ```
        self.action_detail = action_detail
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the Alibaba Cloud account that is used to call the API operation.
        self.real_login_user_uid = real_login_user_uid
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail is not None:
            result['ActionDetail'] = self.action_detail
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteDataCorrectShrinkRequest(TeaModel):
    def __init__(
        self,
        action_detail_shrink: str = None,
        order_id: int = None,
        real_login_user_uid: str = None,
        tid: str = None,
    ):
        # The parameters that are required to perform the data change.
        # 
        # ```
        # 
        # json
        # "actionDetail" : {
        #     "startTime" :"2021-07-01 00:00:00", // Specify the start time to change data. If you want to immediately change data, you do not need to set this parameter. 
        #     "endTime" : "2021-07-01 01:00:00", // Specify the end time to change data. If you want to immediately change data, you do not need to set this parameter. 
        #     "transaction" : false, // Specify whether to change data as a transaction. 
        #     "backupData" : true // Specify whether to back up data. 
        #   }
        # ```
        self.action_detail_shrink = action_detail_shrink
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the Alibaba Cloud account that is used to call the API operation.
        self.real_login_user_uid = real_login_user_uid
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail_shrink is not None:
            result['ActionDetail'] = self.action_detail_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail_shrink = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteDataCorrectResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteDataCorrectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteDataCorrectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteDataCorrectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteDataExportRequest(TeaModel):
    def __init__(
        self,
        action_detail: Dict[str, Any] = None,
        order_id: int = None,
        real_login_user_uid: str = None,
        tid: int = None,
    ):
        # The parameters that are required to perform the operation. Sample code:
        # 
        # ```json
        # {
        #   "mode" : "FAST",   // The mode in which data is exported. Default value: FAST. A value of NORMAL specifies that the export task can be terminated during the export.  "encoding" : "UTF8",  // The encoding format.  "startTime" : "2022-12-22 00:00:00",  // The point in time at which data export starts.  "transaction" : false,    // Specifies whether to enable transactions.  "fileType" : "SQL"    // The format of the exported file.}
        # ```
        # 
        # >  You can also set mode, encoding, and fileType to the following values:
        # 
        # *   mode: NORMAL
        # 
        # *   encoding: UTF8MB4, GB2312, ISO_8859_1, GBK, LATAIN1, or CP1252
        # 
        # *   fileType: XLSX, CSV, JSON, or TXT
        self.action_detail = action_detail
        # The ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the Alibaba Cloud account that is used to call the API operation.
        self.real_login_user_uid = real_login_user_uid
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail is not None:
            result['ActionDetail'] = self.action_detail
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteDataExportShrinkRequest(TeaModel):
    def __init__(
        self,
        action_detail_shrink: str = None,
        order_id: int = None,
        real_login_user_uid: str = None,
        tid: int = None,
    ):
        # The parameters that are required to perform the operation. Sample code:
        # 
        # ```json
        # {
        #   "mode" : "FAST",   // The mode in which data is exported. Default value: FAST. A value of NORMAL specifies that the export task can be terminated during the export.  "encoding" : "UTF8",  // The encoding format.  "startTime" : "2022-12-22 00:00:00",  // The point in time at which data export starts.  "transaction" : false,    // Specifies whether to enable transactions.  "fileType" : "SQL"    // The format of the exported file.}
        # ```
        # 
        # >  You can also set mode, encoding, and fileType to the following values:
        # 
        # *   mode: NORMAL
        # 
        # *   encoding: UTF8MB4, GB2312, ISO_8859_1, GBK, LATAIN1, or CP1252
        # 
        # *   fileType: XLSX, CSV, JSON, or TXT
        self.action_detail_shrink = action_detail_shrink
        # The ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the Alibaba Cloud account that is used to call the API operation.
        self.real_login_user_uid = real_login_user_uid
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail_shrink is not None:
            result['ActionDetail'] = self.action_detail_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail_shrink = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteDataExportResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteDataExportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteDataExportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteDataExportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteScriptRequest(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
        script: str = None,
        tid: int = None,
    ):
        # The ID of the database.
        # 
        # >  This parameter is equivalent to the DatabaseId parameter in the SearchDatabase, ListDatabases, and GetDatabase operations. You can call one of these operations to obtain the required database ID. For more information, see [SearchDatabase](https://help.aliyun.com/document_detail/141876.html), [ListDatabases](https://help.aliyun.com/document_detail/141873.html), and [GetDatabase](https://help.aliyun.com/document_detail/141869.html).
        # 
        # This parameter is required.
        self.db_id = db_id
        # Specifies whether the database is a logical database.
        # 
        # This parameter is required.
        self.logic = logic
        # The SQL statements to be executed. Data query language (DQL) statements, data definition language (DDL) statements, and data manipulation language (DML) statements are supported. The control mode of the instance that you want to query determines whether you can execute DDL and DML statements.
        # 
        # This parameter is required.
        self.script = script
        # The ID of the tenant.
        # 
        # >  To obtain the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Tenant information](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.script is not None:
            result['Script'] = self.script
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Script') is not None:
            self.script = m.get('Script')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteScriptResponseBodyResults(TeaModel):
    def __init__(
        self,
        column_names: List[str] = None,
        message: str = None,
        row_count: int = None,
        rows: List[Dict[str, Any]] = None,
        success: bool = None,
    ):
        # The fields that are queried after the SQL statement is executed.
        self.column_names = column_names
        # The error message that is returned if the SQL statement fails to be executed. For example, an error message is returned because the SQL statement is invalid.
        self.message = message
        # The total number of entries that are returned.
        self.row_count = row_count
        # The rows that are queried after the SQL statement is executed.
        self.rows = rows
        # Indicates whether the SQL statement is executed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_names is not None:
            result['ColumnNames'] = self.column_names
        if self.message is not None:
            result['Message'] = self.message
        if self.row_count is not None:
            result['RowCount'] = self.row_count
        if self.rows is not None:
            result['Rows'] = self.rows
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnNames') is not None:
            self.column_names = m.get('ColumnNames')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RowCount') is not None:
            self.row_count = m.get('RowCount')
        if m.get('Rows') is not None:
            self.rows = m.get('Rows')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteScriptResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        results: List[ExecuteScriptResponseBodyResults] = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message about the gateway.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The results of the SQL statements that are executed, in the format of an array. Each entry in the array indicates the result of an SQL statement.
        self.results = results
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.results:
            for k in self.results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Results'] = []
        if self.results is not None:
            for k in self.results:
                result['Results'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.results = []
        if m.get('Results') is not None:
            for k in m.get('Results'):
                temp_model = ExecuteScriptResponseBodyResults()
                self.results.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteScriptResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteScriptResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteScriptResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteStructSyncRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteStructSyncResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteStructSyncResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteStructSyncResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteStructSyncResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenMetaKnowledgeAssetRequest(TeaModel):
    def __init__(
        self,
        db_id: int = None,
    ):
        # This parameter is required.
        self.db_id = db_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        return self


class GenMetaKnowledgeAssetResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GenMetaKnowledgeAssetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenMetaKnowledgeAssetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenMetaKnowledgeAssetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateSqlFromNLRequest(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        dialect: str = None,
        knowledge: str = None,
        level: str = None,
        model: str = None,
        question: str = None,
    ):
        # This parameter is required.
        self.db_id = db_id
        self.dialect = dialect
        self.knowledge = knowledge
        self.level = level
        self.model = model
        # This parameter is required.
        self.question = question

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.dialect is not None:
            result['Dialect'] = self.dialect
        if self.knowledge is not None:
            result['Knowledge'] = self.knowledge
        if self.level is not None:
            result['Level'] = self.level
        if self.model is not None:
            result['Model'] = self.model
        if self.question is not None:
            result['Question'] = self.question
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Dialect') is not None:
            self.dialect = m.get('Dialect')
        if m.get('Knowledge') is not None:
            self.knowledge = m.get('Knowledge')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Model') is not None:
            self.model = m.get('Model')
        if m.get('Question') is not None:
            self.question = m.get('Question')
        return self


class GenerateSqlFromNLResponseBodyDataKnowledgeReferences(TeaModel):
    def __init__(
        self,
        content: str = None,
        level: str = None,
        name: str = None,
    ):
        self.content = content
        self.level = level
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.level is not None:
            result['Level'] = self.level
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GenerateSqlFromNLResponseBodyDataSimilarSql(TeaModel):
    def __init__(
        self,
        question: str = None,
        score: str = None,
        sql: str = None,
        thought: str = None,
    ):
        self.question = question
        self.score = score
        self.sql = sql
        self.thought = thought

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.question is not None:
            result['Question'] = self.question
        if self.score is not None:
            result['Score'] = self.score
        if self.sql is not None:
            result['Sql'] = self.sql
        if self.thought is not None:
            result['Thought'] = self.thought
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Question') is not None:
            self.question = m.get('Question')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Sql') is not None:
            self.sql = m.get('Sql')
        if m.get('Thought') is not None:
            self.thought = m.get('Thought')
        return self


class GenerateSqlFromNLResponseBodyDataTables(TeaModel):
    def __init__(
        self,
        table_name: str = None,
    ):
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GenerateSqlFromNLResponseBodyData(TeaModel):
    def __init__(
        self,
        knowledge_references: List[GenerateSqlFromNLResponseBodyDataKnowledgeReferences] = None,
        question: str = None,
        similar_sql: List[GenerateSqlFromNLResponseBodyDataSimilarSql] = None,
        sql: str = None,
        tables: List[GenerateSqlFromNLResponseBodyDataTables] = None,
        thought: str = None,
    ):
        self.knowledge_references = knowledge_references
        self.question = question
        self.similar_sql = similar_sql
        self.sql = sql
        self.tables = tables
        self.thought = thought

    def validate(self):
        if self.knowledge_references:
            for k in self.knowledge_references:
                if k:
                    k.validate()
        if self.similar_sql:
            for k in self.similar_sql:
                if k:
                    k.validate()
        if self.tables:
            for k in self.tables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['KnowledgeReferences'] = []
        if self.knowledge_references is not None:
            for k in self.knowledge_references:
                result['KnowledgeReferences'].append(k.to_map() if k else None)
        if self.question is not None:
            result['Question'] = self.question
        result['SimilarSql'] = []
        if self.similar_sql is not None:
            for k in self.similar_sql:
                result['SimilarSql'].append(k.to_map() if k else None)
        if self.sql is not None:
            result['Sql'] = self.sql
        result['Tables'] = []
        if self.tables is not None:
            for k in self.tables:
                result['Tables'].append(k.to_map() if k else None)
        if self.thought is not None:
            result['Thought'] = self.thought
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.knowledge_references = []
        if m.get('KnowledgeReferences') is not None:
            for k in m.get('KnowledgeReferences'):
                temp_model = GenerateSqlFromNLResponseBodyDataKnowledgeReferences()
                self.knowledge_references.append(temp_model.from_map(k))
        if m.get('Question') is not None:
            self.question = m.get('Question')
        self.similar_sql = []
        if m.get('SimilarSql') is not None:
            for k in m.get('SimilarSql'):
                temp_model = GenerateSqlFromNLResponseBodyDataSimilarSql()
                self.similar_sql.append(temp_model.from_map(k))
        if m.get('Sql') is not None:
            self.sql = m.get('Sql')
        self.tables = []
        if m.get('Tables') is not None:
            for k in m.get('Tables'):
                temp_model = GenerateSqlFromNLResponseBodyDataTables()
                self.tables.append(temp_model.from_map(k))
        if m.get('Thought') is not None:
            self.thought = m.get('Thought')
        return self


class GenerateSqlFromNLResponseBody(TeaModel):
    def __init__(
        self,
        data: GenerateSqlFromNLResponseBodyData = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GenerateSqlFromNLResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GenerateSqlFromNLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateSqlFromNLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateSqlFromNLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAbacPolicyRequest(TeaModel):
    def __init__(
        self,
        abac_policy_id: int = None,
        abac_policy_name: str = None,
        tid: int = None,
    ):
        self.abac_policy_id = abac_policy_id
        self.abac_policy_name = abac_policy_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abac_policy_id is not None:
            result['AbacPolicyId'] = self.abac_policy_id
        if self.abac_policy_name is not None:
            result['AbacPolicyName'] = self.abac_policy_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbacPolicyId') is not None:
            self.abac_policy_id = m.get('AbacPolicyId')
        if m.get('AbacPolicyName') is not None:
            self.abac_policy_name = m.get('AbacPolicyName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetAbacPolicyResponseBodyPolicy(TeaModel):
    def __init__(
        self,
        authorized_quantity: str = None,
        creator_id: int = None,
        policy_content: str = None,
        policy_desc: str = None,
        policy_id: int = None,
        policy_name: str = None,
        policy_source: str = None,
    ):
        self.authorized_quantity = authorized_quantity
        self.creator_id = creator_id
        self.policy_content = policy_content
        self.policy_desc = policy_desc
        self.policy_id = policy_id
        self.policy_name = policy_name
        self.policy_source = policy_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorized_quantity is not None:
            result['AuthorizedQuantity'] = self.authorized_quantity
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.policy_content is not None:
            result['PolicyContent'] = self.policy_content
        if self.policy_desc is not None:
            result['PolicyDesc'] = self.policy_desc
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.policy_source is not None:
            result['PolicySource'] = self.policy_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorizedQuantity') is not None:
            self.authorized_quantity = m.get('AuthorizedQuantity')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('PolicyContent') is not None:
            self.policy_content = m.get('PolicyContent')
        if m.get('PolicyDesc') is not None:
            self.policy_desc = m.get('PolicyDesc')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('PolicySource') is not None:
            self.policy_source = m.get('PolicySource')
        return self


class GetAbacPolicyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        policy: GetAbacPolicyResponseBodyPolicy = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.policy = policy
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.policy:
            self.policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.policy is not None:
            result['Policy'] = self.policy.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Policy') is not None:
            temp_model = GetAbacPolicyResponseBodyPolicy()
            self.policy = temp_model.from_map(m['Policy'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAbacPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAbacPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAbacPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetApprovalDetailRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
        workflow_instance_id: int = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
        self.tid = tid
        # The ID of the approval process. You can call the [GetOrderBaseInfo](https://help.aliyun.com/document_detail/144642.html) operation to obtain the ID of the approval process.
        # 
        # This parameter is required.
        self.workflow_instance_id = workflow_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler(TeaModel):
    def __init__(
        self,
        id: int = None,
        nick_name: str = None,
    ):
        # The ID of the user.
        self.id = id
        # The nickname of the user.
        self.nick_name = nick_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        return self


class GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers(TeaModel):
    def __init__(
        self,
        current_handler: List[GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler] = None,
    ):
        self.current_handler = current_handler

    def validate(self):
        if self.current_handler:
            for k in self.current_handler:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CurrentHandler'] = []
        if self.current_handler is not None:
            for k in self.current_handler:
                result['CurrentHandler'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.current_handler = []
        if m.get('CurrentHandler') is not None:
            for k in m.get('CurrentHandler'):
                temp_model = GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler()
                self.current_handler.append(temp_model.from_map(k))
        return self


class GetApprovalDetailResponseBodyApprovalDetailReasonList(TeaModel):
    def __init__(
        self,
        reasons: List[str] = None,
    ):
        self.reasons = reasons

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reasons is not None:
            result['Reasons'] = self.reasons
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Reasons') is not None:
            self.reasons = m.get('Reasons')
        return self


class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList(TeaModel):
    def __init__(
        self,
        audit_user_ids: List[str] = None,
    ):
        self.audit_user_ids = audit_user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_user_ids is not None:
            result['AuditUserIds'] = self.audit_user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditUserIds') is not None:
            self.audit_user_ids = m.get('AuditUserIds')
        return self


class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode(TeaModel):
    def __init__(
        self,
        audit_user_id_list: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList = None,
        node_name: str = None,
        operate_comment: str = None,
        operate_time: str = None,
        operator_id: int = None,
        workflow_ins_code: str = None,
    ):
        # The IDs of the approvers.
        self.audit_user_id_list = audit_user_id_list
        # The name of the approval node.
        self.node_name = node_name
        # The remarks of the approval.
        self.operate_comment = operate_comment
        # The time when the ticket was submitted.
        self.operate_time = operate_time
        # The ID of the user who submitted the ticket.
        self.operator_id = operator_id
        # The approval status of the ticket. Valid values:
        # 
        # *   **START**: The ticket was submitted.
        # *   **ERROR**: An error occurred.
        # *   **AUDITING**: The ticket is being reviewed.
        # *   **REJECT**: The ticket was rejected.
        # *   **CANCEL**: The ticket was revoked.
        # *   **APPROVED**: The ticket was approved.
        self.workflow_ins_code = workflow_ins_code

    def validate(self):
        if self.audit_user_id_list:
            self.audit_user_id_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_user_id_list is not None:
            result['AuditUserIdList'] = self.audit_user_id_list.to_map()
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.operate_comment is not None:
            result['OperateComment'] = self.operate_comment
        if self.operate_time is not None:
            result['OperateTime'] = self.operate_time
        if self.operator_id is not None:
            result['OperatorId'] = self.operator_id
        if self.workflow_ins_code is not None:
            result['WorkflowInsCode'] = self.workflow_ins_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditUserIdList') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList()
            self.audit_user_id_list = temp_model.from_map(m['AuditUserIdList'])
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('OperateComment') is not None:
            self.operate_comment = m.get('OperateComment')
        if m.get('OperateTime') is not None:
            self.operate_time = m.get('OperateTime')
        if m.get('OperatorId') is not None:
            self.operator_id = m.get('OperatorId')
        if m.get('WorkflowInsCode') is not None:
            self.workflow_ins_code = m.get('WorkflowInsCode')
        return self


class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes(TeaModel):
    def __init__(
        self,
        workflow_node: List[GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode] = None,
    ):
        self.workflow_node = workflow_node

    def validate(self):
        if self.workflow_node:
            for k in self.workflow_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkflowNode'] = []
        if self.workflow_node is not None:
            for k in self.workflow_node:
                result['WorkflowNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.workflow_node = []
        if m.get('WorkflowNode') is not None:
            for k in m.get('WorkflowNode'):
                temp_model = GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode()
                self.workflow_node.append(temp_model.from_map(k))
        return self


class GetApprovalDetailResponseBodyApprovalDetail(TeaModel):
    def __init__(
        self,
        audit_id: int = None,
        create_time: str = None,
        current_handlers: GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers = None,
        description: str = None,
        order_id: int = None,
        order_type: str = None,
        reason_list: GetApprovalDetailResponseBodyApprovalDetailReasonList = None,
        template_id: int = None,
        thirdparty_workflow_comment: str = None,
        thirdparty_workflow_url: str = None,
        title: str = None,
        workflow_ins_code: str = None,
        workflow_nodes: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes = None,
    ):
        # The ID of the approval process.
        self.audit_id = audit_id
        # The time when the approval process was created.
        self.create_time = create_time
        # The information about the approver.
        self.current_handlers = current_handlers
        # The description of the approval process.
        self.description = description
        # The ID of the ticket.
        self.order_id = order_id
        # The type of the ticket. Valid values:
        # 
        # *   **NDDL**: a schema design ticket
        # *   **DATA_TRACK**: a data tracking ticket
        # *   **TABLE_SYNC**: a table synchronization ticket
        # *   **PERM_APPLY**: a permission application ticket
        # *   **DATA_EXPORT**: a data export ticket
        # *   **DATA_CORRECT**: a data change ticket
        # *   **OWNER_APPLY**: an owner role application ticket
        # *   **SENSITIVITY**: a column sensitivity level change ticket
        self.order_type = order_type
        # The reasons for the approval.
        self.reason_list = reason_list
        # The ID of the workflow template.
        self.template_id = template_id
        # Third-party approval flow remarks.
        self.thirdparty_workflow_comment = thirdparty_workflow_comment
        # The third-party approval flow link.
        self.thirdparty_workflow_url = thirdparty_workflow_url
        # The title of the approval process.
        self.title = title
        # The approval status of the ticket. Valid values:
        # 
        # *   **AUDITING**: The ticket is being reviewed.
        # *   **REJECT**: The ticket was rejected.
        # *   **CANCEL**: The ticket was revoked.
        # *   **APPROVED**: The ticket was approved.
        # 
        # > An approval process contains multiple approval nodes, and this parameter is returned for each approval node.
        self.workflow_ins_code = workflow_ins_code
        # The details of approval nodes.
        self.workflow_nodes = workflow_nodes

    def validate(self):
        if self.current_handlers:
            self.current_handlers.validate()
        if self.reason_list:
            self.reason_list.validate()
        if self.workflow_nodes:
            self.workflow_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_id is not None:
            result['AuditId'] = self.audit_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.current_handlers is not None:
            result['CurrentHandlers'] = self.current_handlers.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.reason_list is not None:
            result['ReasonList'] = self.reason_list.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.thirdparty_workflow_comment is not None:
            result['ThirdpartyWorkflowComment'] = self.thirdparty_workflow_comment
        if self.thirdparty_workflow_url is not None:
            result['ThirdpartyWorkflowUrl'] = self.thirdparty_workflow_url
        if self.title is not None:
            result['Title'] = self.title
        if self.workflow_ins_code is not None:
            result['WorkflowInsCode'] = self.workflow_ins_code
        if self.workflow_nodes is not None:
            result['WorkflowNodes'] = self.workflow_nodes.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditId') is not None:
            self.audit_id = m.get('AuditId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CurrentHandlers') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers()
            self.current_handlers = temp_model.from_map(m['CurrentHandlers'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('ReasonList') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetailReasonList()
            self.reason_list = temp_model.from_map(m['ReasonList'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('ThirdpartyWorkflowComment') is not None:
            self.thirdparty_workflow_comment = m.get('ThirdpartyWorkflowComment')
        if m.get('ThirdpartyWorkflowUrl') is not None:
            self.thirdparty_workflow_url = m.get('ThirdpartyWorkflowUrl')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('WorkflowInsCode') is not None:
            self.workflow_ins_code = m.get('WorkflowInsCode')
        if m.get('WorkflowNodes') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes()
            self.workflow_nodes = temp_model.from_map(m['WorkflowNodes'])
        return self


class GetApprovalDetailResponseBody(TeaModel):
    def __init__(
        self,
        approval_detail: GetApprovalDetailResponseBodyApprovalDetail = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The approval details of the ticket.
        self.approval_detail = approval_detail
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        if self.approval_detail:
            self.approval_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.approval_detail is not None:
            result['ApprovalDetail'] = self.approval_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApprovalDetail') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetail()
            self.approval_detail = temp_model.from_map(m['ApprovalDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetApprovalDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetApprovalDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetApprovalDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAuthorityTemplateRequest(TeaModel):
    def __init__(
        self,
        template_id: int = None,
        tid: int = None,
    ):
        # The ID of the permission template.
        # 
        # This parameter is required.
        self.template_id = template_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem(TeaModel):
    def __init__(
        self,
        attribute: str = None,
        db_id: int = None,
        instance_id: int = None,
        item_id: int = None,
        modifier_id: int = None,
        resource_type: str = None,
        table_name: str = None,
        template_id: int = None,
    ):
        # Other information. For example, you can add the logon permission on an instance to the permission template.
        self.attribute = attribute
        # The ID of the database.
        self.db_id = db_id
        # The ID of the instance.
        self.instance_id = instance_id
        # The ID of the resource.
        self.item_id = item_id
        # The ID of the user who modified the resource.
        self.modifier_id = modifier_id
        # The type of the resource. Valid values:
        # 
        # *   **INSTANCE**: instance
        # *   **LOGIC_DB**: logical database
        # *   **META_DB**: physical database
        # *   **LOGIC_TABLE**: logical table
        # *   **SINGLE_TABLE**: physical table
        self.resource_type = resource_type
        # The name of the table.
        self.table_name = table_name
        # The ID of the permission template.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attribute is not None:
            result['Attribute'] = self.attribute
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attribute') is not None:
            self.attribute = m.get('Attribute')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList(TeaModel):
    def __init__(
        self,
        authority_template_item: List[GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem] = None,
    ):
        self.authority_template_item = authority_template_item

    def validate(self):
        if self.authority_template_item:
            for k in self.authority_template_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuthorityTemplateItem'] = []
        if self.authority_template_item is not None:
            for k in self.authority_template_item:
                result['AuthorityTemplateItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.authority_template_item = []
        if m.get('AuthorityTemplateItem') is not None:
            for k in m.get('AuthorityTemplateItem'):
                temp_model = GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem()
                self.authority_template_item.append(temp_model.from_map(k))
        return self


class GetAuthorityTemplateResponseBodyAuthorityTemplateView(TeaModel):
    def __init__(
        self,
        authority_template_item_list: GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList = None,
        create_time: str = None,
        creator_id: int = None,
        description: str = None,
        name: str = None,
        template_id: int = None,
    ):
        # The resource information in the permission template.
        self.authority_template_item_list = authority_template_item_list
        # The time when the permission template was created. The time is in the yyyy-MM-DD HH:mm:ss format.
        self.create_time = create_time
        # The ID of the user who created the permission template.
        self.creator_id = creator_id
        # The description of the permission template.
        self.description = description
        # The name of the permission template.
        self.name = name
        # The ID of the permission template.
        self.template_id = template_id

    def validate(self):
        if self.authority_template_item_list:
            self.authority_template_item_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authority_template_item_list is not None:
            result['AuthorityTemplateItemList'] = self.authority_template_item_list.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorityTemplateItemList') is not None:
            temp_model = GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList()
            self.authority_template_item_list = temp_model.from_map(m['AuthorityTemplateItemList'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetAuthorityTemplateResponseBody(TeaModel):
    def __init__(
        self,
        authority_template_view: GetAuthorityTemplateResponseBodyAuthorityTemplateView = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tid: int = None,
    ):
        # The details of the permission template.
        self.authority_template_view = authority_template_view
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The ID of the tenant.
        self.tid = tid

    def validate(self):
        if self.authority_template_view:
            self.authority_template_view.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authority_template_view is not None:
            result['AuthorityTemplateView'] = self.authority_template_view.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorityTemplateView') is not None:
            temp_model = GetAuthorityTemplateResponseBodyAuthorityTemplateView()
            self.authority_template_view = temp_model.from_map(m['AuthorityTemplateView'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetAuthorityTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAuthorityTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAuthorityTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAuthorityTemplateItemRequest(TeaModel):
    def __init__(
        self,
        template_id: int = None,
        tid: int = None,
    ):
        # The ID of the permission template.
        # 
        # This parameter is required.
        self.template_id = template_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem(TeaModel):
    def __init__(
        self,
        attribute: str = None,
        db_id: int = None,
        instance_id: int = None,
        item_id: int = None,
        modifier_id: int = None,
        resource_type: str = None,
        table_name: str = None,
        template_id: int = None,
    ):
        # The additional information. For example, permissions to log on to an instance are added to the permission template.
        self.attribute = attribute
        # The ID of the database.
        self.db_id = db_id
        # The ID of the instance.
        self.instance_id = instance_id
        # The ID of the resource.
        self.item_id = item_id
        # The ID of the user who modifies the resource.
        self.modifier_id = modifier_id
        # The type of the resource. Valid values:
        # 
        # *   **INSTANCE**: instance
        # *   **LOGIC_DB**: logical database
        # *   **META_DB**: physical database
        # *   **LOGIC_TABLE**: logical table
        # *   **LOGIC_TABLE**: physical table
        self.resource_type = resource_type
        # The name of the table.
        self.table_name = table_name
        # The ID of the permission template.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attribute is not None:
            result['Attribute'] = self.attribute
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.item_id is not None:
            result['ItemId'] = self.item_id
        if self.modifier_id is not None:
            result['ModifierId'] = self.modifier_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attribute') is not None:
            self.attribute = m.get('Attribute')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ItemId') is not None:
            self.item_id = m.get('ItemId')
        if m.get('ModifierId') is not None:
            self.modifier_id = m.get('ModifierId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList(TeaModel):
    def __init__(
        self,
        authority_template_item: List[GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem] = None,
    ):
        self.authority_template_item = authority_template_item

    def validate(self):
        if self.authority_template_item:
            for k in self.authority_template_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuthorityTemplateItem'] = []
        if self.authority_template_item is not None:
            for k in self.authority_template_item:
                result['AuthorityTemplateItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.authority_template_item = []
        if m.get('AuthorityTemplateItem') is not None:
            for k in m.get('AuthorityTemplateItem'):
                temp_model = GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem()
                self.authority_template_item.append(temp_model.from_map(k))
        return self


class GetAuthorityTemplateItemResponseBody(TeaModel):
    def __init__(
        self,
        authority_template_item_list: GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tid: int = None,
    ):
        # The permission templates.
        self.authority_template_item_list = authority_template_item_list
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The ID of the tenant.
        self.tid = tid

    def validate(self):
        if self.authority_template_item_list:
            self.authority_template_item_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authority_template_item_list is not None:
            result['AuthorityTemplateItemList'] = self.authority_template_item_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorityTemplateItemList') is not None:
            temp_model = GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList()
            self.authority_template_item_list = temp_model.from_map(m['AuthorityTemplateItemList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetAuthorityTemplateItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAuthorityTemplateItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAuthorityTemplateItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClassificationTemplateRequest(TeaModel):
    def __init__(
        self,
        instance_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetClassificationTemplateResponseBodyClassificationResourceTemplateMap(TeaModel):
    def __init__(
        self,
        resource_id: int = None,
        resource_type: str = None,
        template_id: int = None,
        template_type: str = None,
    ):
        self.resource_id = resource_id
        self.resource_type = resource_type
        self.template_id = template_id
        self.template_type = template_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class GetClassificationTemplateResponseBody(TeaModel):
    def __init__(
        self,
        classification_resource_template_map: GetClassificationTemplateResponseBodyClassificationResourceTemplateMap = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.classification_resource_template_map = classification_resource_template_map
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.classification_resource_template_map:
            self.classification_resource_template_map.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classification_resource_template_map is not None:
            result['ClassificationResourceTemplateMap'] = self.classification_resource_template_map.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClassificationResourceTemplateMap') is not None:
            temp_model = GetClassificationTemplateResponseBodyClassificationResourceTemplateMap()
            self.classification_resource_template_map = temp_model.from_map(m['ClassificationResourceTemplateMap'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetClassificationTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetClassificationTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClassificationTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDBTaskSQLJobLogRequest(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        tid: int = None,
    ):
        # The ID of the SQL task. You can call the [ListDBTaskSQLJob](https://help.aliyun.com/document_detail/207049.html) operation to query the ID of the SQL task.
        # 
        # This parameter is required.
        self.job_id = job_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDBTaskSQLJobLogResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        log: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The log that records the scheduling details.
        self.log = log
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.log is not None:
            result['Log'] = self.log
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Log') is not None:
            self.log = m.get('Log')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDBTaskSQLJobLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDBTaskSQLJobLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDBTaskSQLJobLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDBTopologyRequest(TeaModel):
    def __init__(
        self,
        logic_db_id: int = None,
        tid: int = None,
    ):
        # The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the ID of the logical database.
        # 
        # This parameter is required.
        self.logic_db_id = logic_db_id
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        instance_id: int = None,
        instance_resource_id: str = None,
        instance_source: str = None,
        region_id: str = None,
        schema_name: str = None,
        search_name: str = None,
    ):
        # The name of the catalog to which the database belongs.
        # 
        # > If the database is a PostgreSQL database, the value of this parameter is the name of the database.
        self.catalog_name = catalog_name
        # The ID of the database for which the schema design is executed.
        self.db_id = db_id
        # The type of the database engine.
        self.db_type = db_type
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   product: production environment
        # *   dev: development environment
        # *   pre: staging environment
        # *   test: test environment
        # *   sit: SIT environment
        # *   uat: user acceptance testing (UAT) environment
        # *   pet: stress testing environment
        # *   stag: STAG environment
        self.env_type = env_type
        # The ID of the instance. The valid value is returned if you call the ListInstances operation. The instance ID is not the ID of the RDS instance.
        self.instance_id = instance_id
        # Instance resource ID.
        self.instance_resource_id = instance_resource_id
        # The source of the database instance. Valid values:
        # 
        # *   **PUBLIC_OWN:** a self-managed database instance that is deployed on the Internet
        # *   **RDS:** an ApsaraDB RDS instance
        # *   **ECS_OWN:** a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
        # *   **VPC_IDC:** a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
        self.instance_source = instance_source
        # The ID of the region in which the instance resides.
        self.region_id = region_id
        # The name of the logical database.
        # 
        # > If the database is a PostgreSQL database, the value of this parameter is the name of the database schema.
        self.schema_name = schema_name
        # The name of the saved search.
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_resource_id is not None:
            result['InstanceResourceId'] = self.instance_resource_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceResourceId') is not None:
            self.instance_resource_id = m.get('InstanceResourceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetDBTopologyResponseBodyDBTopology(TeaModel):
    def __init__(
        self,
        alias: str = None,
        dbtopology_info_list: List[GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList] = None,
        db_type: str = None,
        env_type: str = None,
        logic_db_id: int = None,
        logic_db_name: str = None,
        search_name: str = None,
    ):
        # The alias of the access point.
        self.alias = alias
        # The list of database splitting topology information.
        self.dbtopology_info_list = dbtopology_info_list
        # The type of the database engine.
        self.db_type = db_type
        # The type of the environment in which the database instance is deployed. Valid values:
        # 
        # *   product: production environment
        # *   dev: development environment
        # *   pre: pre-release environment
        # *   test: test environment
        # *   sit: system integration testing (SIT) environment
        # *   uat: user acceptance testing (UAT) environment
        # *   pet: stress testing environment
        # *   stag: staging environment
        self.env_type = env_type
        # The ID of the logical database.
        self.logic_db_id = logic_db_id
        # Logical database name.
        self.logic_db_name = logic_db_name
        # The name of the saved search.
        self.search_name = search_name

    def validate(self):
        if self.dbtopology_info_list:
            for k in self.dbtopology_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['DBTopologyInfoList'] = []
        if self.dbtopology_info_list is not None:
            for k in self.dbtopology_info_list:
                result['DBTopologyInfoList'].append(k.to_map() if k else None)
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.logic_db_name is not None:
            result['LogicDbName'] = self.logic_db_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.dbtopology_info_list = []
        if m.get('DBTopologyInfoList') is not None:
            for k in m.get('DBTopologyInfoList'):
                temp_model = GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList()
                self.dbtopology_info_list.append(temp_model.from_map(k))
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('LogicDbName') is not None:
            self.logic_db_name = m.get('LogicDbName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetDBTopologyResponseBody(TeaModel):
    def __init__(
        self,
        dbtopology: GetDBTopologyResponseBodyDBTopology = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The topology of the data table.
        self.dbtopology = dbtopology
        # The error code.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        if self.dbtopology:
            self.dbtopology.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtopology is not None:
            result['DBTopology'] = self.dbtopology.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBTopology') is not None:
            temp_model = GetDBTopologyResponseBodyDBTopology()
            self.dbtopology = temp_model.from_map(m['DBTopology'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDBTopologyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDBTopologyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDBTopologyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataArchiveCountRequest(TeaModel):
    def __init__(
        self,
        order_result_type: str = None,
        plugin_type: str = None,
        search_date_type: str = None,
        tid: int = None,
    ):
        # The type of the identity. Default value: AS_ADMIN.
        self.order_result_type = order_result_type
        # The plugin type. Default value: DATA_ARCHIVE.
        self.plugin_type = plugin_type
        # The time when the ticket is modified or created. The statistics of data archiving tickets are calculated based on the creation time.
        self.search_date_type = search_date_type
        # The tenant ID.
        # 
        # >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_result_type is not None:
            result['OrderResultType'] = self.order_result_type
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.search_date_type is not None:
            result['SearchDateType'] = self.search_date_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderResultType') is not None:
            self.order_result_type = m.get('OrderResultType')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('SearchDateType') is not None:
            self.search_date_type = m.get('SearchDateType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataArchiveCountResponseBodyData(TeaModel):
    def __init__(
        self,
        fail_count: int = None,
        processing_count: int = None,
        success_count: int = None,
        total_count: int = None,
    ):
        # The number of tickets that data archiving failed.
        self.fail_count = fail_count
        # The number of tickets that data archiving is in progress.
        self.processing_count = processing_count
        # The number of tickets that data archiving is successful.
        self.success_count = success_count
        # The total number of data archiving tickets.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.processing_count is not None:
            result['ProcessingCount'] = self.processing_count
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('ProcessingCount') is not None:
            self.processing_count = m.get('ProcessingCount')
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetDataArchiveCountResponseBody(TeaModel):
    def __init__(
        self,
        data: GetDataArchiveCountResponseBodyData = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The data returned.
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetDataArchiveCountResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataArchiveCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataArchiveCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataArchiveCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataArchiveOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The IDs of data archiving tickets.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The tenant ID.
        # 
        # >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo(TeaModel):
    def __init__(
        self,
        creator_id: str = None,
        cron_begin_date: str = None,
        cron_end_date: str = None,
        cron_trigger: bool = None,
        dwdevelop: bool = None,
        dag_name: str = None,
        dag_owner_id: str = None,
        deploy_id: int = None,
        description: str = None,
        edit_dag_id: int = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        id: int = None,
        is_public: int = None,
        legacy: bool = None,
        system: bool = None,
        tenant_id: str = None,
        trigger_once: bool = None,
    ):
        # The ID of the user who created the task flow.
        self.creator_id = creator_id
        # The start time for scheduling. The task flow is not scheduled before this point in time.
        self.cron_begin_date = cron_begin_date
        # The end time for scheduling. The task flow is not scheduled after this point in time.
        self.cron_end_date = cron_end_date
        # Indicates whether the archiving task is a scheduled task. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.cron_trigger = cron_trigger
        # Indicates whether the task is used to develop warehouses.
        # 
        # >  This field is a retained field that is not in use.
        self.dwdevelop = dwdevelop
        # The name of the workflow.
        self.dag_name = dag_name
        # The ID of the owner of the workflow.
        self.dag_owner_id = dag_owner_id
        # The ID of the deployment record.
        self.deploy_id = deploy_id
        # The description of the workflow.
        self.description = description
        # The ID of the editable workflow version.
        self.edit_dag_id = edit_dag_id
        # The time when the workflow was created.
        self.gmt_create = gmt_create
        # The time when the workflow was last modified.
        self.gmt_modified = gmt_modified
        # The ID of the task flow.
        self.id = id
        # Indicates whether the workflow is public. Valid values:
        # 
        # *   **0**: not public.
        # *   **1**: public.
        self.is_public = is_public
        # Indicates whether the task is a historical task. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.legacy = legacy
        # Indicates whether the task was created by the system. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.system = system
        # The tenant ID.
        self.tenant_id = tenant_id
        # Indicates whether the workflow is triggered to run once. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.trigger_once = trigger_once

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.cron_begin_date is not None:
            result['CronBeginDate'] = self.cron_begin_date
        if self.cron_end_date is not None:
            result['CronEndDate'] = self.cron_end_date
        if self.cron_trigger is not None:
            result['CronTrigger'] = self.cron_trigger
        if self.dwdevelop is not None:
            result['DWDevelop'] = self.dwdevelop
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.description is not None:
            result['Description'] = self.description
        if self.edit_dag_id is not None:
            result['EditDagId'] = self.edit_dag_id
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.is_public is not None:
            result['IsPublic'] = self.is_public
        if self.legacy is not None:
            result['Legacy'] = self.legacy
        if self.system is not None:
            result['System'] = self.system
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.trigger_once is not None:
            result['TriggerOnce'] = self.trigger_once
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CronBeginDate') is not None:
            self.cron_begin_date = m.get('CronBeginDate')
        if m.get('CronEndDate') is not None:
            self.cron_end_date = m.get('CronEndDate')
        if m.get('CronTrigger') is not None:
            self.cron_trigger = m.get('CronTrigger')
        if m.get('DWDevelop') is not None:
            self.dwdevelop = m.get('DWDevelop')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EditDagId') is not None:
            self.edit_dag_id = m.get('EditDagId')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsPublic') is not None:
            self.is_public = m.get('IsPublic')
        if m.get('Legacy') is not None:
            self.legacy = m.get('Legacy')
        if m.get('System') is not None:
            self.system = m.get('System')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TriggerOnce') is not None:
            self.trigger_once = m.get('TriggerOnce')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        description: str = None,
        free_or_stable: bool = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        group_mode: str = None,
        group_name: str = None,
        id: int = None,
        last_mender_id: int = None,
    ):
        # The type of the instance engine. For information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        self.db_type = db_type
        # The description of the security rule set.
        self.description = description
        # Indicates whether the instance is managed in Flexible Management or Stable Change mode. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.free_or_stable = free_or_stable
        # The time when the security rule was created.
        self.gmt_create = gmt_create
        # The time when the security rule was last modified.
        self.gmt_modified = gmt_modified
        # The type of the control mode of the instance. Valid values:
        # 
        # *   **COMMON**: The instance is managed in Security Collaboration mode.
        # *   **NONE_CONTROL**: The instance is managed in Flexible Management mode.
        # *   **STABLE**: The instance is managed in Stable Change mode.
        self.group_mode = group_mode
        # The name of the security rule that corresponds to the control mode.
        self.group_name = group_name
        # The ID of the security rule.
        self.id = id
        # The user ID of the last modified security rule.
        self.last_mender_id = last_mender_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.free_or_stable is not None:
            result['FreeOrStable'] = self.free_or_stable
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.id is not None:
            result['Id'] = self.id
        if self.last_mender_id is not None:
            result['LastMenderId'] = self.last_mender_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FreeOrStable') is not None:
            self.free_or_stable = m.get('FreeOrStable')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LastMenderId') is not None:
            self.last_mender_id = m.get('LastMenderId')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo(TeaModel):
    def __init__(
        self,
        alias: str = None,
        alter_timeout: int = None,
        asset_control: bool = None,
        catalog_name: str = None,
        cluster_node: str = None,
        db_id: int = None,
        db_type: str = None,
        dba_id: int = None,
        dba_name: str = None,
        description: str = None,
        encoding: str = None,
        env_type: str = None,
        follow: bool = None,
        host: str = None,
        idc: str = None,
        idc_title: str = None,
        instance_id: int = None,
        instance_source: str = None,
        last_sync_time: str = None,
        level: str = None,
        logic: bool = None,
        owner_ids: List[int] = None,
        owner_names: List[str] = None,
        port: int = None,
        schema_name: str = None,
        search_name: str = None,
        standard_group: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup = None,
        state: str = None,
        table_count: int = None,
        tns_name: str = None,
        unit_type: str = None,
    ):
        # The alias of the database instance.
        self.alias = alias
        # The timeout period of queries on the database.
        self.alter_timeout = alter_timeout
        # Indicates whether access control is enabled for data assets. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.asset_control = asset_control
        # The name of the instance in the instance list.
        self.catalog_name = catalog_name
        # Indicates whether the instance is added to the DMS whitelist.
        self.cluster_node = cluster_node
        # The ID of the database. You can call the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
        # 
        # >  You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to query the ID of a physical database or the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to query the ID of a logical database.
        self.db_id = db_id
        # The type of the database. For information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        self.db_type = db_type
        # The ID of the database administrator (DBA) of the instance.
        self.dba_id = dba_id
        # The nickname of the DBA of the instance.
        self.dba_name = dba_name
        # The complete endpoint of the database.
        self.description = description
        # The encoding format of the database.
        self.encoding = encoding
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: staging environment
        # *   **test**: test environment
        # *   **sit**: system integration testing (SIT) environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: STAG environment
        self.env_type = env_type
        # Indicates whether the instance needs special attention. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.follow = follow
        # The endpoint that is used to connect to the database.
        self.host = host
        # The region in which the database instance resides.
        self.idc = idc
        # The name of the region in which the database instance resides.
        self.idc_title = idc_title
        # The ID of the instance to which the database belongs.
        self.instance_id = instance_id
        # The source of the database instance.Valid values:
        # 
        # *   **RDS**: an ApsaraDB RDS instance.
        # *   **ECS_OWN**: a self-managed database deployed on an Elastic Compute Service (ECS) instance.
        # *   **PUBLIC_OWN**: a self-managed database instance that is connected over the Internet.
        # *   **VPC_ID**: a self-managed database instance in a virtual private cloud (VPC) that is connected over Express Connect circuits.
        # *   **GATEWAY**: a database instance connected by using a database gateway.
        self.instance_source = instance_source
        # The time when the database information was last obtained.
        self.last_sync_time = last_sync_time
        # The instance level.
        self.level = level
        # Indicates whether the database is logical. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.logic = logic
        # The IDs of the owners of the databases, which are stored as an array. You can call the [GetUser](https://help.aliyun.com/document_detail/147098.html) or [ListUsers](https://help.aliyun.com/document_detail/141938.html) operation to query the IDs of the owners.
        # 
        # >  The value of OwnerIds is the same as the value of UserId
        self.owner_ids = owner_ids
        # The usernames of the database owners.
        self.owner_names = owner_names
        # The port that is used to connect to the database.
        self.port = port
        # The name of the database.
        self.schema_name = schema_name
        # The name that is used to search for the database.
        self.search_name = search_name
        # The details of the control mode of the instance.
        self.standard_group = standard_group
        # The status of the database. Valid values:
        # 
        # *   **NORMAL**: The database is running as expected.
        # *   **DISABLE**: The database is disabled.
        # *   **OFFLINE**: The database is unpublished.
        # *   **NOT_EXIST**: The database does not exist.
        self.state = state
        # The number of tables.
        self.table_count = table_count
        # The name of TNS.
        self.tns_name = tns_name
        # The unit type.
        self.unit_type = unit_type

    def validate(self):
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.alter_timeout is not None:
            result['AlterTimeout'] = self.alter_timeout
        if self.asset_control is not None:
            result['AssetControl'] = self.asset_control
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.cluster_node is not None:
            result['ClusterNode'] = self.cluster_node
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_name is not None:
            result['DbaName'] = self.dba_name
        if self.description is not None:
            result['Description'] = self.description
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.follow is not None:
            result['Follow'] = self.follow
        if self.host is not None:
            result['Host'] = self.host
        if self.idc is not None:
            result['Idc'] = self.idc
        if self.idc_title is not None:
            result['IdcTitle'] = self.idc_title
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.last_sync_time is not None:
            result['LastSyncTime'] = self.last_sync_time
        if self.level is not None:
            result['Level'] = self.level
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.table_count is not None:
            result['TableCount'] = self.table_count
        if self.tns_name is not None:
            result['TnsName'] = self.tns_name
        if self.unit_type is not None:
            result['UnitType'] = self.unit_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('AlterTimeout') is not None:
            self.alter_timeout = m.get('AlterTimeout')
        if m.get('AssetControl') is not None:
            self.asset_control = m.get('AssetControl')
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('ClusterNode') is not None:
            self.cluster_node = m.get('ClusterNode')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaName') is not None:
            self.dba_name = m.get('DbaName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Follow') is not None:
            self.follow = m.get('Follow')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Idc') is not None:
            self.idc = m.get('Idc')
        if m.get('IdcTitle') is not None:
            self.idc_title = m.get('IdcTitle')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('LastSyncTime') is not None:
            self.last_sync_time = m.get('LastSyncTime')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('StandardGroup') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TableCount') is not None:
            self.table_count = m.get('TableCount')
        if m.get('TnsName') is not None:
            self.tns_name = m.get('TnsName')
        if m.get('UnitType') is not None:
            self.unit_type = m.get('UnitType')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances(TeaModel):
    def __init__(
        self,
        business_time: str = None,
        dag_id: int = None,
        end_time: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        history_dag_id: int = None,
        id: int = None,
        last_running_context: str = None,
        msg: str = None,
        status: int = None,
        tenant_id: str = None,
        trigger_type: int = None,
        version: str = None,
    ):
        # The business time of the task flow. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.business_time = business_time
        # The task flow ID. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the value of this parameter.
        self.dag_id = dag_id
        # The time when the task flow ended. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.end_time = end_time
        # The time when the task flow was created.
        self.gmt_create = gmt_create
        # The time when the task flow was last modified.
        self.gmt_modified = gmt_modified
        # The ID of the historical task flow.
        self.history_dag_id = history_dag_id
        # The ID of the instance in the task flow that is executed.
        self.id = id
        # The context of the previous execution of the task flow.
        self.last_running_context = last_running_context
        # The context of the current execution of the task flow.
        self.msg = msg
        # The status of the task. Valid values:
        # 
        # *   **0**: The task is waiting for execution.
        # *   **1**: The task is in progress.
        # *   **2**: The task is suspended.
        # *   **3**: The task failed.
        # *   **4**: The task is successful.
        # *   **5**: The task is complete.
        self.status = status
        # The tenant ID.
        self.tenant_id = tenant_id
        # The mode in which the task flow was triggered. Valid values:
        # 
        # *   **0**: The task flow was triggered based on a schedule.
        # *   **1**: The task flow was manually triggered.
        self.trigger_type = trigger_type
        # The version number.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_time is not None:
            result['BusinessTime'] = self.business_time
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.history_dag_id is not None:
            result['HistoryDagId'] = self.history_dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.last_running_context is not None:
            result['LastRunningContext'] = self.last_running_context
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessTime') is not None:
            self.business_time = m.get('BusinessTime')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('HistoryDagId') is not None:
            self.history_dag_id = m.get('HistoryDagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LastRunningContext') is not None:
            self.last_running_context = m.get('LastRunningContext')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult(TeaModel):
    def __init__(
        self,
        cron_fire_type: str = None,
    ):
        # The type of scheduled triggering.
        self.cron_fire_type = cron_fire_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron_fire_type is not None:
            result['CronFireType'] = self.cron_fire_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CronFireType') is not None:
            self.cron_fire_type = m.get('CronFireType')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData(TeaModel):
    def __init__(
        self,
        dag_info: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo = None,
        db_base_info: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo = None,
        instance_total: int = None,
        instances: List[GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances] = None,
        next_fire_time_result: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult = None,
        page_index: int = None,
        page_size: int = None,
        temp_table_name_map: Dict[str, Any] = None,
    ):
        # The information about the workflow.
        self.dag_info = dag_info
        # The database information related to data archiving tickets.
        self.db_base_info = db_base_info
        # The total number of archiving tasks.
        self.instance_total = instance_total
        # The list of archiving tasks.
        self.instances = instances
        # The time when the next task is triggered.
        self.next_fire_time_result = next_fire_time_result
        # The page number.
        self.page_index = page_index
        # The number of entries per page.
        self.page_size = page_size
        # The name of the temporary table that is generated by the archiving task (indicated by the archiving task ID).
        self.temp_table_name_map = temp_table_name_map

    def validate(self):
        if self.dag_info:
            self.dag_info.validate()
        if self.db_base_info:
            self.db_base_info.validate()
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()
        if self.next_fire_time_result:
            self.next_fire_time_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_info is not None:
            result['DagInfo'] = self.dag_info.to_map()
        if self.db_base_info is not None:
            result['DbBaseInfo'] = self.db_base_info.to_map()
        if self.instance_total is not None:
            result['InstanceTotal'] = self.instance_total
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.next_fire_time_result is not None:
            result['NextFireTimeResult'] = self.next_fire_time_result.to_map()
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.temp_table_name_map is not None:
            result['TempTableNameMap'] = self.temp_table_name_map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagInfo') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo()
            self.dag_info = temp_model.from_map(m['DagInfo'])
        if m.get('DbBaseInfo') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo()
            self.db_base_info = temp_model.from_map(m['DbBaseInfo'])
        if m.get('InstanceTotal') is not None:
            self.instance_total = m.get('InstanceTotal')
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('NextFireTimeResult') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult()
            self.next_fire_time_result = temp_model.from_map(m['NextFireTimeResult'])
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TempTableNameMap') is not None:
            self.temp_table_name_map = m.get('TempTableNameMap')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes(TeaModel):
    def __init__(
        self,
        table_name: str = None,
        table_where: str = None,
    ):
        # The table name.
        self.table_name = table_name
        # The filter condition.
        self.table_where = table_where

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_where is not None:
            result['TableWhere'] = self.table_where
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableWhere') is not None:
            self.table_where = m.get('TableWhere')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam(TeaModel):
    def __init__(
        self,
        archive_method: str = None,
        db_schema: str = None,
        logic: bool = None,
        order_after: List[str] = None,
        run_method: str = None,
        source_database_id: int = None,
        table_includes: List[GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes] = None,
        table_mapping: List[str] = None,
        target_instance_id: str = None,
        variables: List[str] = None,
    ):
        # The type of the archiving destination.
        self.archive_method = archive_method
        # The schema of the database and table to be archived.
        self.db_schema = db_schema
        # Indicates whether the database is logical.
        # 
        # *   **true**\
        # *   **false**\
        self.logic = logic
        # The post behavior of archiving.
        self.order_after = order_after
        # The running method, which indicates whether to run the task immediately or at a specific point in time.
        self.run_method = run_method
        # The ID of the source database.
        self.source_database_id = source_database_id
        # The list of the archived tables and the filter conditions.
        self.table_includes = table_includes
        # The mapping of schemas.
        self.table_mapping = table_mapping
        # The ID of the destination instance.
        self.target_instance_id = target_instance_id
        # The time variable defined for scheduled archiving.
        self.variables = variables

    def validate(self):
        if self.table_includes:
            for k in self.table_includes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.archive_method is not None:
            result['ArchiveMethod'] = self.archive_method
        if self.db_schema is not None:
            result['DbSchema'] = self.db_schema
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.order_after is not None:
            result['OrderAfter'] = self.order_after
        if self.run_method is not None:
            result['RunMethod'] = self.run_method
        if self.source_database_id is not None:
            result['SourceDatabaseId'] = self.source_database_id
        result['TableIncludes'] = []
        if self.table_includes is not None:
            for k in self.table_includes:
                result['TableIncludes'].append(k.to_map() if k else None)
        if self.table_mapping is not None:
            result['TableMapping'] = self.table_mapping
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        if self.variables is not None:
            result['Variables'] = self.variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArchiveMethod') is not None:
            self.archive_method = m.get('ArchiveMethod')
        if m.get('DbSchema') is not None:
            self.db_schema = m.get('DbSchema')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OrderAfter') is not None:
            self.order_after = m.get('OrderAfter')
        if m.get('RunMethod') is not None:
            self.run_method = m.get('RunMethod')
        if m.get('SourceDatabaseId') is not None:
            self.source_database_id = m.get('SourceDatabaseId')
        self.table_includes = []
        if m.get('TableIncludes') is not None:
            for k in m.get('TableIncludes'):
                temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes()
                self.table_includes.append(temp_model.from_map(k))
        if m.get('TableMapping') is not None:
            self.table_mapping = m.get('TableMapping')
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        if m.get('Variables') is not None:
            self.variables = m.get('Variables')
        return self


class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail(TeaModel):
    def __init__(
        self,
        comment: str = None,
        committer: str = None,
        committer_id: int = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        id: int = None,
        plugin_extra_data: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData = None,
        plugin_param: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam = None,
        plugin_type: str = None,
        related_user_list: List[int] = None,
        related_user_nick_list: List[str] = None,
        status_code: str = None,
        status_desc: str = None,
        workflow_instance_id: int = None,
        workflow_status_desc: str = None,
    ):
        # The description of the data archiving tickets.
        self.comment = comment
        # The user who submitted the ticket.
        self.committer = committer
        # The ID of the user who submitted the ticket. The ID is a user ID and not the ID of an Alibaba Cloud account.
        self.committer_id = committer_id
        # The time when the ticket was created.
        self.gmt_create = gmt_create
        # The time when the ticket was last modified.
        self.gmt_modified = gmt_modified
        # The ID of data archiving tickets.
        self.id = id
        # The additional information about the ticket.
        self.plugin_extra_data = plugin_extra_data
        # The ticket creation parameter. The value is a JSON string. For more information, see [PluginType parameter](https://help.aliyun.com/document_detail/429109.html).
        self.plugin_param = plugin_param
        # The plug-in type that corresponds to the type of the ticket. The plug-in type for data archiving is DATA_ARCHIVE. For more information, see [PluginType parameter](https://help.aliyun.com/document_detail/429109.html).
        self.plugin_type = plugin_type
        # The user IDs related to the ticket.
        self.related_user_list = related_user_list
        # The nicknames of the users that are related to the ticket.
        self.related_user_nick_list = related_user_nick_list
        # The status code of the ticket. Valid values:
        # 
        # *   **new**: newly created.
        # *   **toaudit**: being reviewed.
        # *   **Approved**: approved.
        # *   **reject**: rejected.
        # *   **processing**: being executed.
        # *   **Success**: successful.
        # *   **closed**: disabled.
        self.status_code = status_code
        # The status description of the ticket.
        self.status_desc = status_desc
        # The ID of the approval process. You can call the [GetOrderBaseInfo](https://help.aliyun.com/document_detail/144642.html) operation to obtain the ID of the approval process.
        self.workflow_instance_id = workflow_instance_id
        # The description of the approval process.
        self.workflow_status_desc = workflow_status_desc

    def validate(self):
        if self.plugin_extra_data:
            self.plugin_extra_data.validate()
        if self.plugin_param:
            self.plugin_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.committer is not None:
            result['Committer'] = self.committer
        if self.committer_id is not None:
            result['CommitterId'] = self.committer_id
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.plugin_extra_data is not None:
            result['PluginExtraData'] = self.plugin_extra_data.to_map()
        if self.plugin_param is not None:
            result['PluginParam'] = self.plugin_param.to_map()
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.related_user_nick_list is not None:
            result['RelatedUserNickList'] = self.related_user_nick_list
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_status_desc is not None:
            result['WorkflowStatusDesc'] = self.workflow_status_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Committer') is not None:
            self.committer = m.get('Committer')
        if m.get('CommitterId') is not None:
            self.committer_id = m.get('CommitterId')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PluginExtraData') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData()
            self.plugin_extra_data = temp_model.from_map(m['PluginExtraData'])
        if m.get('PluginParam') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam()
            self.plugin_param = temp_model.from_map(m['PluginParam'])
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('RelatedUserNickList') is not None:
            self.related_user_nick_list = m.get('RelatedUserNickList')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowStatusDesc') is not None:
            self.workflow_status_desc = m.get('WorkflowStatusDesc')
        return self


class GetDataArchiveOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        data_archive_order_detail: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The details of data archiving tickets.
        self.data_archive_order_detail = data_archive_order_detail
        # The error code returned if the call failed.
        self.error_code = error_code
        # The error message that is returned if the request failed.
        self.error_message = error_message
        # The ID of the request, which is used to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # Tracks service requests.
        self.trace_id = trace_id

    def validate(self):
        if self.data_archive_order_detail:
            self.data_archive_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_archive_order_detail is not None:
            result['DataArchiveOrderDetail'] = self.data_archive_order_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataArchiveOrderDetail') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail()
            self.data_archive_order_detail = temp_model.from_map(m['DataArchiveOrderDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class GetDataArchiveOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataArchiveOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataArchiveOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectBackupFilesRequest(TeaModel):
    def __init__(
        self,
        action_detail: Dict[str, Any] = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The parameters that are required to perform the operation. You do not need to specify this parameter.
        self.action_detail = action_detail
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail is not None:
            result['ActionDetail'] = self.action_detail
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectBackupFilesShrinkRequest(TeaModel):
    def __init__(
        self,
        action_detail_shrink: str = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The parameters that are required to perform the operation. You do not need to specify this parameter.
        self.action_detail_shrink = action_detail_shrink
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail_shrink is not None:
            result['ActionDetail'] = self.action_detail_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail_shrink = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles(TeaModel):
    def __init__(
        self,
        file_url: List[str] = None,
    ):
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class GetDataCorrectBackupFilesResponseBody(TeaModel):
    def __init__(
        self,
        data_correct_backup_files: GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The download URL of the backup file for the ticket.
        self.data_correct_backup_files = data_correct_backup_files
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.data_correct_backup_files:
            self.data_correct_backup_files.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_correct_backup_files is not None:
            result['DataCorrectBackupFiles'] = self.data_correct_backup_files.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataCorrectBackupFiles') is not None:
            temp_model = GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles()
            self.data_correct_backup_files = temp_model.from_map(m['DataCorrectBackupFiles'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectBackupFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCorrectBackupFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectBackupFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailCronExtConfig(TeaModel):
    def __init__(
        self,
        current_clear_task_count: int = None,
        optimize_table_after_every_clear_times: int = None,
    ):
        # The number of times defragmentation is performed. This parameter is valid only if the value of OptimizeTableAfterEveryClearTimes is greater than 0.
        self.current_clear_task_count = current_clear_task_count
        # Indicates whether the Periodically Optimize Table feature is enabled. Valid values:
        # 
        # *   **0** (default): The feature is disabled.
        # *   **A value greater than 0**: The feature is enabled. The value indicates the number of cleanups after which the system performs defragmentation.
        self.optimize_table_after_every_clear_times = optimize_table_after_every_clear_times

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_clear_task_count is not None:
            result['CurrentClearTaskCount'] = self.current_clear_task_count
        if self.optimize_table_after_every_clear_times is not None:
            result['OptimizeTableAfterEveryClearTimes'] = self.optimize_table_after_every_clear_times
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentClearTaskCount') is not None:
            self.current_clear_task_count = m.get('CurrentClearTaskCount')
        if m.get('OptimizeTableAfterEveryClearTimes') is not None:
            self.optimize_table_after_every_clear_times = m.get('OptimizeTableAfterEveryClearTimes')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailImportExtConfig(TeaModel):
    def __init__(
        self,
        csv_first_row_is_column_def: bool = None,
        ignore_error: bool = None,
        import_mode: str = None,
        insert_type: str = None,
    ):
        # Indicates whether the first row of the CSV file contains field names. Valid values:
        # 
        # *   **true**: The first row in the CSV file contains field names.
        # *   **false**: The first row in the CSV file contains data.
        # 
        # >  This parameter is valid if the value of **FileType** is **CSV** or **EXCEL**.
        self.csv_first_row_is_column_def = csv_first_row_is_column_def
        # Indicates whether an error that occurs is ignored. Valid values:
        # 
        # *   **true**: If an error occurs when SQL statements are being executed, DMS skips the current SQL statement and continues to execute subsequent SQL statements.
        # *   **false**: If an error occurs when SQL statements are being executed, DMS stops executing subsequent SQL statements.
        self.ignore_error = ignore_error
        # The import mode. Valid values:
        # 
        # *   **FAST_MODE**: fast mode. In the Execute step, the uploaded file is read and SQL statements are executed to import data to the specified destination database. Compared with the security mode, this mode can be used to import data in a less secure but more efficient manner.
        # *   **SAFE_MODE**: security mode. In the Precheck step, the uploaded file is parsed, and SQL statements or CSV file data is cached. In the Execute step, the cached SQL statements are read and executed to import data, or the cached CSV file data is read and imported to the specified destination database. Compared with the fast mode, this mode can be used to import data in a more secure but less efficient manner.
        self.import_mode = import_mode
        # The mode in which data is to be imported to the destination table. Valid values:
        # 
        # *   **INSERT**: The database checks the primary key during data insertion. If the primary key is duplicated, an error is reported.
        # *   **INSERT_IGNORE**: If the imported data contains data records that are the same as those in the destination table, the new data records are ignored.
        # *   **REPLACE_INTO**: If the imported data contains a row that has the same value for the primary key or unique index as an existing row in the destination table, the system deletes the existing row and inserts the new row into the destination table.
        # 
        # >  This parameter is valid if the value of FileType is CSV or EXCEL.
        self.insert_type = insert_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.csv_first_row_is_column_def is not None:
            result['CsvFirstRowIsColumnDef'] = self.csv_first_row_is_column_def
        if self.ignore_error is not None:
            result['IgnoreError'] = self.ignore_error
        if self.import_mode is not None:
            result['ImportMode'] = self.import_mode
        if self.insert_type is not None:
            result['InsertType'] = self.insert_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CsvFirstRowIsColumnDef') is not None:
            self.csv_first_row_is_column_def = m.get('CsvFirstRowIsColumnDef')
        if m.get('IgnoreError') is not None:
            self.ignore_error = m.get('IgnoreError')
        if m.get('ImportMode') is not None:
            self.import_mode = m.get('ImportMode')
        if m.get('InsertType') is not None:
            self.insert_type = m.get('InsertType')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetail(TeaModel):
    def __init__(
        self,
        cron: bool = None,
        cron_call_times: int = None,
        cron_ext_config: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailCronExtConfig = None,
        cron_format: str = None,
        cron_last_call_start_time: str = None,
        cron_next_call_time: str = None,
        cron_status: str = None,
        csv_table_name: str = None,
        current_task_id: int = None,
        detail_type: str = None,
        duration: int = None,
        file_encoding: str = None,
        file_type: str = None,
        import_ext_config: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailImportExtConfig = None,
    ):
        # Indicates whether the task is a scheduled task for historical data cleanup. This parameter is a reserved parameter and is valid only if the value of DetailType is CRON_CLEAR_DATA.
        self.cron = cron
        # The number of times the scheduled task is run. This parameter is valid only if the value of DetailType is CRON_CLEAR_DATA.
        self.cron_call_times = cron_call_times
        # The additional configuration information about historical data cleanup. This parameter is valid only if the value of DetailType is CRON_CLEAR_DATA.
        self.cron_ext_config = cron_ext_config
        # The CRON expression of the scheduled task. This parameter is valid only if the value of DetailType is CRON_CLEAR_DATA.
        self.cron_format = cron_format
        # The time when the task was last run.
        self.cron_last_call_start_time = cron_last_call_start_time
        # The time when the task is run next time. This parameter is returned only if the value of CronStatus is SUCCESS.
        self.cron_next_call_time = cron_next_call_time
        # The state of the scheduled task. If this parameter is empty, the task is not run. Valid values:
        # 
        # *   PAUSE: The task is suspended.
        # *   WAITING: The task is waiting to be run.
        # *   SUCCESS: The task is run.
        self.cron_status = cron_status
        # The name of the table to which data is to be imported. This parameter is valid only if the value of DetailType is BIG_FILE. If the value of FileType is SQL, this parameter is empty.
        self.csv_table_name = csv_table_name
        # The ID of the current data change task. This is a reserved parameter and can be ignored.
        self.current_task_id = current_task_id
        # The type of the ticket. Valid values:
        # 
        # *   COMMON: regular data change.
        # *   CHUNK_DML: lock-free data change.
        # *   BIG_FILE: large data import.
        # *   CRON_CLEAR_DATA: historical data cleanup.
        # *   PROCEDURE: programmable object change.
        self.detail_type = detail_type
        # The execution duration of the scheduled task. Unit: hour. This parameter is valid only if the value of DetailType is CRON_CLEAR_DATA. If the value is greater than 0, an execution duration is set.
        self.duration = duration
        # The encoding method of the file. This parameter may be empty, which indicates the value of AUTO. Valid values:
        # 
        # *   **AUTO**: automatic identification.
        # *   **UTF-8**: UTF-8 encoding.
        # *   **GBK**: GBK encoding.
        # *   **ISO-8859-1**: ISO-8859-1 encoding.
        self.file_encoding = file_encoding
        # The type of the file to be imported. This parameter is valid if the value of DetailType is BIG_FILE. Valid values:
        # 
        # *   **SQL**: an SQL file.
        # *   **CSV**: a CSV file.
        # *   **EXCEL**: an Excel file.
        # *   **JSON**: a JSON file, which is supported only by MongoDB databases.
        self.file_type = file_type
        # The additional configuration information about data import. This parameter is valid if the value of DetailType is BIG_FILE.
        self.import_ext_config = import_ext_config

    def validate(self):
        if self.cron_ext_config:
            self.cron_ext_config.validate()
        if self.import_ext_config:
            self.import_ext_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.cron_call_times is not None:
            result['CronCallTimes'] = self.cron_call_times
        if self.cron_ext_config is not None:
            result['CronExtConfig'] = self.cron_ext_config.to_map()
        if self.cron_format is not None:
            result['CronFormat'] = self.cron_format
        if self.cron_last_call_start_time is not None:
            result['CronLastCallStartTime'] = self.cron_last_call_start_time
        if self.cron_next_call_time is not None:
            result['CronNextCallTime'] = self.cron_next_call_time
        if self.cron_status is not None:
            result['CronStatus'] = self.cron_status
        if self.csv_table_name is not None:
            result['CsvTableName'] = self.csv_table_name
        if self.current_task_id is not None:
            result['CurrentTaskId'] = self.current_task_id
        if self.detail_type is not None:
            result['DetailType'] = self.detail_type
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_encoding is not None:
            result['FileEncoding'] = self.file_encoding
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.import_ext_config is not None:
            result['ImportExtConfig'] = self.import_ext_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('CronCallTimes') is not None:
            self.cron_call_times = m.get('CronCallTimes')
        if m.get('CronExtConfig') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailCronExtConfig()
            self.cron_ext_config = temp_model.from_map(m['CronExtConfig'])
        if m.get('CronFormat') is not None:
            self.cron_format = m.get('CronFormat')
        if m.get('CronLastCallStartTime') is not None:
            self.cron_last_call_start_time = m.get('CronLastCallStartTime')
        if m.get('CronNextCallTime') is not None:
            self.cron_next_call_time = m.get('CronNextCallTime')
        if m.get('CronStatus') is not None:
            self.cron_status = m.get('CronStatus')
        if m.get('CsvTableName') is not None:
            self.csv_table_name = m.get('CsvTableName')
        if m.get('CurrentTaskId') is not None:
            self.current_task_id = m.get('CurrentTaskId')
        if m.get('DetailType') is not None:
            self.detail_type = m.get('DetailType')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileEncoding') is not None:
            self.file_encoding = m.get('FileEncoding')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('ImportExtConfig') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailImportExtConfig()
            self.import_ext_config = temp_model.from_map(m['ImportExtConfig'])
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        search_name: str = None,
    ):
        # The database ID.
        self.db_id = db_id
        # The engine of the database.
        self.db_type = db_type
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   product: production environment.
        # *   dev: development environment.
        # *   pre: pre-release environment.
        # *   test: test environment.
        # *   sit: system integration testing (SIT) environment
        # *   uat: user acceptance testing (UAT) environment.
        # *   pet: stress testing environment.
        # *   stag: staging environment.
        self.env_type = env_type
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true.**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic
        # The name that is used to search for the database.
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList(TeaModel):
    def __init__(
        self,
        database: List[GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase] = None,
    ):
        self.database = database

    def validate(self):
        if self.database:
            for k in self.database:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Database'] = []
        if self.database is not None:
            for k in self.database:
                result['Database'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.database = []
        if m.get('Database') is not None:
            for k in m.get('Database'):
                temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase()
                self.database.append(temp_model.from_map(k))
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail(TeaModel):
    def __init__(
        self,
        actual_affect_rows: int = None,
        attachment_name: str = None,
        classify: str = None,
        estimate_affect_rows: int = None,
        exe_sql: str = None,
        ignore_affect_rows: bool = None,
        ignore_affect_rows_reason: str = None,
        rb_attachment_name: str = None,
        rb_sql: str = None,
        rb_sqltype: str = None,
        sql_type: str = None,
    ):
        # The number of affected rows that is obtained by the precheck.
        self.actual_affect_rows = actual_affect_rows
        # The name of the attachment that contains the SQL statements used to change data.
        self.attachment_name = attachment_name
        # The category of the reason for the data change.
        self.classify = classify
        # The estimated number of affected rows.
        self.estimate_affect_rows = estimate_affect_rows
        # The executed SQL statements.
        self.exe_sql = exe_sql
        # Indicates whether the precheck result is ignored. Valid values:
        # 
        # - **true**: The precheck result is ignored.
        # - **false**: The precheck result is not ignored.
        self.ignore_affect_rows = ignore_affect_rows
        # The reason why the precheck result is ignored.
        self.ignore_affect_rows_reason = ignore_affect_rows_reason
        # The name of the attachment that contains the SQL statements used to roll back the data change.
        self.rb_attachment_name = rb_attachment_name
        # The SQL statements used to roll back the data change.
        self.rb_sql = rb_sql
        # The format of the SQL statements used to roll back the data change. Valid values:
        # 
        # - **TEXT**: text
        # - **ATTACHMENT**: attachment
        self.rb_sqltype = rb_sqltype
        # The format of the SQL statements used to change data. Valid values:
        # 
        # - **TEXT**: text
        # - **ATTACHMENT**: attachment
        self.sql_type = sql_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_affect_rows is not None:
            result['ActualAffectRows'] = self.actual_affect_rows
        if self.attachment_name is not None:
            result['AttachmentName'] = self.attachment_name
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.estimate_affect_rows is not None:
            result['EstimateAffectRows'] = self.estimate_affect_rows
        if self.exe_sql is not None:
            result['ExeSQL'] = self.exe_sql
        if self.ignore_affect_rows is not None:
            result['IgnoreAffectRows'] = self.ignore_affect_rows
        if self.ignore_affect_rows_reason is not None:
            result['IgnoreAffectRowsReason'] = self.ignore_affect_rows_reason
        if self.rb_attachment_name is not None:
            result['RbAttachmentName'] = self.rb_attachment_name
        if self.rb_sql is not None:
            result['RbSQL'] = self.rb_sql
        if self.rb_sqltype is not None:
            result['RbSQLType'] = self.rb_sqltype
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualAffectRows') is not None:
            self.actual_affect_rows = m.get('ActualAffectRows')
        if m.get('AttachmentName') is not None:
            self.attachment_name = m.get('AttachmentName')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('EstimateAffectRows') is not None:
            self.estimate_affect_rows = m.get('EstimateAffectRows')
        if m.get('ExeSQL') is not None:
            self.exe_sql = m.get('ExeSQL')
        if m.get('IgnoreAffectRows') is not None:
            self.ignore_affect_rows = m.get('IgnoreAffectRows')
        if m.get('IgnoreAffectRowsReason') is not None:
            self.ignore_affect_rows_reason = m.get('IgnoreAffectRowsReason')
        if m.get('RbAttachmentName') is not None:
            self.rb_attachment_name = m.get('RbAttachmentName')
        if m.get('RbSQL') is not None:
            self.rb_sql = m.get('RbSQL')
        if m.get('RbSQLType') is not None:
            self.rb_sqltype = m.get('RbSQLType')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO(TeaModel):
    def __init__(
        self,
        check_status: str = None,
        check_step: str = None,
        user_tip: str = None,
    ):
        # The state of the precheck. Valid values:
        # 
        # *   **WAITING**: The ticket is pending precheck.
        # *   **RUNNING**: The ticket is being prechecked.
        # *   **SUCCESS**: The ticket passes the precheck.
        # *   **FAIL**: The ticket fails the precheck.
        self.check_status = check_status
        # The check step of the precheck. Valid values:
        # 
        # *   **SQL_PARSE**: The system checks the syntax of the SQL statement.
        # *   **SQL_TYPE_CHECK**: The system checks the type of the SQL statement.
        # *   **PERMISSION_CHECK**: The system checks the permissions required for the data change.
        # *   **ROW_CHECK**: The system checks the number of affected rows.
        self.check_step = check_step
        # The message that appears when a check step is executed.
        self.user_tip = user_tip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_status is not None:
            result['CheckStatus'] = self.check_status
        if self.check_step is not None:
            result['CheckStep'] = self.check_step
        if self.user_tip is not None:
            result['UserTip'] = self.user_tip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckStatus') is not None:
            self.check_status = m.get('CheckStatus')
        if m.get('CheckStep') is not None:
            self.check_step = m.get('CheckStep')
        if m.get('UserTip') is not None:
            self.user_tip = m.get('UserTip')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail(TeaModel):
    def __init__(
        self,
        task_check_do: List[GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO] = None,
    ):
        self.task_check_do = task_check_do

    def validate(self):
        if self.task_check_do:
            for k in self.task_check_do:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskCheckDO'] = []
        if self.task_check_do is not None:
            for k in self.task_check_do:
                result['TaskCheckDO'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_check_do = []
        if m.get('TaskCheckDO') is not None:
            for k in m.get('TaskCheckDO'):
                temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO()
                self.task_check_do.append(temp_model.from_map(k))
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail(TeaModel):
    def __init__(
        self,
        config_detail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetail = None,
        database_list: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList = None,
        exec_mode: str = None,
        order_detail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail = None,
        pre_check_detail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail = None,
        status: str = None,
    ):
        # The configurations of the ticket. This parameter is used to store the configuration information specific to a data change ticket type.
        self.config_detail = config_detail
        # The information about the database in which data is changed.
        self.database_list = database_list
        # The execution mode of the ticket after the ticket is approved. Valid values:
        # 
        # - **COMMITOR**: The data change is performed by the user who submits the ticket.
        # - **AUTO**: The data change is automatically performed after the ticket is approved.
        # - **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
        self.exec_mode = exec_mode
        # The details of the ticket.
        self.order_detail = order_detail
        # The precheck details of the ticket.
        self.pre_check_detail = pre_check_detail
        # The specific state of the data change ticket. Valid values:
        # 
        # >  The state of the ticket is not exactly equivalent to the status code for the ticket. To query the status code of the ticket, you can call the [GetOrderBaseInfo](https://help.aliyun.com/document_detail/465868.html) operation and check the value of StatusCode in the response.
        # 
        # *   **new**: The ticket is created.
        # *   **precheck**: The ticket is in the pre-check phase.
        # *   **precheckFailed**: The ticket failed to pass the precheck.
        # *   **precheck_success**: The ticket passes the precheck and waits to be submitted for approval.
        # *   **toaudit**: The ticket is being reviewed.
        # *   **Approved**: The ticket is approved.
        # *   **reject**: The ticket is rejected.
        # *   **waiting**: The task is submitted and waits to be scheduled.
        # *   **processing**: The task is being executed.
        # *   **Success**: The task is successful.
        self.status = status

    def validate(self):
        if self.config_detail:
            self.config_detail.validate()
        if self.database_list:
            self.database_list.validate()
        if self.order_detail:
            self.order_detail.validate()
        if self.pre_check_detail:
            self.pre_check_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_detail is not None:
            result['ConfigDetail'] = self.config_detail.to_map()
        if self.database_list is not None:
            result['DatabaseList'] = self.database_list.to_map()
        if self.exec_mode is not None:
            result['ExecMode'] = self.exec_mode
        if self.order_detail is not None:
            result['OrderDetail'] = self.order_detail.to_map()
        if self.pre_check_detail is not None:
            result['PreCheckDetail'] = self.pre_check_detail.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigDetail') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetail()
            self.config_detail = temp_model.from_map(m['ConfigDetail'])
        if m.get('DatabaseList') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList()
            self.database_list = temp_model.from_map(m['DatabaseList'])
        if m.get('ExecMode') is not None:
            self.exec_mode = m.get('ExecMode')
        if m.get('OrderDetail') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail()
            self.order_detail = temp_model.from_map(m['OrderDetail'])
        if m.get('PreCheckDetail') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail()
            self.pre_check_detail = temp_model.from_map(m['PreCheckDetail'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetDataCorrectOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        data_correct_order_detail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The information about the data change ticket.
        self.data_correct_order_detail = data_correct_order_detail
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the operation was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data_correct_order_detail:
            self.data_correct_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_correct_order_detail is not None:
            result['DataCorrectOrderDetail'] = self.data_correct_order_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataCorrectOrderDetail') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail()
            self.data_correct_order_detail = temp_model.from_map(m['DataCorrectOrderDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCorrectOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectRollbackFileRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectRollbackFileResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        file_url: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The download URL of the attachment.
        self.file_url = file_url
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectRollbackFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCorrectRollbackFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectRollbackFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectSQLFileRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectSQLFileResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        file_url: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The download URL of the SQL script.
        self.file_url = file_url
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectSQLFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCorrectSQLFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectSQLFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectTaskDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can call the [CreateDataCorrectOrder](https://help.aliyun.com/document_detail/208388.html), [CreateDataImportOrder](https://help.aliyun.com/document_detail/208387.html), or [CreateFreeLockCorrectOrder](https://help.aliyun.com/document_detail/208386.html) operation to obtain the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail(TeaModel):
    def __init__(
        self,
        actual_affect_rows: int = None,
        create_time: str = None,
        dbtask_group_id: int = None,
        job_status: str = None,
    ):
        # The number of rows affected by the SQL statement.
        self.actual_affect_rows = actual_affect_rows
        # The time when the task was created.
        self.create_time = create_time
        # The ID of the SQL task group.
        self.dbtask_group_id = dbtask_group_id
        # The state of the SQL task. Valid values:
        # 
        # *   **INIT**: The SQL task was initialized.
        # *   **PENDING**: The SQL task waited to be run.
        # *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
        # *   **FAIL**: The SQL task failed.
        # *   **SUCCESS**: The SQL task was successful.
        # *   **PAUSE**: The SQL task was paused.
        # *   **DELETE**: The SQL task was deleted.
        # *   **RUNNING**: The SQL task was being run.
        self.job_status = job_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_affect_rows is not None:
            result['ActualAffectRows'] = self.actual_affect_rows
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.job_status is not None:
            result['jobStatus'] = self.job_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualAffectRows') is not None:
            self.actual_affect_rows = m.get('ActualAffectRows')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('jobStatus') is not None:
            self.job_status = m.get('jobStatus')
        return self


class GetDataCorrectTaskDetailResponseBody(TeaModel):
    def __init__(
        self,
        data_correct_task_detail: GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details of the data change task.
        self.data_correct_task_detail = data_correct_task_detail
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.data_correct_task_detail:
            self.data_correct_task_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_correct_task_detail is not None:
            result['DataCorrectTaskDetail'] = self.data_correct_task_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataCorrectTaskDetail') is not None:
            temp_model = GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail()
            self.data_correct_task_detail = temp_model.from_map(m['DataCorrectTaskDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectTaskDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCorrectTaskDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectTaskDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCronClearConfigRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCronClearConfigResponseBodyDataCronClearConfig(TeaModel):
    def __init__(
        self,
        cron_call_times: str = None,
        cron_format: str = None,
        cron_last_call_start_time: str = None,
        cron_next_call_time: str = None,
        cron_status: str = None,
        current_clear_task_count: int = None,
        duration: str = None,
        optimize_table_after_every_clear_times: int = None,
    ):
        # The number of times that the task is run.
        self.cron_call_times = cron_call_times
        # The crontab expression that you can use to run the task at a specified time. For more information, see [Crontab expression](https://help.aliyun.com/document_detail/206581.html).
        self.cron_format = cron_format
        # The time when the task was last run.
        self.cron_last_call_start_time = cron_last_call_start_time
        # The time when the task is run next time. This parameter is displayed only when the status of the scheduled task is SUCCESS.
        self.cron_next_call_time = cron_next_call_time
        # The status of the scheduled task. If this parameter is empty, it indicates the task is not run. Valid values:
        # 
        # *   PAUSE: The task is suspended.
        # *   WAITING: The task is waiting to be run.
        # *   SUCCESS: The task is complete.
        self.cron_status = cron_status
        # The number of times that the Optimize Table statement is automatically exeuted. This parameter is valid only when the value of the OptimizeTableAfterEveryClearTimes parameter is greater than 0.
        self.current_clear_task_count = current_clear_task_count
        # The execution duration of the task. Unit: hours. If the value is 0, it indicates the duration is not specified.
        self.duration = duration
        # Specifies whether to enable automatic execution of the OPTIMIZE TABLE statement. Valid values:
        # 
        # *   0: disables automatic execution
        # *   A number greater than 0: enables automatic execution. The number specifies the number of times that cleanup operations must be performed before the OPTIMIZE TABLE statement is automatically executed.
        self.optimize_table_after_every_clear_times = optimize_table_after_every_clear_times

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron_call_times is not None:
            result['CronCallTimes'] = self.cron_call_times
        if self.cron_format is not None:
            result['CronFormat'] = self.cron_format
        if self.cron_last_call_start_time is not None:
            result['CronLastCallStartTime'] = self.cron_last_call_start_time
        if self.cron_next_call_time is not None:
            result['CronNextCallTime'] = self.cron_next_call_time
        if self.cron_status is not None:
            result['CronStatus'] = self.cron_status
        if self.current_clear_task_count is not None:
            result['CurrentClearTaskCount'] = self.current_clear_task_count
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.optimize_table_after_every_clear_times is not None:
            result['OptimizeTableAfterEveryClearTimes'] = self.optimize_table_after_every_clear_times
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CronCallTimes') is not None:
            self.cron_call_times = m.get('CronCallTimes')
        if m.get('CronFormat') is not None:
            self.cron_format = m.get('CronFormat')
        if m.get('CronLastCallStartTime') is not None:
            self.cron_last_call_start_time = m.get('CronLastCallStartTime')
        if m.get('CronNextCallTime') is not None:
            self.cron_next_call_time = m.get('CronNextCallTime')
        if m.get('CronStatus') is not None:
            self.cron_status = m.get('CronStatus')
        if m.get('CurrentClearTaskCount') is not None:
            self.current_clear_task_count = m.get('CurrentClearTaskCount')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('OptimizeTableAfterEveryClearTimes') is not None:
            self.optimize_table_after_every_clear_times = m.get('OptimizeTableAfterEveryClearTimes')
        return self


class GetDataCronClearConfigResponseBody(TeaModel):
    def __init__(
        self,
        data_cron_clear_config: GetDataCronClearConfigResponseBodyDataCronClearConfig = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Data configuration.
        self.data_cron_clear_config = data_cron_clear_config
        # The error code.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success

    def validate(self):
        if self.data_cron_clear_config:
            self.data_cron_clear_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_cron_clear_config is not None:
            result['DataCronClearConfig'] = self.data_cron_clear_config.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataCronClearConfig') is not None:
            temp_model = GetDataCronClearConfigResponseBodyDataCronClearConfig()
            self.data_cron_clear_config = temp_model.from_map(m['DataCronClearConfig'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCronClearConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCronClearConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCronClearConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCronClearTaskDetailListRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can query the ticket ID from the response parameters of the [CreateDataCronClearOrder](https://help.aliyun.com/document_detail/208385.html) operation.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList(TeaModel):
    def __init__(
        self,
        actual_affect_rows: int = None,
        create_time: str = None,
        dbtask_group_id: int = None,
        job_status: str = None,
    ):
        # The number of rows affected by the SQL task.
        self.actual_affect_rows = actual_affect_rows
        # The time when the SQL task was created.
        self.create_time = create_time
        # The ID of the SQL task group.
        self.dbtask_group_id = dbtask_group_id
        # The state of the SQL task. Valid values:
        # 
        # *   **INIT**: The SQL task was initialized.
        # *   **PENDING**: The SQL task waited to be run.
        # *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
        # *   **FAIL**: The SQL task failed.
        # *   **SUCCESS**: The SQL task was successful.
        # *   **PAUSE**: The SQL task was paused.
        # *   **DELETE**: The SQL task was deleted.
        # *   **RUNNING**: The SQL task was being run.
        self.job_status = job_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_affect_rows is not None:
            result['ActualAffectRows'] = self.actual_affect_rows
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.job_status is not None:
            result['jobStatus'] = self.job_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualAffectRows') is not None:
            self.actual_affect_rows = m.get('ActualAffectRows')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('jobStatus') is not None:
            self.job_status = m.get('jobStatus')
        return self


class GetDataCronClearTaskDetailListResponseBody(TeaModel):
    def __init__(
        self,
        data_cron_clear_task_detail_list: List[GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The historical data cleansing tasks
        self.data_cron_clear_task_detail_list = data_cron_clear_task_detail_list
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success
        # The total number of SQL tasks.
        self.total_count = total_count

    def validate(self):
        if self.data_cron_clear_task_detail_list:
            for k in self.data_cron_clear_task_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataCronClearTaskDetailList'] = []
        if self.data_cron_clear_task_detail_list is not None:
            for k in self.data_cron_clear_task_detail_list:
                result['DataCronClearTaskDetailList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_cron_clear_task_detail_list = []
        if m.get('DataCronClearTaskDetailList') is not None:
            for k in m.get('DataCronClearTaskDetailList'):
                temp_model = GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList()
                self.data_cron_clear_task_detail_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetDataCronClearTaskDetailListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCronClearTaskDetailListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCronClearTaskDetailListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataExportDownloadURLRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        real_login_user_uid: str = None,
        tid: int = None,
    ):
        # The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the Alibaba Cloud account that is used to call the API operation.
        self.real_login_user_uid = real_login_user_uid
        # The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataExportDownloadURLResponseBodyDownloadURLResult(TeaModel):
    def __init__(
        self,
        has_result: bool = None,
        tip_message: str = None,
        url: str = None,
    ):
        # Indicates whether export results are available for download. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.has_result = has_result
        # The message that indicates an exception.
        self.tip_message = tip_message
        # The download URL of the file that records the export results for the ticket.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_result is not None:
            result['HasResult'] = self.has_result
        if self.tip_message is not None:
            result['TipMessage'] = self.tip_message
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HasResult') is not None:
            self.has_result = m.get('HasResult')
        if m.get('TipMessage') is not None:
            self.tip_message = m.get('TipMessage')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class GetDataExportDownloadURLResponseBody(TeaModel):
    def __init__(
        self,
        download_urlresult: GetDataExportDownloadURLResponseBodyDownloadURLResult = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details of the download URL of the file that records the export results for the ticket.
        self.download_urlresult = download_urlresult
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.download_urlresult:
            self.download_urlresult.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_urlresult is not None:
            result['DownloadURLResult'] = self.download_urlresult.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadURLResult') is not None:
            temp_model = GetDataExportDownloadURLResponseBodyDownloadURLResult()
            self.download_urlresult = temp_model.from_map(m['DownloadURLResult'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataExportDownloadURLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataExportDownloadURLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataExportDownloadURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataExportOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/465867.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        job_status: str = None,
        pre_check_id: int = None,
    ):
        # Export task ID.
        self.job_id = job_id
        # The state of the data export ticket. Valid values:
        # 
        # *   **PRE_CHECKING**: The ticket was being prechecked.
        # *   **PRE_CHECK_SUCCESS**: The ticket passed the precheck.
        # *   **PRE_CHECK_FAIL**: The ticket failed to pass the prechecked.
        # *   **WAITING_APPLY_AUDIT**: The ticket was to be submitted for approval.
        # *   **APPLY_AUDIT_SUCCESS**: The ticket was submitted for approval.
        # *   **ENABLE_EXPORT**: The ticket was approved. Data can be exported.
        # *   **WAITING_EXPORT**: Data was to be scheduled for export.
        # *   **DOING_EXPORT**: Data was being exported.
        # *   **EXPORT_FAIL**: Data failed to be exported.
        # *   **EXPORT_SUCCESS**: Data was exported.
        self.job_status = job_status
        # The precheck ID.
        self.pre_check_id = pre_check_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.pre_check_id is not None:
            result['PreCheckId'] = self.pre_check_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('PreCheckId') is not None:
            self.pre_check_id = m.get('PreCheckId')
        return self


class GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail(TeaModel):
    def __init__(
        self,
        actual_affect_rows: int = None,
        classify: str = None,
        database: str = None,
        db_id: int = None,
        env_type: str = None,
        exe_sql: str = None,
        ignore_affect_rows: bool = None,
        ignore_affect_rows_reason: str = None,
        logic: bool = None,
    ):
        # The number of rows that were affected by the SQL statement.
        self.actual_affect_rows = actual_affect_rows
        # The category of the reason for the data export.
        self.classify = classify
        # The name of the database from which data was exported.
        self.database = database
        # The ID of the database from which data was exported.
        self.db_id = db_id
        # The type of the environment to which the database belongs.
        self.env_type = env_type
        # The SQL statement that was executed to export data.
        self.exe_sql = exe_sql
        # Indicates whether the affected rows are skipped.
        self.ignore_affect_rows = ignore_affect_rows
        # The reason why the affected rows are skipped.
        self.ignore_affect_rows_reason = ignore_affect_rows_reason
        # Indicates whether the database is a logical database.
        self.logic = logic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_affect_rows is not None:
            result['ActualAffectRows'] = self.actual_affect_rows
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.database is not None:
            result['Database'] = self.database
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.exe_sql is not None:
            result['ExeSQL'] = self.exe_sql
        if self.ignore_affect_rows is not None:
            result['IgnoreAffectRows'] = self.ignore_affect_rows
        if self.ignore_affect_rows_reason is not None:
            result['IgnoreAffectRowsReason'] = self.ignore_affect_rows_reason
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualAffectRows') is not None:
            self.actual_affect_rows = m.get('ActualAffectRows')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExeSQL') is not None:
            self.exe_sql = m.get('ExeSQL')
        if m.get('IgnoreAffectRows') is not None:
            self.ignore_affect_rows = m.get('IgnoreAffectRows')
        if m.get('IgnoreAffectRowsReason') is not None:
            self.ignore_affect_rows_reason = m.get('IgnoreAffectRowsReason')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class GetDataExportOrderDetailResponseBodyDataExportOrderDetail(TeaModel):
    def __init__(
        self,
        key_info: GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo = None,
        order_detail: GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail = None,
    ):
        # The status information.
        self.key_info = key_info
        # The details of the ticket.
        self.order_detail = order_detail

    def validate(self):
        if self.key_info:
            self.key_info.validate()
        if self.order_detail:
            self.order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_info is not None:
            result['KeyInfo'] = self.key_info.to_map()
        if self.order_detail is not None:
            result['OrderDetail'] = self.order_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyInfo') is not None:
            temp_model = GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo()
            self.key_info = temp_model.from_map(m['KeyInfo'])
        if m.get('OrderDetail') is not None:
            temp_model = GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail()
            self.order_detail = temp_model.from_map(m['OrderDetail'])
        return self


class GetDataExportOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        data_export_order_detail: GetDataExportOrderDetailResponseBodyDataExportOrderDetail = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The information about the data export ticket.
        self.data_export_order_detail = data_export_order_detail
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data_export_order_detail:
            self.data_export_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_export_order_detail is not None:
            result['DataExportOrderDetail'] = self.data_export_order_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataExportOrderDetail') is not None:
            temp_model = GetDataExportOrderDetailResponseBodyDataExportOrderDetail()
            self.data_export_order_detail = temp_model.from_map(m['DataExportOrderDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataExportOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataExportOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataExportOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataExportPreCheckDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList(TeaModel):
    def __init__(
        self,
        affect_rows: int = None,
        sql: str = None,
    ):
        # The estimated number of data rows to be affected.
        self.affect_rows = affect_rows
        # The SQL statement.
        self.sql = sql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.sql is not None:
            result['SQL'] = self.sql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('SQL') is not None:
            self.sql = m.get('SQL')
        return self


class GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList(TeaModel):
    def __init__(
        self,
        pre_check_detail_list: List[GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList] = None,
    ):
        self.pre_check_detail_list = pre_check_detail_list

    def validate(self):
        if self.pre_check_detail_list:
            for k in self.pre_check_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PreCheckDetailList'] = []
        if self.pre_check_detail_list is not None:
            for k in self.pre_check_detail_list:
                result['PreCheckDetailList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.pre_check_detail_list = []
        if m.get('PreCheckDetailList') is not None:
            for k in m.get('PreCheckDetailList'):
                temp_model = GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList()
                self.pre_check_detail_list.append(temp_model.from_map(k))
        return self


class GetDataExportPreCheckDetailResponseBodyPreCheckResult(TeaModel):
    def __init__(
        self,
        ignore_affect_rows: bool = None,
        pre_check_detail_list: GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList = None,
    ):
        # Specifies whether to skip verification. Valid values:
        # 
        # - true
        # - false
        self.ignore_affect_rows = ignore_affect_rows
        # The list of pre-check details.
        self.pre_check_detail_list = pre_check_detail_list

    def validate(self):
        if self.pre_check_detail_list:
            self.pre_check_detail_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_affect_rows is not None:
            result['IgnoreAffectRows'] = self.ignore_affect_rows
        if self.pre_check_detail_list is not None:
            result['PreCheckDetailList'] = self.pre_check_detail_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IgnoreAffectRows') is not None:
            self.ignore_affect_rows = m.get('IgnoreAffectRows')
        if m.get('PreCheckDetailList') is not None:
            temp_model = GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList()
            self.pre_check_detail_list = temp_model.from_map(m['PreCheckDetailList'])
        return self


class GetDataExportPreCheckDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pre_check_result: GetDataExportPreCheckDetailResponseBodyPreCheckResult = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # Indicates the result of the precheck task.
        self.pre_check_result = pre_check_result
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.pre_check_result:
            self.pre_check_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.pre_check_result is not None:
            result['PreCheckResult'] = self.pre_check_result.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PreCheckResult') is not None:
            temp_model = GetDataExportPreCheckDetailResponseBodyPreCheckResult()
            self.pre_check_result = temp_model.from_map(m['PreCheckResult'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataExportPreCheckDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataExportPreCheckDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataExportPreCheckDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataImportSQLRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        sql_id: int = None,
        tid: int = None,
    ):
        # The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The SQL ID. You can call the ListDataImportSQLPreCheckDetail operation to query the SQL ID.
        # 
        # This parameter is required.
        self.sql_id = sql_id
        # The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataImportSQLResponseBodySQLDetail(TeaModel):
    def __init__(
        self,
        exec_sql: str = None,
    ):
        # The SQL script.
        self.exec_sql = exec_sql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exec_sql is not None:
            result['ExecSql'] = self.exec_sql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExecSql') is not None:
            self.exec_sql = m.get('ExecSql')
        return self


class GetDataImportSQLResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sqldetail: GetDataImportSQLResponseBodySQLDetail = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # The details of SQL statements.
        self.sqldetail = sqldetail
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.sqldetail:
            self.sqldetail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sqldetail is not None:
            result['SQLDetail'] = self.sqldetail.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SQLDetail') is not None:
            temp_model = GetDataImportSQLResponseBodySQLDetail()
            self.sqldetail = temp_model.from_map(m['SQLDetail'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataImportSQLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataImportSQLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataImportSQLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataLakeCatalogRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetDataLakeCatalogResponseBody(TeaModel):
    def __init__(
        self,
        catalog: DLCatalog = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.catalog = catalog
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.catalog:
            self.catalog.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog is not None:
            result['Catalog'] = self.catalog.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Catalog') is not None:
            temp_model = DLCatalog()
            self.catalog = temp_model.from_map(m['Catalog'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataLakeCatalogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataLakeCatalogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataLakeCatalogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataLakeDatabaseRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.name = name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.name is not None:
            result['Name'] = self.name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetDataLakeDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        database: DLDatabase = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.database = database
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.database:
            self.database.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Database') is not None:
            temp_model = DLDatabase()
            self.database = temp_model.from_map(m['Database'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataLakeDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataLakeDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataLakeDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataLakeFunctionRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        function_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.function_name = function_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetDataLakeFunctionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        function: DLFunction = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.function = function
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.function:
            self.function.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.function is not None:
            result['Function'] = self.function.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Function') is not None:
            temp_model = DLFunction()
            self.function = temp_model.from_map(m['Function'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataLakeFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataLakeFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataLakeFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataLakePartitionRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        partition_values: List[str] = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.partition_values = partition_values
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.partition_values is not None:
            result['PartitionValues'] = self.partition_values
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('PartitionValues') is not None:
            self.partition_values = m.get('PartitionValues')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetDataLakePartitionShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        partition_values_shrink: str = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.partition_values_shrink = partition_values_shrink
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.partition_values_shrink is not None:
            result['PartitionValues'] = self.partition_values_shrink
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('PartitionValues') is not None:
            self.partition_values_shrink = m.get('PartitionValues')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetDataLakePartitionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        partition: DLPartition = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.partition = partition
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.partition:
            self.partition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.partition is not None:
            result['Partition'] = self.partition.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Partition') is not None:
            temp_model = DLPartition()
            self.partition = temp_model.from_map(m['Partition'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataLakePartitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataLakePartitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataLakePartitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataLakeTableRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.name = name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.name is not None:
            result['Name'] = self.name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetDataLakeTableResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: str = None,
        table: DLTable = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.table = table

    def validate(self):
        if self.table:
            self.table.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.table is not None:
            result['Table'] = self.table.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Table') is not None:
            temp_model = DLTable()
            self.table = temp_model.from_map(m['Table'])
        return self


class GetDataLakeTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataLakeTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataLakeTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataTrackJobDegreeRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataTrackJobDegreeResponseBodyJobDegree(TeaModel):
    def __init__(
        self,
        download_completion_degree: float = None,
        filter_completion_degree: float = None,
        job_status: str = None,
        list_completion_degree: float = None,
        status_desc: str = None,
    ):
        # The progress of binary log download. Valid values: 0 to 1. A value of 1 indicates that binary log download is complete.
        self.download_completion_degree = download_completion_degree
        # The progress of binary log parsing. Valid values: 0 to 1. A value of 1 indicates that binary log parsing is complete.
        self.filter_completion_degree = filter_completion_degree
        # The status of the data tracking task. Valid values:
        # 
        # *   **INIT**: The task is being initialized.
        # *   **LISTING**: The binary logs are being obtained.
        # *   **LIST_SUCCESS**: The binary logs are successfully obtained.
        # *   **DOWNLOADING**: The binary logs are being downloaded.
        # *   **DOWNLOAD_FAIL**: The binary logs failed to be downloaded.
        # *   **DOWNLOAD_SUCCESS**: The binary logs are successfully downloaded.
        # *   **FILTERING**: The binary logs are being parsed.
        # *   **FILTER_FAIL**: The binary logs failed to be parsed.
        # *   **FILTER_SUCCESS**: The binary logs are successfully parsed.
        self.job_status = job_status
        # The progress of binary log obtaining. Valid values: 0 to 1. A value of 1 indicates that binary log obtaining is complete.
        self.list_completion_degree = list_completion_degree
        # The description of the task status.
        self.status_desc = status_desc

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_completion_degree is not None:
            result['DownloadCompletionDegree'] = self.download_completion_degree
        if self.filter_completion_degree is not None:
            result['FilterCompletionDegree'] = self.filter_completion_degree
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.list_completion_degree is not None:
            result['ListCompletionDegree'] = self.list_completion_degree
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadCompletionDegree') is not None:
            self.download_completion_degree = m.get('DownloadCompletionDegree')
        if m.get('FilterCompletionDegree') is not None:
            self.filter_completion_degree = m.get('FilterCompletionDegree')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('ListCompletionDegree') is not None:
            self.list_completion_degree = m.get('ListCompletionDegree')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        return self


class GetDataTrackJobDegreeResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        job_degree: GetDataTrackJobDegreeResponseBodyJobDegree = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The progress details of the data tracking task.
        self.job_degree = job_degree
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.job_degree:
            self.job_degree.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_degree is not None:
            result['JobDegree'] = self.job_degree.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobDegree') is not None:
            temp_model = GetDataTrackJobDegreeResponseBodyJobDegree()
            self.job_degree = temp_model.from_map(m['JobDegree'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataTrackJobDegreeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataTrackJobDegreeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataTrackJobDegreeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataTrackJobTableMetaRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataTrackJobTableMetaResponseBodyTableMetaListColumns(TeaModel):
    def __init__(
        self,
        charset: str = None,
        column_name: str = None,
        column_position: int = None,
        column_type: str = None,
        fictive: bool = None,
    ):
        # The name of the character set.
        self.charset = charset
        # The name of the column.
        self.column_name = column_name
        # The position of the column.
        self.column_position = column_position
        # The data type of the column. Examples: BIGINT, INT, and VARCHAR.
        self.column_type = column_type
        # Indicates whether the column is a virtual column. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.fictive = fictive

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charset is not None:
            result['Charset'] = self.charset
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_position is not None:
            result['ColumnPosition'] = self.column_position
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.fictive is not None:
            result['Fictive'] = self.fictive
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Charset') is not None:
            self.charset = m.get('Charset')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnPosition') is not None:
            self.column_position = m.get('ColumnPosition')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('Fictive') is not None:
            self.fictive = m.get('Fictive')
        return self


class GetDataTrackJobTableMetaResponseBodyTableMetaList(TeaModel):
    def __init__(
        self,
        columns: List[GetDataTrackJobTableMetaResponseBodyTableMetaListColumns] = None,
        schema_name: str = None,
        table_name: str = None,
    ):
        # The information about columns.
        self.columns = columns
        # The name of the database.
        self.schema_name = schema_name
        # The name of the table.
        self.table_name = table_name

    def validate(self):
        if self.columns:
            for k in self.columns:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Columns'] = []
        if self.columns is not None:
            for k in self.columns:
                result['Columns'].append(k.to_map() if k else None)
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.columns = []
        if m.get('Columns') is not None:
            for k in m.get('Columns'):
                temp_model = GetDataTrackJobTableMetaResponseBodyTableMetaListColumns()
                self.columns.append(temp_model.from_map(k))
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetDataTrackJobTableMetaResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        table_meta_list: List[GetDataTrackJobTableMetaResponseBodyTableMetaList] = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The metadata of tables.
        self.table_meta_list = table_meta_list

    def validate(self):
        if self.table_meta_list:
            for k in self.table_meta_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TableMetaList'] = []
        if self.table_meta_list is not None:
            for k in self.table_meta_list:
                result['TableMetaList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.table_meta_list = []
        if m.get('TableMetaList') is not None:
            for k in m.get('TableMetaList'):
                temp_model = GetDataTrackJobTableMetaResponseBodyTableMetaList()
                self.table_meta_list.append(temp_model.from_map(k))
        return self


class GetDataTrackJobTableMetaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataTrackJobTableMetaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataTrackJobTableMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataTrackOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail(TeaModel):
    def __init__(
        self,
        database_search_name: str = None,
        db_id: int = None,
        job_end_time: str = None,
        job_start_time: str = None,
        job_status: str = None,
        logic: bool = None,
        schema_name: str = None,
        status_desc: str = None,
        table_names: List[str] = None,
        track_types: List[str] = None,
    ):
        # The name that is used to search for the database.
        self.database_search_name = database_search_name
        # The ID of the database.
        self.db_id = db_id
        # The end time of the time range in which data operations are tracked. The time is in the yyyy-MM-dd HH:mm:ss format.
        self.job_end_time = job_end_time
        # The start time of the time range in which data operations are tracked. The time is in the yyyy-MM-dd HH:mm:ss format.
        self.job_start_time = job_start_time
        # The status of the data tracking task. Valid values:
        # 
        # *   **INIT**: The task is being initialized.
        # *   **LISTING**: The binary logs are being obtained.
        # *   **LIST_SUCCESS**: The binary logs are successfully obtained.
        # *   **DOWNLOADING**: The binary logs are being downloaded.
        # *   **DOWNLOAD_FAIL**: The binary logs failed to be downloaded.
        # *   **DOWNLOAD_SUCCESS**: The binary logs are successfully downloaded.
        # *   **FILTERING**: The binary logs are being parsed.
        # *   **FILTER_FAIL**: The binary logs failed to be parsed.
        # *   **FILTER_SUCCESS**: The binary logs are successfully parsed.
        self.job_status = job_status
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.logic = logic
        # The name of the database.
        self.schema_name = schema_name
        # The description of the task status.
        self.status_desc = status_desc
        # The names of the tables for which data operations are tracked.
        self.table_names = table_names
        # The types of data operations that are tracked.
        self.track_types = track_types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_search_name is not None:
            result['DatabaseSearchName'] = self.database_search_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.job_end_time is not None:
            result['JobEndTime'] = self.job_end_time
        if self.job_start_time is not None:
            result['JobStartTime'] = self.job_start_time
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.table_names is not None:
            result['TableNames'] = self.table_names
        if self.track_types is not None:
            result['TrackTypes'] = self.track_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseSearchName') is not None:
            self.database_search_name = m.get('DatabaseSearchName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('JobEndTime') is not None:
            self.job_end_time = m.get('JobEndTime')
        if m.get('JobStartTime') is not None:
            self.job_start_time = m.get('JobStartTime')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('TableNames') is not None:
            self.table_names = m.get('TableNames')
        if m.get('TrackTypes') is not None:
            self.track_types = m.get('TrackTypes')
        return self


class GetDataTrackOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        data_track_order_detail: GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details of the ticket.
        self.data_track_order_detail = data_track_order_detail
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.data_track_order_detail:
            self.data_track_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_track_order_detail is not None:
            result['DataTrackOrderDetail'] = self.data_track_order_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataTrackOrderDetail') is not None:
            temp_model = GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail()
            self.data_track_order_detail = temp_model.from_map(m['DataTrackOrderDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataTrackOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataTrackOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataTrackOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDatabaseRequest(TeaModel):
    def __init__(
        self,
        host: str = None,
        port: int = None,
        schema_name: str = None,
        sid: str = None,
        tid: int = None,
    ):
        # The endpoint that is used to connect to the database.
        # 
        # This parameter is required.
        self.host = host
        # The port that is used to connect to the database.
        # 
        # This parameter is required.
        self.port = port
        # The name of the database.
        # 
        # This parameter is required.
        self.schema_name = schema_name
        # The system identifier (SID) of the database.
        # 
        # >  The SID uniquely identifies an Oracle database. After a database is created, a SID is generated for the database.
        self.sid = sid
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDatabaseResponseBodyDatabaseOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class GetDatabaseResponseBodyDatabaseOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class GetDatabaseResponseBodyDatabase(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        database_id: str = None,
        db_type: str = None,
        dba_id: str = None,
        dba_name: str = None,
        encoding: str = None,
        env_type: str = None,
        host: str = None,
        instance_alias: str = None,
        instance_id: str = None,
        owner_id_list: GetDatabaseResponseBodyDatabaseOwnerIdList = None,
        owner_name_list: GetDatabaseResponseBodyDatabaseOwnerNameList = None,
        port: int = None,
        schema_name: str = None,
        search_name: str = None,
        sid: str = None,
        state: str = None,
    ):
        # The name of the catalog to which the database belongs.
        self.catalog_name = catalog_name
        # The ID of the database.
        self.database_id = database_id
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        self.db_type = db_type
        # The ID of the database administrator (DBA).
        self.dba_id = dba_id
        # The nickname of the DBA.
        self.dba_name = dba_name
        # The encoding format of the database.
        self.encoding = encoding
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: staging environment
        # *   **test**: test environment
        # *   **sit**: SIT environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: STAG environment
        self.env_type = env_type
        # The endpoint that is used to connect to the database.
        self.host = host
        # The alias of the instance.
        self.instance_alias = instance_alias
        # The ID of the instance.
        self.instance_id = instance_id
        # The IDs of the owners of the database.
        self.owner_id_list = owner_id_list
        # The names of the owners of the database.
        self.owner_name_list = owner_name_list
        # The port that is used to connect to the database.
        self.port = port
        # The name of the database.
        self.schema_name = schema_name
        # The keyword that is used to search for the database.
        self.search_name = search_name
        # The SID of the database.
        # 
        # >  The value of the parameter is returned only for Oracle databases.
        self.sid = sid
        # The status of the database. Valid values:
        # 
        # *   **NORMAL**: The database is running as expected.
        # *   **DISABLE**: The database is disabled.
        # *   **OFFLINE**: The database is unpublished.
        # *   **NOT_EXIST**: The database does not exist.
        self.state = state

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_name is not None:
            result['DbaName'] = self.dba_name
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaName') is not None:
            self.dba_name = m.get('DbaName')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerIdList') is not None:
            temp_model = GetDatabaseResponseBodyDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = GetDatabaseResponseBodyDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class GetDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        database: GetDatabaseResponseBodyDatabase = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details of the database.
        self.database = database
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        if self.database:
            self.database.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Database') is not None:
            temp_model = GetDatabaseResponseBodyDatabase()
            self.database = temp_model.from_map(m['Database'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDatabaseExportOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes(TeaModel):
    def __init__(
        self,
        export_types: List[str] = None,
    ):
        self.export_types = export_types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.export_types is not None:
            result['ExportTypes'] = self.export_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExportTypes') is not None:
            self.export_types = m.get('ExportTypes')
        return self


class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption(TeaModel):
    def __init__(
        self,
        sqlext_option: List[str] = None,
    ):
        self.sqlext_option = sqlext_option

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sqlext_option is not None:
            result['SQLExtOption'] = self.sqlext_option
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SQLExtOption') is not None:
            self.sqlext_option = m.get('SQLExtOption')
        return self


class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables(TeaModel):
    def __init__(
        self,
        selected_tables: List[str] = None,
    ):
        self.selected_tables = selected_tables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.selected_tables is not None:
            result['SelectedTables'] = self.selected_tables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SelectedTables') is not None:
            self.selected_tables = m.get('SelectedTables')
        return self


class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig(TeaModel):
    def __init__(
        self,
        db_name: str = None,
        export_content: str = None,
        export_types: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes = None,
        sqlext_option: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption = None,
        selected_tables: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables = None,
        target_option: str = None,
    ):
        # The database name.
        self.db_name = db_name
        # The type of data that was exported. Valid values:
        # 
        # *   **DATA**: The data of the database was exported.
        # *   **STRUCT**: The schema of the database was exported.
        # *   **DATA_STRUCT**: The data and schema of the database were exported.
        self.export_content = export_content
        # The type of schema that was exported.
        self.export_types = export_types
        # The extension options of the SQL script.
        self.sqlext_option = sqlext_option
        # The tables that were exported from the database.
        self.selected_tables = selected_tables
        # The format in which the database was exported. Valid values:
        # 
        # *   **SQL**\
        # *   **CSV**\
        # *   **XLSX**\
        self.target_option = target_option

    def validate(self):
        if self.export_types:
            self.export_types.validate()
        if self.sqlext_option:
            self.sqlext_option.validate()
        if self.selected_tables:
            self.selected_tables.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.export_content is not None:
            result['ExportContent'] = self.export_content
        if self.export_types is not None:
            result['ExportTypes'] = self.export_types.to_map()
        if self.sqlext_option is not None:
            result['SQLExtOption'] = self.sqlext_option.to_map()
        if self.selected_tables is not None:
            result['SelectedTables'] = self.selected_tables.to_map()
        if self.target_option is not None:
            result['TargetOption'] = self.target_option
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('ExportContent') is not None:
            self.export_content = m.get('ExportContent')
        if m.get('ExportTypes') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes()
            self.export_types = temp_model.from_map(m['ExportTypes'])
        if m.get('SQLExtOption') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption()
            self.sqlext_option = temp_model.from_map(m['SQLExtOption'])
        if m.get('SelectedTables') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables()
            self.selected_tables = temp_model.from_map(m['SelectedTables'])
        if m.get('TargetOption') is not None:
            self.target_option = m.get('TargetOption')
        return self


class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo(TeaModel):
    def __init__(
        self,
        audit_date: str = None,
        config: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig = None,
        db_id: int = None,
        download_url: str = None,
    ):
        # The time when the ticket was submitted.
        self.audit_date = audit_date
        # The configuration information about the ticket.
        self.config = config
        # The database ID.
        self.db_id = db_id
        # The URL that is used to download the export result.
        self.download_url = download_url

    def validate(self):
        if self.config:
            self.config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_date is not None:
            result['AuditDate'] = self.audit_date
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.download_url is not None:
            result['DownloadURL'] = self.download_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditDate') is not None:
            self.audit_date = m.get('AuditDate')
        if m.get('Config') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DownloadURL') is not None:
            self.download_url = m.get('DownloadURL')
        return self


class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail(TeaModel):
    def __init__(
        self,
        comment: str = None,
        committer: str = None,
        committer_id: str = None,
        id: int = None,
        key_info: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo = None,
        log: str = None,
        search_name: str = None,
        status_desc: str = None,
        workflow_status_desc: str = None,
    ):
        # The business background information of the database export ticket.
        self.comment = comment
        # The user who submitted the ticket.
        self.committer = committer
        # The ID of the user who submitted the ticket. This ID is a user ID and is not the ID of an Alibaba Cloud account.
        self.committer_id = committer_id
        # The ticket ID.
        self.id = id
        # The key information about the ticket.
        self.key_info = key_info
        # The execution logs.
        self.log = log
        # The name that is used to search for the database.
        self.search_name = search_name
        # The status description of the ticket.
        self.status_desc = status_desc
        # The status description of the workflow.
        self.workflow_status_desc = workflow_status_desc

    def validate(self):
        if self.key_info:
            self.key_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.committer is not None:
            result['Committer'] = self.committer
        if self.committer_id is not None:
            result['CommitterId'] = self.committer_id
        if self.id is not None:
            result['Id'] = self.id
        if self.key_info is not None:
            result['KeyInfo'] = self.key_info.to_map()
        if self.log is not None:
            result['Log'] = self.log
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.workflow_status_desc is not None:
            result['WorkflowStatusDesc'] = self.workflow_status_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Committer') is not None:
            self.committer = m.get('Committer')
        if m.get('CommitterId') is not None:
            self.committer_id = m.get('CommitterId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('KeyInfo') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo()
            self.key_info = temp_model.from_map(m['KeyInfo'])
        if m.get('Log') is not None:
            self.log = m.get('Log')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('WorkflowStatusDesc') is not None:
            self.workflow_status_desc = m.get('WorkflowStatusDesc')
        return self


class GetDatabaseExportOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        database_export_order_detail: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details of the database export ticket.
        self.database_export_order_detail = database_export_order_detail
        # The error code.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.database_export_order_detail:
            self.database_export_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_export_order_detail is not None:
            result['DatabaseExportOrderDetail'] = self.database_export_order_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseExportOrderDetail') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail()
            self.database_export_order_detail = temp_model.from_map(m['DatabaseExportOrderDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDatabaseExportOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDatabaseExportOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDatabaseExportOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDbExportDownloadURLRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDbExportDownloadURLResponseBodyDownloadURLResult(TeaModel):
    def __init__(
        self,
        has_result: bool = None,
        tip_message: str = None,
        url: str = None,
    ):
        self.has_result = has_result
        self.tip_message = tip_message
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_result is not None:
            result['HasResult'] = self.has_result
        if self.tip_message is not None:
            result['TipMessage'] = self.tip_message
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HasResult') is not None:
            self.has_result = m.get('HasResult')
        if m.get('TipMessage') is not None:
            self.tip_message = m.get('TipMessage')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class GetDbExportDownloadURLResponseBody(TeaModel):
    def __init__(
        self,
        download_urlresult: GetDbExportDownloadURLResponseBodyDownloadURLResult = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.download_urlresult = download_urlresult
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.download_urlresult:
            self.download_urlresult.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_urlresult is not None:
            result['DownloadURLResult'] = self.download_urlresult.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadURLResult') is not None:
            temp_model = GetDbExportDownloadURLResponseBodyDownloadURLResult()
            self.download_urlresult = temp_model.from_map(m['DownloadURLResult'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDbExportDownloadURLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDbExportDownloadURLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDbExportDownloadURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInstanceRequest(TeaModel):
    def __init__(
        self,
        host: str = None,
        port: int = None,
        sid: str = None,
        tid: int = None,
    ):
        # The endpoint of the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the endpoint.
        # 
        # This parameter is required.
        self.host = host
        # The port number that is used to connect to the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the port number.
        # 
        # This parameter is required.
        self.port = port
        # The system ID (SID) of the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the SID.
        self.sid = sid
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetInstanceResponseBodyInstanceOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class GetInstanceResponseBodyInstanceOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class GetInstanceResponseBodyInstanceStandardGroup(TeaModel):
    def __init__(
        self,
        group_mode: str = None,
        group_name: str = None,
    ):
        # The type of the control mode. Valid values:
        # 
        # *   **COMMON**: Security Collaboration
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        self.group_mode = group_mode
        # The name of the security rule set corresponding to the control mode.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class GetInstanceResponseBodyInstance(TeaModel):
    def __init__(
        self,
        data_link_name: str = None,
        database_password: str = None,
        database_user: str = None,
        dba_id: str = None,
        dba_nick_name: str = None,
        ddl_online: int = None,
        ecs_instance_id: str = None,
        ecs_region: str = None,
        env_type: str = None,
        export_timeout: int = None,
        host: str = None,
        instance_alias: str = None,
        instance_id: str = None,
        instance_source: str = None,
        instance_type: str = None,
        owner_id_list: GetInstanceResponseBodyInstanceOwnerIdList = None,
        owner_name_list: GetInstanceResponseBodyInstanceOwnerNameList = None,
        port: int = None,
        query_timeout: int = None,
        safe_rule_id: str = None,
        sell_sitd: str = None,
        sell_trust: str = None,
        sid: str = None,
        standard_group: GetInstanceResponseBodyInstanceStandardGroup = None,
        state: str = None,
        use_dsql: int = None,
        vpc_id: str = None,
    ):
        # The name of the database link for the database instance.
        self.data_link_name = data_link_name
        # The password that is used to log on to the database.
        self.database_password = database_password
        # The account that is used to log on to the database instance.
        self.database_user = database_user
        # The ID of the database administrator (DBA) for the database instance.
        self.dba_id = dba_id
        # The nickname of the DBA for the database instance.
        self.dba_nick_name = dba_nick_name
        # Indicates whether the lock-free schema change feature is enabled for the database instance.
        self.ddl_online = ddl_online
        # The ID of the Elastic Compute Service (ECS) instance on which the database instance is deployed.
        self.ecs_instance_id = ecs_instance_id
        # The ID of the region in which the database instance resides.
        self.ecs_region = ecs_region
        # The type of the environment to which the database instance belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: staging environment
        # *   **test**: test environment
        # *   **sit**: system integration testing (SIT) environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: STAG environment
        self.env_type = env_type
        # The timeout period for exporting data from the database instance.
        self.export_timeout = export_timeout
        # The host address that is used to connect to the database instance.
        self.host = host
        # The alias of the database instance.
        self.instance_alias = instance_alias
        # The ID of the database instance.
        self.instance_id = instance_id
        # The source of the database instance.
        self.instance_source = instance_source
        # The type of the database instance.
        self.instance_type = instance_type
        # The IDs of the owners for the database instance.
        self.owner_id_list = owner_id_list
        # The nicknames of the owners for the database instance.
        self.owner_name_list = owner_name_list
        # The port number that is used to connect to the database instance.
        self.port = port
        # The timeout period for querying data in the database instance.
        self.query_timeout = query_timeout
        # The ID of the security rule set for the database instance.
        self.safe_rule_id = safe_rule_id
        # Whether sensitive data protection is enabled.  Valid values:
        # 
        # - **true**: Enable.
        # 
        # - **false**: Close.
        self.sell_sitd = sell_sitd
        self.sell_trust = sell_trust
        # The SID of the database instance.
        self.sid = sid
        # The control mode of the database instance.
        self.standard_group = standard_group
        # The status of the database instance. Valid values:
        # 
        # *   **NORMAL**: normal
        # *   **DISABLE**: disabled
        self.state = state
        # Indicates whether the cross-database query feature is enabled for the database instance. Valid values:
        # 
        # *   **0**: disabled
        # *   **1**: enabled
        self.use_dsql = use_dsql
        # The ID of the virtual private cloud (VPC) to which the database instance belongs.
        self.vpc_id = vpc_id

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_nick_name is not None:
            result['DbaNickName'] = self.dba_nick_name
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule_id is not None:
            result['SafeRuleId'] = self.safe_rule_id
        if self.sell_sitd is not None:
            result['SellSitd'] = self.sell_sitd
        if self.sell_trust is not None:
            result['SellTrust'] = self.sell_trust
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaNickName') is not None:
            self.dba_nick_name = m.get('DbaNickName')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerIdList') is not None:
            temp_model = GetInstanceResponseBodyInstanceOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = GetInstanceResponseBodyInstanceOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRuleId') is not None:
            self.safe_rule_id = m.get('SafeRuleId')
        if m.get('SellSitd') is not None:
            self.sell_sitd = m.get('SellSitd')
        if m.get('SellTrust') is not None:
            self.sell_trust = m.get('SellTrust')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('StandardGroup') is not None:
            temp_model = GetInstanceResponseBodyInstanceStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class GetInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        instance: GetInstanceResponseBodyInstance = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The details of the database instance.
        self.instance = instance
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        if self.instance:
            self.instance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance is not None:
            result['Instance'] = self.instance.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Instance') is not None:
            temp_model = GetInstanceResponseBodyInstance()
            self.instance = temp_model.from_map(m['Instance'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetIntervalLimitOfSLARequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetIntervalLimitOfSLAResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        interval_limit: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The minimum scheduling cycle. Unit: minutes.
        self.interval_limit = interval_limit
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.interval_limit is not None:
            result['IntervalLimit'] = self.interval_limit
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('IntervalLimit') is not None:
            self.interval_limit = m.get('IntervalLimit')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetIntervalLimitOfSLAResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetIntervalLimitOfSLAResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetIntervalLimitOfSLAResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLhSpaceByNameRequest(TeaModel):
    def __init__(
        self,
        space_name: str = None,
        tid: int = None,
    ):
        # The name of the workspace.
        # 
        # This parameter is required.
        self.space_name = space_name
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_name is not None:
            result['SpaceName'] = self.space_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SpaceName') is not None:
            self.space_name = m.get('SpaceName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetLhSpaceByNameResponseBodyLakehouseSpace(TeaModel):
    def __init__(
        self,
        creator_id: str = None,
        description: str = None,
        dev_db_id: int = None,
        dw_db_type: str = None,
        id: int = None,
        is_deleted: bool = None,
        mode: int = None,
        prod_db_id: int = None,
        space_config: str = None,
        space_name: str = None,
        tenant_id: str = None,
    ):
        # The ID of the user who creates the workspace.
        self.creator_id = creator_id
        # The description of the workspace.
        self.description = description
        # The ID of the development database.
        self.dev_db_id = dev_db_id
        # The type of the database. Valid values:
        # 
        # *   **14**: AnalyticDB for MySQL
        # *   **18**: AnalyticDB for PostgreSQL
        self.dw_db_type = dw_db_type
        # The ID of the workspace.
        self.id = id
        # Indicates whether the workspace is deleted. Valid values:
        # 
        # *   **true**: The workspace is deleted.
        # *   **false**: The workspace is not deleted.
        self.is_deleted = is_deleted
        # The mode in which the workspace runs. Valid values:
        # 
        # *   **0**: basic mode
        # *   **1**: standard mode
        self.mode = mode
        # The ID of the production database.
        self.prod_db_id = prod_db_id
        # The configuration of the workspace. Valid values:
        # 
        # *   **skipManualRunCheck**: No security rule check is required in the trial run phase.
        # *   **skipPublishApprove**: No approval is required for publishing and O\\&M.
        self.space_config = space_config
        # The name of the workspace.
        self.space_name = space_name
        # The ID of the tenant to which the workspace belongs.
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_db_id is not None:
            result['DevDbId'] = self.dev_db_id
        if self.dw_db_type is not None:
            result['DwDbType'] = self.dw_db_type
        if self.id is not None:
            result['Id'] = self.id
        if self.is_deleted is not None:
            result['IsDeleted'] = self.is_deleted
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.prod_db_id is not None:
            result['ProdDbId'] = self.prod_db_id
        if self.space_config is not None:
            result['SpaceConfig'] = self.space_config
        if self.space_name is not None:
            result['SpaceName'] = self.space_name
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevDbId') is not None:
            self.dev_db_id = m.get('DevDbId')
        if m.get('DwDbType') is not None:
            self.dw_db_type = m.get('DwDbType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsDeleted') is not None:
            self.is_deleted = m.get('IsDeleted')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('ProdDbId') is not None:
            self.prod_db_id = m.get('ProdDbId')
        if m.get('SpaceConfig') is not None:
            self.space_config = m.get('SpaceConfig')
        if m.get('SpaceName') is not None:
            self.space_name = m.get('SpaceName')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class GetLhSpaceByNameResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        lakehouse_space: GetLhSpaceByNameResponseBodyLakehouseSpace = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The workspace for data warehouse development.
        self.lakehouse_space = lakehouse_space
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        if self.lakehouse_space:
            self.lakehouse_space.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.lakehouse_space is not None:
            result['LakehouseSpace'] = self.lakehouse_space.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LakehouseSpace') is not None:
            temp_model = GetLhSpaceByNameResponseBodyLakehouseSpace()
            self.lakehouse_space = temp_model.from_map(m['LakehouseSpace'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetLhSpaceByNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLhSpaceByNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLhSpaceByNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLogicDatabaseRequest(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        tid: int = None,
    ):
        # The ID of the logical database. You can call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the ID of the logical database.
        # 
        # This parameter is required.
        self.db_id = db_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds(TeaModel):
    def __init__(
        self,
        database_ids: List[int] = None,
    ):
        self.database_ids = database_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseIds') is not None:
            self.database_ids = m.get('DatabaseIds')
        return self


class GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class GetLogicDatabaseResponseBodyLogicDatabase(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_id: str = None,
        database_ids: GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        owner_id_list: GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList = None,
        owner_name_list: GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList = None,
        schema_name: str = None,
        search_name: str = None,
    ):
        # The alias of the logical database.
        self.alias = alias
        # The ID of the logical database.
        self.database_id = database_id
        # The IDs of database shards of the logical database.
        self.database_ids = database_ids
        # The database engine. For more information about the valid values of the DbType parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        self.db_type = db_type
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   product: production environment
        # *   dev: development environment
        # *   pre: pre-release environment
        # *   test: test environment
        # *   sit: system integration testing (SIT) environment
        # *   uat: user acceptance testing (UAT) environment
        # *   pet: stress testing environment
        # *   stag: staging environment
        self.env_type = env_type
        # Indicates whether the database is a logical database. The return value is true.
        self.logic = logic
        # The IDs of the owners of the logical database.
        self.owner_id_list = owner_id_list
        # The names of the owners of the logical database.
        self.owner_name_list = owner_name_list
        # The name of the logical database.
        self.schema_name = schema_name
        # The name that is used to search for the logical database.
        self.search_name = search_name

    def validate(self):
        if self.database_ids:
            self.database_ids.validate()
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids.to_map()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatabaseIds') is not None:
            temp_model = GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds()
            self.database_ids = temp_model.from_map(m['DatabaseIds'])
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetLogicDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        logic_database: GetLogicDatabaseResponseBodyLogicDatabase = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The details of the logical database.
        self.logic_database = logic_database
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success

    def validate(self):
        if self.logic_database:
            self.logic_database.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_database is not None:
            result['LogicDatabase'] = self.logic_database.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicDatabase') is not None:
            temp_model = GetLogicDatabaseResponseBodyLogicDatabase()
            self.logic_database = temp_model.from_map(m['LogicDatabase'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetLogicDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLogicDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLogicDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMetaTableColumnRequest(TeaModel):
    def __init__(
        self,
        table_guid: str = None,
        tid: int = None,
    ):
        # The globally unique identifier (GUID) of the table in Data Management (DMS).
        # 
        # *   If the database to which the table belongs is a logical database, you can call the [ListLogicTables](https://help.aliyun.com/document_detail/141875.html) operation to obtain the value of this parameter.
        # *   If the database to which the table belongs is a physical database, you can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to obtain the value of this parameter.
        # 
        # This parameter is required.
        self.table_guid = table_guid
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetMetaTableColumnResponseBodyColumnList(TeaModel):
    def __init__(
        self,
        auto_increment: bool = None,
        column_id: str = None,
        column_name: str = None,
        column_type: str = None,
        data_length: int = None,
        data_precision: int = None,
        data_scale: int = None,
        description: str = None,
        nullable: bool = None,
        position: int = None,
        primary_key: str = None,
        security_level: str = None,
    ):
        # Indicates whether the column is an auto-increment column. Valid values:
        # 
        # *   **true**: The column is an auto-increment column.
        # *   **false**: The column is not an auto-increment column.
        self.auto_increment = auto_increment
        # The ID of the column.
        self.column_id = column_id
        # The name of the column.
        self.column_name = column_name
        # The data type of the column.
        # 
        # > The return value of a column is not unique, such as **bigint** or **int**.
        self.column_type = column_type
        # The length of the field.
        self.data_length = data_length
        # The precision of the field.
        self.data_precision = data_precision
        # The number of decimal places for the field.
        self.data_scale = data_scale
        # The description of the column.
        self.description = description
        # Indicates whether the field can be empty. Valid values:
        # 
        # *   **true**: The field can be empty.
        # *   **false**: The field cannot be empty.
        self.nullable = nullable
        # The position of the field in the table.
        self.position = position
        # Indicates whether the field is the primary key. Valid values:
        # 
        # *   **true**: The field is the primary key.
        # *   **false**: The field is not the primary key.
        self.primary_key = primary_key
        # The sensitivity level of the column. Valid values:
        # 
        # *   **INNER**: The column is not sensitive.
        # *   **SENSITIVE**: The column is sensitive.
        # *   **CONFIDENTIAL**: The column is confidential.
        # 
        # > For more information, see [Sensitivity levels of columns](https://help.aliyun.com/document_detail/66091.html).
        self.security_level = security_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_increment is not None:
            result['AutoIncrement'] = self.auto_increment
        if self.column_id is not None:
            result['ColumnId'] = self.column_id
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.data_length is not None:
            result['DataLength'] = self.data_length
        if self.data_precision is not None:
            result['DataPrecision'] = self.data_precision
        if self.data_scale is not None:
            result['DataScale'] = self.data_scale
        if self.description is not None:
            result['Description'] = self.description
        if self.nullable is not None:
            result['Nullable'] = self.nullable
        if self.position is not None:
            result['Position'] = self.position
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoIncrement') is not None:
            self.auto_increment = m.get('AutoIncrement')
        if m.get('ColumnId') is not None:
            self.column_id = m.get('ColumnId')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DataLength') is not None:
            self.data_length = m.get('DataLength')
        if m.get('DataPrecision') is not None:
            self.data_precision = m.get('DataPrecision')
        if m.get('DataScale') is not None:
            self.data_scale = m.get('DataScale')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Nullable') is not None:
            self.nullable = m.get('Nullable')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        return self


class GetMetaTableColumnResponseBody(TeaModel):
    def __init__(
        self,
        column_list: List[GetMetaTableColumnResponseBodyColumnList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details about fields in the table.
        self.column_list = column_list
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.column_list:
            for k in self.column_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ColumnList'] = []
        if self.column_list is not None:
            for k in self.column_list:
                result['ColumnList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.column_list = []
        if m.get('ColumnList') is not None:
            for k in m.get('ColumnList'):
                temp_model = GetMetaTableColumnResponseBodyColumnList()
                self.column_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetMetaTableColumnResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMetaTableColumnResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMetaTableColumnResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMetaTableDetailInfoRequest(TeaModel):
    def __init__(
        self,
        table_guid: str = None,
        tid: int = None,
    ):
        # The GUID of the table in Data Management (DMS).
        # 
        # > 
        # 
        # *   You can call the [ListLogicTables](https://help.aliyun.com/document_detail/141875.html) operation with ReturnGuid set to true to query the GUIDs of logical tables in a specific logical database.
        # 
        # *   You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation with ReturnGuid set to true to query the GUIDs of tables in a specific physical database.
        # 
        # This parameter is required.
        self.table_guid = table_guid
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the Manage DMS tenants topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetMetaTableDetailInfoResponseBodyDetailInfoColumnList(TeaModel):
    def __init__(
        self,
        auto_increment: bool = None,
        column_id: str = None,
        column_name: str = None,
        column_type: str = None,
        data_length: int = None,
        data_precision: int = None,
        data_scale: int = None,
        description: str = None,
        nullable: bool = None,
        position: str = None,
    ):
        # Indicates whether the column is an auto-increment column. Valid values:
        # 
        # *   true: The column is an auto-increment column.
        # *   false: The column is not an auto-increment column.
        self.auto_increment = auto_increment
        # The ID of the column.
        self.column_id = column_id
        # The name of the column.
        self.column_name = column_name
        # The data type of the column. Examples: Bigint, Int, and Varchar.
        self.column_type = column_type
        # The length of the field.
        self.data_length = data_length
        # The precision of the field.
        self.data_precision = data_precision
        # The scale of the column.
        self.data_scale = data_scale
        # The description of the column.
        self.description = description
        # Indicates whether the column is nullable. Valid values:
        # 
        # *   true: The column is nullable.
        # *   false: The column is not nullable.
        self.nullable = nullable
        # The position of the field in the table.
        self.position = position

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_increment is not None:
            result['AutoIncrement'] = self.auto_increment
        if self.column_id is not None:
            result['ColumnId'] = self.column_id
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.data_length is not None:
            result['DataLength'] = self.data_length
        if self.data_precision is not None:
            result['DataPrecision'] = self.data_precision
        if self.data_scale is not None:
            result['DataScale'] = self.data_scale
        if self.description is not None:
            result['Description'] = self.description
        if self.nullable is not None:
            result['Nullable'] = self.nullable
        if self.position is not None:
            result['Position'] = self.position
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoIncrement') is not None:
            self.auto_increment = m.get('AutoIncrement')
        if m.get('ColumnId') is not None:
            self.column_id = m.get('ColumnId')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DataLength') is not None:
            self.data_length = m.get('DataLength')
        if m.get('DataPrecision') is not None:
            self.data_precision = m.get('DataPrecision')
        if m.get('DataScale') is not None:
            self.data_scale = m.get('DataScale')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Nullable') is not None:
            self.nullable = m.get('Nullable')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        return self


class GetMetaTableDetailInfoResponseBodyDetailInfoIndexList(TeaModel):
    def __init__(
        self,
        index_columns: List[str] = None,
        index_id: str = None,
        index_name: str = None,
        index_type: str = None,
        unique: bool = None,
    ):
        # The index column.
        self.index_columns = index_columns
        # The ID of the index.
        self.index_id = index_id
        # The name of the index.
        self.index_name = index_name
        # The type of the index. Examples: Primary, Unique, and Normal.
        self.index_type = index_type
        # Indicates whether the index is unique. Valid values:
        # 
        # *   true: The index is unique.
        # *   false: The index is not unique.
        self.unique = unique

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_columns is not None:
            result['IndexColumns'] = self.index_columns
        if self.index_id is not None:
            result['IndexId'] = self.index_id
        if self.index_name is not None:
            result['IndexName'] = self.index_name
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        if self.unique is not None:
            result['Unique'] = self.unique
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndexColumns') is not None:
            self.index_columns = m.get('IndexColumns')
        if m.get('IndexId') is not None:
            self.index_id = m.get('IndexId')
        if m.get('IndexName') is not None:
            self.index_name = m.get('IndexName')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        if m.get('Unique') is not None:
            self.unique = m.get('Unique')
        return self


class GetMetaTableDetailInfoResponseBodyDetailInfo(TeaModel):
    def __init__(
        self,
        column_list: List[GetMetaTableDetailInfoResponseBodyDetailInfoColumnList] = None,
        index_list: List[GetMetaTableDetailInfoResponseBodyDetailInfoIndexList] = None,
    ):
        # The columns in the table.
        self.column_list = column_list
        # The list of indexes.
        self.index_list = index_list

    def validate(self):
        if self.column_list:
            for k in self.column_list:
                if k:
                    k.validate()
        if self.index_list:
            for k in self.index_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ColumnList'] = []
        if self.column_list is not None:
            for k in self.column_list:
                result['ColumnList'].append(k.to_map() if k else None)
        result['IndexList'] = []
        if self.index_list is not None:
            for k in self.index_list:
                result['IndexList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.column_list = []
        if m.get('ColumnList') is not None:
            for k in m.get('ColumnList'):
                temp_model = GetMetaTableDetailInfoResponseBodyDetailInfoColumnList()
                self.column_list.append(temp_model.from_map(k))
        self.index_list = []
        if m.get('IndexList') is not None:
            for k in m.get('IndexList'):
                temp_model = GetMetaTableDetailInfoResponseBodyDetailInfoIndexList()
                self.index_list.append(temp_model.from_map(k))
        return self


class GetMetaTableDetailInfoResponseBody(TeaModel):
    def __init__(
        self,
        detail_info: GetMetaTableDetailInfoResponseBodyDetailInfo = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details of the table.
        self.detail_info = detail_info
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.detail_info:
            self.detail_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.detail_info is not None:
            result['DetailInfo'] = self.detail_info.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DetailInfo') is not None:
            temp_model = GetMetaTableDetailInfoResponseBodyDetailInfo()
            self.detail_info = temp_model.from_map(m['DetailInfo'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetMetaTableDetailInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMetaTableDetailInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMetaTableDetailInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOnlineDDLProgressRequest(TeaModel):
    def __init__(
        self,
        job_detail_id: int = None,
        tid: int = None,
    ):
        # The ID of the OnlineDDL SQL task details. You can call the [ListDBTaskSQLJobDetail](https://help.aliyun.com/document_detail/207073.html) operation to obtain the task detail ID.
        # 
        # This parameter is required.
        self.job_detail_id = job_detail_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_detail_id is not None:
            result['JobDetailId'] = self.job_detail_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobDetailId') is not None:
            self.job_detail_id = m.get('JobDetailId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail(TeaModel):
    def __init__(
        self,
        clean_strategy: str = None,
        copy_chunk_mode: str = None,
        copy_chunk_size: int = None,
        copy_count: int = None,
        copy_total: int = None,
        cutover_fail_retry_times: int = None,
        cutover_lock_time_seconds: int = None,
        cutover_window_end_time: str = None,
        cutover_window_start_time: str = None,
        delay_seconds: int = None,
        job_status: str = None,
        progress_ratio: str = None,
        status_desc: str = None,
    ):
        # The cleanup policy of the original table after the cut-over. Valid values:
        # 
        # *   **DROP**: Invalid original tables are deleted.
        # *   **MOVE**: Invalid original tables are moved to the test database. You can delete the tables manually.
        # *   **NOTHING**: Invalid original tables are retained in the original database. You can delete the tables manually.
        self.clean_strategy = clean_strategy
        # The policy of full replication. Valid values:
        # 
        # *   **AUTO**: DMS dynamically adjusts the chunk size based on the performance of the database. Tables are locked for less than 1.5 seconds during a single replication operation.
        # *   **RUNNING**: DMS uses the specified value of the CopyChunkSize parameter. The valid value of the CopyChunkSize parameter ranges from 1 to 60000. If you set this parameter to RUNNING, you must specify the CopyChunkSize parameter.
        self.copy_chunk_mode = copy_chunk_mode
        # The size of each chunk that is used to replicate data. This parameter is used to specify the size of each chunk. A larger chunk size increases the replication efficiency and decreases the business performance.
        # 
        # > During full replication, the original table is divided into N small chunks and each chunk is replicated to the temporary table one by one. By default, DMS dynamically adjusts the size of each chunk.
        self.copy_chunk_size = copy_chunk_size
        # The actual amount of data replicated from the original table in the lock-free change operation.
        self.copy_count = copy_count
        # The estimated total number of rows of the data. The value is obtained from the statistical data in the information_schema database. In most cases, the estimated total number of rows is smaller than the actual number of rows in a table.
        self.copy_total = copy_total
        # The number of retries when the cut-over fails.
        self.cutover_fail_retry_times = cutover_fail_retry_times
        # The maximum period of time that a table can be locked during cut-over. Unit: seconds.
        self.cutover_lock_time_seconds = cutover_lock_time_seconds
        # The end of the time window of the cut-over operation. This value is at least 30 minutes later than the CutoverWindowStartTime parameter. Default value: 23:59:59
        self.cutover_window_end_time = cutover_window_end_time
        # The beginning of the time window of the cut-over operation. Default value: 00:00:00. This parameter controls the time window of the cut-over. Cut-over can be performed only when the cut-over conditions are met and the time is within the specified time window. If the time is not within the time window, the cut-over operation is not performed until the time reaches the beginning of the time window.
        self.cutover_window_start_time = cutover_window_start_time
        # The replay latency of DMS. Unit: seconds. The replay latency is the period of time that is taken to replay the binary logs of the table to the temporary table. The latency does not indicate the data migration latency between a primary database and a secondary database.
        self.delay_seconds = delay_seconds
        # The state of the task. Valid values:
        # 
        # *   **INIT**: The task is being initialized.
        # *   **SUCCESS**: The task is complete.
        # *   **RUNNING**: The task is being executed.
        # *   **WAITING_CUTOVER**: The task is waiting for cut-over.
        # *   **RESTARTING**: The task is restarting.
        # *   **PAUSE**: The task is suspended.
        # *   **UNSUPPORTED**: The task is not supported.
        # *   **CANCELED**: The task is canceled.
        # *   **FAIL**: The task failed.
        # *   **INTERRUPT**: The task is interrupted.
        self.job_status = job_status
        # The estimated execution progress. The actual progress is subject to the task status.
        self.progress_ratio = progress_ratio
        # The description of the task status.
        self.status_desc = status_desc

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clean_strategy is not None:
            result['CleanStrategy'] = self.clean_strategy
        if self.copy_chunk_mode is not None:
            result['CopyChunkMode'] = self.copy_chunk_mode
        if self.copy_chunk_size is not None:
            result['CopyChunkSize'] = self.copy_chunk_size
        if self.copy_count is not None:
            result['CopyCount'] = self.copy_count
        if self.copy_total is not None:
            result['CopyTotal'] = self.copy_total
        if self.cutover_fail_retry_times is not None:
            result['CutoverFailRetryTimes'] = self.cutover_fail_retry_times
        if self.cutover_lock_time_seconds is not None:
            result['CutoverLockTimeSeconds'] = self.cutover_lock_time_seconds
        if self.cutover_window_end_time is not None:
            result['CutoverWindowEndTime'] = self.cutover_window_end_time
        if self.cutover_window_start_time is not None:
            result['CutoverWindowStartTime'] = self.cutover_window_start_time
        if self.delay_seconds is not None:
            result['DelaySeconds'] = self.delay_seconds
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.progress_ratio is not None:
            result['ProgressRatio'] = self.progress_ratio
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CleanStrategy') is not None:
            self.clean_strategy = m.get('CleanStrategy')
        if m.get('CopyChunkMode') is not None:
            self.copy_chunk_mode = m.get('CopyChunkMode')
        if m.get('CopyChunkSize') is not None:
            self.copy_chunk_size = m.get('CopyChunkSize')
        if m.get('CopyCount') is not None:
            self.copy_count = m.get('CopyCount')
        if m.get('CopyTotal') is not None:
            self.copy_total = m.get('CopyTotal')
        if m.get('CutoverFailRetryTimes') is not None:
            self.cutover_fail_retry_times = m.get('CutoverFailRetryTimes')
        if m.get('CutoverLockTimeSeconds') is not None:
            self.cutover_lock_time_seconds = m.get('CutoverLockTimeSeconds')
        if m.get('CutoverWindowEndTime') is not None:
            self.cutover_window_end_time = m.get('CutoverWindowEndTime')
        if m.get('CutoverWindowStartTime') is not None:
            self.cutover_window_start_time = m.get('CutoverWindowStartTime')
        if m.get('DelaySeconds') is not None:
            self.delay_seconds = m.get('DelaySeconds')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('ProgressRatio') is not None:
            self.progress_ratio = m.get('ProgressRatio')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        return self


class GetOnlineDDLProgressResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        online_ddltask_detail: GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The details of the task.
        self.online_ddltask_detail = online_ddltask_detail
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.online_ddltask_detail:
            self.online_ddltask_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.online_ddltask_detail is not None:
            result['OnlineDDLTaskDetail'] = self.online_ddltask_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OnlineDDLTaskDetail') is not None:
            temp_model = GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail()
            self.online_ddltask_detail = temp_model.from_map(m['OnlineDDLTaskDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetOnlineDDLProgressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOnlineDDLProgressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOnlineDDLProgressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOpLogRequest(TeaModel):
    def __init__(
        self,
        database_name: str = None,
        end_time: str = None,
        module: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time: str = None,
        tid: int = None,
        user_nick: str = None,
    ):
        # DatabaseName.
        self.database_name = database_name
        # The end of the time range to query. Specify the time in the yyyy-MM-DD HH:mm:ss format.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The functional module for which you want to query operation logs. If you do not specify this parameter, operation logs for all functional modules are returned. Valid values:
        # 
        # *   **PERMISSION**: permissions
        # *   **OWNER**: data owner
        # *   **SQL_CONSOLE**: data query
        # *   **SQL_CONSOLE_EXPORT**: query result export
        # *   **DATA_CHANGE**: data change
        # *   **DATA_EXPORT**: data export
        # *   **SQL_REVIEW**: SQL review
        # *   **DT_SYNC**: database and table synchronization
        # *   **DT_DETAIL**: database and table details
        # *   **DB_TASK**: task management
        # *   **INSTANCE_MANAGE**: instance management
        # *   **USER_MANAGE**: user management
        # *   **SECURITY_RULE**: security rules
        # *   **CONFIG_MANAGE**: configuration management
        # *   **RESOURCE_AUTH**: resource authorization
        # *   **ACCESS_WHITE_IP**: access IP address whitelist
        # *   **NDDL**: schema design
        # *   **DSQL_CONSOLE**: cross-database data query
        # *   **DSQL_CONSOLE_EXPORT**: cross-database query result export
        # *   **DATA_TRACT**: data tracking
        # *   **DATA_QUALITY**: data quality
        # *   **DATALINK_MANAGE** :DBLink management
        # *   **DATASEC_MANAGE**: sensitive data management
        # *   **SELL**: sales
        self.module = module
        # The number of the page to return. Pages start from page 1.
        # 
        # This parameter is required.
        self.page_number = page_number
        # The number of entries to return on each page. Valid values:
        # 
        # *   30
        # *   50
        # *   100
        # 
        # This parameter is required.
        self.page_size = page_size
        # The beginning of the time range to query. Specify the time in the yyyy-MM-DD HH:mm:ss format.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid
        # UserNick.
        self.user_nick = user_nick

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.module is not None:
            result['Module'] = self.module
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Module') is not None:
            self.module = m.get('Module')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class GetOpLogResponseBodyOpLogDetailsOpLogDetail(TeaModel):
    def __init__(
        self,
        database: str = None,
        module: str = None,
        op_content: str = None,
        op_time: str = None,
        op_user_id: int = None,
        order_id: int = None,
        user_id: str = None,
        user_nick: str = None,
    ):
        # The endpoint of the database instance.
        # 
        # > 
        # 
        # *   This parameter is valid only for database instances of the LocalInstance type.
        # 
        # *   This parameter is valid only for operations on the functional modules related to tasks.
        self.database = database
        # The functional module for which the operation log is queried.
        self.module = module
        # The details of the operation.
        self.op_content = op_content
        # The time when the operation was performed.
        self.op_time = op_time
        # The ID of the user who performed the operation.
        self.op_user_id = op_user_id
        # The ID of the ticket or task.
        # 
        # >  This parameter is valid only for operations on the functional modules related to tasks and the task management module in system management.
        self.order_id = order_id
        # The ID of the Alibaba Cloud account.
        self.user_id = user_id
        # The display name of the user.
        self.user_nick = user_nick

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database
        if self.module is not None:
            result['Module'] = self.module
        if self.op_content is not None:
            result['OpContent'] = self.op_content
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        if self.op_user_id is not None:
            result['OpUserId'] = self.op_user_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('Module') is not None:
            self.module = m.get('Module')
        if m.get('OpContent') is not None:
            self.op_content = m.get('OpContent')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        if m.get('OpUserId') is not None:
            self.op_user_id = m.get('OpUserId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class GetOpLogResponseBodyOpLogDetails(TeaModel):
    def __init__(
        self,
        op_log_detail: List[GetOpLogResponseBodyOpLogDetailsOpLogDetail] = None,
    ):
        self.op_log_detail = op_log_detail

    def validate(self):
        if self.op_log_detail:
            for k in self.op_log_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OpLogDetail'] = []
        if self.op_log_detail is not None:
            for k in self.op_log_detail:
                result['OpLogDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.op_log_detail = []
        if m.get('OpLogDetail') is not None:
            for k in m.get('OpLogDetail'):
                temp_model = GetOpLogResponseBodyOpLogDetailsOpLogDetail()
                self.op_log_detail.append(temp_model.from_map(k))
        return self


class GetOpLogResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        op_log_details: GetOpLogResponseBodyOpLogDetails = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The details of the operation log.
        self.op_log_details = op_log_details
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The total number of operation logs that are returned.
        self.total_count = total_count

    def validate(self):
        if self.op_log_details:
            self.op_log_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.op_log_details is not None:
            result['OpLogDetails'] = self.op_log_details.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OpLogDetails') is not None:
            temp_model = GetOpLogResponseBodyOpLogDetails()
            self.op_log_details = temp_model.from_map(m['OpLogDetails'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetOpLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOpLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOpLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOrderAttachmentFileRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOrderAttachmentFileResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        file_url: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned. Take note of the following rules:
        # 
        # *   The **ErrorCode** parameter is not returned if the request is successful.
        # *   The **ErrorCode** parameter is returned if the request fails. For more information, see the **Error codes** section of this topic.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The download URL of the attachment.
        self.file_url = file_url
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetOrderAttachmentFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOrderAttachmentFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOrderAttachmentFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOrderBaseInfoRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList(TeaModel):
    def __init__(
        self,
        user_ids: List[str] = None,
    ):
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList(TeaModel):
    def __init__(
        self,
        user_nicks: List[str] = None,
    ):
        self.user_nicks = user_nicks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_nicks is not None:
            result['UserNicks'] = self.user_nicks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserNicks') is not None:
            self.user_nicks = m.get('UserNicks')
        return self


class GetOrderBaseInfoResponseBodyOrderBaseInfo(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        committer: str = None,
        committer_id: int = None,
        create_time: str = None,
        last_modify_time: str = None,
        order_id: int = None,
        origin_attachment_name: str = None,
        plugin_type: str = None,
        related_user_list: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList = None,
        related_user_nick_list: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList = None,
        status_code: str = None,
        status_desc: str = None,
        workflow_instance_id: int = None,
        workflow_status_desc: str = None,
    ):
        # The Key of the ticket attachment. This information is returned only when an attachment is uploaded when a ticket is created.
        self.attachment_key = attachment_key
        # The remarks of the ticket.
        self.comment = comment
        # The applicant.
        self.committer = committer
        # The ID of the applicant. Note: The ID is different from the Alibaba Cloud account ID of the applicant.
        self.committer_id = committer_id
        # The time when the ticket was created.
        self.create_time = create_time
        # The time when the ticket was last modified.
        self.last_modify_time = last_modify_time
        # The ID of the ticket.
        self.order_id = order_id
        # The original file name of the ticket attachment. This information is returned only when an attachment is uploaded when a ticket is created.
        self.origin_attachment_name = origin_attachment_name
        # The type of the ticket. For more information about the value of this parameter, see the request parameters of the [CreateOrder](https://help.aliyun.com/document_detail/465865.html) operation.
        self.plugin_type = plugin_type
        # The IDs of the operators that are related to the ticket.
        self.related_user_list = related_user_list
        # The nicknames of the operators that are related to the ticket.
        self.related_user_nick_list = related_user_nick_list
        # The status code of the ticket. Valid values:
        # 
        # *   **new**: The ticket is created.
        # *   **toaudit**: The ticket is being reviewed.
        # *   **Approved**: The ticket is approved.
        # *   **reject**: The ticket is rejected.
        # *   **processing**: The ticket is being executed.
        # *   **success**: The ticket is executed.
        # *   **closed**: The ticket is closed.
        self.status_code = status_code
        # The description of the status.
        self.status_desc = status_desc
        # The ID of the approval process.
        self.workflow_instance_id = workflow_instance_id
        # The description of the approval process.
        self.workflow_status_desc = workflow_status_desc

    def validate(self):
        if self.related_user_list:
            self.related_user_list.validate()
        if self.related_user_nick_list:
            self.related_user_nick_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.committer is not None:
            result['Committer'] = self.committer
        if self.committer_id is not None:
            result['CommitterId'] = self.committer_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modify_time is not None:
            result['LastModifyTime'] = self.last_modify_time
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.origin_attachment_name is not None:
            result['OriginAttachmentName'] = self.origin_attachment_name
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list.to_map()
        if self.related_user_nick_list is not None:
            result['RelatedUserNickList'] = self.related_user_nick_list.to_map()
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_status_desc is not None:
            result['WorkflowStatusDesc'] = self.workflow_status_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Committer') is not None:
            self.committer = m.get('Committer')
        if m.get('CommitterId') is not None:
            self.committer_id = m.get('CommitterId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModifyTime') is not None:
            self.last_modify_time = m.get('LastModifyTime')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('OriginAttachmentName') is not None:
            self.origin_attachment_name = m.get('OriginAttachmentName')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            temp_model = GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList()
            self.related_user_list = temp_model.from_map(m['RelatedUserList'])
        if m.get('RelatedUserNickList') is not None:
            temp_model = GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList()
            self.related_user_nick_list = temp_model.from_map(m['RelatedUserNickList'])
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowStatusDesc') is not None:
            self.workflow_status_desc = m.get('WorkflowStatusDesc')
        return self


class GetOrderBaseInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        order_base_info: GetOrderBaseInfoResponseBodyOrderBaseInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The basic information about the ticket.
        self.order_base_info = order_base_info
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.order_base_info:
            self.order_base_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.order_base_info is not None:
            result['OrderBaseInfo'] = self.order_base_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OrderBaseInfo') is not None:
            temp_model = GetOrderBaseInfoResponseBodyOrderBaseInfo()
            self.order_base_info = temp_model.from_map(m['OrderBaseInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetOrderBaseInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOrderBaseInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOrderBaseInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOwnerApplyOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        env_type: str = None,
        owner_ids: List[int] = None,
        owner_nick_names: List[str] = None,
        search_name: str = None,
        table_name: str = None,
    ):
        # The type of the database engine.
        self.db_type = db_type
        # The type of the environment to which the instance belongs. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
        self.env_type = env_type
        # The IDs of the original owners.
        self.owner_ids = owner_ids
        # The nicknames of the owners.
        self.owner_nick_names = owner_nick_names
        # The search name of the resource.
        self.search_name = search_name
        # The name of the table.
        # 
        # > : This parameter is returned when you submit a Database-OWNER ticket.
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_nick_names is not None:
            result['OwnerNickNames'] = self.owner_nick_names
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerNickNames') is not None:
            self.owner_nick_names = m.get('OwnerNickNames')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources(TeaModel):
    def __init__(
        self,
        logic: bool = None,
        resource_detail: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail = None,
        target_id: str = None,
    ):
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The instance is a logical database.
        # *   **false**: The instance is not a logical database.
        self.logic = logic
        # The details of the resource.
        self.resource_detail = resource_detail
        # The ID of the resource.
        self.target_id = target_id

    def validate(self):
        if self.resource_detail:
            self.resource_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.resource_detail is not None:
            result['ResourceDetail'] = self.resource_detail.to_map()
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('ResourceDetail') is not None:
            temp_model = GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail()
            self.resource_detail = temp_model.from_map(m['ResourceDetail'])
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        return self


class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail(TeaModel):
    def __init__(
        self,
        apply_type: str = None,
        resources: List[GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources] = None,
    ):
        # The type of the submitted ticket. Valid values:
        # 
        # *   **INSTANCE**: the ticket that applies for the permissions to be an instance owner
        # *   **DB**: the ticket that applies for the permissions to be a database owner
        # *   **TABLE**: the ticket that applies for the permissions to be a table owner
        self.apply_type = apply_type
        # The details of the requested resource.
        self.resources = resources

    def validate(self):
        if self.resources:
            for k in self.resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_type is not None:
            result['ApplyType'] = self.apply_type
        result['Resources'] = []
        if self.resources is not None:
            for k in self.resources:
                result['Resources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyType') is not None:
            self.apply_type = m.get('ApplyType')
        self.resources = []
        if m.get('Resources') is not None:
            for k in m.get('Resources'):
                temp_model = GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources()
                self.resources.append(temp_model.from_map(k))
        return self


class GetOwnerApplyOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        owner_apply_order_detail: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The details of the ticket.
        self.owner_apply_order_detail = owner_apply_order_detail
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.owner_apply_order_detail:
            self.owner_apply_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.owner_apply_order_detail is not None:
            result['OwnerApplyOrderDetail'] = self.owner_apply_order_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OwnerApplyOrderDetail') is not None:
            temp_model = GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail()
            self.owner_apply_order_detail = temp_model.from_map(m['OwnerApplyOrderDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetOwnerApplyOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOwnerApplyOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOwnerApplyOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPagedInstanceRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetPagedInstanceResponseBodyDataInstance(TeaModel):
    def __init__(
        self,
        business_time: str = None,
        check_status: int = None,
        dag_id: int = None,
        delete: str = None,
        end_time: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        history_dag_id: int = None,
        id: int = None,
        last_running_context: str = None,
        msg: str = None,
        status: int = None,
        task_type: int = None,
        tenant_id: str = None,
        trigger_type: int = None,
        version: str = None,
    ):
        self.business_time = business_time
        self.check_status = check_status
        self.dag_id = dag_id
        self.delete = delete
        self.end_time = end_time
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.history_dag_id = history_dag_id
        self.id = id
        self.last_running_context = last_running_context
        self.msg = msg
        self.status = status
        self.task_type = task_type
        self.tenant_id = tenant_id
        self.trigger_type = trigger_type
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_time is not None:
            result['BusinessTime'] = self.business_time
        if self.check_status is not None:
            result['CheckStatus'] = self.check_status
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.delete is not None:
            result['Delete'] = self.delete
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.history_dag_id is not None:
            result['HistoryDagId'] = self.history_dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.last_running_context is not None:
            result['LastRunningContext'] = self.last_running_context
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.status is not None:
            result['Status'] = self.status
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessTime') is not None:
            self.business_time = m.get('BusinessTime')
        if m.get('CheckStatus') is not None:
            self.check_status = m.get('CheckStatus')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Delete') is not None:
            self.delete = m.get('Delete')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('HistoryDagId') is not None:
            self.history_dag_id = m.get('HistoryDagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LastRunningContext') is not None:
            self.last_running_context = m.get('LastRunningContext')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetPagedInstanceResponseBodyData(TeaModel):
    def __init__(
        self,
        instance: List[GetPagedInstanceResponseBodyDataInstance] = None,
    ):
        self.instance = instance

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = GetPagedInstanceResponseBodyDataInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class GetPagedInstanceResponseBody(TeaModel):
    def __init__(
        self,
        data: GetPagedInstanceResponseBodyData = None,
        error_code: str = None,
        error_message: str = None,
        page_index: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
        trace_id: str = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.page_index = page_index
        self.page_size = page_size
        self.request_id = request_id
        self.success = success
        self.total = total
        # Id of the request
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetPagedInstanceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class GetPagedInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPagedInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPagedInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPermApplyOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/465867.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The tenant ID.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        table_name: str = None,
    ):
        # The name of the column.
        self.column_name = column_name
        # The name of the table.
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        owner_ids: List[int] = None,
        owner_nick_names: List[str] = None,
        search_name: str = None,
    ):
        # The database ID.
        self.db_id = db_id
        # The type of the database engine.
        self.db_type = db_type
        # The type of the environment to which the instance belongs. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
        self.env_type = env_type
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.logic = logic
        # The IDs of the owners of the database.
        self.owner_ids = owner_ids
        # The nicknames of the owners of the database.
        self.owner_nick_names = owner_nick_names
        # The name that is used to search for the database.
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_nick_names is not None:
            result['OwnerNickNames'] = self.owner_nick_names
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerNickNames') is not None:
            self.owner_nick_names = m.get('OwnerNickNames')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        dba_id: int = None,
        dba_nick_name: str = None,
        env_type: str = None,
        host: str = None,
        instance_id: str = None,
        owner_ids: List[int] = None,
        owner_nick_name: List[str] = None,
        port: int = None,
        search_name: str = None,
    ):
        # The type of the database engine.
        self.db_type = db_type
        # The ID of the database administrator (DBA) of the instance.
        self.dba_id = dba_id
        # The nickname of the DBA of the instance.
        self.dba_nick_name = dba_nick_name
        # The type of the environment to which the instance belongs. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
        self.env_type = env_type
        # The endpoint of the instance.
        self.host = host
        # The ID of the instance.
        self.instance_id = instance_id
        # The IDs of the owners of the instance.
        self.owner_ids = owner_ids
        # The nicknames of the owners of the instance.
        self.owner_nick_name = owner_nick_name
        # The port that is used to connect to the instance.
        self.port = port
        # The name that is used to search for the instance.
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_nick_name is not None:
            result['DbaNickName'] = self.dba_nick_name
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_nick_name is not None:
            result['OwnerNickName'] = self.owner_nick_name
        if self.port is not None:
            result['Port'] = self.port
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaNickName') is not None:
            self.dba_nick_name = m.get('DbaNickName')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerNickName') is not None:
            self.owner_nick_name = m.get('OwnerNickName')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo(TeaModel):
    def __init__(
        self,
        table_name: str = None,
    ):
        # The name of the table.
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources(TeaModel):
    def __init__(
        self,
        column_info: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo = None,
        database_info: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo = None,
        instance_info: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo = None,
        table_info: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo = None,
    ):
        # The information about the column.
        self.column_info = column_info
        # The information about the database.
        self.database_info = database_info
        # The information about the instance.
        self.instance_info = instance_info
        # The information about the table.
        self.table_info = table_info

    def validate(self):
        if self.column_info:
            self.column_info.validate()
        if self.database_info:
            self.database_info.validate()
        if self.instance_info:
            self.instance_info.validate()
        if self.table_info:
            self.table_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_info is not None:
            result['ColumnInfo'] = self.column_info.to_map()
        if self.database_info is not None:
            result['DatabaseInfo'] = self.database_info.to_map()
        if self.instance_info is not None:
            result['InstanceInfo'] = self.instance_info.to_map()
        if self.table_info is not None:
            result['TableInfo'] = self.table_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnInfo') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo()
            self.column_info = temp_model.from_map(m['ColumnInfo'])
        if m.get('DatabaseInfo') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo()
            self.database_info = temp_model.from_map(m['DatabaseInfo'])
        if m.get('InstanceInfo') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo()
            self.instance_info = temp_model.from_map(m['InstanceInfo'])
        if m.get('TableInfo') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo()
            self.table_info = temp_model.from_map(m['TableInfo'])
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail(TeaModel):
    def __init__(
        self,
        apply_type: str = None,
        perm_type: int = None,
        resources: List[GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources] = None,
        seconds: int = None,
    ):
        # The type of objects on which you apply for permissions. Valid values:
        # 
        # *   **DB**: database
        # *   **TAB**: table
        # *   **COL**: column
        # *   **INSTANT**: instance
        self.apply_type = apply_type
        # The type of the permissions that you apply for. Valid values:
        # 
        # *   **1**: the permissions to query information.
        # *   **2**: the permissions to export information.
        # *   **3**: the permissions to query and export information.
        # *   **4**: the permissions to modify information.
        # *   **5**: the permissions to query and modify information.
        # *   **6**: the permissions to export and modify information.
        # *   **7**: the permissions to query, export, and modify information.
        # *   **8**: the permissions to log on to the database.
        self.perm_type = perm_type
        # The list of resources.
        self.resources = resources
        # The validity duration of the permissions. Unit: seconds.
        self.seconds = seconds

    def validate(self):
        if self.resources:
            for k in self.resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_type is not None:
            result['ApplyType'] = self.apply_type
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        result['Resources'] = []
        if self.resources is not None:
            for k in self.resources:
                result['Resources'].append(k.to_map() if k else None)
        if self.seconds is not None:
            result['Seconds'] = self.seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyType') is not None:
            self.apply_type = m.get('ApplyType')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        self.resources = []
        if m.get('Resources') is not None:
            for k in m.get('Resources'):
                temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources()
                self.resources.append(temp_model.from_map(k))
        if m.get('Seconds') is not None:
            self.seconds = m.get('Seconds')
        return self


class GetPermApplyOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        perm_apply_order_detail: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The details of the permission application ticket.
        self.perm_apply_order_detail = perm_apply_order_detail
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.perm_apply_order_detail:
            self.perm_apply_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.perm_apply_order_detail is not None:
            result['PermApplyOrderDetail'] = self.perm_apply_order_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PermApplyOrderDetail') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail()
            self.perm_apply_order_detail = temp_model.from_map(m['PermApplyOrderDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetPermApplyOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPermApplyOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPermApplyOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPhysicalDatabaseRequest(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        tid: int = None,
    ):
        # The ID of the physical database. You can call the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the ID.
        # 
        # This parameter is required.
        self.db_id = db_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class GetPhysicalDatabaseResponseBodyDatabase(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        database_id: str = None,
        db_type: str = None,
        dba_id: str = None,
        dba_name: str = None,
        encoding: str = None,
        env_type: str = None,
        host: str = None,
        instance_alias: str = None,
        instance_id: str = None,
        owner_id_list: GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList = None,
        owner_name_list: GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList = None,
        port: int = None,
        schema_name: str = None,
        search_name: str = None,
        sid: str = None,
        state: str = None,
    ):
        # The name of the catalog to which the database belongs.
        # 
        # > : If the database is a PostgreSQL database, the name of the database is displayed.
        self.catalog_name = catalog_name
        # The ID of the physical database.
        self.database_id = database_id
        # The type of the database engine.
        self.db_type = db_type
        # The user ID of the DBA in the destination database.
        self.dba_id = dba_id
        # The nickname of the database administrator (DBA) in the destination database.
        self.dba_name = dba_name
        # The encoding format of the database.
        self.encoding = encoding
        # The type of the environment to which the database belongs. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
        self.env_type = env_type
        # The endpoint that is used to connect to the database.
        self.host = host
        # The alias of the database instance.
        self.instance_alias = instance_alias
        # The instance ID of the destination database.
        self.instance_id = instance_id
        # The user IDs of the database owners.
        self.owner_id_list = owner_id_list
        # The nicknames of the database owners.
        self.owner_name_list = owner_name_list
        # The port that is used to connect to the database.
        self.port = port
        # The name of the database.
        # 
        # > : If the database is a PostgreSQL database, the name of the mode is displayed.
        self.schema_name = schema_name
        # The name that is used for searching the database.
        self.search_name = search_name
        # The system ID (SID) of the database.
        # 
        # > : The value of the parameter is returned only for Oracle databases.
        self.sid = sid
        # The state of the database. Valid values:
        # 
        # *   **NORMAL**: The database is normal.
        # *   **DISABLE**: The database is disabled.
        # *   **OFFLINE**: The database is unpublished.
        # *   **NOT_EXIST**: The database does not exist.
        self.state = state

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_name is not None:
            result['DbaName'] = self.dba_name
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaName') is not None:
            self.dba_name = m.get('DbaName')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerIdList') is not None:
            temp_model = GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class GetPhysicalDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        database: GetPhysicalDatabaseResponseBodyDatabase = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The information about the physical database.
        self.database = database
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.database:
            self.database.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Database') is not None:
            temp_model = GetPhysicalDatabaseResponseBodyDatabase()
            self.database = temp_model.from_map(m['Database'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetPhysicalDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPhysicalDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPhysicalDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProxyRequest(TeaModel):
    def __init__(
        self,
        proxy_id: int = None,
        tid: int = None,
    ):
        # The ID of the secure access proxy. You can call the [ListProxies](https://help.aliyun.com/document_detail/295371.html) operation to query the ID of the secure access proxy.
        # 
        # This parameter is required.
        self.proxy_id = proxy_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetProxyResponseBody(TeaModel):
    def __init__(
        self,
        creator_id: int = None,
        creator_name: str = None,
        error_code: str = None,
        error_message: str = None,
        https_port: int = None,
        instance_id: int = None,
        private_enable: bool = None,
        private_host: str = None,
        protocol_port: int = None,
        protocol_type: str = None,
        proxy_id: int = None,
        public_enable: bool = None,
        public_host: str = None,
        region_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the user who enabled the secure access proxy feature.
        self.creator_id = creator_id
        # The nickname of the user who enabled the secure access proxy feature.
        self.creator_name = creator_name
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The port number used by the HTTPS protocol.
        self.https_port = https_port
        # The ID of the instance.
        self.instance_id = instance_id
        # Indicates whether the internal endpoint was enabled. Default value: **true**.
        self.private_enable = private_enable
        # The internal endpoint.
        self.private_host = private_host
        # The port number used by the protocol.
        self.protocol_port = protocol_port
        # The protocol type of the database. Example: MYSQL.
        self.protocol_type = protocol_type
        # The ID of the secure access proxy.
        self.proxy_id = proxy_id
        # Indicates whether the public endpoint was enabled. Valid values:
        # 
        # *   **true**: The public endpoint was enabled.
        # *   **false**: The public endpoint was disabled.
        self.public_enable = public_enable
        # The public endpoint. A public endpoint is returned no matter whether the public endpoint is enabled or disabled.
        # 
        # > 
        # 
        # *   If the value of the PublicEnable parameter is **true**, a valid public endpoint that can be resolved by using Alibaba Cloud DNS is returned.
        # 
        # *   If the value of the PublicEnable parameter is **false**, an invalid public endpoint that cannot be resolved by using Alibaba Cloud DNS is returned.
        self.public_host = public_host
        # The ID of the region in which the instance resides.
        self.region_id = region_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_name is not None:
            result['CreatorName'] = self.creator_name
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.https_port is not None:
            result['HttpsPort'] = self.https_port
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.private_enable is not None:
            result['PrivateEnable'] = self.private_enable
        if self.private_host is not None:
            result['PrivateHost'] = self.private_host
        if self.protocol_port is not None:
            result['ProtocolPort'] = self.protocol_port
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.public_enable is not None:
            result['PublicEnable'] = self.public_enable
        if self.public_host is not None:
            result['PublicHost'] = self.public_host
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorName') is not None:
            self.creator_name = m.get('CreatorName')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpsPort') is not None:
            self.https_port = m.get('HttpsPort')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PrivateEnable') is not None:
            self.private_enable = m.get('PrivateEnable')
        if m.get('PrivateHost') is not None:
            self.private_host = m.get('PrivateHost')
        if m.get('ProtocolPort') is not None:
            self.protocol_port = m.get('ProtocolPort')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('PublicEnable') is not None:
            self.public_enable = m.get('PublicEnable')
        if m.get('PublicHost') is not None:
            self.public_host = m.get('PublicHost')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetProxyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProxyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProxyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProxyAccessRequest(TeaModel):
    def __init__(
        self,
        proxy_access_id: int = None,
        tid: int = None,
    ):
        # The ID that Data Management (DMS) generates after the user is authorized to enable the secure access proxy feature for an instance. The ID is unique in DMS. You can call the [ListProxyAccesses](https://help.aliyun.com/document_detail/295386.html) operation to query the ID.
        # 
        # This parameter is required.
        self.proxy_access_id = proxy_access_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetProxyAccessResponseBodyProxyAccess(TeaModel):
    def __init__(
        self,
        access_id: str = None,
        gmt_create: str = None,
        indep_account: str = None,
        instance_id: int = None,
        origin_info: str = None,
        proxy_access_id: int = None,
        proxy_id: int = None,
        user_id: int = None,
        user_name: str = None,
        user_uid: str = None,
    ):
        # The username of the database account that is authorized to enable the secure access proxy feature for an instance.
        self.access_id = access_id
        # The time when the user is authorized to enable the secure access proxy feature for an instance.
        self.gmt_create = gmt_create
        # The username of the independent database account.
        self.indep_account = indep_account
        # The ID of the instance for which the secure access proxy feature is enabled.
        self.instance_id = instance_id
        # The method that is used to authorize the user to enable the secure access proxy feature for an instance. Valid values:
        # 
        # *   **Authorization by the Alibaba Cloud Account ()**: The information in the parentheses () indicates the ID of the Alibaba Cloud account.
        # *   **Authorization by submitting the ticket ()**:The information in the parentheses () indicates the number of the ticket that the user submits to apply for permissions.
        self.origin_info = origin_info
        # The ID that DMS generates after the user is authorized to enable the secure access proxy feature for an instance. The ID is unique in DMS. You can call the [ListProxyAccesses](https://help.aliyun.com/document_detail/295386.html) operation to query the ID.
        self.proxy_access_id = proxy_access_id
        # The ID of the secure access proxy.
        # 
        # >  You can call the [ListProxies](https://help.aliyun.com/document_detail/295371.html) operation to query the ID of the secure access proxy.
        self.proxy_id = proxy_id
        # The ID of the user.
        self.user_id = user_id
        # The nickname of the user.
        self.user_name = user_name
        # The ID of the Alibaba Cloud account.
        self.user_uid = user_uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.indep_account is not None:
            result['IndepAccount'] = self.indep_account
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.origin_info is not None:
            result['OriginInfo'] = self.origin_info
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_uid is not None:
            result['UserUid'] = self.user_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('IndepAccount') is not None:
            self.indep_account = m.get('IndepAccount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OriginInfo') is not None:
            self.origin_info = m.get('OriginInfo')
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserUid') is not None:
            self.user_uid = m.get('UserUid')
        return self


class GetProxyAccessResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        proxy_access: GetProxyAccessResponseBodyProxyAccess = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The authorization information about the secure access proxy feature.
        self.proxy_access = proxy_access
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.proxy_access:
            self.proxy_access.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.proxy_access is not None:
            result['ProxyAccess'] = self.proxy_access.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProxyAccess') is not None:
            temp_model = GetProxyAccessResponseBodyProxyAccess()
            self.proxy_access = temp_model.from_map(m['ProxyAccess'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetProxyAccessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProxyAccessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProxyAccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRuleNumLimitOfSLARequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetRuleNumLimitOfSLAResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        rule_num_limit: int = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # The maximum number of SLA rules.
        self.rule_num_limit = rule_num_limit
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_num_limit is not None:
            result['RuleNumLimit'] = self.rule_num_limit
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleNumLimit') is not None:
            self.rule_num_limit = m.get('RuleNumLimit')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRuleNumLimitOfSLAResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRuleNumLimitOfSLAResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRuleNumLimitOfSLAResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSQLReviewCheckResultStatusRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can obtain the ticket ID from the response parameters of the [CreateSQLReviewOrder](https://help.aliyun.com/document_detail/257777.html) operation.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult(TeaModel):
    def __init__(
        self,
        check_not_pass: int = None,
        check_pass: int = None,
        force_not_pass: int = None,
        force_pass: int = None,
        new: int = None,
        unknown: int = None,
    ):
        # The number of SQL statements that failed to pass the review.
        self.check_not_pass = check_not_pass
        # The number of SQL statements that passed the review.
        self.check_pass = check_pass
        # The number of SQL statements that failed to pass the manual review.
        self.force_not_pass = force_not_pass
        # The number of SQL statements that passed the manual review.
        self.force_pass = force_pass
        # The number of SQL statements to be reviewed.
        self.new = new
        # The number of abnormal SQL statements.
        self.unknown = unknown

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_not_pass is not None:
            result['CheckNotPass'] = self.check_not_pass
        if self.check_pass is not None:
            result['CheckPass'] = self.check_pass
        if self.force_not_pass is not None:
            result['ForceNotPass'] = self.force_not_pass
        if self.force_pass is not None:
            result['ForcePass'] = self.force_pass
        if self.new is not None:
            result['New'] = self.new
        if self.unknown is not None:
            result['Unknown'] = self.unknown
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckNotPass') is not None:
            self.check_not_pass = m.get('CheckNotPass')
        if m.get('CheckPass') is not None:
            self.check_pass = m.get('CheckPass')
        if m.get('ForceNotPass') is not None:
            self.force_not_pass = m.get('ForceNotPass')
        if m.get('ForcePass') is not None:
            self.force_pass = m.get('ForcePass')
        if m.get('New') is not None:
            self.new = m.get('New')
        if m.get('Unknown') is not None:
            self.unknown = m.get('Unknown')
        return self


class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult(TeaModel):
    def __init__(
        self,
        must_improve: int = None,
        potential_issue: int = None,
        suggest_improve: int = None,
        table_index_suggest: int = None,
        use_dms_dml_unlock: int = None,
        use_dms_toolkit: int = None,
    ):
        # The number of SQL statements that must be modified.
        self.must_improve = must_improve
        # The number of SQL statements that have potential issues.
        self.potential_issue = potential_issue
        # The number of SQL statements that can be modified.
        self.suggest_improve = suggest_improve
        # The number of SQL statements that can use indexes.
        self.table_index_suggest = table_index_suggest
        # The number of SQL statements that can be used for lock-free data changes.
        self.use_dms_dml_unlock = use_dms_dml_unlock
        # The number of SQL statements that can be used for lock-free schema changes.
        self.use_dms_toolkit = use_dms_toolkit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.must_improve is not None:
            result['MustImprove'] = self.must_improve
        if self.potential_issue is not None:
            result['PotentialIssue'] = self.potential_issue
        if self.suggest_improve is not None:
            result['SuggestImprove'] = self.suggest_improve
        if self.table_index_suggest is not None:
            result['TableIndexSuggest'] = self.table_index_suggest
        if self.use_dms_dml_unlock is not None:
            result['UseDmsDmlUnlock'] = self.use_dms_dml_unlock
        if self.use_dms_toolkit is not None:
            result['UseDmsToolkit'] = self.use_dms_toolkit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MustImprove') is not None:
            self.must_improve = m.get('MustImprove')
        if m.get('PotentialIssue') is not None:
            self.potential_issue = m.get('PotentialIssue')
        if m.get('SuggestImprove') is not None:
            self.suggest_improve = m.get('SuggestImprove')
        if m.get('TableIndexSuggest') is not None:
            self.table_index_suggest = m.get('TableIndexSuggest')
        if m.get('UseDmsDmlUnlock') is not None:
            self.use_dms_dml_unlock = m.get('UseDmsDmlUnlock')
        if m.get('UseDmsToolkit') is not None:
            self.use_dms_toolkit = m.get('UseDmsToolkit')
        return self


class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus(TeaModel):
    def __init__(
        self,
        check_status_result: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult = None,
        checked_count: int = None,
        sqlreview_result: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult = None,
        total_sqlcount: int = None,
    ):
        # The result of the SQL status check.
        self.check_status_result = check_status_result
        # The number of SQL statements that were reviewed.
        self.checked_count = checked_count
        # The optimization suggestion for SQL statements.
        self.sqlreview_result = sqlreview_result
        # The total number of SQL statements.
        self.total_sqlcount = total_sqlcount

    def validate(self):
        if self.check_status_result:
            self.check_status_result.validate()
        if self.sqlreview_result:
            self.sqlreview_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_status_result is not None:
            result['CheckStatusResult'] = self.check_status_result.to_map()
        if self.checked_count is not None:
            result['CheckedCount'] = self.checked_count
        if self.sqlreview_result is not None:
            result['SQLReviewResult'] = self.sqlreview_result.to_map()
        if self.total_sqlcount is not None:
            result['TotalSQLCount'] = self.total_sqlcount
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckStatusResult') is not None:
            temp_model = GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult()
            self.check_status_result = temp_model.from_map(m['CheckStatusResult'])
        if m.get('CheckedCount') is not None:
            self.checked_count = m.get('CheckedCount')
        if m.get('SQLReviewResult') is not None:
            temp_model = GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult()
            self.sqlreview_result = temp_model.from_map(m['SQLReviewResult'])
        if m.get('TotalSQLCount') is not None:
            self.total_sqlcount = m.get('TotalSQLCount')
        return self


class GetSQLReviewCheckResultStatusResponseBody(TeaModel):
    def __init__(
        self,
        check_result_status: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The result of the SQL review.
        self.check_result_status = check_result_status
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.check_result_status:
            self.check_result_status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_result_status is not None:
            result['CheckResultStatus'] = self.check_result_status.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckResultStatus') is not None:
            temp_model = GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus()
            self.check_result_status = temp_model.from_map(m['CheckResultStatus'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSQLReviewCheckResultStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSQLReviewCheckResultStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSQLReviewCheckResultStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSQLReviewOptimizeDetailRequest(TeaModel):
    def __init__(
        self,
        sqlreview_query_key: str = None,
        tid: int = None,
    ):
        # The key that is used to query the details of optimization suggestions. You can call the [ListSQLReviewOriginSQL](https://help.aliyun.com/document_detail/257870.html) operation to query the key.
        # 
        # This parameter is required.
        self.sqlreview_query_key = sqlreview_query_key
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sqlreview_query_key is not None:
            result['SQLReviewQueryKey'] = self.sqlreview_query_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SQLReviewQueryKey') is not None:
            self.sqlreview_query_key = m.get('SQLReviewQueryKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts(TeaModel):
    def __init__(
        self,
        content: str = None,
        op_type: str = None,
        table_name: str = None,
    ):
        # The content of the SQL script.
        self.content = content
        # The purpose of the SQL script. The value is set to AddIndex.
        self.op_type = op_type
        # The name of the table.
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.op_type is not None:
            result['OpType'] = self.op_type
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('OpType') is not None:
            self.op_type = m.get('OpType')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults(TeaModel):
    def __init__(
        self,
        comments: str = None,
        feedback: str = None,
        messages: List[str] = None,
        rule_name: str = None,
        rule_type: str = None,
        scripts: List[GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts] = None,
    ):
        # The comment that is specified when you create the SQL review rule. For more information, see [SQL review optimization](https://help.aliyun.com/document_detail/194114.html).
        self.comments = comments
        # The optimization suggestion for the SQL statement. Valid values:
        # 
        # *   **MUST_IMPROVE**: The SQL statement must be improved.
        # *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
        # *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
        # *   **USEDMSTOOLKIT**: We recommend that you change schemas without locking tables.
        # *   **USEDMSDML_UNLOCK**: We recommend that you change data without locking tables.
        # *   **TABLEINDEXSUGGEST**: We recommend that you use SQL statements that use indexes.
        self.feedback = feedback
        # The review results.
        self.messages = messages
        # The name of the rule. For more information, see [SQL review optimization](https://help.aliyun.com/document_detail/194114.html).
        self.rule_name = rule_name
        # The type of the SQL review rule. Valid values:
        # 
        # *   **REVIEW**: a rule that is used to review SQL statements based on standards.
        # *   **OPTIMIZE**: a rule that is used to provide optimization suggestions.
        self.rule_type = rule_type
        # The SQL script for data changes.
        self.scripts = scripts

    def validate(self):
        if self.scripts:
            for k in self.scripts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comments is not None:
            result['Comments'] = self.comments
        if self.feedback is not None:
            result['Feedback'] = self.feedback
        if self.messages is not None:
            result['Messages'] = self.messages
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        result['Scripts'] = []
        if self.scripts is not None:
            for k in self.scripts:
                result['Scripts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comments') is not None:
            self.comments = m.get('Comments')
        if m.get('Feedback') is not None:
            self.feedback = m.get('Feedback')
        if m.get('Messages') is not None:
            self.messages = m.get('Messages')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        self.scripts = []
        if m.get('Scripts') is not None:
            for k in m.get('Scripts'):
                temp_model = GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts()
                self.scripts.append(temp_model.from_map(k))
        return self


class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult(TeaModel):
    def __init__(
        self,
        error_message: str = None,
        occur_error: bool = None,
        results: List[GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults] = None,
    ):
        # The error message returned.
        self.error_message = error_message
        # Indicates whether an error occurs. Valid values:
        # 
        # *   **true**: An error occurs.
        # *   **false**: No error occurs.
        self.occur_error = occur_error
        # The review results based on rules.
        self.results = results

    def validate(self):
        if self.results:
            for k in self.results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.occur_error is not None:
            result['OccurError'] = self.occur_error
        result['Results'] = []
        if self.results is not None:
            for k in self.results:
                result['Results'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OccurError') is not None:
            self.occur_error = m.get('OccurError')
        self.results = []
        if m.get('Results') is not None:
            for k in m.get('Results'):
                temp_model = GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults()
                self.results.append(temp_model.from_map(k))
        return self


class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        instance_id: int = None,
        quality_result: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult = None,
        query_key: str = None,
        sql_type: str = None,
    ):
        # The ID of the database.
        self.db_id = db_id
        # The ID of the instance to which the database belongs.
        self.instance_id = instance_id
        # The quality of the SQL statement.
        self.quality_result = quality_result
        # The key that is used to query the details of optimization suggestions.
        self.query_key = query_key
        # The type of the SQL statement. Valid values: DELETE, UPDATE, and ALTER_TABLE.
        self.sql_type = sql_type

    def validate(self):
        if self.quality_result:
            self.quality_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.quality_result is not None:
            result['QualityResult'] = self.quality_result.to_map()
        if self.query_key is not None:
            result['QueryKey'] = self.query_key
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('QualityResult') is not None:
            temp_model = GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult()
            self.quality_result = temp_model.from_map(m['QualityResult'])
        if m.get('QueryKey') is not None:
            self.query_key = m.get('QueryKey')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        return self


class GetSQLReviewOptimizeDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        optimize_detail: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The details of optimization suggestions for SQL statements.
        self.optimize_detail = optimize_detail
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.optimize_detail:
            self.optimize_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.optimize_detail is not None:
            result['OptimizeDetail'] = self.optimize_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OptimizeDetail') is not None:
            temp_model = GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail()
            self.optimize_detail = temp_model.from_map(m['OptimizeDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSQLReviewOptimizeDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSQLReviewOptimizeDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSQLReviewOptimizeDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStandardGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.group_id = group_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStandardGroupResponseBodyStandardGroup(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        description: str = None,
        group_id: int = None,
        group_mode: str = None,
        group_name: str = None,
        last_mender_id: int = None,
    ):
        self.db_type = db_type
        self.description = description
        self.group_id = group_id
        self.group_mode = group_mode
        self.group_name = group_name
        self.last_mender_id = last_mender_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.last_mender_id is not None:
            result['LastMenderId'] = self.last_mender_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LastMenderId') is not None:
            self.last_mender_id = m.get('LastMenderId')
        return self


class GetStandardGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        standard_group: GetStandardGroupResponseBodyStandardGroup = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.standard_group = standard_group
        self.success = success

    def validate(self):
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StandardGroup') is not None:
            temp_model = GetStandardGroupResponseBodyStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStandardGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStandardGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStandardGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStructSyncExecSqlDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail(TeaModel):
    def __init__(
        self,
        exec_sql: str = None,
        total_sql_count: int = None,
    ):
        # The SQL statements that are executed.
        self.exec_sql = exec_sql
        # The total number of SQL statements.
        self.total_sql_count = total_sql_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exec_sql is not None:
            result['ExecSql'] = self.exec_sql
        if self.total_sql_count is not None:
            result['TotalSqlCount'] = self.total_sql_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExecSql') is not None:
            self.exec_sql = m.get('ExecSql')
        if m.get('TotalSqlCount') is not None:
            self.total_sql_count = m.get('TotalSqlCount')
        return self


class GetStructSyncExecSqlDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        struct_sync_exec_sql_detail: GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The details of the SQL statements.
        self.struct_sync_exec_sql_detail = struct_sync_exec_sql_detail
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.struct_sync_exec_sql_detail:
            self.struct_sync_exec_sql_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.struct_sync_exec_sql_detail is not None:
            result['StructSyncExecSqlDetail'] = self.struct_sync_exec_sql_detail.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StructSyncExecSqlDetail') is not None:
            temp_model = GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail()
            self.struct_sync_exec_sql_detail = temp_model.from_map(m['StructSyncExecSqlDetail'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStructSyncExecSqlDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStructSyncExecSqlDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStructSyncExecSqlDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStructSyncJobAnalyzeResultRequest(TeaModel):
    def __init__(
        self,
        compare_type: str = None,
        order_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The type of the comparison. Valid values:
        # 
        # *   **CREATE_TABLE**: compares the created tables.
        # *   **ALTER_TABLE**: compares the modified tables.
        # *   **EQUAL_TABLE**: compares the identical tables.
        # *   **PASS_TABLE**: compares the tables that are skipped during schema synchronization.
        # *   **NOT_COMPARE**: does not compare tables.
        self.compare_type = compare_type
        # The ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.compare_type is not None:
            result['CompareType'] = self.compare_type
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CompareType') is not None:
            self.compare_type = m.get('CompareType')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList(TeaModel):
    def __init__(
        self,
        script: str = None,
        source_table_name: str = None,
        target_table_name: str = None,
    ):
        # The SQL script.
        self.script = script
        # The name of the source table.
        self.source_table_name = source_table_name
        # The name of the destination table.
        self.target_table_name = target_table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.script is not None:
            result['Script'] = self.script
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        if self.target_table_name is not None:
            result['TargetTableName'] = self.target_table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Script') is not None:
            self.script = m.get('Script')
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        if m.get('TargetTableName') is not None:
            self.target_table_name = m.get('TargetTableName')
        return self


class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList(TeaModel):
    def __init__(
        self,
        compare_type: str = None,
        count: int = None,
    ):
        # The type of the comparison. Valid values:
        # 
        # *   **CREATE_TABLE**: compares the created tables.
        # *   **ALTER_TABLE**: compares the modified tables.
        # *   **EQUAL_TABLE**: compares the identical tables.
        # *   **PASS_TABLE**: compares the tables that are skipped during schema synchronization.
        # *   **NOT_COMPARE**: does not compare tables.
        self.compare_type = compare_type
        # The number of tables.
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.compare_type is not None:
            result['CompareType'] = self.compare_type
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CompareType') is not None:
            self.compare_type = m.get('CompareType')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult(TeaModel):
    def __init__(
        self,
        result_list: List[GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList] = None,
        summary_list: List[GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList] = None,
    ):
        # The details of the analysis results.
        self.result_list = result_list
        # The statistics on the analysis results.
        self.summary_list = summary_list

    def validate(self):
        if self.result_list:
            for k in self.result_list:
                if k:
                    k.validate()
        if self.summary_list:
            for k in self.summary_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ResultList'] = []
        if self.result_list is not None:
            for k in self.result_list:
                result['ResultList'].append(k.to_map() if k else None)
        result['SummaryList'] = []
        if self.summary_list is not None:
            for k in self.summary_list:
                result['SummaryList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.result_list = []
        if m.get('ResultList') is not None:
            for k in m.get('ResultList'):
                temp_model = GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList()
                self.result_list.append(temp_model.from_map(k))
        self.summary_list = []
        if m.get('SummaryList') is not None:
            for k in m.get('SummaryList'):
                temp_model = GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList()
                self.summary_list.append(temp_model.from_map(k))
        return self


class GetStructSyncJobAnalyzeResultResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        struct_sync_job_analyze_result: GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The analysis result of the schema synchronization task.
        self.struct_sync_job_analyze_result = struct_sync_job_analyze_result
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.struct_sync_job_analyze_result:
            self.struct_sync_job_analyze_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.struct_sync_job_analyze_result is not None:
            result['StructSyncJobAnalyzeResult'] = self.struct_sync_job_analyze_result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StructSyncJobAnalyzeResult') is not None:
            temp_model = GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult()
            self.struct_sync_job_analyze_result = temp_model.from_map(m['StructSyncJobAnalyzeResult'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStructSyncJobAnalyzeResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStructSyncJobAnalyzeResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStructSyncJobAnalyzeResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStructSyncJobDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The tenant ID.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStructSyncJobDetailResponseBodyStructSyncJobDetail(TeaModel):
    def __init__(
        self,
        dbtask_group_id: int = None,
        execute_count: int = None,
        job_status: str = None,
        message: str = None,
        security_rule: str = None,
        sql_count: int = None,
        table_analyzed: int = None,
        table_count: int = None,
    ):
        # The ID of the SQL task group.
        self.dbtask_group_id = dbtask_group_id
        # The number of SQL statements that have been executed.
        self.execute_count = execute_count
        # The status of the task. Valid values:
        # 
        # *   **NEW**: The task was created.
        # *   **COMPARING**: The schemas of tables were being compared.
        # *   **COMPARE_BREAK**: The schema comparison was interrupted.
        # *   **COMPARE_FINISH**: The comparison was finished.
        # *   **NOT_SCRIPTS**: The comparison was finished but no executable script was available.
        # *   **SUBMITED_DBTASK**: The task was submitted.
        # *   **DBTASK_SUCCESS**: The task was complete.
        # *   **SUBMITED_WORKFLOW**: The ticket was submitted.
        # *   **WORKFLOW_SUCCESS**: The ticket was approved.
        self.job_status = job_status
        # The description of the task.
        self.message = message
        # The type of security rule. Valid values:
        # 
        # *   **CANNOT_SYNC**: Synchronization cannot be performed.
        # *   **WITH_APPROVE**: The schema synchronization can be performed after the ticket is approved. You can call the [SubmitStructSyncOrderApproval](https://help.aliyun.com/document_detail/206166.html) operation to submit the ticket for approval.
        # *   **WITHOUT_APPROVE**: The schema synchronization can be performed without approval.
        self.security_rule = security_rule
        # The total number of SQL statements.
        self.sql_count = sql_count
        # The number of tables that have been analyzed.
        self.table_analyzed = table_analyzed
        # The total number of tables.
        self.table_count = table_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.execute_count is not None:
            result['ExecuteCount'] = self.execute_count
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.message is not None:
            result['Message'] = self.message
        if self.security_rule is not None:
            result['SecurityRule'] = self.security_rule
        if self.sql_count is not None:
            result['SqlCount'] = self.sql_count
        if self.table_analyzed is not None:
            result['TableAnalyzed'] = self.table_analyzed
        if self.table_count is not None:
            result['TableCount'] = self.table_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('ExecuteCount') is not None:
            self.execute_count = m.get('ExecuteCount')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('SecurityRule') is not None:
            self.security_rule = m.get('SecurityRule')
        if m.get('SqlCount') is not None:
            self.sql_count = m.get('SqlCount')
        if m.get('TableAnalyzed') is not None:
            self.table_analyzed = m.get('TableAnalyzed')
        if m.get('TableCount') is not None:
            self.table_count = m.get('TableCount')
        return self


class GetStructSyncJobDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        struct_sync_job_detail: GetStructSyncJobDetailResponseBodyStructSyncJobDetail = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # The details of the schema synchronization task.
        self.struct_sync_job_detail = struct_sync_job_detail
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.struct_sync_job_detail:
            self.struct_sync_job_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.struct_sync_job_detail is not None:
            result['StructSyncJobDetail'] = self.struct_sync_job_detail.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StructSyncJobDetail') is not None:
            temp_model = GetStructSyncJobDetailResponseBodyStructSyncJobDetail()
            self.struct_sync_job_detail = temp_model.from_map(m['StructSyncJobDetail'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStructSyncJobDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStructSyncJobDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStructSyncJobDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStructSyncOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        search_name: str = None,
    ):
        # The ID of the source database.
        self.db_id = db_id
        # The type of the database engine.
        self.db_type = db_type
        # The type of the environment to which the database instance belongs. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
        self.env_type = env_type
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database
        self.logic = logic
        # The name that is used to search for the database.
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo(TeaModel):
    def __init__(
        self,
        version_id: str = None,
    ):
        # The version number.
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList(TeaModel):
    def __init__(
        self,
        source_table_name: str = None,
        target_table_name: str = None,
    ):
        # The name of the table whose schema you want to synchronize.
        self.source_table_name = source_table_name
        # The name of the table to which you want to synchronize the schema of a table.
        self.target_table_name = target_table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        if self.target_table_name is not None:
            result['TargetTableName'] = self.target_table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        if m.get('TargetTableName') is not None:
            self.target_table_name = m.get('TargetTableName')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        search_name: str = None,
    ):
        # The ID of the destination database.
        self.db_id = db_id
        # The type of the database engine.
        self.db_type = db_type
        # The type of the environment to which the database instance belongs. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
        self.env_type = env_type
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database
        self.logic = logic
        # The name that is used to search for the database.
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo(TeaModel):
    def __init__(
        self,
        version_id: str = None,
    ):
        # The version number.
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail(TeaModel):
    def __init__(
        self,
        ignore_error: bool = None,
        source_database_info: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo = None,
        source_type: str = None,
        source_version_info: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo = None,
        table_info_list: List[GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList] = None,
        target_database_info: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo = None,
        target_type: str = None,
        target_version_info: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo = None,
    ):
        # Indicates whether to skip errors. Valid values:
        # 
        # *   **true**: skips the error and continues to execute SQL statements.
        # *   **false**: stops executing SQL statements.
        self.ignore_error = ignore_error
        # The information about the source database.
        self.source_database_info = source_database_info
        # The schema version of the source database. Valid values:
        # 
        # *   **DATASOURCE**: the default latest version of the system
        # *   **VERSION**: a previous schema version that you manually specify
        self.source_type = source_type
        # The version information about the source instance.
        # 
        # > This parameter is displayed only when the value of the **SourceType** parameter is **VERSION**.
        self.source_version_info = source_version_info
        # The information about the table whose schema you want to synchronize.
        self.table_info_list = table_info_list
        # The information about the destination database.
        self.target_database_info = target_database_info
        # The schema version of the destination database. Valid values:
        # 
        # *   **DATASOURCE**: the default latest version of the system
        # *   **VERSION**: a previous schema version that you manually specify
        self.target_type = target_type
        # The version information about the destination instance.
        # 
        # > This parameter is displayed only when the value of the **SourceType** parameter is **VERSION**.
        self.target_version_info = target_version_info

    def validate(self):
        if self.source_database_info:
            self.source_database_info.validate()
        if self.source_version_info:
            self.source_version_info.validate()
        if self.table_info_list:
            for k in self.table_info_list:
                if k:
                    k.validate()
        if self.target_database_info:
            self.target_database_info.validate()
        if self.target_version_info:
            self.target_version_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_error is not None:
            result['IgnoreError'] = self.ignore_error
        if self.source_database_info is not None:
            result['SourceDatabaseInfo'] = self.source_database_info.to_map()
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.source_version_info is not None:
            result['SourceVersionInfo'] = self.source_version_info.to_map()
        result['TableInfoList'] = []
        if self.table_info_list is not None:
            for k in self.table_info_list:
                result['TableInfoList'].append(k.to_map() if k else None)
        if self.target_database_info is not None:
            result['TargetDatabaseInfo'] = self.target_database_info.to_map()
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.target_version_info is not None:
            result['TargetVersionInfo'] = self.target_version_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IgnoreError') is not None:
            self.ignore_error = m.get('IgnoreError')
        if m.get('SourceDatabaseInfo') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo()
            self.source_database_info = temp_model.from_map(m['SourceDatabaseInfo'])
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('SourceVersionInfo') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo()
            self.source_version_info = temp_model.from_map(m['SourceVersionInfo'])
        self.table_info_list = []
        if m.get('TableInfoList') is not None:
            for k in m.get('TableInfoList'):
                temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList()
                self.table_info_list.append(temp_model.from_map(k))
        if m.get('TargetDatabaseInfo') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo()
            self.target_database_info = temp_model.from_map(m['TargetDatabaseInfo'])
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TargetVersionInfo') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo()
            self.target_version_info = temp_model.from_map(m['TargetVersionInfo'])
        return self


class GetStructSyncOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        struct_sync_order_detail: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The details of the schema synchronization ticket.
        self.struct_sync_order_detail = struct_sync_order_detail
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.struct_sync_order_detail:
            self.struct_sync_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.struct_sync_order_detail is not None:
            result['StructSyncOrderDetail'] = self.struct_sync_order_detail.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StructSyncOrderDetail') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail()
            self.struct_sync_order_detail = temp_model.from_map(m['StructSyncOrderDetail'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStructSyncOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStructSyncOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStructSyncOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTableDBTopologyRequest(TeaModel):
    def __init__(
        self,
        table_guid: str = None,
        tid: int = None,
    ):
        # The GUID of the table in DMS.
        # 
        # > 
        # 
        # *   If the database to which the table belongs is a logical database, you can call the [ListLogicTables](https://help.aliyun.com/document_detail/141875.html) operation to obtain the GUID. The value of the ReturnGuid parameter must be set to true.
        # 
        # *   If the database to which the table belongs is a physical database, you can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to obtain the GUID. The value of the ReturnGuid parameter must be set to true.
        # 
        # This parameter is required.
        self.table_guid = table_guid
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList(TeaModel):
    def __init__(
        self,
        table_id: str = None,
        table_name: str = None,
        table_type: str = None,
    ):
        # The ID of the table.
        self.table_id = table_id
        # The name of the physical table.
        self.table_name = table_name
        # The type of the table. This is a reserved parameter.
        self.table_type = table_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_type is not None:
            result['TableType'] = self.table_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableType') is not None:
            self.table_type = m.get('TableType')
        return self


class GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        db_name: str = None,
        db_type: str = None,
        env_type: str = None,
        table_list: List[GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList] = None,
    ):
        # The ID of the database.
        self.db_id = db_id
        # The name of the database.
        self.db_name = db_name
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        self.db_type = db_type
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: pre-release environment
        # *   **test**: test environment
        # *   **sit**: system integration testing (SIT) environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: staging environment
        # 
        # > For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
        self.env_type = env_type
        # The physical tables.
        self.table_list = table_list

    def validate(self):
        if self.table_list:
            for k in self.table_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        result['TableList'] = []
        if self.table_list is not None:
            for k in self.table_list:
                result['TableList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        self.table_list = []
        if m.get('TableList') is not None:
            for k in m.get('TableList'):
                temp_model = GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList()
                self.table_list.append(temp_model.from_map(k))
        return self


class GetTableDBTopologyResponseBodyDBTopologyDataSourceList(TeaModel):
    def __init__(
        self,
        database_list: List[GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList] = None,
        db_type: str = None,
        host: str = None,
        port: int = None,
        sid: str = None,
    ):
        # The physical databases.
        self.database_list = database_list
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        self.db_type = db_type
        # The endpoint of the data source.
        self.host = host
        # The port that is used to connect to the data source.
        self.port = port
        # The system ID (SID) of the data source.
        self.sid = sid

    def validate(self):
        if self.database_list:
            for k in self.database_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DatabaseList'] = []
        if self.database_list is not None:
            for k in self.database_list:
                result['DatabaseList'].append(k.to_map() if k else None)
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        if self.sid is not None:
            result['Sid'] = self.sid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.database_list = []
        if m.get('DatabaseList') is not None:
            for k in m.get('DatabaseList'):
                temp_model = GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList()
                self.database_list.append(temp_model.from_map(k))
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        return self


class GetTableDBTopologyResponseBodyDBTopology(TeaModel):
    def __init__(
        self,
        data_source_list: List[GetTableDBTopologyResponseBodyDBTopologyDataSourceList] = None,
        table_guid: str = None,
        table_name: str = None,
    ):
        # The data sources.
        self.data_source_list = data_source_list
        # The GUID of the table in DMS.
        self.table_guid = table_guid
        # The name of the table.
        # 
        # > 
        # 
        # *   If a logical table is queried, the name of the logical table is returned.
        # 
        # *   If a physical table is queried, the name of the physical table is returned.
        self.table_name = table_name

    def validate(self):
        if self.data_source_list:
            for k in self.data_source_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataSourceList'] = []
        if self.data_source_list is not None:
            for k in self.data_source_list:
                result['DataSourceList'].append(k.to_map() if k else None)
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_source_list = []
        if m.get('DataSourceList') is not None:
            for k in m.get('DataSourceList'):
                temp_model = GetTableDBTopologyResponseBodyDBTopologyDataSourceList()
                self.data_source_list.append(temp_model.from_map(k))
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetTableDBTopologyResponseBody(TeaModel):
    def __init__(
        self,
        dbtopology: GetTableDBTopologyResponseBodyDBTopology = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The topology of the data table.
        self.dbtopology = dbtopology
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.dbtopology:
            self.dbtopology.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtopology is not None:
            result['DBTopology'] = self.dbtopology.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBTopology') is not None:
            temp_model = GetTableDBTopologyResponseBodyDBTopology()
            self.dbtopology = temp_model.from_map(m['DBTopology'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTableDBTopologyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTableDBTopologyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTableDBTopologyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTableDesignProjectFlowRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the schema design ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The tenant ID.
        # 
        # >  To view the tenant ID, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTableDesignProjectFlowResponseBodyProjectFlowFlowNodeArray(TeaModel):
    def __init__(
        self,
        back_to_design: bool = None,
        can_skip: bool = None,
        node_role: str = None,
        node_title: str = None,
        position: int = None,
        publish_anchor: bool = None,
        publish_strategies: List[str] = None,
    ):
        # Indicates whether the ticket can be returned to the schema design node. Valid values:
        # 
        # *   **1**: The ticket can be returned to the schema design node.
        # *   **0**: The ticket cannot be returned to the schema design node. This value can be returned only for the PUBLISH node.
        self.back_to_design = back_to_design
        # Indicates whether the current node can be skipped. Valid values:
        # 
        # *   **1**: The current node can be skipped.
        # *   **0**: The current node cannot be skipped. This value can be returned only for the PUBLISH node.
        self.can_skip = can_skip
        # The role of the node in the process.
        # 
        # *   START: The ticket was created.
        # *   DESIGN: The schema is being created.
        # *   PUBLISH: The schema is published.
        # *   END: The ticket is complete.
        self.node_role = node_role
        # The title of the node.
        self.node_title = node_title
        # The position of the node in the process. The value starts from 1.
        self.position = position
        # Indicates whether the node is the anchor node. A schema design process has only one anchor node, on which the schema is published. After the schema is published on the anchor node, a post-publish image is generated and the DDL metadata lock is released.
        self.publish_anchor = publish_anchor
        # The available publishing strategies.
        self.publish_strategies = publish_strategies

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.back_to_design is not None:
            result['BackToDesign'] = self.back_to_design
        if self.can_skip is not None:
            result['CanSkip'] = self.can_skip
        if self.node_role is not None:
            result['NodeRole'] = self.node_role
        if self.node_title is not None:
            result['NodeTitle'] = self.node_title
        if self.position is not None:
            result['Position'] = self.position
        if self.publish_anchor is not None:
            result['PublishAnchor'] = self.publish_anchor
        if self.publish_strategies is not None:
            result['PublishStrategies'] = self.publish_strategies
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackToDesign') is not None:
            self.back_to_design = m.get('BackToDesign')
        if m.get('CanSkip') is not None:
            self.can_skip = m.get('CanSkip')
        if m.get('NodeRole') is not None:
            self.node_role = m.get('NodeRole')
        if m.get('NodeTitle') is not None:
            self.node_title = m.get('NodeTitle')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('PublishAnchor') is not None:
            self.publish_anchor = m.get('PublishAnchor')
        if m.get('PublishStrategies') is not None:
            self.publish_strategies = m.get('PublishStrategies')
        return self


class GetTableDesignProjectFlowResponseBodyProjectFlow(TeaModel):
    def __init__(
        self,
        current_position: int = None,
        flow_node_array: List[GetTableDesignProjectFlowResponseBodyProjectFlowFlowNodeArray] = None,
        rule_comment: str = None,
        rule_name: str = None,
    ):
        # The position of the current node in the process.
        self.current_position = current_position
        # The nodes in the process.
        self.flow_node_array = flow_node_array
        # The description of the security rule set that is applied to the schema design ticket.
        self.rule_comment = rule_comment
        # The name of the security rule set that is applied to the schema design ticket.
        self.rule_name = rule_name

    def validate(self):
        if self.flow_node_array:
            for k in self.flow_node_array:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_position is not None:
            result['CurrentPosition'] = self.current_position
        result['FlowNodeArray'] = []
        if self.flow_node_array is not None:
            for k in self.flow_node_array:
                result['FlowNodeArray'].append(k.to_map() if k else None)
        if self.rule_comment is not None:
            result['RuleComment'] = self.rule_comment
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPosition') is not None:
            self.current_position = m.get('CurrentPosition')
        self.flow_node_array = []
        if m.get('FlowNodeArray') is not None:
            for k in m.get('FlowNodeArray'):
                temp_model = GetTableDesignProjectFlowResponseBodyProjectFlowFlowNodeArray()
                self.flow_node_array.append(temp_model.from_map(k))
        if m.get('RuleComment') is not None:
            self.rule_comment = m.get('RuleComment')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class GetTableDesignProjectFlowResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        project_flow: GetTableDesignProjectFlowResponseBodyProjectFlow = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The information about the schema design process.
        self.project_flow = project_flow
        # The request ID. You can use the request ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.project_flow:
            self.project_flow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.project_flow is not None:
            result['ProjectFlow'] = self.project_flow.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProjectFlow') is not None:
            temp_model = GetTableDesignProjectFlowResponseBodyProjectFlow()
            self.project_flow = temp_model.from_map(m['ProjectFlow'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTableDesignProjectFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTableDesignProjectFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTableDesignProjectFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTableDesignProjectInfoRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the schema design ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/465867.html) operation to obtain the ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The tenant ID.
        # 
        # >  To view the tenant ID, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTableDesignProjectInfoResponseBodyProjectInfoBaseDatabase(TeaModel):
    def __init__(
        self,
        alias: str = None,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        schema_name: str = None,
        search_name: str = None,
    ):
        # The alias of the database instance.
        self.alias = alias
        # The database ID.
        self.db_id = db_id
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        self.db_type = db_type
        # The type of the environment in which the database instance is deployed. Valid values:
        # 
        # *   **product**: production environment.
        # *   **dev**: development environment.
        # *   **pre**: pre-release environment.
        # *   **test**: test environment.
        # *   **sit**: system integration testing (SIT) environment.
        # *   **uat**: user acceptance testing (UAT) environment.
        # *   **pet**: stress testing environment.
        # *   **stag**: staging environment.
        self.env_type = env_type
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.logic = logic
        # The database name.
        self.schema_name = schema_name
        # The name that is used to search for the database.
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetTableDesignProjectInfoResponseBodyProjectInfo(TeaModel):
    def __init__(
        self,
        base_database: GetTableDesignProjectInfoResponseBodyProjectInfoBaseDatabase = None,
        creator_id: int = None,
        description: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        order_id: int = None,
        project_id: int = None,
        status: str = None,
        title: str = None,
    ):
        # The information about the change base database of the schema design ticket.
        self.base_database = base_database
        # The ID of the user who created the ticket.
        self.creator_id = creator_id
        # The description of the schema design project.
        self.description = description
        # The time when the ticket was created.
        self.gmt_create = gmt_create
        # The time when the ticket was last modified.
        self.gmt_modified = gmt_modified
        # The ticket ID.
        self.order_id = order_id
        # The project ID.
        self.project_id = project_id
        # The state of the schema design project. Valid values:
        # 
        # *   **DESIGN**: The schema is being designed.
        # *   **PUBLISHED**: The schema is published.
        # *   **CLOSE**: The ticket is closed.
        self.status = status
        # The name of the schema design project.
        self.title = title

    def validate(self):
        if self.base_database:
            self.base_database.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_database is not None:
            result['BaseDatabase'] = self.base_database.to_map()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BaseDatabase') is not None:
            temp_model = GetTableDesignProjectInfoResponseBodyProjectInfoBaseDatabase()
            self.base_database = temp_model.from_map(m['BaseDatabase'])
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetTableDesignProjectInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        project_info: GetTableDesignProjectInfoResponseBodyProjectInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The information about the schema design project.
        self.project_info = project_info
        # The request ID. You can use the request ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.project_info:
            self.project_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.project_info is not None:
            result['ProjectInfo'] = self.project_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProjectInfo') is not None:
            temp_model = GetTableDesignProjectInfoResponseBodyProjectInfo()
            self.project_info = temp_model.from_map(m['ProjectInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTableDesignProjectInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTableDesignProjectInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTableDesignProjectInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTableKnowledgeInfoRequest(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        table_name: str = None,
        table_schema_name: str = None,
    ):
        # This parameter is required.
        self.db_id = db_id
        # This parameter is required.
        self.table_name = table_name
        self.table_schema_name = table_schema_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_schema_name is not None:
            result['TableSchemaName'] = self.table_schema_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableSchemaName') is not None:
            self.table_schema_name = m.get('TableSchemaName')
        return self


class GetTableKnowledgeInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        table: TableKnowledgeInfo = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.table = table

    def validate(self):
        if self.table:
            self.table.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.table is not None:
            result['Table'] = self.table.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Table') is not None:
            temp_model = TableKnowledgeInfo()
            self.table = temp_model.from_map(m['Table'])
        return self


class GetTableKnowledgeInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTableKnowledgeInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTableKnowledgeInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTableTopologyRequest(TeaModel):
    def __init__(
        self,
        table_guid: str = None,
        tid: int = None,
    ):
        # The GUID of the table in Data Management (DMS).
        # 
        # > 
        # > - You can call the [ListLogicTables](https://help.aliyun.com/document_detail/141875.html) operation with ReturnGuid set to true to query the GUIDs of logical tables in a specific logical database.
        # > - You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation with ReturnGuid set to true to query the GUIDs of tables in a specific physical database.
        # 
        # This parameter is required.
        self.table_guid = table_guid
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Tenant information](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_name: str = None,
        db_search_name: str = None,
        db_type: str = None,
        instance_id: int = None,
        instance_resource_id: str = None,
        instance_source: str = None,
        region_id: str = None,
        table_count: int = None,
        table_name_expr: str = None,
        table_name_list: str = None,
    ):
        # The ID of the physical database.
        self.db_id = db_id
        # The name of the database.
        self.db_name = db_name
        # The name that is used to search for the database.
        # > We recommend that you do not use this parameter for business development. The format of the parameter value may be modified in later versions.
        self.db_search_name = db_search_name
        # The database engine.
        self.db_type = db_type
        # The ID of the instance to which the physical database belongs.
        self.instance_id = instance_id
        # The ID of the resource related to the instance. The resource corresponds with the database instance type returned in the InstanceSource parameter.
        # 
        # *   **RDS**:The ID of the ApsaraDB RDS instance.
        # *   **ECS_OWN**: The ID of the Elastic Compute Service (ECS) instance.
        # *   **PUBLIC_OWN**: This parameter is left empty for self-managed database instances that are connected over the Internet.
        # *   **VPC_ID**:The ID of the virtual private cloud (VPC).
        # *   **GATEWAY**: The ID of the database gateway.
        self.instance_resource_id = instance_resource_id
        # The type of the database instance. Valid values:
        # 
        # *   **RDS**: an ApsaraDB RDS instance.
        # *   **ECS_OWN**: a self-managed database that is deployed on an ECS instance
        # *   **PUBLIC_OWN**: a self-managed database instance that is connected over the Internet.
        # *   **VPC_ID**: a self-managed database instance in a VPC that is connected over Express Connect circuits.
        # *   **GATEWAY**: a database instance connected by using a database gateway.
        self.instance_source = instance_source
        # The region ID of the instance.
        self.region_id = region_id
        # The number of tables.
        self.table_count = table_count
        # The expression of the names of logical tables.
        # 
        # **\
        # 
        # **Description** This parameter is not returned for physical tables.
        self.table_name_expr = table_name_expr
        # The names of tables.
        # 
        # > The table names are separated by commas (,).
        self.table_name_list = table_name_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.db_search_name is not None:
            result['DbSearchName'] = self.db_search_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_resource_id is not None:
            result['InstanceResourceId'] = self.instance_resource_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.table_count is not None:
            result['TableCount'] = self.table_count
        if self.table_name_expr is not None:
            result['TableNameExpr'] = self.table_name_expr
        if self.table_name_list is not None:
            result['TableNameList'] = self.table_name_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DbSearchName') is not None:
            self.db_search_name = m.get('DbSearchName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceResourceId') is not None:
            self.instance_resource_id = m.get('InstanceResourceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TableCount') is not None:
            self.table_count = m.get('TableCount')
        if m.get('TableNameExpr') is not None:
            self.table_name_expr = m.get('TableNameExpr')
        if m.get('TableNameList') is not None:
            self.table_name_list = m.get('TableNameList')
        return self


class GetTableTopologyResponseBodyTableTopology(TeaModel):
    def __init__(
        self,
        logic: bool = None,
        table_guid: str = None,
        table_name: str = None,
        table_topology_info_list: List[GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList] = None,
    ):
        # Indicates whether the table is a logical table. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.logic = logic
        # The GUID of the table in DMS.
        self.table_guid = table_guid
        # The name of the table.
        self.table_name = table_name
        # Information of the topology of the table.
        self.table_topology_info_list = table_topology_info_list

    def validate(self):
        if self.table_topology_info_list:
            for k in self.table_topology_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_name is not None:
            result['TableName'] = self.table_name
        result['TableTopologyInfoList'] = []
        if self.table_topology_info_list is not None:
            for k in self.table_topology_info_list:
                result['TableTopologyInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        self.table_topology_info_list = []
        if m.get('TableTopologyInfoList') is not None:
            for k in m.get('TableTopologyInfoList'):
                temp_model = GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList()
                self.table_topology_info_list.append(temp_model.from_map(k))
        return self


class GetTableTopologyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        table_topology: GetTableTopologyResponseBodyTableTopology = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success
        # The topology information.
        self.table_topology = table_topology

    def validate(self):
        if self.table_topology:
            self.table_topology.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.table_topology is not None:
            result['TableTopology'] = self.table_topology.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TableTopology') is not None:
            temp_model = GetTableTopologyResponseBodyTableTopology()
            self.table_topology = temp_model.from_map(m['TableTopology'])
        return self


class GetTableTopologyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTableTopologyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTableTopologyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskRequest(TeaModel):
    def __init__(
        self,
        node_id: int = None,
        tid: int = None,
    ):
        # The ID of the task node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
        # 
        # This parameter is required.
        self.node_id = node_id
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTaskResponseBodyTask(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        graph_param: str = None,
        node_config: str = None,
        node_content: str = None,
        node_name: str = None,
        node_output: str = None,
        node_type: str = None,
        time_variables: str = None,
    ):
        # The ID of the task flow to which the node belongs.
        self.dag_id = dag_id
        # The position of the node on the Directed Acyclic Graph (DAG).
        self.graph_param = graph_param
        # The advanced configuration for the node.
        self.node_config = node_config
        # The configuration for the node.
        self.node_content = node_content
        # The name of the node.
        self.node_name = node_name
        # The output variables for the node. This parameter is available only for some types of nodes.
        self.node_output = node_output
        # The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](https://help.aliyun.com/document_detail/424705.html).
        self.node_type = node_type
        # The time variables configured for the node.
        self.time_variables = time_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.graph_param is not None:
            result['GraphParam'] = self.graph_param
        if self.node_config is not None:
            result['NodeConfig'] = self.node_config
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_output is not None:
            result['NodeOutput'] = self.node_output
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('GraphParam') is not None:
            self.graph_param = m.get('GraphParam')
        if m.get('NodeConfig') is not None:
            self.node_config = m.get('NodeConfig')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeOutput') is not None:
            self.node_output = m.get('NodeOutput')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class GetTaskResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        task: GetTaskResponseBodyTask = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The task node.
        self.task = task

    def validate(self):
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task is not None:
            result['Task'] = self.task.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Task') is not None:
            temp_model = GetTaskResponseBodyTask()
            self.task = temp_model.from_map(m['Task'])
        return self


class GetTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskFlowGraphRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        id: int = None,
        node_end: int = None,
        node_from: int = None,
    ):
        # The ID of the task flow.
        self.dag_id = dag_id
        # The ID of the task flow edge.
        self.id = id
        # The ID of the end node on the edge.
        self.node_end = node_end
        # The ID of the start node on the edge.
        self.node_from = node_from

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraphEdges(TeaModel):
    def __init__(
        self,
        edge: List[GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge] = None,
    ):
        self.edge = edge

    def validate(self):
        if self.edge:
            for k in self.edge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Edge'] = []
        if self.edge is not None:
            for k in self.edge:
                result['Edge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.edge = []
        if m.get('Edge') is not None:
            for k in m.get('Edge'):
                temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge()
                self.edge.append(temp_model.from_map(k))
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        graph_param: str = None,
        node_config: str = None,
        node_content: str = None,
        node_id: int = None,
        node_name: str = None,
        node_type: int = None,
        time_variables: str = None,
    ):
        # The ID of the task flow.
        self.dag_id = dag_id
        # The position of the node in the DAG.
        self.graph_param = graph_param
        # The advanced configuration of the node.
        self.node_config = node_config
        # The configuration of the node.
        self.node_content = node_content
        # The ID of the node.
        self.node_id = node_id
        # The name of the node.
        self.node_name = node_name
        # The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](https://help.aliyun.com/document_detail/424705.html).
        self.node_type = node_type
        # The time variables for the node.
        self.time_variables = time_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.graph_param is not None:
            result['GraphParam'] = self.graph_param
        if self.node_config is not None:
            result['NodeConfig'] = self.node_config
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('GraphParam') is not None:
            self.graph_param = m.get('GraphParam')
        if m.get('NodeConfig') is not None:
            self.node_config = m.get('NodeConfig')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraphNodes(TeaModel):
    def __init__(
        self,
        node: List[GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode] = None,
    ):
        self.node = node

    def validate(self):
        if self.node:
            for k in self.node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Node'] = []
        if self.node is not None:
            for k in self.node:
                result['Node'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node = []
        if m.get('Node') is not None:
            for k in m.get('Node'):
                temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode()
                self.node.append(temp_model.from_map(k))
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraph(TeaModel):
    def __init__(
        self,
        can_edit: bool = None,
        dag_name: str = None,
        edges: GetTaskFlowGraphResponseBodyTaskFlowGraphEdges = None,
        nodes: GetTaskFlowGraphResponseBodyTaskFlowGraphNodes = None,
        status: int = None,
    ):
        # Indicates whether the task flow is editable. Valid values:
        # 
        # - **true**: editable
        # - **false**: non-editable
        self.can_edit = can_edit
        # The name of the task flow.
        self.dag_name = dag_name
        # The list of task flow edges.
        self.edges = edges
        # The node list of the task flow.
        self.nodes = nodes
        # The status of the task flow. Valid values:
        # 
        # - **0**: invalid
        # - **1**: not scheduled
        # - **2**: to be scheduled
        self.status = status

    def validate(self):
        if self.edges:
            self.edges.validate()
        if self.nodes:
            self.nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_edit is not None:
            result['CanEdit'] = self.can_edit
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.edges is not None:
            result['Edges'] = self.edges.to_map()
        if self.nodes is not None:
            result['Nodes'] = self.nodes.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanEdit') is not None:
            self.can_edit = m.get('CanEdit')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('Edges') is not None:
            temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraphEdges()
            self.edges = temp_model.from_map(m['Edges'])
        if m.get('Nodes') is not None:
            temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraphNodes()
            self.nodes = temp_model.from_map(m['Nodes'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetTaskFlowGraphResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        task_flow_graph: GetTaskFlowGraphResponseBodyTaskFlowGraph = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The list of DAG variables of the task flow.
        self.task_flow_graph = task_flow_graph

    def validate(self):
        if self.task_flow_graph:
            self.task_flow_graph.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_flow_graph is not None:
            result['TaskFlowGraph'] = self.task_flow_graph.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskFlowGraph') is not None:
            temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraph()
            self.task_flow_graph = temp_model.from_map(m['TaskFlowGraph'])
        return self


class GetTaskFlowGraphResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskFlowGraphResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskFlowGraphResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskFlowNotificationRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTaskFlowNotificationResponseBodyNotification(TeaModel):
    def __init__(
        self,
        dag_notification_fail: bool = None,
        dag_notification_sla: bool = None,
        dag_notification_success: bool = None,
    ):
        # Indicates whether notifications for failed task flows are enabled. Valid values:
        # 
        # *   **true**: enabled
        # *   **false**: disabled
        self.dag_notification_fail = dag_notification_fail
        # Indicates whether service level agreement (SLA) global notifications for task flows are enabled. Valid values:
        # 
        # *   **true**: enabled
        # *   **false**: disabled
        self.dag_notification_sla = dag_notification_sla
        # Indicates whether notifications for successful task flows are enabled. Valid values:
        # 
        # *   **true**: enabled
        # *   **false**: disabled
        self.dag_notification_success = dag_notification_success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_notification_fail is not None:
            result['DagNotificationFail'] = self.dag_notification_fail
        if self.dag_notification_sla is not None:
            result['DagNotificationSla'] = self.dag_notification_sla
        if self.dag_notification_success is not None:
            result['DagNotificationSuccess'] = self.dag_notification_success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagNotificationFail') is not None:
            self.dag_notification_fail = m.get('DagNotificationFail')
        if m.get('DagNotificationSla') is not None:
            self.dag_notification_sla = m.get('DagNotificationSla')
        if m.get('DagNotificationSuccess') is not None:
            self.dag_notification_success = m.get('DagNotificationSuccess')
        return self


class GetTaskFlowNotificationResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        notification: GetTaskFlowNotificationResponseBodyNotification = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The notification settings specified by the user.
        self.notification = notification
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.notification:
            self.notification.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.notification is not None:
            result['Notification'] = self.notification.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Notification') is not None:
            temp_model = GetTaskFlowNotificationResponseBodyNotification()
            self.notification = temp_model.from_map(m['Notification'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTaskFlowNotificationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskFlowNotificationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskFlowNotificationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskInstanceRelationRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_instance_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the ID of the task flow.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to obtain the execution record ID.
        # 
        # This parameter is required.
        self.dag_instance_id = dag_instance_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTaskInstanceRelationResponseBodyNodeListNode(TeaModel):
    def __init__(
        self,
        business_time: str = None,
        end_time: str = None,
        execute_time: int = None,
        id: int = None,
        message: str = None,
        node_id: int = None,
        node_name: str = None,
        node_type: int = None,
        status: int = None,
    ):
        # The business time of the node.
        self.business_time = business_time
        # The time when the execution of the task flow was complete. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.end_time = end_time
        # The amount of time consumed for running the node. Unit: milliseconds.
        self.execute_time = execute_time
        # The ID of the execution record of the task flow.
        self.id = id
        # The description of the task.
        self.message = message
        # The ID of the node.
        self.node_id = node_id
        # The name of the node.
        self.node_name = node_name
        # The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](https://help.aliyun.com/document_detail/424705.html).
        self.node_type = node_type
        # The status of the node. Valid values:
        # 
        # *   **0**: The node is waiting to be scheduled.
        # *   **1**: The node is running.
        # *   **2**: The node is suspended.
        # *   **3**: The node failed to run.
        # *   **4**: The node is run.
        # *   **5**: The node is complete.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_time is not None:
            result['BusinessTime'] = self.business_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.execute_time is not None:
            result['ExecuteTime'] = self.execute_time
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessTime') is not None:
            self.business_time = m.get('BusinessTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecuteTime') is not None:
            self.execute_time = m.get('ExecuteTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetTaskInstanceRelationResponseBodyNodeList(TeaModel):
    def __init__(
        self,
        node: List[GetTaskInstanceRelationResponseBodyNodeListNode] = None,
    ):
        self.node = node

    def validate(self):
        if self.node:
            for k in self.node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Node'] = []
        if self.node is not None:
            for k in self.node:
                result['Node'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node = []
        if m.get('Node') is not None:
            for k in m.get('Node'):
                temp_model = GetTaskInstanceRelationResponseBodyNodeListNode()
                self.node.append(temp_model.from_map(k))
        return self


class GetTaskInstanceRelationResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        node_list: GetTaskInstanceRelationResponseBodyNodeList = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The information about the nodes in the execution record of the task flow.
        self.node_list = node_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        if self.node_list:
            self.node_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.node_list is not None:
            result['NodeList'] = self.node_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NodeList') is not None:
            temp_model = GetTaskInstanceRelationResponseBodyNodeList()
            self.node_list = temp_model.from_map(m['NodeList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTaskInstanceRelationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskInstanceRelationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskInstanceRelationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
        uid: str = None,
        user_id: str = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
        self.tid = tid
        # The UID of the Alibaba Cloud account. You can view your UID by moving the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console.
        self.uid = uid
        # The ID of the user. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) operation to query the ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetUserResponseBodyUserRoleIdList(TeaModel):
    def __init__(
        self,
        role_ids: List[int] = None,
    ):
        self.role_ids = role_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_ids is not None:
            result['RoleIds'] = self.role_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoleIds') is not None:
            self.role_ids = m.get('RoleIds')
        return self


class GetUserResponseBodyUserRoleNameList(TeaModel):
    def __init__(
        self,
        role_names: List[str] = None,
    ):
        self.role_names = role_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_names is not None:
            result['RoleNames'] = self.role_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoleNames') is not None:
            self.role_names = m.get('RoleNames')
        return self


class GetUserResponseBodyUser(TeaModel):
    def __init__(
        self,
        cur_execute_count: int = None,
        cur_result_count: int = None,
        ding_robot: str = None,
        email: str = None,
        last_login_time: str = None,
        max_execute_count: int = None,
        max_result_count: int = None,
        mobile: str = None,
        nick_name: str = None,
        notification_mode: str = None,
        parent_uid: int = None,
        role_id_list: GetUserResponseBodyUserRoleIdList = None,
        role_name_list: GetUserResponseBodyUserRoleNameList = None,
        signature_method: str = None,
        state: str = None,
        uid: str = None,
        user_id: str = None,
        webhook: str = None,
    ):
        # The number of queries that are performed on the current day.
        self.cur_execute_count = cur_execute_count
        # The number of rows that are queried on the current day.
        self.cur_result_count = cur_result_count
        # The DingTalk chatbot URL that is used to receive notifications.
        # 
        # > 
        # 
        # *   The system returns this parameter if the user has set a DingTalk chatbot URL in the console. To set a DingTalk chatbot URL in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # 
        # *   The system does not return this parameter if the user has not set a DingTalk chatbot URL.
        self.ding_robot = ding_robot
        # The email address that is used to receive notifications.
        # 
        # > 
        # 
        # *   The system returns this parameter if the user has set an email address in the console. To set an email address in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # 
        # *   The system does not return this parameter if the user has not set an email address.
        self.email = email
        # The last point in time when the user logged on to the console.
        self.last_login_time = last_login_time
        # The maximum number of queries that can be performed on the current day.
        self.max_execute_count = max_execute_count
        # The maximum number of rows that can be queried on the current day.
        self.max_result_count = max_result_count
        # The mobile number of the user.
        # 
        # > 
        # 
        # *   The system returns this parameter if the user has set a mobile phone number in the console. To set a mobile phone number in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # 
        # *   The system does not return this parameter if the user has not set a mobile phone number.
        self.mobile = mobile
        # The nickname of the user.
        self.nick_name = nick_name
        # The notification method. The system returns one or more values. Valid values:
        # 
        # *   **SMS**: text message
        # *   **EMAIL**: email.
        # *   **DINGDING**: DingTalk.
        # *   **DINGROBOT**: DingTalk chatbot.
        # *   **WEBHOOK**: webhook.
        self.notification_mode = notification_mode
        # The UID of the Alibaba Cloud account of the user.
        # 
        # > An Alibaba Cloud account can contain one or more RAM users.
        self.parent_uid = parent_uid
        # The list of role IDs.
        self.role_id_list = role_id_list
        # The list of role names.
        self.role_name_list = role_name_list
        # The signature method that is used to secure connections when a webhook URL is used. Valid values:
        # 
        # *   **NONE**: no signature.
        # *   **HMAC_SHA1**: HMAC_SHA1.
        self.signature_method = signature_method
        # The status of the user. Valid values:
        # 
        # *   **NORMAL**: The user is normal.
        # *   **DISABLE**: The user is disabled.
        # *   **DELETE**: The user is deleted.
        self.state = state
        # The UID of the user.
        self.uid = uid
        # The ID of the user.
        self.user_id = user_id
        # The webhook URL that is used to receive notifications.
        # 
        # > 
        # 
        # *   If the user has set a webhook URL, DMS sends notifications to the specified URL.
        # 
        # *   The system does not return this parameter if the user has not set a webhook URL.
        self.webhook = webhook

    def validate(self):
        if self.role_id_list:
            self.role_id_list.validate()
        if self.role_name_list:
            self.role_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cur_execute_count is not None:
            result['CurExecuteCount'] = self.cur_execute_count
        if self.cur_result_count is not None:
            result['CurResultCount'] = self.cur_result_count
        if self.ding_robot is not None:
            result['DingRobot'] = self.ding_robot
        if self.email is not None:
            result['Email'] = self.email
        if self.last_login_time is not None:
            result['LastLoginTime'] = self.last_login_time
        if self.max_execute_count is not None:
            result['MaxExecuteCount'] = self.max_execute_count
        if self.max_result_count is not None:
            result['MaxResultCount'] = self.max_result_count
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.notification_mode is not None:
            result['NotificationMode'] = self.notification_mode
        if self.parent_uid is not None:
            result['ParentUid'] = self.parent_uid
        if self.role_id_list is not None:
            result['RoleIdList'] = self.role_id_list.to_map()
        if self.role_name_list is not None:
            result['RoleNameList'] = self.role_name_list.to_map()
        if self.signature_method is not None:
            result['SignatureMethod'] = self.signature_method
        if self.state is not None:
            result['State'] = self.state
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurExecuteCount') is not None:
            self.cur_execute_count = m.get('CurExecuteCount')
        if m.get('CurResultCount') is not None:
            self.cur_result_count = m.get('CurResultCount')
        if m.get('DingRobot') is not None:
            self.ding_robot = m.get('DingRobot')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('LastLoginTime') is not None:
            self.last_login_time = m.get('LastLoginTime')
        if m.get('MaxExecuteCount') is not None:
            self.max_execute_count = m.get('MaxExecuteCount')
        if m.get('MaxResultCount') is not None:
            self.max_result_count = m.get('MaxResultCount')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('NotificationMode') is not None:
            self.notification_mode = m.get('NotificationMode')
        if m.get('ParentUid') is not None:
            self.parent_uid = m.get('ParentUid')
        if m.get('RoleIdList') is not None:
            temp_model = GetUserResponseBodyUserRoleIdList()
            self.role_id_list = temp_model.from_map(m['RoleIdList'])
        if m.get('RoleNameList') is not None:
            temp_model = GetUserResponseBodyUserRoleNameList()
            self.role_name_list = temp_model.from_map(m['RoleNameList'])
        if m.get('SignatureMethod') is not None:
            self.signature_method = m.get('SignatureMethod')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class GetUserResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        user: GetUserResponseBodyUser = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request fails.
        self.success = success
        # The information about the user.
        self.user = user

    def validate(self):
        if self.user:
            self.user.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.user is not None:
            result['User'] = self.user.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('User') is not None:
            temp_model = GetUserResponseBodyUser()
            self.user = temp_model.from_map(m['User'])
        return self


class GetUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserActiveTenantRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetUserActiveTenantResponseBodyTenant(TeaModel):
    def __init__(
        self,
        status: str = None,
        tenant_name: str = None,
        tid: int = None,
    ):
        # The status of the tenant. Valid values:
        # 
        # *   **ACTIVE**: The tenant is used to access DMS.
        # *   **IN_ACTIVE**: The tenant is not used.
        self.status = status
        # The name of the tenant.
        self.tenant_name = tenant_name
        # The ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetUserActiveTenantResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tenant: GetUserActiveTenantResponseBodyTenant = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success
        # The details of the tenant.
        self.tenant = tenant

    def validate(self):
        if self.tenant:
            self.tenant.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tenant is not None:
            result['Tenant'] = self.tenant.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tenant') is not None:
            temp_model = GetUserActiveTenantResponseBodyTenant()
            self.tenant = temp_model.from_map(m['Tenant'])
        return self


class GetUserActiveTenantResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUserActiveTenantResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserActiveTenantResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserUploadFileJobRequest(TeaModel):
    def __init__(
        self,
        job_key: str = None,
        tid: int = None,
    ):
        # The key of the file upload task. The key is returned when you call the [CreateUploadFileJob](https://help.aliyun.com/document_detail/206059.html) or [CreateUploadOSSFileJob](https://help.aliyun.com/document_detail/206060.html) operation.
        # 
        # This parameter is required.
        self.job_key = job_key
        # The tenant ID.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_key is not None:
            result['JobKey'] = self.job_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobKey') is not None:
            self.job_key = m.get('JobKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        endpoint: str = None,
        object_name: str = None,
    ):
        # The name of the OSS bucket.
        self.bucket_name = bucket_name
        # The endpoint of the OSS bucket.
        self.endpoint = endpoint
        # The name of the OSS object.
        self.object_name = object_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.object_name is not None:
            result['ObjectName'] = self.object_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('ObjectName') is not None:
            self.object_name = m.get('ObjectName')
        return self


class GetUserUploadFileJobResponseBodyUploadFileJobDetail(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        file_name: str = None,
        file_size: int = None,
        file_source: str = None,
        job_key: str = None,
        job_status: str = None,
        job_status_desc: str = None,
        upload_ossparam: GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam = None,
        upload_type: str = None,
        upload_url: str = None,
        uploaded_size: int = None,
    ):
        # The key of the file that is returned after the file is uploaded. You can use this key when you upload the file as an attachment in a ticket.
        self.attachment_key = attachment_key
        # The name of the file.
        self.file_name = file_name
        # The size of the file. Unit: byte.
        self.file_size = file_size
        # The purpose of the uploaded file. Valid values:
        # 
        # *   **datacorrect**: The file is uploaded to change data.
        # *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
        # *   **big-file**: The file is uploaded to import multiple data records at a time.
        # *   **sqlreview**: The file is uploaded for SQL review.
        self.file_source = file_source
        # The key of the file upload task.
        self.job_key = job_key
        # The status of the file upload task. Valid values:
        # 
        # *   **INIT**: The file upload task was initialized.
        # *   **PENDING**: The file upload task waited to be run.
        # *   **BE_SCHEDULED**: The file upload task waited to be scheduled.
        # *   **FAIL**: The file upload task failed.
        # *   **SUCCESS**: The file upload task was successful.
        # *   **RUNNING**: The file upload task was being run.
        self.job_status = job_status
        # The information about the status of the file upload task.
        self.job_status_desc = job_status_desc
        # The information about the Object Storage Service (OSS) bucket from which the file is uploaded.
        # 
        # > This parameter is returned if the value of **UploadType** is **OSS**.
        self.upload_ossparam = upload_ossparam
        # The method used to upload the file. Valid values:
        # 
        # *   **URL**\
        # *   **OSS**\
        self.upload_type = upload_type
        # The URL of the file.
        # 
        # > This parameter is returned if the value of **UploadType** is **URL**.
        self.upload_url = upload_url
        # The size of the uploaded file. Unit: byte.
        self.uploaded_size = uploaded_size

    def validate(self):
        if self.upload_ossparam:
            self.upload_ossparam.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_source is not None:
            result['FileSource'] = self.file_source
        if self.job_key is not None:
            result['JobKey'] = self.job_key
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.job_status_desc is not None:
            result['JobStatusDesc'] = self.job_status_desc
        if self.upload_ossparam is not None:
            result['UploadOSSParam'] = self.upload_ossparam.to_map()
        if self.upload_type is not None:
            result['UploadType'] = self.upload_type
        if self.upload_url is not None:
            result['UploadURL'] = self.upload_url
        if self.uploaded_size is not None:
            result['UploadedSize'] = self.uploaded_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileSource') is not None:
            self.file_source = m.get('FileSource')
        if m.get('JobKey') is not None:
            self.job_key = m.get('JobKey')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('JobStatusDesc') is not None:
            self.job_status_desc = m.get('JobStatusDesc')
        if m.get('UploadOSSParam') is not None:
            temp_model = GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam()
            self.upload_ossparam = temp_model.from_map(m['UploadOSSParam'])
        if m.get('UploadType') is not None:
            self.upload_type = m.get('UploadType')
        if m.get('UploadURL') is not None:
            self.upload_url = m.get('UploadURL')
        if m.get('UploadedSize') is not None:
            self.uploaded_size = m.get('UploadedSize')
        return self


class GetUserUploadFileJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        upload_file_job_detail: GetUserUploadFileJobResponseBodyUploadFileJobDetail = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success
        # The details of the file upload task.
        self.upload_file_job_detail = upload_file_job_detail

    def validate(self):
        if self.upload_file_job_detail:
            self.upload_file_job_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.upload_file_job_detail is not None:
            result['UploadFileJobDetail'] = self.upload_file_job_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('UploadFileJobDetail') is not None:
            temp_model = GetUserUploadFileJobResponseBodyUploadFileJobDetail()
            self.upload_file_job_detail = temp_model.from_map(m['UploadFileJobDetail'])
        return self


class GetUserUploadFileJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUserUploadFileJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserUploadFileJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GrantTemplateAuthorityRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        expire_date: str = None,
        template_id: int = None,
        tid: int = None,
        user_ids: str = None,
    ):
        # The reason why you want to grant permissions on resources to the users by using the permission template.
        self.comment = comment
        # The time when the permission expires. Specify the time in the yyyy-MM-DD HH:mm:ss format.
        # 
        # This parameter is required.
        self.expire_date = expire_date
        # The ID of the permission template.
        # 
        # This parameter is required.
        self.template_id = template_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid
        # The IDs of users to which you want to grant permissions on resources by using the permission template.
        # 
        # This parameter is required.
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class GrantTemplateAuthorityResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: bool = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the permissions on resources were granted to the users by using the permission template.
        self.result = result
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GrantTemplateAuthorityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GrantTemplateAuthorityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GrantTemplateAuthorityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GrantUserPermissionRequest(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        ds_type: str = None,
        expire_date: str = None,
        instance_id: int = None,
        logic: bool = None,
        perm_types: str = None,
        table_id: str = None,
        table_name: str = None,
        tid: int = None,
        user_id: str = None,
    ):
        # The ID of the database. You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to query the ID of a physical database and the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to query the ID of a logical database.
        # 
        # >  The value of the DatabaseId parameter is that of the DbId parameter.
        self.db_id = db_id
        # The permissions on a specific type of object that you want to grant to the user. Valid values:
        # 
        # *   INSTANCE: permissions on instances
        # *   DATABASE: permissions on physical databases
        # *   LOGIC_DATABASE: permissions on logical databases
        # *   TABLE: permissions on physical tables
        # *   LOGIC_TABLE: permissions on logical tables
        # 
        # This parameter is required.
        self.ds_type = ds_type
        # The time when the permissions expire.
        # 
        # This parameter is required.
        self.expire_date = expire_date
        # The ID of the instance. You must specify this parameter if you grant permissions on an instance to the user. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the ID of the instance.
        self.instance_id = instance_id
        # Specifies whether the database is a logical database. You must specify this parameter if you grant permissions on a database to the user. Valid values:
        # 
        # *   true: The database is a logical database.
        # *   false: The database is a physical database.
        self.logic = logic
        # The permission type. Separate multiple permission types with commas (,). Valid values:
        # 
        # *   **QUERY**: the query permissions
        # *   **EXPORT**: the export permissions
        # *   **CORRECT**: the change permissions
        # *   **LOGIN**: the logon permissions
        # *   **PERF**: the query permissions on the performance details of the instance
        # 
        # This parameter is required.
        self.perm_types = perm_types
        # The ID of the table. You must specify this parameter if you grant permissions on a table to the user. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to query the table ID.
        self.table_id = table_id
        # The name of the table. You must specify this parameter if you grant permissions on a table to the user.
        self.table_name = table_name
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid
        # The ID of the user. You can call the [GetUser](https://help.aliyun.com/document_detail/147098.html) or [ListUsers](https://help.aliyun.com/document_detail/141938.html) operation to query the ID of the user.
        # 
        # >  The user ID is different from the ID of your Alibaba Cloud account.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.perm_types is not None:
            result['PermTypes'] = self.perm_types
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermTypes') is not None:
            self.perm_types = m.get('PermTypes')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GrantUserPermissionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GrantUserPermissionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GrantUserPermissionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GrantUserPermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InspectProxyAccessSecretRequest(TeaModel):
    def __init__(
        self,
        proxy_access_id: int = None,
        tid: int = None,
    ):
        # The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique. You can call the [ListProxyAccesses](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxyaccesses) operation to obtain this parameter.
        # 
        # This parameter is required.
        self.proxy_access_id = proxy_access_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class InspectProxyAccessSecretResponseBody(TeaModel):
    def __init__(
        self,
        access_secret: str = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The authorization password of the security protection agent.
        self.access_secret = access_secret
        # The error code returned to the query task.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_secret is not None:
            result['AccessSecret'] = self.access_secret
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessSecret') is not None:
            self.access_secret = m.get('AccessSecret')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InspectProxyAccessSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InspectProxyAccessSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InspectProxyAccessSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAbacAuthorizationsRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        policy_id: str = None,
        policy_source: str = None,
        tid: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.policy_id = policy_id
        self.policy_source = policy_source
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_source is not None:
            result['PolicySource'] = self.policy_source
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicySource') is not None:
            self.policy_source = m.get('PolicySource')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListAbacAuthorizationsResponseBodyAuthorizationList(TeaModel):
    def __init__(
        self,
        authorization_id: int = None,
        identity_id: int = None,
        identity_name: str = None,
        identity_type: str = None,
        policy_id: int = None,
        policy_name: str = None,
        policy_source: str = None,
    ):
        self.authorization_id = authorization_id
        self.identity_id = identity_id
        self.identity_name = identity_name
        self.identity_type = identity_type
        self.policy_id = policy_id
        self.policy_name = policy_name
        self.policy_source = policy_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorization_id is not None:
            result['AuthorizationId'] = self.authorization_id
        if self.identity_id is not None:
            result['IdentityId'] = self.identity_id
        if self.identity_name is not None:
            result['IdentityName'] = self.identity_name
        if self.identity_type is not None:
            result['IdentityType'] = self.identity_type
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.policy_source is not None:
            result['PolicySource'] = self.policy_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorizationId') is not None:
            self.authorization_id = m.get('AuthorizationId')
        if m.get('IdentityId') is not None:
            self.identity_id = m.get('IdentityId')
        if m.get('IdentityName') is not None:
            self.identity_name = m.get('IdentityName')
        if m.get('IdentityType') is not None:
            self.identity_type = m.get('IdentityType')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('PolicySource') is not None:
            self.policy_source = m.get('PolicySource')
        return self


class ListAbacAuthorizationsResponseBody(TeaModel):
    def __init__(
        self,
        authorization_list: List[ListAbacAuthorizationsResponseBodyAuthorizationList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.authorization_list = authorization_list
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.authorization_list:
            for k in self.authorization_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuthorizationList'] = []
        if self.authorization_list is not None:
            for k in self.authorization_list:
                result['AuthorizationList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.authorization_list = []
        if m.get('AuthorizationList') is not None:
            for k in m.get('AuthorizationList'):
                temp_model = ListAbacAuthorizationsResponseBodyAuthorizationList()
                self.authorization_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAbacAuthorizationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAbacAuthorizationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAbacAuthorizationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAbacPoliciesRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        search_key: str = None,
        tid: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.search_key = search_key
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListAbacPoliciesResponseBodyPolicyList(TeaModel):
    def __init__(
        self,
        abac_policy_content: str = None,
        abac_policy_desc: str = None,
        abac_policy_id: int = None,
        abac_policy_name: str = None,
        abac_policy_source: str = None,
        creator_id: int = None,
    ):
        self.abac_policy_content = abac_policy_content
        self.abac_policy_desc = abac_policy_desc
        self.abac_policy_id = abac_policy_id
        self.abac_policy_name = abac_policy_name
        self.abac_policy_source = abac_policy_source
        self.creator_id = creator_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abac_policy_content is not None:
            result['AbacPolicyContent'] = self.abac_policy_content
        if self.abac_policy_desc is not None:
            result['AbacPolicyDesc'] = self.abac_policy_desc
        if self.abac_policy_id is not None:
            result['AbacPolicyId'] = self.abac_policy_id
        if self.abac_policy_name is not None:
            result['AbacPolicyName'] = self.abac_policy_name
        if self.abac_policy_source is not None:
            result['AbacPolicySource'] = self.abac_policy_source
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbacPolicyContent') is not None:
            self.abac_policy_content = m.get('AbacPolicyContent')
        if m.get('AbacPolicyDesc') is not None:
            self.abac_policy_desc = m.get('AbacPolicyDesc')
        if m.get('AbacPolicyId') is not None:
            self.abac_policy_id = m.get('AbacPolicyId')
        if m.get('AbacPolicyName') is not None:
            self.abac_policy_name = m.get('AbacPolicyName')
        if m.get('AbacPolicySource') is not None:
            self.abac_policy_source = m.get('AbacPolicySource')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        return self


class ListAbacPoliciesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        policy_list: List[ListAbacPoliciesResponseBodyPolicyList] = None,
        request_id: str = None,
        success: bool = None,
        tid: int = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.policy_list = policy_list
        self.request_id = request_id
        self.success = success
        self.tid = tid
        self.total_count = total_count

    def validate(self):
        if self.policy_list:
            for k in self.policy_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['PolicyList'] = []
        if self.policy_list is not None:
            for k in self.policy_list:
                result['PolicyList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.policy_list = []
        if m.get('PolicyList') is not None:
            for k in m.get('PolicyList'):
                temp_model = ListAbacPoliciesResponseBodyPolicyList()
                self.policy_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAbacPoliciesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAbacPoliciesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAbacPoliciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAuthorityTemplateRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        search_key: str = None,
        tid: int = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.search_key = search_key
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        creator_id: int = None,
        description: str = None,
        name: str = None,
        template_id: int = None,
    ):
        self.create_time = create_time
        self.creator_id = creator_id
        self.description = description
        self.name = name
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ListAuthorityTemplateResponseBodyAuthorityTemplateViewList(TeaModel):
    def __init__(
        self,
        authority_template_view: List[ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView] = None,
    ):
        self.authority_template_view = authority_template_view

    def validate(self):
        if self.authority_template_view:
            for k in self.authority_template_view:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuthorityTemplateView'] = []
        if self.authority_template_view is not None:
            for k in self.authority_template_view:
                result['AuthorityTemplateView'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.authority_template_view = []
        if m.get('AuthorityTemplateView') is not None:
            for k in m.get('AuthorityTemplateView'):
                temp_model = ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView()
                self.authority_template_view.append(temp_model.from_map(k))
        return self


class ListAuthorityTemplateResponseBody(TeaModel):
    def __init__(
        self,
        authority_template_view_list: ListAuthorityTemplateResponseBodyAuthorityTemplateViewList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tid: int = None,
        total_count: int = None,
    ):
        self.authority_template_view_list = authority_template_view_list
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.tid = tid
        self.total_count = total_count

    def validate(self):
        if self.authority_template_view_list:
            self.authority_template_view_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authority_template_view_list is not None:
            result['AuthorityTemplateViewList'] = self.authority_template_view_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorityTemplateViewList') is not None:
            temp_model = ListAuthorityTemplateResponseBodyAuthorityTemplateViewList()
            self.authority_template_view_list = temp_model.from_map(m['AuthorityTemplateViewList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAuthorityTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAuthorityTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAuthorityTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAuthorizedDatabasesForUserRequest(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        page_number: str = None,
        page_size: str = None,
        search_key: str = None,
        tid: int = None,
        user_id: str = None,
    ):
        self.db_type = db_type
        self.env_type = env_type
        self.logic = logic
        self.page_number = page_number
        self.page_size = page_size
        self.search_key = search_key
        self.tid = tid
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListAuthorizedDatabasesForUserResponseBodyDatabasesPermissionDetail(TeaModel):
    def __init__(
        self,
        ds_type: str = None,
        expire_date: str = None,
        message: str = None,
        perm_type: str = None,
    ):
        self.ds_type = ds_type
        self.expire_date = expire_date
        self.message = message
        self.perm_type = perm_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.message is not None:
            result['Message'] = self.message
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        return self


class ListAuthorizedDatabasesForUserResponseBodyDatabases(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        db_type: str = None,
        env_type: str = None,
        instance_id: str = None,
        logic: bool = None,
        permission_detail: ListAuthorizedDatabasesForUserResponseBodyDatabasesPermissionDetail = None,
        schema_name: str = None,
        search_name: str = None,
        user_id: str = None,
    ):
        self.db_id = db_id
        self.db_type = db_type
        self.env_type = env_type
        self.instance_id = instance_id
        self.logic = logic
        self.permission_detail = permission_detail
        self.schema_name = schema_name
        self.search_name = search_name
        self.user_id = user_id

    def validate(self):
        if self.permission_detail:
            self.permission_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.permission_detail is not None:
            result['PermissionDetail'] = self.permission_detail.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermissionDetail') is not None:
            temp_model = ListAuthorizedDatabasesForUserResponseBodyDatabasesPermissionDetail()
            self.permission_detail = temp_model.from_map(m['PermissionDetail'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListAuthorizedDatabasesForUserResponseBody(TeaModel):
    def __init__(
        self,
        databases: List[ListAuthorizedDatabasesForUserResponseBodyDatabases] = None,
        request_id: str = None,
    ):
        self.databases = databases
        self.request_id = request_id

    def validate(self):
        if self.databases:
            for k in self.databases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Databases'] = []
        if self.databases is not None:
            for k in self.databases:
                result['Databases'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.databases = []
        if m.get('Databases') is not None:
            for k in m.get('Databases'):
                temp_model = ListAuthorizedDatabasesForUserResponseBodyDatabases()
                self.databases.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAuthorizedDatabasesForUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAuthorizedDatabasesForUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAuthorizedDatabasesForUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAuthorizedInstancesForUserRequest(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        env_type: str = None,
        page_number: str = None,
        page_size: str = None,
        search_key: str = None,
        tid: int = None,
        user_id: str = None,
    ):
        self.db_type = db_type
        self.env_type = env_type
        self.page_number = page_number
        self.page_size = page_size
        self.search_key = search_key
        self.tid = tid
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListAuthorizedInstancesForUserResponseBodyInstancesPermissionDetail(TeaModel):
    def __init__(
        self,
        ds_type: str = None,
        expire_date: str = None,
        message: str = None,
        perm_type: str = None,
    ):
        self.ds_type = ds_type
        self.expire_date = expire_date
        self.message = message
        self.perm_type = perm_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.message is not None:
            result['Message'] = self.message
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        return self


class ListAuthorizedInstancesForUserResponseBodyInstances(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        env_type: str = None,
        host: str = None,
        instance_alias: str = None,
        instance_id: str = None,
        permission_detail: ListAuthorizedInstancesForUserResponseBodyInstancesPermissionDetail = None,
        port: str = None,
        user_id: str = None,
        user_name: str = None,
    ):
        self.db_type = db_type
        self.env_type = env_type
        self.host = host
        self.instance_alias = instance_alias
        self.instance_id = instance_id
        self.permission_detail = permission_detail
        self.port = port
        self.user_id = user_id
        self.user_name = user_name

    def validate(self):
        if self.permission_detail:
            self.permission_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.permission_detail is not None:
            result['PermissionDetail'] = self.permission_detail.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PermissionDetail') is not None:
            temp_model = ListAuthorizedInstancesForUserResponseBodyInstancesPermissionDetail()
            self.permission_detail = temp_model.from_map(m['PermissionDetail'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListAuthorizedInstancesForUserResponseBody(TeaModel):
    def __init__(
        self,
        instances: List[ListAuthorizedInstancesForUserResponseBodyInstances] = None,
        request_id: str = None,
    ):
        self.instances = instances
        self.request_id = request_id

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = ListAuthorizedInstancesForUserResponseBodyInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAuthorizedInstancesForUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAuthorizedInstancesForUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAuthorizedInstancesForUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAuthorizedUsersForDatabaseRequest(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        logic: bool = None,
        page_number: str = None,
        page_size: str = None,
        search_key: str = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.db_id = db_id
        self.logic = logic
        self.page_number = page_number
        self.page_size = page_size
        self.search_key = search_key
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListAuthorizedUsersForDatabaseResponseBodyUsers(TeaModel):
    def __init__(
        self,
        uid: str = None,
        user_id: str = None,
        user_nick_name: str = None,
    ):
        self.uid = uid
        self.user_id = user_id
        self.user_nick_name = user_nick_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick_name is not None:
            result['UserNickName'] = self.user_nick_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNickName') is not None:
            self.user_nick_name = m.get('UserNickName')
        return self


class ListAuthorizedUsersForDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        users: List[ListAuthorizedUsersForDatabaseResponseBodyUsers] = None,
    ):
        self.request_id = request_id
        self.users = users

    def validate(self):
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Users'] = []
        if self.users is not None:
            for k in self.users:
                result['Users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.users = []
        if m.get('Users') is not None:
            for k in m.get('Users'):
                temp_model = ListAuthorizedUsersForDatabaseResponseBodyUsers()
                self.users.append(temp_model.from_map(k))
        return self


class ListAuthorizedUsersForDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAuthorizedUsersForDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAuthorizedUsersForDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAuthorizedUsersForInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: str = None,
        page_size: str = None,
        search_key: str = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.instance_id = instance_id
        self.page_number = page_number
        self.page_size = page_size
        self.search_key = search_key
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListAuthorizedUsersForInstanceResponseBodyUsers(TeaModel):
    def __init__(
        self,
        uid: str = None,
        user_id: str = None,
        user_nick_name: str = None,
        user_real_name: str = None,
    ):
        self.uid = uid
        self.user_id = user_id
        self.user_nick_name = user_nick_name
        self.user_real_name = user_real_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick_name is not None:
            result['UserNickName'] = self.user_nick_name
        if self.user_real_name is not None:
            result['UserRealName'] = self.user_real_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNickName') is not None:
            self.user_nick_name = m.get('UserNickName')
        if m.get('UserRealName') is not None:
            self.user_real_name = m.get('UserRealName')
        return self


class ListAuthorizedUsersForInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        users: List[ListAuthorizedUsersForInstanceResponseBodyUsers] = None,
    ):
        self.request_id = request_id
        self.users = users

    def validate(self):
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Users'] = []
        if self.users is not None:
            for k in self.users:
                result['Users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.users = []
        if m.get('Users') is not None:
            for k in m.get('Users'):
                temp_model = ListAuthorizedUsersForInstanceResponseBodyUsers()
                self.users.append(temp_model.from_map(k))
        return self


class ListAuthorizedUsersForInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAuthorizedUsersForInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAuthorizedUsersForInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClassificationTemplatesRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListClassificationTemplatesResponseBodyTemplateList(TeaModel):
    def __init__(
        self,
        name: str = None,
        remark: str = None,
        template_id: int = None,
        template_type: str = None,
    ):
        # The name of the classification template.
        self.name = name
        # The remarks.
        self.remark = remark
        # The ID of the classification template.
        self.template_id = template_id
        # The type of the classification template. Valid values:
        # 
        # *   **INNER**: built-in template
        # *   **USER_DEFINE**: custom template
        self.template_type = template_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class ListClassificationTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        template_list: List[ListClassificationTemplatesResponseBodyTemplateList] = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The list of templates.
        self.template_list = template_list

    def validate(self):
        if self.template_list:
            for k in self.template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TemplateList'] = []
        if self.template_list is not None:
            for k in self.template_list:
                result['TemplateList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.template_list = []
        if m.get('TemplateList') is not None:
            for k in m.get('TemplateList'):
                temp_model = ListClassificationTemplatesResponseBodyTemplateList()
                self.template_list.append(temp_model.from_map(k))
        return self


class ListClassificationTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListClassificationTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClassificationTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListColumnsRequest(TeaModel):
    def __init__(
        self,
        logic: bool = None,
        table_id: str = None,
        tid: int = None,
    ):
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic
        # The ID of the table. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to obtain the table ID.
        # 
        # This parameter is required.
        self.table_id = table_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListColumnsResponseBodyColumnListColumn(TeaModel):
    def __init__(
        self,
        auto_increment: bool = None,
        column_id: str = None,
        column_name: str = None,
        column_type: str = None,
        data_length: int = None,
        data_precision: int = None,
        data_scale: int = None,
        default_value: str = None,
        description: str = None,
        function_type: str = None,
        nullable: bool = None,
        security_level: str = None,
        sensitive: bool = None,
    ):
        # Indicates whether the column is an auto-increment column. Valid values:
        # 
        # *   true: The column is an auto-increment column.
        # *   false: The column is not an auto-increment column.
        self.auto_increment = auto_increment
        # The ID of the column.
        self.column_id = column_id
        # The name of the column.
        self.column_name = column_name
        # The data type of the column.
        self.column_type = column_type
        # The length of the field.
        self.data_length = data_length
        # The number of valid digits for the field.
        self.data_precision = data_precision
        # The number of decimal places for the field.
        self.data_scale = data_scale
        # The default value of the column.
        self.default_value = default_value
        # The description of the column.
        self.description = description
        # The type of the masking algorithm that is used for the field. Valid values:
        # 
        # *   null: No masking algorithm is used.
        # *   DEFAULT: A full masking algorithm is used.
        # *   FIX_POS: The fixed position is masked.
        # *   FIX_CHAR: The fixed characters are replaced.
        self.function_type = function_type
        # Indicates whether the column can be empty. Valid values:
        # 
        # *   **true**: The column can be empty.
        # *   **false**: The column cannot be empty.
        self.nullable = nullable
        # The security level of the column. Valid values:
        # 
        # *   INNER: The column is an internal column but not sensitive.
        # *   SENSITIVE: The column is a sensitive column.
        # *   CONFIDENTIAL: The column is a confidential column.
        # 
        # > For more information, see [Sensitivity levels of fields](https://help.aliyun.com/document_detail/66091.html).
        self.security_level = security_level
        # Indicates whether the column is a sensitive column. Valid values:
        # 
        # *   **true**: The column is a sensitive column.
        # *   **false**: The column is not a sensitive column.
        self.sensitive = sensitive

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_increment is not None:
            result['AutoIncrement'] = self.auto_increment
        if self.column_id is not None:
            result['ColumnId'] = self.column_id
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.data_length is not None:
            result['DataLength'] = self.data_length
        if self.data_precision is not None:
            result['DataPrecision'] = self.data_precision
        if self.data_scale is not None:
            result['DataScale'] = self.data_scale
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.description is not None:
            result['Description'] = self.description
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.nullable is not None:
            result['Nullable'] = self.nullable
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.sensitive is not None:
            result['Sensitive'] = self.sensitive
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoIncrement') is not None:
            self.auto_increment = m.get('AutoIncrement')
        if m.get('ColumnId') is not None:
            self.column_id = m.get('ColumnId')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DataLength') is not None:
            self.data_length = m.get('DataLength')
        if m.get('DataPrecision') is not None:
            self.data_precision = m.get('DataPrecision')
        if m.get('DataScale') is not None:
            self.data_scale = m.get('DataScale')
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('Nullable') is not None:
            self.nullable = m.get('Nullable')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('Sensitive') is not None:
            self.sensitive = m.get('Sensitive')
        return self


class ListColumnsResponseBodyColumnList(TeaModel):
    def __init__(
        self,
        column: List[ListColumnsResponseBodyColumnListColumn] = None,
    ):
        self.column = column

    def validate(self):
        if self.column:
            for k in self.column:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Column'] = []
        if self.column is not None:
            for k in self.column:
                result['Column'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.column = []
        if m.get('Column') is not None:
            for k in m.get('Column'):
                temp_model = ListColumnsResponseBodyColumnListColumn()
                self.column.append(temp_model.from_map(k))
        return self


class ListColumnsResponseBody(TeaModel):
    def __init__(
        self,
        column_list: ListColumnsResponseBodyColumnList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details about columns.
        self.column_list = column_list
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.column_list:
            self.column_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_list is not None:
            result['ColumnList'] = self.column_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnList') is not None:
            temp_model = ListColumnsResponseBodyColumnList()
            self.column_list = temp_model.from_map(m['ColumnList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListColumnsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListColumnsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListColumnsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDAGVersionsRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        page_index: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the ID of the task flow.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page_index = page_index
        # The number of entries to return on each page.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDAGVersionsResponseBodyDagVersionListDagVersion(TeaModel):
    def __init__(
        self,
        dag_name: str = None,
        dag_owner_id: str = None,
        dag_owner_nick_name: str = None,
        last_version_id: int = None,
        version_comments: str = None,
        version_id: int = None,
    ):
        # The name of the task flow.
        self.dag_name = dag_name
        # The ID of the task flow owner.
        self.dag_owner_id = dag_owner_id
        # The name of the task flow owner.
        self.dag_owner_nick_name = dag_owner_nick_name
        # The ID of the previously published version.
        self.last_version_id = last_version_id
        # The description of the version.
        self.version_comments = version_comments
        # The ID of the version.
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.last_version_id is not None:
            result['LastVersionId'] = self.last_version_id
        if self.version_comments is not None:
            result['VersionComments'] = self.version_comments
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('LastVersionId') is not None:
            self.last_version_id = m.get('LastVersionId')
        if m.get('VersionComments') is not None:
            self.version_comments = m.get('VersionComments')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class ListDAGVersionsResponseBodyDagVersionList(TeaModel):
    def __init__(
        self,
        dag_version: List[ListDAGVersionsResponseBodyDagVersionListDagVersion] = None,
    ):
        self.dag_version = dag_version

    def validate(self):
        if self.dag_version:
            for k in self.dag_version:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DagVersion'] = []
        if self.dag_version is not None:
            for k in self.dag_version:
                result['DagVersion'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dag_version = []
        if m.get('DagVersion') is not None:
            for k in m.get('DagVersion'):
                temp_model = ListDAGVersionsResponseBodyDagVersionListDagVersion()
                self.dag_version.append(temp_model.from_map(k))
        return self


class ListDAGVersionsResponseBody(TeaModel):
    def __init__(
        self,
        dag_version_list: ListDAGVersionsResponseBodyDagVersionList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The information about the published versions.
        self.dag_version_list = dag_version_list
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.dag_version_list:
            self.dag_version_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_version_list is not None:
            result['DagVersionList'] = self.dag_version_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagVersionList') is not None:
            temp_model = ListDAGVersionsResponseBodyDagVersionList()
            self.dag_version_list = temp_model.from_map(m['DagVersionList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDAGVersionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDAGVersionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDAGVersionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDBTaskSQLJobRequest(TeaModel):
    def __init__(
        self,
        dbtask_group_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The ID of the SQL task group. You can call the [GetStructSyncJobDetail](https://help.aliyun.com/document_detail/206160.html) operation to obtain this parameter.
        # 
        # This parameter is required.
        self.dbtask_group_id = dbtask_group_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDBTaskSQLJobResponseBodyDBTaskSQLJobList(TeaModel):
    def __init__(
        self,
        comment: str = None,
        create_time: str = None,
        db_id: int = None,
        db_search_name: str = None,
        db_task_group_id: int = None,
        job_id: int = None,
        job_type: str = None,
        last_exec_time: str = None,
        logic: bool = None,
        status: str = None,
        transactional: bool = None,
    ):
        # The description of the SQL task.
        self.comment = comment
        # The time when the SQL task was created.
        self.create_time = create_time
        # The ID of the database.
        self.db_id = db_id
        # The name that is used to search for the database.
        self.db_search_name = db_search_name
        # The ID of the SQL task group.
        self.db_task_group_id = db_task_group_id
        # The ID of the SQL task.
        self.job_id = job_id
        # The type of the SQL task.
        self.job_type = job_type
        # The time when the SQL task was last executed.
        self.last_exec_time = last_exec_time
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a logical database.
        self.logic = logic
        # The state of the SQL task. Valid values:
        # 
        # *   **INIT**: The SQL task was initialized.
        # *   **PENDING**: The SQL task waited to be run.
        # *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
        # *   **FAIL**: The SQL task failed.
        # *   **SUCCESS**: The SQL task was successful.
        # *   **PAUSE**: The SQL task was paused.
        # *   **DELETE**: The SQL task was deleted.
        # *   **RUNNING**: The SQL task was being run.
        self.status = status
        # Indicates whether the SQL task is executed as a transaction. Valid values:
        # 
        # *   **true**: The SQL task is executed as a transaction.
        # *   **false**: The SQL task is not executed as a transaction.
        self.transactional = transactional

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_search_name is not None:
            result['DbSearchName'] = self.db_search_name
        if self.db_task_group_id is not None:
            result['DbTaskGroupId'] = self.db_task_group_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.last_exec_time is not None:
            result['LastExecTime'] = self.last_exec_time
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.status is not None:
            result['Status'] = self.status
        if self.transactional is not None:
            result['Transactional'] = self.transactional
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbSearchName') is not None:
            self.db_search_name = m.get('DbSearchName')
        if m.get('DbTaskGroupId') is not None:
            self.db_task_group_id = m.get('DbTaskGroupId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('LastExecTime') is not None:
            self.last_exec_time = m.get('LastExecTime')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Transactional') is not None:
            self.transactional = m.get('Transactional')
        return self


class ListDBTaskSQLJobResponseBody(TeaModel):
    def __init__(
        self,
        dbtask_sqljob_list: List[ListDBTaskSQLJobResponseBodyDBTaskSQLJobList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The list of the SQL tasks.
        self.dbtask_sqljob_list = dbtask_sqljob_list
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success
        # The total number of the SQL tasks.
        self.total_count = total_count

    def validate(self):
        if self.dbtask_sqljob_list:
            for k in self.dbtask_sqljob_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DBTaskSQLJobList'] = []
        if self.dbtask_sqljob_list is not None:
            for k in self.dbtask_sqljob_list:
                result['DBTaskSQLJobList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dbtask_sqljob_list = []
        if m.get('DBTaskSQLJobList') is not None:
            for k in m.get('DBTaskSQLJobList'):
                temp_model = ListDBTaskSQLJobResponseBodyDBTaskSQLJobList()
                self.dbtask_sqljob_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDBTaskSQLJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDBTaskSQLJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDBTaskSQLJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDBTaskSQLJobDetailRequest(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The ID of the SQL task. You can call the [ListDBTaskSQLJob](https://help.aliyun.com/document_detail/207049.html) operation to query the SQL task ID.
        # 
        # This parameter is required.
        self.job_id = job_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList(TeaModel):
    def __init__(
        self,
        affect_rows: int = None,
        current_sql: str = None,
        db_id: int = None,
        end_time: str = None,
        execute_count: int = None,
        job_detail_id: int = None,
        job_id: int = None,
        log: str = None,
        logic: bool = None,
        skip: bool = None,
        sql_type: str = None,
        start_time: str = None,
        status: str = None,
        time_delay: int = None,
    ):
        # The number of rows affected by the SQL task.
        self.affect_rows = affect_rows
        # The SQL statement that was executed in the SQL task.
        self.current_sql = current_sql
        # The ID of the physical database.
        self.db_id = db_id
        # The point in time when the SQL task ended.
        self.end_time = end_time
        # The number of times that the SQL statement was executed.
        self.execute_count = execute_count
        # The ID of the details of the SQL task.
        self.job_detail_id = job_detail_id
        # The ID of the SQL task.
        self.job_id = job_id
        # The details of the operational log.
        self.log = log
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic
        # Indicates whether the SQL statement was skipped. Valid values:
        # 
        # *   **true**: The SQL statement was skipped.
        # *   **false**: The SQL statement was not skipped.
        self.skip = skip
        # The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
        self.sql_type = sql_type
        # The point in time when the SQL task started.
        self.start_time = start_time
        # The status of the SQL task. Valid values:
        # 
        # *   **INIT**: The SQL task was initialized.
        # *   **PENDING**: The SQL task waited to be run.
        # *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
        # *   **FAIL**: The SQL task failed.
        # *   **SUCCESS**: The SQL task was successful.
        # *   **PAUSE**: The SQL task was paused.
        # *   **DELETE**: The SQL task was deleted.
        # *   **RUNNING**: The SQL task was being run.
        self.status = status
        # The duration of the SQL task. Unit: milliseconds.
        self.time_delay = time_delay

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.current_sql is not None:
            result['CurrentSql'] = self.current_sql
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.execute_count is not None:
            result['ExecuteCount'] = self.execute_count
        if self.job_detail_id is not None:
            result['JobDetailId'] = self.job_detail_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.log is not None:
            result['Log'] = self.log
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.skip is not None:
            result['Skip'] = self.skip
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.time_delay is not None:
            result['TimeDelay'] = self.time_delay
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('CurrentSql') is not None:
            self.current_sql = m.get('CurrentSql')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecuteCount') is not None:
            self.execute_count = m.get('ExecuteCount')
        if m.get('JobDetailId') is not None:
            self.job_detail_id = m.get('JobDetailId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Log') is not None:
            self.log = m.get('Log')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Skip') is not None:
            self.skip = m.get('Skip')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TimeDelay') is not None:
            self.time_delay = m.get('TimeDelay')
        return self


class ListDBTaskSQLJobDetailResponseBody(TeaModel):
    def __init__(
        self,
        dbtask_sqljob_detail_list: List[ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The details of SQL tasks.
        self.dbtask_sqljob_detail_list = dbtask_sqljob_detail_list
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success
        # The total number of SQL tasks.
        self.total_count = total_count

    def validate(self):
        if self.dbtask_sqljob_detail_list:
            for k in self.dbtask_sqljob_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DBTaskSQLJobDetailList'] = []
        if self.dbtask_sqljob_detail_list is not None:
            for k in self.dbtask_sqljob_detail_list:
                result['DBTaskSQLJobDetailList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dbtask_sqljob_detail_list = []
        if m.get('DBTaskSQLJobDetailList') is not None:
            for k in m.get('DBTaskSQLJobDetailList'):
                temp_model = ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList()
                self.dbtask_sqljob_detail_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDBTaskSQLJobDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDBTaskSQLJobDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDBTaskSQLJobDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDDLPublishRecordsRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket.
        # 
        # > You can create a schema design ticket in the Data Management (DMS) console. For more information, see [Design schemas](https://help.aliyun.com/document_detail/69711.html). You can also call the [CreateOrder](https://help.aliyun.com/document_detail/144649.html) operation to create a schema design ticket and obtain the ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, log on to the DMS console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList(TeaModel):
    def __init__(
        self,
        dbtask_group_id: int = None,
        execute_count: int = None,
        scripts: str = None,
        status_desc: str = None,
        table_name: str = None,
        task_job_status: str = None,
    ):
        # The ID of the SQL task group.
        self.dbtask_group_id = dbtask_group_id
        # The number of SQL statements that are executed.
        self.execute_count = execute_count
        # The script for data changes.
        self.scripts = scripts
        # The description of the state.
        self.status_desc = status_desc
        # The name of the table after the change.
        self.table_name = table_name
        # The state of the publishing task. Valid values:
        # 
        # *   **NONE**: The state of the task is unknown.
        # *   **SUCCESS**: The task is successful.
        # *   **FAIL**: The task fails.
        self.task_job_status = task_job_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.execute_count is not None:
            result['ExecuteCount'] = self.execute_count
        if self.scripts is not None:
            result['Scripts'] = self.scripts
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.task_job_status is not None:
            result['TaskJobStatus'] = self.task_job_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('ExecuteCount') is not None:
            self.execute_count = m.get('ExecuteCount')
        if m.get('Scripts') is not None:
            self.scripts = m.get('Scripts')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TaskJobStatus') is not None:
            self.task_job_status = m.get('TaskJobStatus')
        return self


class ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
        plan_time: str = None,
        publish_job_list: List[ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList] = None,
        publish_strategy: str = None,
        status_desc: str = None,
        task_job_status: str = None,
    ):
        # The ID of the database.
        self.db_id = db_id
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: the database is not a logical database.
        self.logic = logic
        # The time to publish the ticket.
        self.plan_time = plan_time
        # The list of the publishing tasks.
        self.publish_job_list = publish_job_list
        # The publishing policy. Valid values:
        # 
        # *   **IMMEDIATELY**: immediately publishes the ticket.
        # *   **REGULARLY**: publishes the ticket at a scheduled time.
        self.publish_strategy = publish_strategy
        # The description of the state.
        self.status_desc = status_desc
        # The state of the task.
        self.task_job_status = task_job_status

    def validate(self):
        if self.publish_job_list:
            for k in self.publish_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.plan_time is not None:
            result['PlanTime'] = self.plan_time
        result['PublishJobList'] = []
        if self.publish_job_list is not None:
            for k in self.publish_job_list:
                result['PublishJobList'].append(k.to_map() if k else None)
        if self.publish_strategy is not None:
            result['PublishStrategy'] = self.publish_strategy
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.task_job_status is not None:
            result['TaskJobStatus'] = self.task_job_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PlanTime') is not None:
            self.plan_time = m.get('PlanTime')
        self.publish_job_list = []
        if m.get('PublishJobList') is not None:
            for k in m.get('PublishJobList'):
                temp_model = ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList()
                self.publish_job_list.append(temp_model.from_map(k))
        if m.get('PublishStrategy') is not None:
            self.publish_strategy = m.get('PublishStrategy')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('TaskJobStatus') is not None:
            self.task_job_status = m.get('TaskJobStatus')
        return self


class ListDDLPublishRecordsResponseBodyDDLPublishRecordList(TeaModel):
    def __init__(
        self,
        audit_expire_time: str = None,
        audit_status: str = None,
        comment: str = None,
        creator_id: int = None,
        finality: bool = None,
        finality_reason: str = None,
        publish_status: str = None,
        publish_task_info_list: List[ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList] = None,
        risk_level: str = None,
        status_desc: str = None,
        workflow_instance_id: int = None,
    ):
        # The time when the approval expires.
        self.audit_expire_time = audit_expire_time
        # The approval state of the ticket. Valid values:
        # 
        # *   **EXEMPT_PASS**: The ticket passes without approval.
        # *   **TO_AUDIT**: The ticket is pending for approval.
        # *   **CANCEL**: The ticket is canceled.
        # *   **SUCCESS**: The ticket is approved.
        # *   **FAIL**: The ticket fails to pass the approval.
        self.audit_status = audit_status
        # Release remarks.
        self.comment = comment
        # The ID of the user who creates the ticket. You can obtain the user ID by calling the [GetUser](https://help.aliyun.com/document_detail/147098.html) operation and querying the value of the UserId parameter. The value is not the unique ID (UID) of the Alibaba Cloud account.
        self.creator_id = creator_id
        # Indicates whether the approval is terminated. Valid values:
        # 
        # *   **true**: The approval is terminated.
        # *   **false**: The approval is not terminated.
        # 
        # > Multiple reasons can terminate the approval. For example, you withdraw the application or your ticket is not approved before the specified time.
        self.finality = finality
        # The reason for the termination.
        self.finality_reason = finality_reason
        # The publishing state of the ticket. Valid values:
        # 
        # *   **START**: The ticket is created.
        # *   **ANALYZE**: The ticket is under analysis.
        # *   **AUDIT**: The ticket is under approval.
        # *   **DISPATCH**: A task is generated for the ticket.
        # *   **SUCCESS**: The task is successful.
        self.publish_status = publish_status
        # The list of publishing tasks.
        self.publish_task_info_list = publish_task_info_list
        # The risk level of the operation. Valid values:
        # 
        # *   **NONE_RISK**: The operation does not have risks.
        # *   **LOW_RISK**: The operation is at low risk.
        # *   **MIDDLE_RISK**: The operation is at medium risk.
        # *   **HIGH_RISK**: The operation is at high risk.
        self.risk_level = risk_level
        # The description of the publishing state.
        self.status_desc = status_desc
        # The ID of the approval process.
        self.workflow_instance_id = workflow_instance_id

    def validate(self):
        if self.publish_task_info_list:
            for k in self.publish_task_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_expire_time is not None:
            result['AuditExpireTime'] = self.audit_expire_time
        if self.audit_status is not None:
            result['AuditStatus'] = self.audit_status
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.finality is not None:
            result['Finality'] = self.finality
        if self.finality_reason is not None:
            result['FinalityReason'] = self.finality_reason
        if self.publish_status is not None:
            result['PublishStatus'] = self.publish_status
        result['PublishTaskInfoList'] = []
        if self.publish_task_info_list is not None:
            for k in self.publish_task_info_list:
                result['PublishTaskInfoList'].append(k.to_map() if k else None)
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditExpireTime') is not None:
            self.audit_expire_time = m.get('AuditExpireTime')
        if m.get('AuditStatus') is not None:
            self.audit_status = m.get('AuditStatus')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Finality') is not None:
            self.finality = m.get('Finality')
        if m.get('FinalityReason') is not None:
            self.finality_reason = m.get('FinalityReason')
        if m.get('PublishStatus') is not None:
            self.publish_status = m.get('PublishStatus')
        self.publish_task_info_list = []
        if m.get('PublishTaskInfoList') is not None:
            for k in m.get('PublishTaskInfoList'):
                temp_model = ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList()
                self.publish_task_info_list.append(temp_model.from_map(k))
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class ListDDLPublishRecordsResponseBody(TeaModel):
    def __init__(
        self,
        ddlpublish_record_list: List[ListDDLPublishRecordsResponseBodyDDLPublishRecordList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details of the publishing records.
        self.ddlpublish_record_list = ddlpublish_record_list
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.ddlpublish_record_list:
            for k in self.ddlpublish_record_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DDLPublishRecordList'] = []
        if self.ddlpublish_record_list is not None:
            for k in self.ddlpublish_record_list:
                result['DDLPublishRecordList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ddlpublish_record_list = []
        if m.get('DDLPublishRecordList') is not None:
            for k in m.get('DDLPublishRecordList'):
                temp_model = ListDDLPublishRecordsResponseBodyDDLPublishRecordList()
                self.ddlpublish_record_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDDLPublishRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDDLPublishRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDDLPublishRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataCorrectPreCheckDBRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The ID of the ticket for the data change.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The number of the page to return.
        # 
        # Valid values: an integer that is greater than 0.
        # 
        # Default value: 1.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDataCorrectPreCheckDBResponseBodyPreCheckDBList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        search_name: str = None,
        sql_num: int = None,
    ):
        # The ID of the database.
        self.db_id = db_id
        # The name of the database.
        self.search_name = search_name
        # The number of SQL statements.
        self.sql_num = sql_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sql_num is not None:
            result['SqlNum'] = self.sql_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('SqlNum') is not None:
            self.sql_num = m.get('SqlNum')
        return self


class ListDataCorrectPreCheckDBResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pre_check_dblist: List[ListDataCorrectPreCheckDBResponseBodyPreCheckDBList] = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The information about the databases that are involved in the precheck.
        self.pre_check_dblist = pre_check_dblist
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.pre_check_dblist:
            for k in self.pre_check_dblist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['PreCheckDBList'] = []
        if self.pre_check_dblist is not None:
            for k in self.pre_check_dblist:
                result['PreCheckDBList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.pre_check_dblist = []
        if m.get('PreCheckDBList') is not None:
            for k in m.get('PreCheckDBList'):
                temp_model = ListDataCorrectPreCheckDBResponseBodyPreCheckDBList()
                self.pre_check_dblist.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataCorrectPreCheckDBResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataCorrectPreCheckDBResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataCorrectPreCheckDBResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataCorrectPreCheckSQLRequest(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        order_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To query the ID of a physical database, call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
        # *   To query the ID of a logical database, call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
        self.db_id = db_id
        # The ID of the data change ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the data change ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList(TeaModel):
    def __init__(
        self,
        affect_rows: int = None,
        check_sql: str = None,
        db_id: int = None,
        sqlreview_query_key: str = None,
        sql_review_status: str = None,
        sql_type: str = None,
        table_names: str = None,
    ):
        # The estimated number of affected rows.
        self.affect_rows = affect_rows
        # The SQL statement.
        self.check_sql = check_sql
        # The ID of the database.
        self.db_id = db_id
        # The key that is used to query the details of optimization suggestions. You can call the [GetSQLReviewOptimizeDetail](https://help.aliyun.com/document_detail/265977.html) operation to query the details of optimization suggestions based on the key.
        self.sqlreview_query_key = sqlreview_query_key
        # The review status of the SQL statement. Valid values:
        # 
        # *   **WAITING**: The SQL statement is pending for review.
        # *   **RUNNING**: The SQL statement is being reviewed.
        # *   **IGNORE**: The SQL statement review is skipped.
        # *   **PASS**: The SQL statement passed the review.
        # *   **BLOCK**: The SQL statement failed the review.
        self.sql_review_status = sql_review_status
        # The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
        self.sql_type = sql_type
        # The name of the table whose data is changed.
        self.table_names = table_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.check_sql is not None:
            result['CheckSQL'] = self.check_sql
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.sqlreview_query_key is not None:
            result['SQLReviewQueryKey'] = self.sqlreview_query_key
        if self.sql_review_status is not None:
            result['SqlReviewStatus'] = self.sql_review_status
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.table_names is not None:
            result['TableNames'] = self.table_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('CheckSQL') is not None:
            self.check_sql = m.get('CheckSQL')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('SQLReviewQueryKey') is not None:
            self.sqlreview_query_key = m.get('SQLReviewQueryKey')
        if m.get('SqlReviewStatus') is not None:
            self.sql_review_status = m.get('SqlReviewStatus')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('TableNames') is not None:
            self.table_names = m.get('TableNames')
        return self


class ListDataCorrectPreCheckSQLResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pre_check_sqllist: List[ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList] = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The precheck information about SQL statements.
        self.pre_check_sqllist = pre_check_sqllist
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        if self.pre_check_sqllist:
            for k in self.pre_check_sqllist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['PreCheckSQLList'] = []
        if self.pre_check_sqllist is not None:
            for k in self.pre_check_sqllist:
                result['PreCheckSQLList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.pre_check_sqllist = []
        if m.get('PreCheckSQLList') is not None:
            for k in m.get('PreCheckSQLList'):
                temp_model = ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList()
                self.pre_check_sqllist.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataCorrectPreCheckSQLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataCorrectPreCheckSQLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataCorrectPreCheckSQLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataImportSQLPreCheckDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        page_numer: int = None,
        page_size: int = None,
        sql_type: str = None,
        status_code: str = None,
        tid: int = None,
    ):
        # The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The page number. Pages start from page 1.
        self.page_numer = page_numer
        # The number of entries per page.
        self.page_size = page_size
        # The type of the SQL statement. Valid values:
        # 
        # *   **SELECT**\
        # *   **INSERT**\
        # *   **DELETE**\
        # *   **CREATE_TABLE**\
        # 
        # > You can log on to the Data Management (DMS) console and choose **Security and Specifications** > **Operation Audit** in the top navigation bar to view more types of SQL statements.
        self.sql_type = sql_type
        # The state of the ticket. If you leave this parameter empty, all the states are queried by default. Valid values:
        # 
        # *   **INIT**: The ticket is being initialized.
        # *   **RUNNING**: The ticket is in progress.
        # *   **SUCCESS**: The ticket is complete.
        # *   **TIMEOUT**: The ticket is skipped due to timeout.
        # *   **FAIL**: The ticket fails.
        self.status_code = status_code
        # The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_numer is not None:
            result['PageNumer'] = self.page_numer
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumer') is not None:
            self.page_numer = m.get('PageNumer')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList(TeaModel):
    def __init__(
        self,
        skip: bool = None,
        sql_id: int = None,
        sql_type: str = None,
        status_code: str = None,
    ):
        # Indicates whether the precheck of the SQL statement was skipped. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.skip = skip
        # The SQL ID, which indicates the sequence number of the SQL statement. The number starts with 1.
        self.sql_id = sql_id
        # The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
        self.sql_type = sql_type
        # The state of the ticket. Valid values:
        # 
        # *   **INIT**: The ticket was being initialized.
        # *   **RUNNING**: The ticket was in progress.
        # *   **SUCCESS**: The ticket was complete.
        # *   **TIMEOUT**: The ticket was skipped due to timeout.
        # *   **FAIL**: The ticket failed.
        self.status_code = status_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.skip is not None:
            result['Skip'] = self.skip
        if self.sql_id is not None:
            result['SqlId'] = self.sql_id
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Skip') is not None:
            self.skip = m.get('Skip')
        if m.get('SqlId') is not None:
            self.sql_id = m.get('SqlId')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        return self


class ListDataImportSQLPreCheckDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pre_check_sqldetail_list: List[ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList] = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The precheck information of SQL statements.
        self.pre_check_sqldetail_list = pre_check_sqldetail_list
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The number of SQL statements.
        self.total_count = total_count

    def validate(self):
        if self.pre_check_sqldetail_list:
            for k in self.pre_check_sqldetail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['PreCheckSQLDetailList'] = []
        if self.pre_check_sqldetail_list is not None:
            for k in self.pre_check_sqldetail_list:
                result['PreCheckSQLDetailList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.pre_check_sqldetail_list = []
        if m.get('PreCheckSQLDetailList') is not None:
            for k in m.get('PreCheckSQLDetailList'):
                temp_model = ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList()
                self.pre_check_sqldetail_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataImportSQLPreCheckDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataImportSQLPreCheckDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataImportSQLPreCheckDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataImportSQLTypeRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDataImportSQLTypeResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sql_type_result: List[str] = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The request ID. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # The types of SQL statements.
        self.sql_type_result = sql_type_result
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sql_type_result is not None:
            result['SqlTypeResult'] = self.sql_type_result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SqlTypeResult') is not None:
            self.sql_type_result = m.get('SqlTypeResult')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataImportSQLTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataImportSQLTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataImportSQLTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataLakeCatalogRequest(TeaModel):
    def __init__(
        self,
        data_region: str = None,
        search_key: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.data_region = data_region
        self.search_key = search_key
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDataLakeCatalogResponseBody(TeaModel):
    def __init__(
        self,
        cata_log_list: List[DLCatalog] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.cata_log_list = cata_log_list
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.cata_log_list:
            for k in self.cata_log_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CataLogList'] = []
        if self.cata_log_list is not None:
            for k in self.cata_log_list:
                result['CataLogList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cata_log_list = []
        if m.get('CataLogList') is not None:
            for k in m.get('CataLogList'):
                temp_model = DLCatalog()
                self.cata_log_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataLakeCatalogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataLakeCatalogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataLakeCatalogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataLakeDatabaseRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        max_results: int = None,
        next_token: str = None,
        search_key: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        self.max_results = max_results
        self.next_token = next_token
        self.search_key = search_key
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDataLakeDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        database_list: List[DLDatabase] = None,
        error_code: str = None,
        error_message: str = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.database_list = database_list
        self.error_code = error_code
        self.error_message = error_message
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.database_list:
            for k in self.database_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DatabaseList'] = []
        if self.database_list is not None:
            for k in self.database_list:
                result['DatabaseList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.database_list = []
        if m.get('DatabaseList') is not None:
            for k in m.get('DatabaseList'):
                temp_model = DLDatabase()
                self.database_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataLakeDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataLakeDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataLakeDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataLakeFunctionRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        function_name_pattern: str = None,
        max_results: int = None,
        next_token: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        self.db_name = db_name
        self.function_name_pattern = function_name_pattern
        self.max_results = max_results
        self.next_token = next_token
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.function_name_pattern is not None:
            result['FunctionNamePattern'] = self.function_name_pattern
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('FunctionNamePattern') is not None:
            self.function_name_pattern = m.get('FunctionNamePattern')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDataLakeFunctionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        function_list: List[DLFunction] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.function_list = function_list
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.function_list:
            for k in self.function_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['FunctionList'] = []
        if self.function_list is not None:
            for k in self.function_list:
                result['FunctionList'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.function_list = []
        if m.get('FunctionList') is not None:
            for k in m.get('FunctionList'):
                temp_model = DLFunction()
                self.function_list.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataLakeFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataLakeFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataLakeFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataLakeFunctionNameRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        function_name_pattern: str = None,
        max_results: int = None,
        next_token: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.function_name_pattern = function_name_pattern
        self.max_results = max_results
        self.next_token = next_token
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.function_name_pattern is not None:
            result['FunctionNamePattern'] = self.function_name_pattern
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('FunctionNamePattern') is not None:
            self.function_name_pattern = m.get('FunctionNamePattern')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDataLakeFunctionNameResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        function_name_list: List[str] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.function_name_list = function_name_list
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.function_name_list is not None:
            result['FunctionNameList'] = self.function_name_list
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FunctionNameList') is not None:
            self.function_name_list = m.get('FunctionNameList')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataLakeFunctionNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataLakeFunctionNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataLakeFunctionNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataLakePartitionRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        max_results: int = None,
        next_token: str = None,
        part_names: List[str] = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.max_results = max_results
        self.next_token = next_token
        self.part_names = part_names
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.part_names is not None:
            result['PartNames'] = self.part_names
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PartNames') is not None:
            self.part_names = m.get('PartNames')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDataLakePartitionShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        max_results: int = None,
        next_token: str = None,
        part_names_shrink: str = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.max_results = max_results
        self.next_token = next_token
        self.part_names_shrink = part_names_shrink
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.part_names_shrink is not None:
            result['PartNames'] = self.part_names_shrink
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PartNames') is not None:
            self.part_names_shrink = m.get('PartNames')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDataLakePartitionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        max_results: int = None,
        next_token: str = None,
        partition_list: List[DLPartition] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.max_results = max_results
        self.next_token = next_token
        self.partition_list = partition_list
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.partition_list:
            for k in self.partition_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['PartitionList'] = []
        if self.partition_list is not None:
            for k in self.partition_list:
                result['PartitionList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.partition_list = []
        if m.get('PartitionList') is not None:
            for k in m.get('PartitionList'):
                temp_model = DLPartition()
                self.partition_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataLakePartitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataLakePartitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataLakePartitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataLakePartitionByFilterRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        filter: str = None,
        max_results: int = None,
        next_token: str = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.filter = filter
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.filter is not None:
            result['Filter'] = self.filter
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('Filter') is not None:
            self.filter = m.get('Filter')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDataLakePartitionByFilterResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        max_results: int = None,
        next_token: str = None,
        partition_list: List[DLPartition] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.max_results = max_results
        self.next_token = next_token
        self.partition_list = partition_list
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.partition_list:
            for k in self.partition_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['PartitionList'] = []
        if self.partition_list is not None:
            for k in self.partition_list:
                result['PartitionList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.partition_list = []
        if m.get('PartitionList') is not None:
            for k in m.get('PartitionList'):
                temp_model = DLPartition()
                self.partition_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataLakePartitionByFilterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataLakePartitionByFilterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataLakePartitionByFilterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataLakePartitionNameRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        max_results: int = None,
        next_token: str = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDataLakePartitionNameResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        max_results: int = None,
        next_token: str = None,
        partition_name_list: List[str] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.max_results = max_results
        self.next_token = next_token
        self.partition_name_list = partition_name_list
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.partition_name_list is not None:
            result['PartitionNameList'] = self.partition_name_list
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PartitionNameList') is not None:
            self.partition_name_list = m.get('PartitionNameList')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataLakePartitionNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataLakePartitionNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataLakePartitionNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataLakeTableRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        max_results: int = None,
        next_token: str = None,
        table_name_pattern: str = None,
        table_type: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.max_results = max_results
        self.next_token = next_token
        self.table_name_pattern = table_name_pattern
        self.table_type = table_type
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.table_name_pattern is not None:
            result['TableNamePattern'] = self.table_name_pattern
        if self.table_type is not None:
            result['TableType'] = self.table_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TableNamePattern') is not None:
            self.table_name_pattern = m.get('TableNamePattern')
        if m.get('TableType') is not None:
            self.table_type = m.get('TableType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDataLakeTableResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        table_list: List[DLTable] = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.table_list = table_list

    def validate(self):
        if self.table_list:
            for k in self.table_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TableList'] = []
        if self.table_list is not None:
            for k in self.table_list:
                result['TableList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.table_list = []
        if m.get('TableList') is not None:
            for k in m.get('TableList'):
                temp_model = DLTable()
                self.table_list.append(temp_model.from_map(k))
        return self


class ListDataLakeTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataLakeTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataLakeTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataLakeTableNameRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        max_results: int = None,
        next_token: str = None,
        table_name_pattern: str = None,
        table_type: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.max_results = max_results
        self.next_token = next_token
        self.table_name_pattern = table_name_pattern
        self.table_type = table_type
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.table_name_pattern is not None:
            result['TableNamePattern'] = self.table_name_pattern
        if self.table_type is not None:
            result['TableType'] = self.table_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TableNamePattern') is not None:
            self.table_name_pattern = m.get('TableNamePattern')
        if m.get('TableType') is not None:
            self.table_type = m.get('TableType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDataLakeTableNameResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        table_name_list: List[str] = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.table_name_list = table_name_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.table_name_list is not None:
            result['TableNameList'] = self.table_name_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TableNameList') is not None:
            self.table_name_list = m.get('TableNameList')
        return self


class ListDataLakeTableNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataLakeTableNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataLakeTableNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataLakeTablebaseInfoRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        page: int = None,
        rows: int = None,
        search_key: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.page = page
        self.rows = rows
        self.search_key = search_key
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.page is not None:
            result['Page'] = self.page
        if self.rows is not None:
            result['Rows'] = self.rows
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Rows') is not None:
            self.rows = m.get('Rows')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDataLakeTablebaseInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tablebase_info_list: List[DLTablebaseInfo] = None,
        total_count: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.tablebase_info_list = tablebase_info_list
        self.total_count = total_count

    def validate(self):
        if self.tablebase_info_list:
            for k in self.tablebase_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TablebaseInfoList'] = []
        if self.tablebase_info_list is not None:
            for k in self.tablebase_info_list:
                result['TablebaseInfoList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.tablebase_info_list = []
        if m.get('TablebaseInfoList') is not None:
            for k in m.get('TablebaseInfoList'):
                temp_model = DLTablebaseInfo()
                self.tablebase_info_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDataLakeTablebaseInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataLakeTablebaseInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataLakeTablebaseInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDatabaseUserPermssionsRequest(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        logic: bool = None,
        page_number: int = None,
        page_size: int = None,
        perm_type: str = None,
        tid: int = None,
        user_name: str = None,
    ):
        # The ID of the database.
        # 
        # This parameter is required.
        self.db_id = db_id
        # Specifies whether the database is a logical database.
        self.logic = logic
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The type of the permission. Valid values:
        # 
        # *   DATABASE: permissions on databases
        # *   TABLE: permissions on tables
        # *   COLUMN: permissions on fields
        # 
        # This parameter is required.
        self.perm_type = perm_type
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid
        # The nickname of the user.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail(TeaModel):
    def __init__(
        self,
        create_date: str = None,
        expire_date: str = None,
        extra_data: str = None,
        origin_from: str = None,
        perm_type: str = None,
        user_access_id: str = None,
    ):
        # The time when the permission was created.
        self.create_date = create_date
        # The time when the permissions expire.
        self.expire_date = expire_date
        # The extra information. This parameter is reserved.
        self.extra_data = extra_data
        # The description of the entity that authorizes the permission.
        self.origin_from = origin_from
        # The type of the permission. Valid values:
        # 
        # *   QUERY: the query permissions
        # *   EXPORT: the export permissions
        # *   CORRECT: the change permissions
        self.perm_type = perm_type
        # The ID of the authorization record.
        self.user_access_id = user_access_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_date is not None:
            result['CreateDate'] = self.create_date
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.extra_data is not None:
            result['ExtraData'] = self.extra_data
        if self.origin_from is not None:
            result['OriginFrom'] = self.origin_from
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.user_access_id is not None:
            result['UserAccessId'] = self.user_access_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateDate') is not None:
            self.create_date = m.get('CreateDate')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('ExtraData') is not None:
            self.extra_data = m.get('ExtraData')
        if m.get('OriginFrom') is not None:
            self.origin_from = m.get('OriginFrom')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('UserAccessId') is not None:
            self.user_access_id = m.get('UserAccessId')
        return self


class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails(TeaModel):
    def __init__(
        self,
        perm_detail: List[ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail] = None,
    ):
        self.perm_detail = perm_detail

    def validate(self):
        if self.perm_detail:
            for k in self.perm_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PermDetail'] = []
        if self.perm_detail is not None:
            for k in self.perm_detail:
                result['PermDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.perm_detail = []
        if m.get('PermDetail') is not None:
            for k in m.get('PermDetail'):
                temp_model = ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail()
                self.perm_detail.append(temp_model.from_map(k))
        return self


class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission(TeaModel):
    def __init__(
        self,
        alias: str = None,
        column_name: str = None,
        db_id: str = None,
        db_type: str = None,
        ds_type: str = None,
        env_type: str = None,
        instance_id: str = None,
        logic: bool = None,
        perm_details: ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails = None,
        schema_name: str = None,
        search_name: str = None,
        table_id: str = None,
        table_name: str = None,
        user_id: str = None,
        user_nick_name: str = None,
    ):
        # The alias of the database instance.
        self.alias = alias
        # The name of a column.
        self.column_name = column_name
        # The ID of the database.
        self.db_id = db_id
        # The type of the database engine.
        self.db_type = db_type
        # The type of resources on which the user has permissions.
        self.ds_type = ds_type
        # The type of the environment to which the database belongs.
        self.env_type = env_type
        # The ID of the instance.
        self.instance_id = instance_id
        # Indicates whether the database is a logical database.
        self.logic = logic
        # The details of user permissions.
        self.perm_details = perm_details
        # The name of the database.
        self.schema_name = schema_name
        # The name that is used to search for the database.
        self.search_name = search_name
        # The ID of the table.
        self.table_id = table_id
        # The name of the table.
        self.table_name = table_name
        # The ID of the user.
        self.user_id = user_id
        # The nickname of the user.
        self.user_nick_name = user_nick_name

    def validate(self):
        if self.perm_details:
            self.perm_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.perm_details is not None:
            result['PermDetails'] = self.perm_details.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick_name is not None:
            result['UserNickName'] = self.user_nick_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermDetails') is not None:
            temp_model = ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails()
            self.perm_details = temp_model.from_map(m['PermDetails'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNickName') is not None:
            self.user_nick_name = m.get('UserNickName')
        return self


class ListDatabaseUserPermssionsResponseBodyUserPermissions(TeaModel):
    def __init__(
        self,
        user_permission: List[ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission] = None,
    ):
        self.user_permission = user_permission

    def validate(self):
        if self.user_permission:
            for k in self.user_permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserPermission'] = []
        if self.user_permission is not None:
            for k in self.user_permission:
                result['UserPermission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user_permission = []
        if m.get('UserPermission') is not None:
            for k in m.get('UserPermission'):
                temp_model = ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission()
                self.user_permission.append(temp_model.from_map(k))
        return self


class ListDatabaseUserPermssionsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
        user_permissions: ListDatabaseUserPermssionsResponseBodyUserPermissions = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success
        # The total number of entries returned.
        self.total_count = total_count
        # The details of user permissions.
        self.user_permissions = user_permissions

    def validate(self):
        if self.user_permissions:
            self.user_permissions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_permissions is not None:
            result['UserPermissions'] = self.user_permissions.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserPermissions') is not None:
            temp_model = ListDatabaseUserPermssionsResponseBodyUserPermissions()
            self.user_permissions = temp_model.from_map(m['UserPermissions'])
        return self


class ListDatabaseUserPermssionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDatabaseUserPermssionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDatabaseUserPermssionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDatabasesRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The ID of the instance. The valid value is returned if you call the ListInstances operation. The instance ID is not the ID of the RDS instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return per page.
        self.page_size = page_size
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListDatabasesResponseBodyDatabaseListDatabase(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        database_id: str = None,
        db_type: str = None,
        dba_id: str = None,
        dba_name: str = None,
        encoding: str = None,
        env_type: str = None,
        host: str = None,
        instance_id: str = None,
        owner_id_list: ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList = None,
        owner_name_list: ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList = None,
        port: int = None,
        schema_name: str = None,
        search_name: str = None,
        sid: str = None,
        state: str = None,
    ):
        # The name of the catalog to which the database belongs.
        self.catalog_name = catalog_name
        # The ID of the database.
        self.database_id = database_id
        # The type of the database engine.
        self.db_type = db_type
        # The ID of the DBA.
        self.dba_id = dba_id
        # The nickname of the Database administrator (DBA) to which the database belongs.
        self.dba_name = dba_name
        # The encoding format of the database.
        self.encoding = encoding
        # The type of the environment to which the database belongs.
        self.env_type = env_type
        # The endpoint of the instance to which the database belongs.
        self.host = host
        # The ID of the instance to which the database belongs.
        self.instance_id = instance_id
        # The IDs of the owners of the database.
        self.owner_id_list = owner_id_list
        # The nicknames of the database owners.
        self.owner_name_list = owner_name_list
        # The connection port of the instance to which the database belongs.
        self.port = port
        # The name of the database.
        self.schema_name = schema_name
        # The name that is used for searching the database.
        self.search_name = search_name
        # The system ID (SID) of the instance to which the database belongs.
        self.sid = sid
        # The state of the database. Valid values:
        # 
        # *   NORMAL: The database is normal.
        # *   DISABLE: The database is disabled.
        # *   OFFLINE: The database is unpublished.
        # *   NOT_EXIST: The database does not exist.
        self.state = state

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_name is not None:
            result['DbaName'] = self.dba_name
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaName') is not None:
            self.dba_name = m.get('DbaName')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerIdList') is not None:
            temp_model = ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListDatabasesResponseBodyDatabaseList(TeaModel):
    def __init__(
        self,
        database: List[ListDatabasesResponseBodyDatabaseListDatabase] = None,
    ):
        self.database = database

    def validate(self):
        if self.database:
            for k in self.database:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Database'] = []
        if self.database is not None:
            for k in self.database:
                result['Database'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.database = []
        if m.get('Database') is not None:
            for k in m.get('Database'):
                temp_model = ListDatabasesResponseBodyDatabaseListDatabase()
                self.database.append(temp_model.from_map(k))
        return self


class ListDatabasesResponseBody(TeaModel):
    def __init__(
        self,
        database_list: ListDatabasesResponseBodyDatabaseList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The details of the databases.
        self.database_list = database_list
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success
        # The number of databases that belong to an instance.
        self.total_count = total_count

    def validate(self):
        if self.database_list:
            self.database_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_list is not None:
            result['DatabaseList'] = self.database_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseList') is not None:
            temp_model = ListDatabasesResponseBodyDatabaseList()
            self.database_list = temp_model.from_map(m['DatabaseList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDatabasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDatabasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDatabasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDefaultSLARulesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDefaultSLARulesResponseBodySLARuleListSLARule(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        id: int = None,
        interval_minutes: int = None,
        node_id: int = None,
        rule_type: int = None,
    ):
        # The ID of the task flow.
        self.dag_id = dag_id
        # The ID of the SLA rule.
        self.id = id
        # The timeout period. Unit: minutes.
        self.interval_minutes = interval_minutes
        # The ID of the task node.
        self.node_id = node_id
        # The type of the rule. Valid values:
        # 
        # *   **0**: an SLA rule for a task flow
        # *   **1**: an SLA rule for a task node
        self.rule_type = rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.interval_minutes is not None:
            result['IntervalMinutes'] = self.interval_minutes
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IntervalMinutes') is not None:
            self.interval_minutes = m.get('IntervalMinutes')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        return self


class ListDefaultSLARulesResponseBodySLARuleList(TeaModel):
    def __init__(
        self,
        slarule: List[ListDefaultSLARulesResponseBodySLARuleListSLARule] = None,
    ):
        self.slarule = slarule

    def validate(self):
        if self.slarule:
            for k in self.slarule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SLARule'] = []
        if self.slarule is not None:
            for k in self.slarule:
                result['SLARule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.slarule = []
        if m.get('SLARule') is not None:
            for k in m.get('SLARule'):
                temp_model = ListDefaultSLARulesResponseBodySLARuleListSLARule()
                self.slarule.append(temp_model.from_map(k))
        return self


class ListDefaultSLARulesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        slarule_list: ListDefaultSLARulesResponseBodySLARuleList = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # The list of SLA rules.
        self.slarule_list = slarule_list
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.slarule_list:
            self.slarule_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.slarule_list is not None:
            result['SLARuleList'] = self.slarule_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SLARuleList') is not None:
            temp_model = ListDefaultSLARulesResponseBodySLARuleList()
            self.slarule_list = temp_model.from_map(m['SLARuleList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDefaultSLARulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDefaultSLARulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDefaultSLARulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDesensitizationRuleRequest(TeaModel):
    def __init__(
        self,
        func_type: str = None,
        page_number: int = None,
        page_size: int = None,
        rule_id: int = None,
        rule_name: str = None,
        rule_type: str = None,
        tid: int = None,
    ):
        # The type of the masking algorithm.
        self.func_type = func_type
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page. The maximum value is 100.
        self.page_size = page_size
        # The ID of the masking rule.
        self.rule_id = rule_id
        # The name of the masking rule.
        self.rule_name = rule_name
        # The algorithm used for masking.
        self.rule_type = rule_type
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.func_type is not None:
            result['FuncType'] = self.func_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FuncType') is not None:
            self.func_type = m.get('FuncType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDesensitizationRuleResponseBodyDesensitizationRuleList(TeaModel):
    def __init__(
        self,
        func_params: str = None,
        func_sample: str = None,
        function_type: str = None,
        last_modifier_id: str = None,
        last_modifier_name: str = None,
        reference_count: int = None,
        rule_desc: str = None,
        rule_id: int = None,
        rule_name: str = None,
        rule_type: str = None,
    ):
        # The parameter.
        self.func_params = func_params
        # The example.
        self.func_sample = func_sample
        # The algorithm type.
        self.function_type = function_type
        # The ID of the user who last modified the masking rule.
        self.last_modifier_id = last_modifier_id
        # The name of the user who last modified the masking rule.
        self.last_modifier_name = last_modifier_name
        # The number of times that the masking was used.
        self.reference_count = reference_count
        # The description of the rule.
        self.rule_desc = rule_desc
        # The ID of the masking rule.
        self.rule_id = rule_id
        # The name of the masking rule.
        self.rule_name = rule_name
        # The algorithm used for masking.
        self.rule_type = rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.func_params is not None:
            result['FuncParams'] = self.func_params
        if self.func_sample is not None:
            result['FuncSample'] = self.func_sample
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.last_modifier_id is not None:
            result['LastModifierId'] = self.last_modifier_id
        if self.last_modifier_name is not None:
            result['LastModifierName'] = self.last_modifier_name
        if self.reference_count is not None:
            result['ReferenceCount'] = self.reference_count
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FuncParams') is not None:
            self.func_params = m.get('FuncParams')
        if m.get('FuncSample') is not None:
            self.func_sample = m.get('FuncSample')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('LastModifierId') is not None:
            self.last_modifier_id = m.get('LastModifierId')
        if m.get('LastModifierName') is not None:
            self.last_modifier_name = m.get('LastModifierName')
        if m.get('ReferenceCount') is not None:
            self.reference_count = m.get('ReferenceCount')
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        return self


class ListDesensitizationRuleResponseBody(TeaModel):
    def __init__(
        self,
        desensitization_rule_list: List[ListDesensitizationRuleResponseBodyDesensitizationRuleList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The list of masking rules.
        self.desensitization_rule_list = desensitization_rule_list
        # The error code returned if the request failed.
        # 
        # This parameter is required.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success
        # The total number of entries returned. By default, this parameter is not returned.
        self.total_count = total_count

    def validate(self):
        if self.desensitization_rule_list:
            for k in self.desensitization_rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DesensitizationRuleList'] = []
        if self.desensitization_rule_list is not None:
            for k in self.desensitization_rule_list:
                result['DesensitizationRuleList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.desensitization_rule_list = []
        if m.get('DesensitizationRuleList') is not None:
            for k in m.get('DesensitizationRuleList'):
                temp_model = ListDesensitizationRuleResponseBodyDesensitizationRuleList()
                self.desensitization_rule_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDesensitizationRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDesensitizationRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDesensitizationRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDifyInstancesRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        data_region: str = None,
        max_results: int = None,
        next_token: str = None,
    ):
        self.client_token = client_token
        self.data_region = data_region
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        return self


class ListDifyInstancesResponseBodyRootData(TeaModel):
    def __init__(
        self,
        app_uuid: str = None,
        created_time: str = None,
        edition: str = None,
        enterprise_internet_url: str = None,
        enterprise_intranet_url: str = None,
        instance_id: str = None,
        internet_url: str = None,
        intranet_url: str = None,
        major_version: str = None,
        security_group_id: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
        workspace_id: str = None,
        zone_id: str = None,
    ):
        self.app_uuid = app_uuid
        self.created_time = created_time
        self.edition = edition
        self.enterprise_internet_url = enterprise_internet_url
        self.enterprise_intranet_url = enterprise_intranet_url
        self.instance_id = instance_id
        self.internet_url = internet_url
        self.intranet_url = intranet_url
        self.major_version = major_version
        self.security_group_id = security_group_id
        self.v_switch_id = v_switch_id
        self.vpc_id = vpc_id
        self.workspace_id = workspace_id
        self.zone_id = zone_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_uuid is not None:
            result['AppUuid'] = self.app_uuid
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.edition is not None:
            result['Edition'] = self.edition
        if self.enterprise_internet_url is not None:
            result['EnterpriseInternetUrl'] = self.enterprise_internet_url
        if self.enterprise_intranet_url is not None:
            result['EnterpriseIntranetUrl'] = self.enterprise_intranet_url
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.internet_url is not None:
            result['InternetUrl'] = self.internet_url
        if self.intranet_url is not None:
            result['IntranetUrl'] = self.intranet_url
        if self.major_version is not None:
            result['MajorVersion'] = self.major_version
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppUuid') is not None:
            self.app_uuid = m.get('AppUuid')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Edition') is not None:
            self.edition = m.get('Edition')
        if m.get('EnterpriseInternetUrl') is not None:
            self.enterprise_internet_url = m.get('EnterpriseInternetUrl')
        if m.get('EnterpriseIntranetUrl') is not None:
            self.enterprise_intranet_url = m.get('EnterpriseIntranetUrl')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InternetUrl') is not None:
            self.internet_url = m.get('InternetUrl')
        if m.get('IntranetUrl') is not None:
            self.intranet_url = m.get('IntranetUrl')
        if m.get('MajorVersion') is not None:
            self.major_version = m.get('MajorVersion')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ListDifyInstancesResponseBodyRoot(TeaModel):
    def __init__(
        self,
        data: List[ListDifyInstancesResponseBodyRootData] = None,
    ):
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDifyInstancesResponseBodyRootData()
                self.data.append(temp_model.from_map(k))
        return self


class ListDifyInstancesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_code: str = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        root: ListDifyInstancesResponseBodyRoot = None,
        success: bool = None,
    ):
        self.code = code
        self.error_code = error_code
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.root = root
        self.success = success

    def validate(self):
        if self.root:
            self.root.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.root is not None:
            result['Root'] = self.root.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Root') is not None:
            temp_model = ListDifyInstancesResponseBodyRoot()
            self.root = temp_model.from_map(m['Root'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDifyInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDifyInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDifyInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEffectiveOrdersRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListEffectiveOrdersResponseBodyOrderSummaryOrderList(TeaModel):
    def __init__(
        self,
        buyer_id: str = None,
        end_time: str = None,
        ins_num: str = None,
        instance_id: str = None,
        order_id: str = None,
        start_time: str = None,
    ):
        # The UID of the user who placed the order.
        self.buyer_id = buyer_id
        # The time when the instance expires.
        self.end_time = end_time
        # The maximum number of database instances that you can use DMS to manage.
        self.ins_num = ins_num
        # The ID of the instance for the purchased service.
        self.instance_id = instance_id
        # The ID of the order.
        self.order_id = order_id
        # The time when the instance is started.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.buyer_id is not None:
            result['BuyerId'] = self.buyer_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ins_num is not None:
            result['InsNum'] = self.ins_num
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BuyerId') is not None:
            self.buyer_id = m.get('BuyerId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InsNum') is not None:
            self.ins_num = m.get('InsNum')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListEffectiveOrdersResponseBodyOrderSummary(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
        commodity_type: str = None,
        order_list: List[ListEffectiveOrdersResponseBodyOrderSummaryOrderList] = None,
        total_quota: int = None,
        version_type: str = None,
    ):
        # The commodity code of DMS.
        # 
        # *   dms_pre_public_cn: DMS that uses the subscription billing method
        # *   dms_post_public_cn: DMS that uses the pay-as-you-go billing method
        self.commodity_code = commodity_code
        # The type of the service.
        # 
        # *   **VersionType**: DMS that supports control modes
        # *   **SensitiveDataProtection**: DMS that supports sensitive data protection
        self.commodity_type = commodity_type
        # Details about the orders.
        self.order_list = order_list
        # The sum of the number of instances that you can use DMS to manage in all orders.
        self.total_quota = total_quota
        # The control mode of DMS. Valid values:
        # 
        # *   **stand**: Stable Change
        # *   **safety**: Security Collaboration
        self.version_type = version_type

    def validate(self):
        if self.order_list:
            for k in self.order_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.commodity_type is not None:
            result['CommodityType'] = self.commodity_type
        result['OrderList'] = []
        if self.order_list is not None:
            for k in self.order_list:
                result['OrderList'].append(k.to_map() if k else None)
        if self.total_quota is not None:
            result['TotalQuota'] = self.total_quota
        if self.version_type is not None:
            result['VersionType'] = self.version_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CommodityType') is not None:
            self.commodity_type = m.get('CommodityType')
        self.order_list = []
        if m.get('OrderList') is not None:
            for k in m.get('OrderList'):
                temp_model = ListEffectiveOrdersResponseBodyOrderSummaryOrderList()
                self.order_list.append(temp_model.from_map(k))
        if m.get('TotalQuota') is not None:
            self.total_quota = m.get('TotalQuota')
        if m.get('VersionType') is not None:
            self.version_type = m.get('VersionType')
        return self


class ListEffectiveOrdersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        order_summary: List[ListEffectiveOrdersResponseBodyOrderSummary] = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The information about orders.
        self.order_summary = order_summary
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.order_summary:
            for k in self.order_summary:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['OrderSummary'] = []
        if self.order_summary is not None:
            for k in self.order_summary:
                result['OrderSummary'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.order_summary = []
        if m.get('OrderSummary') is not None:
            for k in m.get('OrderSummary'):
                temp_model = ListEffectiveOrdersResponseBodyOrderSummary()
                self.order_summary.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEffectiveOrdersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEffectiveOrdersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEffectiveOrdersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIndexesRequest(TeaModel):
    def __init__(
        self,
        logic: bool = None,
        table_id: str = None,
        tid: int = None,
    ):
        # Specifies whether the table is a logical table.
        self.logic = logic
        # The ID of the table.
        # 
        # This parameter is required.
        self.table_id = table_id
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListIndexesResponseBodyIndexListIndex(TeaModel):
    def __init__(
        self,
        index_comment: str = None,
        index_id: str = None,
        index_name: str = None,
        index_type: str = None,
        table_id: str = None,
    ):
        # The description of the index.
        self.index_comment = index_comment
        # The ID of the index.
        self.index_id = index_id
        # The name of the index.
        self.index_name = index_name
        # The type of the index. Valid values:
        # 
        # *   Primary
        # *   Unique
        # *   Normal
        # *   FullText
        # *   Spatial
        self.index_type = index_type
        # The ID of the table.
        self.table_id = table_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_comment is not None:
            result['IndexComment'] = self.index_comment
        if self.index_id is not None:
            result['IndexId'] = self.index_id
        if self.index_name is not None:
            result['IndexName'] = self.index_name
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        if self.table_id is not None:
            result['TableId'] = self.table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndexComment') is not None:
            self.index_comment = m.get('IndexComment')
        if m.get('IndexId') is not None:
            self.index_id = m.get('IndexId')
        if m.get('IndexName') is not None:
            self.index_name = m.get('IndexName')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        return self


class ListIndexesResponseBodyIndexList(TeaModel):
    def __init__(
        self,
        index: List[ListIndexesResponseBodyIndexListIndex] = None,
    ):
        self.index = index

    def validate(self):
        if self.index:
            for k in self.index:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Index'] = []
        if self.index is not None:
            for k in self.index:
                result['Index'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.index = []
        if m.get('Index') is not None:
            for k in m.get('Index'):
                temp_model = ListIndexesResponseBodyIndexListIndex()
                self.index.append(temp_model.from_map(k))
        return self


class ListIndexesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        index_list: ListIndexesResponseBodyIndexList = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The details of indexes.
        self.index_list = index_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.index_list:
            self.index_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.index_list is not None:
            result['IndexList'] = self.index_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('IndexList') is not None:
            temp_model = ListIndexesResponseBodyIndexList()
            self.index_list = temp_model.from_map(m['IndexList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListIndexesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIndexesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIndexesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstanceLoginAuditLogRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        op_user_name: str = None,
        page_number: int = None,
        page_size: int = None,
        search_name: str = None,
        start_time: str = None,
        tid: int = None,
    ):
        # The end of the time range to query.
        # 
        # >  The end time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format. We recommend that you use the StartTime and EndTime parameters to specify a time range that does not exceed one day. This way, the returned entries can be displayed by page to increase query efficiency.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The alias of the user.
        self.op_user_name = op_user_name
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: 100.
        self.page_size = page_size
        # The name of the database or instance whose logon records you want to query.
        # 
        # >  If SQL statements are executed at the instance level, you can set this parameter to an instance name. If SQL statements are executed at the database level, you can set this parameter to a database name.
        self.search_name = search_name
        # The beginning of the time range to query.
        # 
        # >  The start time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.op_user_name is not None:
            result['OpUserName'] = self.op_user_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OpUserName') is not None:
            self.op_user_name = m.get('OpUserName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog(TeaModel):
    def __init__(
        self,
        db_user: str = None,
        instance_id: int = None,
        instance_name: str = None,
        op_time: str = None,
        request_ip: str = None,
        user_id: int = None,
        user_name: str = None,
    ):
        # The database account that is used to log on to the instance.
        self.db_user = db_user
        # The ID of the instance.
        self.instance_id = instance_id
        # The name of the instance.
        self.instance_name = instance_name
        # The time when the user performed an operation on the instance.
        self.op_time = op_time
        # The source IP address of the request.
        self.request_ip = request_ip
        # The ID of the user.
        self.user_id = user_id
        # The alias of the user.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_user is not None:
            result['DbUser'] = self.db_user
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        if self.request_ip is not None:
            result['RequestIp'] = self.request_ip
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbUser') is not None:
            self.db_user = m.get('DbUser')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        if m.get('RequestIp') is not None:
            self.request_ip = m.get('RequestIp')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList(TeaModel):
    def __init__(
        self,
        instance_login_audit_log: List[ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog] = None,
    ):
        self.instance_login_audit_log = instance_login_audit_log

    def validate(self):
        if self.instance_login_audit_log:
            for k in self.instance_login_audit_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceLoginAuditLog'] = []
        if self.instance_login_audit_log is not None:
            for k in self.instance_login_audit_log:
                result['InstanceLoginAuditLog'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_login_audit_log = []
        if m.get('InstanceLoginAuditLog') is not None:
            for k in m.get('InstanceLoginAuditLog'):
                temp_model = ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog()
                self.instance_login_audit_log.append(temp_model.from_map(k))
        return self


class ListInstanceLoginAuditLogResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        instance_login_audit_log_list: ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The logon records of the instance.
        self.instance_login_audit_log_list = instance_login_audit_log_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.instance_login_audit_log_list:
            self.instance_login_audit_log_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_login_audit_log_list is not None:
            result['InstanceLoginAuditLogList'] = self.instance_login_audit_log_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceLoginAuditLogList') is not None:
            temp_model = ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList()
            self.instance_login_audit_log_list = temp_model.from_map(m['InstanceLoginAuditLogList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInstanceLoginAuditLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInstanceLoginAuditLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstanceLoginAuditLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstanceUserPermissionsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
        user_name: str = None,
    ):
        # The ID of the instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid
        # The nickname of the user. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to query the nickname of the user.
        # 
        # >  The value of the NickName parameter is that of the UserName parameter.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail(TeaModel):
    def __init__(
        self,
        create_date: str = None,
        expire_date: str = None,
        extra_data: str = None,
        origin_from: str = None,
        perm_type: str = None,
        user_access_id: str = None,
    ):
        # The time when the permissions were granted.
        self.create_date = create_date
        # The time when the permissions expire.
        self.expire_date = expire_date
        # This parameter is reserved.
        self.extra_data = extra_data
        # The user who grants the permissions.
        self.origin_from = origin_from
        # The type of the permissions. Valid values:
        # 
        # *   LOGIN: the logon permissions
        # *   PERF: the query permissions on the instance
        self.perm_type = perm_type
        # The ID of the authorization record.
        self.user_access_id = user_access_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_date is not None:
            result['CreateDate'] = self.create_date
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.extra_data is not None:
            result['ExtraData'] = self.extra_data
        if self.origin_from is not None:
            result['OriginFrom'] = self.origin_from
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.user_access_id is not None:
            result['UserAccessId'] = self.user_access_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateDate') is not None:
            self.create_date = m.get('CreateDate')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('ExtraData') is not None:
            self.extra_data = m.get('ExtraData')
        if m.get('OriginFrom') is not None:
            self.origin_from = m.get('OriginFrom')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('UserAccessId') is not None:
            self.user_access_id = m.get('UserAccessId')
        return self


class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails(TeaModel):
    def __init__(
        self,
        perm_detail: List[ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail] = None,
    ):
        self.perm_detail = perm_detail

    def validate(self):
        if self.perm_detail:
            for k in self.perm_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PermDetail'] = []
        if self.perm_detail is not None:
            for k in self.perm_detail:
                result['PermDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.perm_detail = []
        if m.get('PermDetail') is not None:
            for k in m.get('PermDetail'):
                temp_model = ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail()
                self.perm_detail.append(temp_model.from_map(k))
        return self


class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        perm_details: ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails = None,
        user_id: str = None,
        user_nick_name: str = None,
    ):
        # The ID of the instance.
        self.instance_id = instance_id
        # The details of permissions.
        self.perm_details = perm_details
        # The ID of the user.
        self.user_id = user_id
        # The nickname of the user.
        self.user_nick_name = user_nick_name

    def validate(self):
        if self.perm_details:
            self.perm_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.perm_details is not None:
            result['PermDetails'] = self.perm_details.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick_name is not None:
            result['UserNickName'] = self.user_nick_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PermDetails') is not None:
            temp_model = ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails()
            self.perm_details = temp_model.from_map(m['PermDetails'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNickName') is not None:
            self.user_nick_name = m.get('UserNickName')
        return self


class ListInstanceUserPermissionsResponseBodyUserPermissions(TeaModel):
    def __init__(
        self,
        user_permission: List[ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission] = None,
    ):
        self.user_permission = user_permission

    def validate(self):
        if self.user_permission:
            for k in self.user_permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserPermission'] = []
        if self.user_permission is not None:
            for k in self.user_permission:
                result['UserPermission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user_permission = []
        if m.get('UserPermission') is not None:
            for k in m.get('UserPermission'):
                temp_model = ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission()
                self.user_permission.append(temp_model.from_map(k))
        return self


class ListInstanceUserPermissionsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
        user_permissions: ListInstanceUserPermissionsResponseBodyUserPermissions = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success
        # The total number of returned entries.
        self.total_count = total_count
        # The permissions of the user on the instance.
        self.user_permissions = user_permissions

    def validate(self):
        if self.user_permissions:
            self.user_permissions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_permissions is not None:
            result['UserPermissions'] = self.user_permissions.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserPermissions') is not None:
            temp_model = ListInstanceUserPermissionsResponseBodyUserPermissions()
            self.user_permissions = temp_model.from_map(m['UserPermissions'])
        return self


class ListInstanceUserPermissionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInstanceUserPermissionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstanceUserPermissionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstancesRequest(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        env_type: str = None,
        instance_source: str = None,
        instance_state: str = None,
        net_type: str = None,
        page_number: int = None,
        page_size: int = None,
        region: str = None,
        search_key: str = None,
        tid: int = None,
    ):
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        self.db_type = db_type
        # The type of the environment to which the database instance belongs. Valid values:
        # 
        # *   **product:** production environment
        # *   **dev**: development environment
        # *   **pre**: pre-release environment
        # *   **test**: test environment
        # *   **sit**: system integration testing (SIT) environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag:** staging environment
        self.env_type = env_type
        # The source of the database instance. Valid values:
        # 
        # *   **PUBLIC_OWN**: a self-managed database instance that is deployed on the Internet
        # *   **RDS**: an ApsaraDB RDS instance
        # *   **ECS_OWN**: a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
        # *   **VPC_IDC**: a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
        self.instance_source = instance_source
        # The status of the database instance. Valid values:
        # 
        # *   **NORMAL**\
        # *   **DISABLE**\
        self.instance_state = instance_state
        # The network type of the database instance. Valid values:
        # 
        # *   **CLASSIC:** classic network
        # *   **VPC:** VPC
        self.net_type = net_type
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page. The number cannot exceed 100.
        self.page_size = page_size
        self.region = region
        # The keyword that is used to search for database instances.
        self.search_key = search_key
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_state is not None:
            result['InstanceState'] = self.instance_state
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region is not None:
            result['Region'] = self.region
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceState') is not None:
            self.instance_state = m.get('InstanceState')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListInstancesResponseBodyInstanceListInstanceOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListInstancesResponseBodyInstanceListInstanceOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListInstancesResponseBodyInstanceListInstanceStandardGroup(TeaModel):
    def __init__(
        self,
        group_mode: str = None,
        group_name: str = None,
    ):
        # The type of the control mode. Valid values:
        # 
        # *   **COMMON**: Security Collaboration
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        self.group_mode = group_mode
        # The name of the security rule corresponding to the control mode.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class ListInstancesResponseBodyInstanceListInstance(TeaModel):
    def __init__(
        self,
        data_link_name: str = None,
        database_password: str = None,
        database_user: str = None,
        dba_id: str = None,
        dba_nick_name: str = None,
        ddl_online: int = None,
        ecs_instance_id: str = None,
        ecs_region: str = None,
        env_type: str = None,
        export_timeout: int = None,
        host: str = None,
        instance_alias: str = None,
        instance_id: str = None,
        instance_source: str = None,
        instance_type: str = None,
        owner_id_list: ListInstancesResponseBodyInstanceListInstanceOwnerIdList = None,
        owner_name_list: ListInstancesResponseBodyInstanceListInstanceOwnerNameList = None,
        port: int = None,
        query_timeout: int = None,
        safe_rule_id: str = None,
        sell_sitd: bool = None,
        sell_trust: str = None,
        sid: str = None,
        standard_group: ListInstancesResponseBodyInstanceListInstanceStandardGroup = None,
        state: str = None,
        use_dsql: int = None,
        vpc_id: str = None,
    ):
        # The name of the database link for the database instance.
        self.data_link_name = data_link_name
        # The password that is used to log on to the database instance.
        self.database_password = database_password
        # The account that is used to log on to the database.
        self.database_user = database_user
        # The ID of the database administrator (DBA) of the database instance.
        self.dba_id = dba_id
        # The nickname of the DBA of the instance.
        self.dba_nick_name = dba_nick_name
        # Indicates whether the lock-free schema change feature is enabled for the database instance.
        self.ddl_online = ddl_online
        # The ID of the ECS instance on which the database instance is deployed.
        self.ecs_instance_id = ecs_instance_id
        # The ID of the region in which the database instance resides.
        self.ecs_region = ecs_region
        # The type of the environment to which the database instance belongs. Valid values:
        # 
        # *   **product:** production environment
        # *   **dev**: development environment
        # *   **pre**: pre-release environment
        # *   **test**: test environment
        # *   **sit**: SIT environment
        # *   **uat**: UAT environment
        # *   **pet**: stress testing environment
        # *   **stag:** staging environment
        self.env_type = env_type
        # The timeout period for exporting data from the database instance.
        self.export_timeout = export_timeout
        # The host address that is used to connect to the database instance.
        self.host = host
        # The alias of the database instance.
        self.instance_alias = instance_alias
        # The ID of the instance.
        self.instance_id = instance_id
        # The source of the database instance.
        self.instance_source = instance_source
        # The type of the database instance.
        self.instance_type = instance_type
        # The IDs of the owners of the database instance.
        self.owner_id_list = owner_id_list
        # The nicknames of the owners of the database instance.
        self.owner_name_list = owner_name_list
        # The port number that is used to connect to the database instance.
        self.port = port
        # The timeout period for querying data in the database instance.
        self.query_timeout = query_timeout
        # The ID of the security rule set of the database instance.
        self.safe_rule_id = safe_rule_id
        # Indicates whether the sensitive data protection feature is enabled. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.sell_sitd = sell_sitd
        self.sell_trust = sell_trust
        # The system ID (SID) of the database instance.
        self.sid = sid
        # The control mode of the database instance.
        self.standard_group = standard_group
        # The status of the database instance.
        self.state = state
        # Indicates whether the cross-database query feature is enabled for the database instance. Valid values:
        # 
        # *   **0**: disabled
        # *   **1:**: enabled
        self.use_dsql = use_dsql
        # The ID of the VPC to which the database instance belongs.
        self.vpc_id = vpc_id

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_nick_name is not None:
            result['DbaNickName'] = self.dba_nick_name
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule_id is not None:
            result['SafeRuleId'] = self.safe_rule_id
        if self.sell_sitd is not None:
            result['SellSitd'] = self.sell_sitd
        if self.sell_trust is not None:
            result['SellTrust'] = self.sell_trust
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaNickName') is not None:
            self.dba_nick_name = m.get('DbaNickName')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerIdList') is not None:
            temp_model = ListInstancesResponseBodyInstanceListInstanceOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListInstancesResponseBodyInstanceListInstanceOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRuleId') is not None:
            self.safe_rule_id = m.get('SafeRuleId')
        if m.get('SellSitd') is not None:
            self.sell_sitd = m.get('SellSitd')
        if m.get('SellTrust') is not None:
            self.sell_trust = m.get('SellTrust')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('StandardGroup') is not None:
            temp_model = ListInstancesResponseBodyInstanceListInstanceStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListInstancesResponseBodyInstanceList(TeaModel):
    def __init__(
        self,
        instance: List[ListInstancesResponseBodyInstanceListInstance] = None,
    ):
        self.instance = instance

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = ListInstancesResponseBodyInstanceListInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class ListInstancesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        instance_list: ListInstancesResponseBodyInstanceList = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The information about the database instances that are returned.
        self.instance_list = instance_list
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The total number of database instances that are returned.
        self.total_count = total_count

    def validate(self):
        if self.instance_list:
            self.instance_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_list is not None:
            result['InstanceList'] = self.instance_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceList') is not None:
            temp_model = ListInstancesResponseBodyInstanceList()
            self.instance_list = temp_model.from_map(m['InstanceList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLhTaskFlowAndScenarioRequest(TeaModel):
    def __init__(
        self,
        space_id: int = None,
        tid: int = None,
        user_id: int = None,
    ):
        # The ID of the workspace. You can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to obtain the workspace ID.
        # 
        # This parameter is required.
        self.space_id = space_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid
        # The ID of the user. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain the user ID.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag(TeaModel):
    def __init__(
        self,
        can_edit: bool = None,
        creator_id: str = None,
        creator_nick_name: str = None,
        dag_name: str = None,
        dag_owner_id: str = None,
        dag_owner_nick_name: str = None,
        data_flow_id: int = None,
        demo_id: str = None,
        deploy_id: int = None,
        id: int = None,
        is_deleted: bool = None,
        latest_instance_status: int = None,
        latest_instance_time: int = None,
        scenario_id: int = None,
        space_id: int = None,
        status: int = None,
    ):
        # Indicates whether the task flow can be modified. Valid values:
        # 
        # *   **true**: The task flow can be modified.
        # *   **false**: The task flow cannot be modified.
        self.can_edit = can_edit
        # The ID of the user who creates the task flow.
        self.creator_id = creator_id
        # The name of the user who creates the workspace.
        self.creator_nick_name = creator_nick_name
        # The name of the task flow.
        self.dag_name = dag_name
        # The user ID of the task flow owner.
        self.dag_owner_id = dag_owner_id
        # The name of the task flow owner.
        self.dag_owner_nick_name = dag_owner_nick_name
        # The extended field. No meaning is specified for this field.
        self.data_flow_id = data_flow_id
        # The extended field. No meaning is specified for this field.
        self.demo_id = demo_id
        # The ID of the latest deployment record.
        self.deploy_id = deploy_id
        # The ID of the task flow.
        self.id = id
        # Indicates whether the task flow is deleted. Valid values:
        # 
        # *   **true**: deleted
        # *   **false**: not deleted
        self.is_deleted = is_deleted
        # The status of the latest execution. Valid values:
        # 
        # *   **0**: invalid
        # *   **1**: scheduling disabled
        # *   **2**: waiting to be scheduled
        self.latest_instance_status = latest_instance_status
        # The time when the latest execution record was generated.
        self.latest_instance_time = latest_instance_time
        # The ID of the business scenario.
        self.scenario_id = scenario_id
        # The ID of the workspace.
        self.space_id = space_id
        # The status of the task flow. Valid values:
        # 
        # *   **0**: invalid
        # *   **1**: scheduling disabled
        # *   **2**: waiting to be scheduled
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_edit is not None:
            result['CanEdit'] = self.can_edit
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick_name is not None:
            result['CreatorNickName'] = self.creator_nick_name
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.data_flow_id is not None:
            result['DataFlowId'] = self.data_flow_id
        if self.demo_id is not None:
            result['DemoId'] = self.demo_id
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.id is not None:
            result['Id'] = self.id
        if self.is_deleted is not None:
            result['IsDeleted'] = self.is_deleted
        if self.latest_instance_status is not None:
            result['LatestInstanceStatus'] = self.latest_instance_status
        if self.latest_instance_time is not None:
            result['LatestInstanceTime'] = self.latest_instance_time
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanEdit') is not None:
            self.can_edit = m.get('CanEdit')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNickName') is not None:
            self.creator_nick_name = m.get('CreatorNickName')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('DataFlowId') is not None:
            self.data_flow_id = m.get('DataFlowId')
        if m.get('DemoId') is not None:
            self.demo_id = m.get('DemoId')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsDeleted') is not None:
            self.is_deleted = m.get('IsDeleted')
        if m.get('LatestInstanceStatus') is not None:
            self.latest_instance_status = m.get('LatestInstanceStatus')
        if m.get('LatestInstanceTime') is not None:
            self.latest_instance_time = m.get('LatestInstanceTime')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListLhTaskFlowAndScenarioResponseBodyRawDAGList(TeaModel):
    def __init__(
        self,
        dag: List[ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag] = None,
    ):
        self.dag = dag

    def validate(self):
        if self.dag:
            for k in self.dag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Dag'] = []
        if self.dag is not None:
            for k in self.dag:
                result['Dag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dag = []
        if m.get('Dag') is not None:
            for k in m.get('Dag'):
                temp_model = ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag()
                self.dag.append(temp_model.from_map(k))
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag(TeaModel):
    def __init__(
        self,
        can_edit: bool = None,
        creator_id: str = None,
        creator_nick_name: str = None,
        dag_name: str = None,
        dag_owner_id: str = None,
        dag_owner_nick_name: str = None,
        data_flow_id: int = None,
        demo_id: str = None,
        deploy_id: int = None,
        id: int = None,
        is_deleted: bool = None,
        latest_instance_status: int = None,
        latest_instance_time: int = None,
        scenario_id: int = None,
        space_id: int = None,
        status: int = None,
    ):
        # Indicates whether the task flow can be modified. Valid values:
        # 
        # - **true**: The task flow can be modified.
        # - **false**: The task flow cannot be modified.
        self.can_edit = can_edit
        # The ID of the user who creates the task flow.
        self.creator_id = creator_id
        # The name of the user who creates the workspace.
        self.creator_nick_name = creator_nick_name
        # The name of the task flow.
        self.dag_name = dag_name
        # The user ID of the task flow owner.
        self.dag_owner_id = dag_owner_id
        # The name of the task flow owner.
        self.dag_owner_nick_name = dag_owner_nick_name
        # The extended field. No meaning is specified for this field.
        self.data_flow_id = data_flow_id
        # The extended field. No meaning is specified for this field.
        self.demo_id = demo_id
        # The ID of the latest deployment record.
        self.deploy_id = deploy_id
        # The ID of the task flow.
        self.id = id
        # Indicates whether the task flow is deleted. Valid values:
        # 
        # - **true**: deleted
        # - **false**: not deleted
        self.is_deleted = is_deleted
        # The status of the latest execution. Valid values:
        # 
        # - 0: invalid
        # - 1: scheduling disabled
        # - 2: waiting to be scheduled
        self.latest_instance_status = latest_instance_status
        # The time when the latest execution record was generated.
        self.latest_instance_time = latest_instance_time
        # The ID of the business scenario.
        self.scenario_id = scenario_id
        # The ID of the workspace.
        self.space_id = space_id
        # The status of the task flow. Valid values:
        # 
        # - **0**: invalid
        # - **1**: scheduling disabled
        # - **2**: waiting to be scheduled
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_edit is not None:
            result['CanEdit'] = self.can_edit
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick_name is not None:
            result['CreatorNickName'] = self.creator_nick_name
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.data_flow_id is not None:
            result['DataFlowId'] = self.data_flow_id
        if self.demo_id is not None:
            result['DemoId'] = self.demo_id
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.id is not None:
            result['Id'] = self.id
        if self.is_deleted is not None:
            result['IsDeleted'] = self.is_deleted
        if self.latest_instance_status is not None:
            result['LatestInstanceStatus'] = self.latest_instance_status
        if self.latest_instance_time is not None:
            result['LatestInstanceTime'] = self.latest_instance_time
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanEdit') is not None:
            self.can_edit = m.get('CanEdit')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNickName') is not None:
            self.creator_nick_name = m.get('CreatorNickName')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('DataFlowId') is not None:
            self.data_flow_id = m.get('DataFlowId')
        if m.get('DemoId') is not None:
            self.demo_id = m.get('DemoId')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsDeleted') is not None:
            self.is_deleted = m.get('IsDeleted')
        if m.get('LatestInstanceStatus') is not None:
            self.latest_instance_status = m.get('LatestInstanceStatus')
        if m.get('LatestInstanceTime') is not None:
            self.latest_instance_time = m.get('LatestInstanceTime')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList(TeaModel):
    def __init__(
        self,
        dag: List[ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag] = None,
    ):
        self.dag = dag

    def validate(self):
        if self.dag:
            for k in self.dag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Dag'] = []
        if self.dag is not None:
            for k in self.dag:
                result['Dag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dag = []
        if m.get('Dag') is not None:
            for k in m.get('Dag'):
                temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag()
                self.dag.append(temp_model.from_map(k))
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario(TeaModel):
    def __init__(
        self,
        creator_id: str = None,
        description: str = None,
        scenario_name: str = None,
    ):
        # The ID of the user who creates the business scenario.
        self.creator_id = creator_id
        # The description of the business scenario.
        self.description = description
        # The name of the business scenario.
        self.scenario_name = scenario_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.scenario_name is not None:
            result['ScenarioName'] = self.scenario_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ScenarioName') is not None:
            self.scenario_name = m.get('ScenarioName')
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG(TeaModel):
    def __init__(
        self,
        dag_list: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList = None,
        scenario: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario = None,
    ):
        # The list of task flows.
        self.dag_list = dag_list
        # The information about the business scenario.
        self.scenario = scenario

    def validate(self):
        if self.dag_list:
            self.dag_list.validate()
        if self.scenario:
            self.scenario.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_list is not None:
            result['DagList'] = self.dag_list.to_map()
        if self.scenario is not None:
            result['Scenario'] = self.scenario.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagList') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList()
            self.dag_list = temp_model.from_map(m['DagList'])
        if m.get('Scenario') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario()
            self.scenario = temp_model.from_map(m['Scenario'])
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList(TeaModel):
    def __init__(
        self,
        scenario_dag: List[ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG] = None,
    ):
        self.scenario_dag = scenario_dag

    def validate(self):
        if self.scenario_dag:
            for k in self.scenario_dag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ScenarioDAG'] = []
        if self.scenario_dag is not None:
            for k in self.scenario_dag:
                result['ScenarioDAG'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.scenario_dag = []
        if m.get('ScenarioDAG') is not None:
            for k in m.get('ScenarioDAG'):
                temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG()
                self.scenario_dag.append(temp_model.from_map(k))
        return self


class ListLhTaskFlowAndScenarioResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        raw_daglist: ListLhTaskFlowAndScenarioResponseBodyRawDAGList = None,
        request_id: str = None,
        scenario_daglist: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The task flows in the default business scenario.
        self.raw_daglist = raw_daglist
        # The ID of the request.
        self.request_id = request_id
        # The task flows in other business scenarios.
        self.scenario_daglist = scenario_daglist
        # Indicates whether the request is successful. Valid values:
        # 
        # - **true**: The request is successful.
        # - **false**: The request fails.
        self.success = success

    def validate(self):
        if self.raw_daglist:
            self.raw_daglist.validate()
        if self.scenario_daglist:
            self.scenario_daglist.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.raw_daglist is not None:
            result['RawDAGList'] = self.raw_daglist.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scenario_daglist is not None:
            result['ScenarioDAGList'] = self.scenario_daglist.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RawDAGList') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBodyRawDAGList()
            self.raw_daglist = temp_model.from_map(m['RawDAGList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScenarioDAGList') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList()
            self.scenario_daglist = temp_model.from_map(m['ScenarioDAGList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListLhTaskFlowAndScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLhTaskFlowAndScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLogicDatabasesRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds(TeaModel):
    def __init__(
        self,
        database_ids: List[int] = None,
    ):
        self.database_ids = database_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseIds') is not None:
            self.database_ids = m.get('DatabaseIds')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_id: str = None,
        database_ids: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        owner_id_list: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList = None,
        owner_name_list: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList = None,
        schema_name: str = None,
        search_name: str = None,
    ):
        # The alias of the logical database.
        self.alias = alias
        # The ID of the logical database.
        self.database_id = database_id
        # Logical database sub-ID list.
        self.database_ids = database_ids
        # The type of the logical database. For more information about the valid values of this parameter, see [DbType parameter](https://www.alibabacloud.com/help/en/data-management-service/latest/dbtype-parameter).
        self.db_type = db_type
        # The type of the environment to which the logical database belongs. Valid values:
        # 
        # - **product**: production environment
        # - **dev**: development environment
        # - **pre**: staging environment
        # - **test**: test environment
        # - **sit**: system integration testing (SIT) environment
        # - **uat**: user acceptance testing (UAT) environment
        # - **pet**: stress testing environment
        # - **stag**: STAG environment
        self.env_type = env_type
        # Indicates whether the database is a logical database. The return value is true.
        self.logic = logic
        # The IDs of the owners of the logical database.
        self.owner_id_list = owner_id_list
        # The names of the owners of the logical database.
        self.owner_name_list = owner_name_list
        # The name of the logical database.
        self.schema_name = schema_name
        # The name that is used to search for the logical database.
        # 
        # > We recommend that you do not use this parameter for business development. The format of the parameter value may be modified in later versions.
        self.search_name = search_name

    def validate(self):
        if self.database_ids:
            self.database_ids.validate()
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids.to_map()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatabaseIds') is not None:
            temp_model = ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds()
            self.database_ids = temp_model.from_map(m['DatabaseIds'])
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseList(TeaModel):
    def __init__(
        self,
        logic_database: List[ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase] = None,
    ):
        self.logic_database = logic_database

    def validate(self):
        if self.logic_database:
            for k in self.logic_database:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogicDatabase'] = []
        if self.logic_database is not None:
            for k in self.logic_database:
                result['LogicDatabase'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.logic_database = []
        if m.get('LogicDatabase') is not None:
            for k in m.get('LogicDatabase'):
                temp_model = ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase()
                self.logic_database.append(temp_model.from_map(k))
        return self


class ListLogicDatabasesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        logic_database_list: ListLogicDatabasesResponseBodyLogicDatabaseList = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The details of logical databases.
        self.logic_database_list = logic_database_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - **true**: The request is successful.
        # - **false**: The request fails.
        self.success = success
        # The total number of logical databases.
        self.total_count = total_count

    def validate(self):
        if self.logic_database_list:
            self.logic_database_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_database_list is not None:
            result['LogicDatabaseList'] = self.logic_database_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicDatabaseList') is not None:
            temp_model = ListLogicDatabasesResponseBodyLogicDatabaseList()
            self.logic_database_list = temp_model.from_map(m['LogicDatabaseList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLogicDatabasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLogicDatabasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLogicDatabasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLogicTableRouteConfigRequest(TeaModel):
    def __init__(
        self,
        table_id: int = None,
        tid: int = None,
    ):
        # The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
        # 
        # This parameter is required.
        self.table_id = table_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig(TeaModel):
    def __init__(
        self,
        route_expr: str = None,
        route_key: str = None,
        table_id: int = None,
    ):
        # The routing algorithm expression.
        self.route_expr = route_expr
        # The unique key of the routing algorithm.
        self.route_key = route_key
        # The ID of the logical table.
        self.table_id = table_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_expr is not None:
            result['RouteExpr'] = self.route_expr
        if self.route_key is not None:
            result['RouteKey'] = self.route_key
        if self.table_id is not None:
            result['TableId'] = self.table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RouteExpr') is not None:
            self.route_expr = m.get('RouteExpr')
        if m.get('RouteKey') is not None:
            self.route_key = m.get('RouteKey')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        return self


class ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList(TeaModel):
    def __init__(
        self,
        logic_table_route_config: List[ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig] = None,
    ):
        self.logic_table_route_config = logic_table_route_config

    def validate(self):
        if self.logic_table_route_config:
            for k in self.logic_table_route_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogicTableRouteConfig'] = []
        if self.logic_table_route_config is not None:
            for k in self.logic_table_route_config:
                result['LogicTableRouteConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.logic_table_route_config = []
        if m.get('LogicTableRouteConfig') is not None:
            for k in m.get('LogicTableRouteConfig'):
                temp_model = ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig()
                self.logic_table_route_config.append(temp_model.from_map(k))
        return self


class ListLogicTableRouteConfigResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        logic_table_route_config_list: ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The routing algorithms.
        self.logic_table_route_config_list = logic_table_route_config_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        if self.logic_table_route_config_list:
            self.logic_table_route_config_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_table_route_config_list is not None:
            result['LogicTableRouteConfigList'] = self.logic_table_route_config_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicTableRouteConfigList') is not None:
            temp_model = ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList()
            self.logic_table_route_config_list = temp_model.from_map(m['LogicTableRouteConfigList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListLogicTableRouteConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLogicTableRouteConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLogicTableRouteConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLogicTablesRequest(TeaModel):
    def __init__(
        self,
        database_id: str = None,
        page_number: int = None,
        page_size: int = None,
        return_guid: bool = None,
        search_name: str = None,
        tid: int = None,
    ):
        # The ID of the logical database.
        # 
        # This parameter is required.
        self.database_id = database_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # Specifies whether to return the GUID of the table.
        self.return_guid = return_guid
        # The keyword that is used to search for the logical tables. Prefix match is supported.
        self.search_name = search_name
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.return_guid is not None:
            result['ReturnGuid'] = self.return_guid
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ReturnGuid') is not None:
            self.return_guid = m.get('ReturnGuid')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListLogicTablesResponseBodyLogicTableListLogicTable(TeaModel):
    def __init__(
        self,
        database_id: str = None,
        logic: bool = None,
        owner_id_list: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList = None,
        owner_name_list: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList = None,
        schema_name: str = None,
        table_count: str = None,
        table_expr: str = None,
        table_guid: str = None,
        table_id: str = None,
        table_name: str = None,
    ):
        # The ID of the logical database.
        self.database_id = database_id
        # Indicates whether the table is a logical table. The value is fixed to true.
        self.logic = logic
        # The IDs of the owners of the logical tables.
        self.owner_id_list = owner_id_list
        # The nicknames of the owners of the logical tables.
        self.owner_name_list = owner_name_list
        # The logical database to which the logical table belongs.
        self.schema_name = schema_name
        # The number of logical tables.
        self.table_count = table_count
        # The expression of the logical table.
        self.table_expr = table_expr
        # The GUID of the logical table.
        self.table_guid = table_guid
        # The ID of the logical table.
        self.table_id = table_id
        # The name of the logical table.
        self.table_name = table_name

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_count is not None:
            result['TableCount'] = self.table_count
        if self.table_expr is not None:
            result['TableExpr'] = self.table_expr
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableCount') is not None:
            self.table_count = m.get('TableCount')
        if m.get('TableExpr') is not None:
            self.table_expr = m.get('TableExpr')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListLogicTablesResponseBodyLogicTableList(TeaModel):
    def __init__(
        self,
        logic_table: List[ListLogicTablesResponseBodyLogicTableListLogicTable] = None,
    ):
        self.logic_table = logic_table

    def validate(self):
        if self.logic_table:
            for k in self.logic_table:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogicTable'] = []
        if self.logic_table is not None:
            for k in self.logic_table:
                result['LogicTable'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.logic_table = []
        if m.get('LogicTable') is not None:
            for k in m.get('LogicTable'):
                temp_model = ListLogicTablesResponseBodyLogicTableListLogicTable()
                self.logic_table.append(temp_model.from_map(k))
        return self


class ListLogicTablesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        logic_table_list: ListLogicTablesResponseBodyLogicTableList = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The details of the logical tables.
        self.logic_table_list = logic_table_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success
        # The total number of logical tables that meet the query conditions.
        self.total_count = total_count

    def validate(self):
        if self.logic_table_list:
            self.logic_table_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_table_list is not None:
            result['LogicTableList'] = self.logic_table_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicTableList') is not None:
            temp_model = ListLogicTablesResponseBodyLogicTableList()
            self.logic_table_list = temp_model.from_map(m['LogicTableList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLogicTablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLogicTablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLogicTablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMetaCategoryRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        parent_category_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.parent_category_id = parent_category_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_category_id is not None:
            result['ParentCategoryId'] = self.parent_category_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentCategoryId') is not None:
            self.parent_category_id = m.get('ParentCategoryId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListMetaCategoryResponseBodyCategoryList(TeaModel):
    def __init__(
        self,
        meta_category: List[MetaCategory] = None,
    ):
        self.meta_category = meta_category

    def validate(self):
        if self.meta_category:
            for k in self.meta_category:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MetaCategory'] = []
        if self.meta_category is not None:
            for k in self.meta_category:
                result['MetaCategory'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.meta_category = []
        if m.get('MetaCategory') is not None:
            for k in m.get('MetaCategory'):
                temp_model = MetaCategory()
                self.meta_category.append(temp_model.from_map(k))
        return self


class ListMetaCategoryResponseBody(TeaModel):
    def __init__(
        self,
        category_list: ListMetaCategoryResponseBodyCategoryList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.category_list = category_list
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.category_list:
            self.category_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_list is not None:
            result['CategoryList'] = self.category_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryList') is not None:
            temp_model = ListMetaCategoryResponseBodyCategoryList()
            self.category_list = temp_model.from_map(m['CategoryList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListMetaCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMetaCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMetaCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOrdersRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        order_result_type: str = None,
        order_status: str = None,
        page_number: int = None,
        page_size: int = None,
        plugin_type: str = None,
        search_content: str = None,
        search_date_type: str = None,
        start_time: str = None,
        tid: int = None,
    ):
        # The end of the time range to query.
        self.end_time = end_time
        # The scope of the tickets that you want to query. Valid values:
        # 
        # *   **AS_ADMIN**: all tickets.
        # *   **AS_COMMITTER**: the tickets that are submitted by the current user.
        # *   **AS_HANDLER**: the tickets to be processed by the current user.
        # *   **AS_OWNER**: the tickets that are processed by the current user.
        # *   **AS_Related**: the tickets that are related to the current user.
        self.order_result_type = order_result_type
        # The status of the tickets that you want to query. Valid values:
        # 
        # *   **ALL**: queries the tickets of all statuses.
        # *   **FINISHED**: queries the tickets that are completed.
        # *   **RUNNING**: queries the tickets that are being processed.
        self.order_status = order_status
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The type of the tickets that you want to query. For more information, see [PluginType parameter](https://help.aliyun.com/document_detail/429109.html).
        self.plugin_type = plugin_type
        # The keyword that is used to query tickets.
        self.search_content = search_content
        # The time condition based on which you want to query tickets. Valid values:
        # 
        # *   **CREATE_TIME**: the time when a ticket was created.
        # *   **MODIFY_TIME**: the time when a ticket was last modified.
        self.search_date_type = search_date_type
        # The beginning of the time range to query.
        self.start_time = start_time
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.order_result_type is not None:
            result['OrderResultType'] = self.order_result_type
        if self.order_status is not None:
            result['OrderStatus'] = self.order_status
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.search_content is not None:
            result['SearchContent'] = self.search_content
        if self.search_date_type is not None:
            result['SearchDateType'] = self.search_date_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OrderResultType') is not None:
            self.order_result_type = m.get('OrderResultType')
        if m.get('OrderStatus') is not None:
            self.order_status = m.get('OrderStatus')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('SearchContent') is not None:
            self.search_content = m.get('SearchContent')
        if m.get('SearchDateType') is not None:
            self.search_date_type = m.get('SearchDateType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListOrdersResponseBodyOrdersOrder(TeaModel):
    def __init__(
        self,
        comment: str = None,
        committer: str = None,
        committer_id: int = None,
        create_time: str = None,
        last_modify_time: str = None,
        order_id: int = None,
        plugin_type: str = None,
        status_code: str = None,
        status_desc: str = None,
    ):
        # The remarks of the ticket.
        self.comment = comment
        # The user who submitted the ticket.
        self.committer = committer
        # The ID of the user who submitted the ticket.
        self.committer_id = committer_id
        # The time when the ticket was created.
        self.create_time = create_time
        # The time when the ticket was last modified.
        self.last_modify_time = last_modify_time
        # The ID of the ticket.
        self.order_id = order_id
        # The type of the ticket.
        self.plugin_type = plugin_type
        # The status code of the ticket. Valid values:
        # 
        # *   **fail**: The ticket fails to be executed.
        # *   **toaudit**: The ticket is waiting for approval.
        # *   **cancel**: The ticket is cancelled.
        # *   **processing**: The ticket is being executed.
        # *   **approved**: The ticket is approved.
        # *   **reject**: The ticket is rejected.
        # *   **success**: The ticket is executed.
        # *   **closed**: The ticket is closed.
        self.status_code = status_code
        # The status description of the ticket.
        self.status_desc = status_desc

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.committer is not None:
            result['Committer'] = self.committer
        if self.committer_id is not None:
            result['CommitterId'] = self.committer_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modify_time is not None:
            result['LastModifyTime'] = self.last_modify_time
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Committer') is not None:
            self.committer = m.get('Committer')
        if m.get('CommitterId') is not None:
            self.committer_id = m.get('CommitterId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModifyTime') is not None:
            self.last_modify_time = m.get('LastModifyTime')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        return self


class ListOrdersResponseBodyOrders(TeaModel):
    def __init__(
        self,
        order: List[ListOrdersResponseBodyOrdersOrder] = None,
    ):
        self.order = order

    def validate(self):
        if self.order:
            for k in self.order:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Order'] = []
        if self.order is not None:
            for k in self.order:
                result['Order'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.order = []
        if m.get('Order') is not None:
            for k in m.get('Order'):
                temp_model = ListOrdersResponseBodyOrdersOrder()
                self.order.append(temp_model.from_map(k))
        return self


class ListOrdersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        orders: ListOrdersResponseBodyOrders = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The details about the tickets.
        self.orders = orders
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success
        # The total number of entries that are returned.
        self.total_count = total_count

    def validate(self):
        if self.orders:
            self.orders.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.orders is not None:
            result['Orders'] = self.orders.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Orders') is not None:
            temp_model = ListOrdersResponseBodyOrders()
            self.orders = temp_model.from_map(m['Orders'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListOrdersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOrdersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOrdersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProxiesRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListProxiesResponseBodyProxyList(TeaModel):
    def __init__(
        self,
        creator_id: int = None,
        creator_name: str = None,
        https_port: int = None,
        instance_id: int = None,
        private_enable: bool = None,
        private_host: str = None,
        protocol_port: int = None,
        protocol_type: str = None,
        proxy_id: int = None,
        public_enable: bool = None,
        public_host: str = None,
        region_id: str = None,
    ):
        # The ID of the user who enabled the secure access proxy feature.
        self.creator_id = creator_id
        # The nickname of the user who enabled the secure access proxy feature.
        self.creator_name = creator_name
        # The number of the port that was used by HTTPS clients to connect to the database instance.
        self.https_port = https_port
        # The ID of the instance.
        self.instance_id = instance_id
        # Indicates whether the internal endpoint is enabled. Default value: **true**.
        self.private_enable = private_enable
        # The internal endpoint.
        self.private_host = private_host
        # The number of the port that is used to connect the database instance.
        self.protocol_port = protocol_port
        # The type of the database. Example: MYSQL.
        self.protocol_type = protocol_type
        # The ID of the secure access proxy.
        self.proxy_id = proxy_id
        # Indicates whether the public endpoint is enabled. Valid values:
        # 
        # *   **true**: The public endpoint is enabled.
        # *   **false**: The public endpoint is disabled.
        self.public_enable = public_enable
        # The public endpoint. A public endpoint is returned no matter whether the public endpoint is enabled or disabled.
        # 
        # > 
        # 
        # *   If the value of the PublicEnable parameter is **true**, a valid public endpoint that can be resolved by using Alibaba Cloud DNS (DNS) is returned.
        # 
        # *   If the value of the PublicEnable parameter is **false**, an invalid public endpoint that cannot be resolved by using DNS is returned.
        self.public_host = public_host
        # The ID of the region.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_name is not None:
            result['CreatorName'] = self.creator_name
        if self.https_port is not None:
            result['HttpsPort'] = self.https_port
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.private_enable is not None:
            result['PrivateEnable'] = self.private_enable
        if self.private_host is not None:
            result['PrivateHost'] = self.private_host
        if self.protocol_port is not None:
            result['ProtocolPort'] = self.protocol_port
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.public_enable is not None:
            result['PublicEnable'] = self.public_enable
        if self.public_host is not None:
            result['PublicHost'] = self.public_host
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorName') is not None:
            self.creator_name = m.get('CreatorName')
        if m.get('HttpsPort') is not None:
            self.https_port = m.get('HttpsPort')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PrivateEnable') is not None:
            self.private_enable = m.get('PrivateEnable')
        if m.get('PrivateHost') is not None:
            self.private_host = m.get('PrivateHost')
        if m.get('ProtocolPort') is not None:
            self.protocol_port = m.get('ProtocolPort')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('PublicEnable') is not None:
            self.public_enable = m.get('PublicEnable')
        if m.get('PublicHost') is not None:
            self.public_host = m.get('PublicHost')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListProxiesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        proxy_list: List[ListProxiesResponseBodyProxyList] = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The proxies that are generated by the secure access proxy feature.
        self.proxy_list = proxy_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.proxy_list:
            for k in self.proxy_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['ProxyList'] = []
        if self.proxy_list is not None:
            for k in self.proxy_list:
                result['ProxyList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.proxy_list = []
        if m.get('ProxyList') is not None:
            for k in m.get('ProxyList'):
                temp_model = ListProxiesResponseBodyProxyList()
                self.proxy_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListProxiesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProxiesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProxiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProxyAccessesRequest(TeaModel):
    def __init__(
        self,
        proxy_id: int = None,
        tid: int = None,
    ):
        # The ID of the secure access proxy. 
        # 
        # >  You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) operation to query the ID of the secure access proxy.
        # 
        # This parameter is required.
        self.proxy_id = proxy_id
        # The ID of the tenant. 
        # 
        # >  You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListProxyAccessesResponseBodyProxyAccessList(TeaModel):
    def __init__(
        self,
        access_id: str = None,
        gmt_create: str = None,
        indep_account: str = None,
        instance_id: int = None,
        origin_info: str = None,
        proxy_access_id: int = None,
        proxy_id: int = None,
        user_id: int = None,
        user_name: str = None,
        user_uid: str = None,
    ):
        # The username of the database account that is authorized to access the database instance by using the secure access proxy feature.
        self.access_id = access_id
        # The time when the user is authorized to access the database instance by using the secure access proxy feature.
        self.gmt_create = gmt_create
        # The username of the independent database account.
        self.indep_account = indep_account
        # The ID of the database instance.
        self.instance_id = instance_id
        # The method that is used to authorize the user to access the database instance by using the secure access proxy feature. Valid values: 
        # 
        # - **Authorization by the Alibaba Cloud Account ()**: The information in the parentheses () indicates the user ID (UID) of the Alibaba Cloud account.
        # - **Authorization by submitting the ticket ()**:The information in the parentheses () indicates the number of the ticket that the user submits to apply for permissions.
        self.origin_info = origin_info
        # The ID that DMS generates after the user is authorized to access the database instance by using the secure access proxy feature. The ID is unique in DMS.
        self.proxy_access_id = proxy_access_id
        # The ID of the secure access proxy.
        self.proxy_id = proxy_id
        # The ID of the user.
        self.user_id = user_id
        # The nickname of the user.
        self.user_name = user_name
        # The UID of the Alibaba Cloud account.
        self.user_uid = user_uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.indep_account is not None:
            result['IndepAccount'] = self.indep_account
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.origin_info is not None:
            result['OriginInfo'] = self.origin_info
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_uid is not None:
            result['UserUid'] = self.user_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('IndepAccount') is not None:
            self.indep_account = m.get('IndepAccount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OriginInfo') is not None:
            self.origin_info = m.get('OriginInfo')
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserUid') is not None:
            self.user_uid = m.get('UserUid')
        return self


class ListProxyAccessesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        proxy_access_list: List[ListProxyAccessesResponseBodyProxyAccessList] = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The information about the users that are authorized to access the database instance by using the secure access proxy feature.
        self.proxy_access_list = proxy_access_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        if self.proxy_access_list:
            for k in self.proxy_access_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['ProxyAccessList'] = []
        if self.proxy_access_list is not None:
            for k in self.proxy_access_list:
                result['ProxyAccessList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.proxy_access_list = []
        if m.get('ProxyAccessList') is not None:
            for k in m.get('ProxyAccessList'):
                temp_model = ListProxyAccessesResponseBodyProxyAccessList()
                self.proxy_access_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListProxyAccessesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProxyAccessesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProxyAccessesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProxySQLExecAuditLogRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        exec_state: str = None,
        op_user_name: str = None,
        page_number: int = None,
        page_size: int = None,
        sqltype: str = None,
        search_name: str = None,
        start_time: int = None,
        tid: int = None,
    ):
        # The end of the time range to query. The value of this parameter must be a timestamp that follows the UNIX time format.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The execution status of the SQL statement. Valid values:
        # 
        # *   **FAIL**: The execution of the SQL statement fails.
        # *   **CANCEL**: The execution of the SQL statement is canceled.
        # *   **SUCCESS**: The SQL statement is executed.
        self.exec_state = exec_state
        # The alias of the user.
        self.op_user_name = op_user_name
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum values: 100.
        self.page_size = page_size
        # The type of SQL statement. Valid values:
        # 
        # *   **SELECT**\
        # *   **INSERT**\
        # *   **DELETE**\
        # *   **CREATE_TABLE**\
        # 
        # >  You can choose Operation Audit > Secure Access Proxy in the top navigation bar of the DMS console to view more types of SQL statements.
        self.sqltype = sqltype
        # The name of the database instance.
        self.search_name = search_name
        # The beginning of the time range to query. The value of this parameter must be a timestamp that follows the UNIX time format.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.exec_state is not None:
            result['ExecState'] = self.exec_state
        if self.op_user_name is not None:
            result['OpUserName'] = self.op_user_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sqltype is not None:
            result['SQLType'] = self.sqltype
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecState') is not None:
            self.exec_state = m.get('ExecState')
        if m.get('OpUserName') is not None:
            self.op_user_name = m.get('OpUserName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SQLType') is not None:
            self.sqltype = m.get('SQLType')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog(TeaModel):
    def __init__(
        self,
        affect_rows: int = None,
        elapsed_time: int = None,
        exec_state: str = None,
        instance_id: int = None,
        instance_name: str = None,
        op_time: str = None,
        remark: str = None,
        sql: str = None,
        sqltype: str = None,
        schema_name: str = None,
        user_id: int = None,
        user_name: str = None,
    ):
        # Indicates the total number of rows returned after the SQL statement was executed. If an SELECT SQL statement is executed, the return value of this parameter indicates the total number of the queried data rows.
        self.affect_rows = affect_rows
        # The amount of time that is consumed to execute the SQL statement. Unit: milliseconds.
        self.elapsed_time = elapsed_time
        # The execution status of the SQL statement. Valid values:
        # 
        # *   **FAIL**: The execution of the SQL statement fails.
        # *   **CANCEL**: The execution of the SQL statement is canceled.
        # *   **SUCCESS**: The SQL statement is executed.
        self.exec_state = exec_state
        # The ID of the database instance.
        self.instance_id = instance_id
        # The name of the database instance.
        self.instance_name = instance_name
        # The time at which the user executes the SQL statement on the database instance. The value of this parameter must be a timestamp that follows the UNIX time format.
        self.op_time = op_time
        # The description.
        self.remark = remark
        # The SQL statement that was executed.
        self.sql = sql
        # The type of the SQL statement. Valid values:
        # 
        # *   **SELECT**\
        # *   **INSERT**\
        # *   **DELETE**\
        # *   **CREATE_TABLE**\
        # 
        # >  You can choose Operation Audit > Secure Access Proxy in the top navigation bar of the DMS console to view more types of SQL statements.
        self.sqltype = sqltype
        # The name of the database.
        self.schema_name = schema_name
        # The ID of the user.
        self.user_id = user_id
        # The nickname of the user.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.exec_state is not None:
            result['ExecState'] = self.exec_state
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sql is not None:
            result['SQL'] = self.sql
        if self.sqltype is not None:
            result['SQLType'] = self.sqltype
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('ExecState') is not None:
            self.exec_state = m.get('ExecState')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SQL') is not None:
            self.sql = m.get('SQL')
        if m.get('SQLType') is not None:
            self.sqltype = m.get('SQLType')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList(TeaModel):
    def __init__(
        self,
        proxy_sqlexec_audit_log: List[ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog] = None,
    ):
        self.proxy_sqlexec_audit_log = proxy_sqlexec_audit_log

    def validate(self):
        if self.proxy_sqlexec_audit_log:
            for k in self.proxy_sqlexec_audit_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ProxySQLExecAuditLog'] = []
        if self.proxy_sqlexec_audit_log is not None:
            for k in self.proxy_sqlexec_audit_log:
                result['ProxySQLExecAuditLog'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.proxy_sqlexec_audit_log = []
        if m.get('ProxySQLExecAuditLog') is not None:
            for k in m.get('ProxySQLExecAuditLog'):
                temp_model = ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog()
                self.proxy_sqlexec_audit_log.append(temp_model.from_map(k))
        return self


class ListProxySQLExecAuditLogResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        proxy_sqlexec_audit_log_list: ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The audit information about the database instance that is provided by the secure access proxy feature.
        self.proxy_sqlexec_audit_log_list = proxy_sqlexec_audit_log_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.proxy_sqlexec_audit_log_list:
            self.proxy_sqlexec_audit_log_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.proxy_sqlexec_audit_log_list is not None:
            result['ProxySQLExecAuditLogList'] = self.proxy_sqlexec_audit_log_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProxySQLExecAuditLogList') is not None:
            temp_model = ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList()
            self.proxy_sqlexec_audit_log_list = temp_model.from_map(m['ProxySQLExecAuditLogList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListProxySQLExecAuditLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProxySQLExecAuditLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProxySQLExecAuditLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSLARulesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSLARulesResponseBodySLARuleListSLARule(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        id: int = None,
        interval_minutes: int = None,
        node_id: int = None,
        rule_type: int = None,
    ):
        # The ID of the task flow.
        self.dag_id = dag_id
        # The ID of the SLA rule.
        self.id = id
        # The timeout period. Unit: minutes.
        self.interval_minutes = interval_minutes
        # The ID of the task node.
        self.node_id = node_id
        # The type of the rule. Valid values:
        # 
        # *   **0**: an SLA rule for a task flow
        # *   **1**: an SLA rule for a task node
        self.rule_type = rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.interval_minutes is not None:
            result['IntervalMinutes'] = self.interval_minutes
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IntervalMinutes') is not None:
            self.interval_minutes = m.get('IntervalMinutes')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        return self


class ListSLARulesResponseBodySLARuleList(TeaModel):
    def __init__(
        self,
        slarule: List[ListSLARulesResponseBodySLARuleListSLARule] = None,
    ):
        self.slarule = slarule

    def validate(self):
        if self.slarule:
            for k in self.slarule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SLARule'] = []
        if self.slarule is not None:
            for k in self.slarule:
                result['SLARule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.slarule = []
        if m.get('SLARule') is not None:
            for k in m.get('SLARule'):
                temp_model = ListSLARulesResponseBodySLARuleListSLARule()
                self.slarule.append(temp_model.from_map(k))
        return self


class ListSLARulesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        slarule_list: ListSLARulesResponseBodySLARuleList = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # The list of SLA rules.
        self.slarule_list = slarule_list
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.slarule_list:
            self.slarule_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.slarule_list is not None:
            result['SLARuleList'] = self.slarule_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SLARuleList') is not None:
            temp_model = ListSLARulesResponseBodySLARuleList()
            self.slarule_list = temp_model.from_map(m['SLARuleList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListSLARulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSLARulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSLARulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSQLExecAuditLogRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        exec_state: str = None,
        op_user_name: str = None,
        page_number: int = None,
        page_size: int = None,
        search_name: str = None,
        sql_type: str = None,
        start_time: str = None,
        tid: int = None,
    ):
        # The end of the time range to query.
        # 
        # >  The end time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format. We recommend that you use the StartTime and EndTime parameters to specify a time range that does not exceed one day. The returned entries can be displayed by page to improve query efficiency.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The execution status of the SQL statement. Valid values:
        # 
        # *   **FAIL**: The SQL statement fails to be executed.
        # *   **NOEXE**: The SQL statement has not been executed.
        # *   **RUNNING**: The SQL statement is being executed.
        # *   **CANCEL**: The execution of the SQL statement is canceled.
        # *   **SUCCESS**: The SQL statement is executed.
        self.exec_state = exec_state
        # The nickname of the user who wrote the SQL statement.
        self.op_user_name = op_user_name
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page. The value cannot exceed 100.
        self.page_size = page_size
        # The name of the database or instance based on which you want to query SQL statements.
        # 
        # >  If the SQL statements to be queried are at the instance level, you can set this parameter to an instance name. If the SQL statements to be queried are at the database level, you can set this parameter to a database name.
        self.search_name = search_name
        # The type of the SQL statement. Valid values:
        # 
        # *   **SELECT**: the SQL statement that is used to query data.
        # *   **INSERT**: the SQL statement that is used to insert data.
        # *   **DELETE**: the SQL statement that is used to delete data.
        # *   **CREATE_TABLE**: the SQL statement that is used to create tables.
        # 
        # >  To view more types of SQL statements, log on to the DMS console and click Security and Specifications. In the left-side navigation pane, click **Operation Audit**. Then, you can view all supported types of SQL statements from the **SQL type** drop-down list.
        self.sql_type = sql_type
        # The beginning of the time range to query.
        # 
        # >  The start time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.exec_state is not None:
            result['ExecState'] = self.exec_state
        if self.op_user_name is not None:
            result['OpUserName'] = self.op_user_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecState') is not None:
            self.exec_state = m.get('ExecState')
        if m.get('OpUserName') is not None:
            self.op_user_name = m.get('OpUserName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog(TeaModel):
    def __init__(
        self,
        affect_rows: int = None,
        db_id: int = None,
        elapsed_time: int = None,
        exec_state: str = None,
        instance_id: int = None,
        instance_name: str = None,
        logic: bool = None,
        op_time: str = None,
        remark: str = None,
        sql: str = None,
        sqltype: str = None,
        schema_name: str = None,
        user_id: int = None,
        user_name: str = None,
    ):
        # The number of rows affected by the SQL statement. For example, if you execute an SQL statement to query data, the number of retrieved rows is returned.
        self.affect_rows = affect_rows
        # The ID of the database.
        self.db_id = db_id
        # The amount of time consumed by the execution of the SQL statement. Unit: milliseconds.
        self.elapsed_time = elapsed_time
        # The execution status of the SQL statement. Valid values:
        # 
        # *   **FAIL**: The SQL statement fails to be executed.
        # *   **NOEXE**: The SQL statement has not been executed.
        # *   **RUNNING**: The SQL statement is being executed.
        # *   **CANCEL**: The execution of the SQL statement is canceled.
        # *   **SUCCESS**: The SQL statement is executed.
        self.exec_state = exec_state
        # The ID of the instance.
        self.instance_id = instance_id
        # The name of the database.
        # 
        # >  If the SQL statement takes effect on an instance, the name of the instance is returned.
        self.instance_name = instance_name
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic
        # The time when the operation specified by the SQL statement was performed on the instance or database.
        self.op_time = op_time
        # The comment on the SQL statement.
        self.remark = remark
        # The SQL statement that was written.
        self.sql = sql
        # The type of the SQL statement. Valid values:
        # 
        # *   **SELECT**: the SQL statement that is used to query data.
        # *   **INSERT**: the SQL statement that is used to insert data.
        # *   **DELETE**: the SQL statement that is used to delete data.
        # *   **CREATE_TABLE**: the SQL statement that is used to create tables.
        # 
        # >  To view more types of SQL statements, log on to the DMS console and click Security and Specifications. In the left-side navigation pane, click **Operation Audit**. Then, you can view all supported types of SQL statements from the **SQL type** drop-down list.
        self.sqltype = sqltype
        # The name of the database.
        self.schema_name = schema_name
        # The ID of the user who wrote the SQL statement.
        self.user_id = user_id
        # The nickname of the user who wrote the SQL statement.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.exec_state is not None:
            result['ExecState'] = self.exec_state
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sql is not None:
            result['SQL'] = self.sql
        if self.sqltype is not None:
            result['SQLType'] = self.sqltype
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('ExecState') is not None:
            self.exec_state = m.get('ExecState')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SQL') is not None:
            self.sql = m.get('SQL')
        if m.get('SQLType') is not None:
            self.sqltype = m.get('SQLType')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListSQLExecAuditLogResponseBodySQLExecAuditLogList(TeaModel):
    def __init__(
        self,
        sqlexec_audit_log: List[ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog] = None,
    ):
        self.sqlexec_audit_log = sqlexec_audit_log

    def validate(self):
        if self.sqlexec_audit_log:
            for k in self.sqlexec_audit_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SQLExecAuditLog'] = []
        if self.sqlexec_audit_log is not None:
            for k in self.sqlexec_audit_log:
                result['SQLExecAuditLog'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.sqlexec_audit_log = []
        if m.get('SQLExecAuditLog') is not None:
            for k in m.get('SQLExecAuditLog'):
                temp_model = ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog()
                self.sqlexec_audit_log.append(temp_model.from_map(k))
        return self


class ListSQLExecAuditLogResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sqlexec_audit_log_list: ListSQLExecAuditLogResponseBodySQLExecAuditLogList = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The entries returned.
        self.sqlexec_audit_log_list = sqlexec_audit_log_list
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.sqlexec_audit_log_list:
            self.sqlexec_audit_log_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sqlexec_audit_log_list is not None:
            result['SQLExecAuditLogList'] = self.sqlexec_audit_log_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SQLExecAuditLogList') is not None:
            temp_model = ListSQLExecAuditLogResponseBodySQLExecAuditLogList()
            self.sqlexec_audit_log_list = temp_model.from_map(m['SQLExecAuditLogList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSQLExecAuditLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSQLExecAuditLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSQLExecAuditLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSQLReviewOriginSQLRequestOrderActionDetailPage(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
    ):
        # The page number.
        self.page_number = page_number
        # The number of entries per page.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListSQLReviewOriginSQLRequestOrderActionDetail(TeaModel):
    def __init__(
        self,
        check_status_result: str = None,
        file_id: int = None,
        page: ListSQLReviewOriginSQLRequestOrderActionDetailPage = None,
        sqlreview_result: str = None,
    ):
        # The review status of the SQL statement. Valid values:
        # 
        # *   **new**: The SQL statement was waiting to be reviewed.
        # *   **unknown**: The SQL statement cannot be parsed.
        # *   **check_not_pass**: The SQL statement failed to pass the review.
        # *   **check_pass**: The SQL statement passed the review.
        # *   **force_pass**: The SQL statement passed the manual review.
        # *   **force_not_pass**: The SQL statement failed to pass the manual review.
        self.check_status_result = check_status_result
        # The ID of the file that contains the SQL statements to be reviewed.
        self.file_id = file_id
        # The pagination information.
        self.page = page
        # The optimization suggestion for the SQL statement. Valid values:
        # 
        # *   **MUST_IMPROVE**: The SQL statement must be optimized.
        # *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
        # *   **SUGGEST_IMPROVE**: We recommend that you optimize the SQL statement.
        # *   **USE_DMS_TOOLKIT**: We recommend that you change schemas without locking tables.
        # *   **USE_DMS_DML_UNLOCK**: We recommend that you change data without locking tables.
        # *   **TABLE_INDEX_SUGGEST**: We recommend that you optimize indexes for the SQL statement.
        self.sqlreview_result = sqlreview_result

    def validate(self):
        if self.page:
            self.page.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_status_result is not None:
            result['CheckStatusResult'] = self.check_status_result
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.page is not None:
            result['Page'] = self.page.to_map()
        if self.sqlreview_result is not None:
            result['SQLReviewResult'] = self.sqlreview_result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckStatusResult') is not None:
            self.check_status_result = m.get('CheckStatusResult')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('Page') is not None:
            temp_model = ListSQLReviewOriginSQLRequestOrderActionDetailPage()
            self.page = temp_model.from_map(m['Page'])
        if m.get('SQLReviewResult') is not None:
            self.sqlreview_result = m.get('SQLReviewResult')
        return self


class ListSQLReviewOriginSQLRequest(TeaModel):
    def __init__(
        self,
        order_action_detail: ListSQLReviewOriginSQLRequestOrderActionDetail = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The parameters that are used to filter SQL statements involved in the ticket.
        self.order_action_detail = order_action_detail
        # The ID of the SQL review ticket. You can call the [CreateSQLReviewOrder](https://help.aliyun.com/document_detail/257777.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        if self.order_action_detail:
            self.order_action_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_action_detail is not None:
            result['OrderActionDetail'] = self.order_action_detail.to_map()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderActionDetail') is not None:
            temp_model = ListSQLReviewOriginSQLRequestOrderActionDetail()
            self.order_action_detail = temp_model.from_map(m['OrderActionDetail'])
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSQLReviewOriginSQLShrinkRequest(TeaModel):
    def __init__(
        self,
        order_action_detail_shrink: str = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The parameters that are used to filter SQL statements involved in the ticket.
        self.order_action_detail_shrink = order_action_detail_shrink
        # The ID of the SQL review ticket. You can call the [CreateSQLReviewOrder](https://help.aliyun.com/document_detail/257777.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_action_detail_shrink is not None:
            result['OrderActionDetail'] = self.order_action_detail_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderActionDetail') is not None:
            self.order_action_detail_shrink = m.get('OrderActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSQLReviewOriginSQLResponseBodyOriginSQLList(TeaModel):
    def __init__(
        self,
        check_status: str = None,
        checked_time: str = None,
        file_id: int = None,
        file_name: str = None,
        review_summary: str = None,
        sqlcontent: str = None,
        sqlid: int = None,
        sqlname: str = None,
        sqlreview_query_key: str = None,
        sql_hash: str = None,
        status_desc: str = None,
    ):
        # The review status of the SQL statement. Valid values:
        # 
        # *   **new**: The SQL statement was waiting to be reviewed.
        # *   **unknown**: The SQL statement cannot be parsed.
        # *   **check_not_pass**: The SQL statement failed to pass the review.
        # *   **check_pass**: The SQL statement passed the review.
        # *   **force_pass**: The SQL statement passed the manual review.
        # *   **force_not_pass**: The SQL statement failed to pass the manual review.
        self.check_status = check_status
        # The time when the SQL statement was reviewed.
        self.checked_time = checked_time
        # The file ID.
        self.file_id = file_id
        # The name of the file.
        self.file_name = file_name
        # The statistics on the optimization suggestions for SQL statements. The value is a JSON string. Valid values:
        # 
        # *   **MUST_IMPROVE**: The SQL statements must be optimized.
        # *   **POTENTIAL_ISSUE**: The SQL statements contain potential issues.
        # *   **SUGGEST_IMPROVE**: We recommend that you optimize the SQL statements.
        # *   **USEDMSTOOLKIT**: We recommend that you change schemas without locking tables.
        # *   **USEDMSDML_UNLOCK**: We recommend that you change data without locking tables.
        # *   **TABLEINDEXSUGGEST**: We recommend that you optimize indexes for the SQL statements.
        self.review_summary = review_summary
        # The SQL statement in the file.
        self.sqlcontent = sqlcontent
        # The ID of the SQL statement.
        self.sqlid = sqlid
        # The name of the SQL statement.
        self.sqlname = sqlname
        # The key that is used to query the information about optimization suggestions. You can call the [GetSQLReviewOptimizeDetail](https://help.aliyun.com/document_detail/465919.html) operation to query the details based on this key.
        self.sqlreview_query_key = sqlreview_query_key
        # The MD5 hash value that is obtained after the SQL statement is calculated by using a hash algorithm.
        self.sql_hash = sql_hash
        # The description of the review status.
        self.status_desc = status_desc

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_status is not None:
            result['CheckStatus'] = self.check_status
        if self.checked_time is not None:
            result['CheckedTime'] = self.checked_time
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.review_summary is not None:
            result['ReviewSummary'] = self.review_summary
        if self.sqlcontent is not None:
            result['SQLContent'] = self.sqlcontent
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.sqlname is not None:
            result['SQLName'] = self.sqlname
        if self.sqlreview_query_key is not None:
            result['SQLReviewQueryKey'] = self.sqlreview_query_key
        if self.sql_hash is not None:
            result['SqlHash'] = self.sql_hash
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckStatus') is not None:
            self.check_status = m.get('CheckStatus')
        if m.get('CheckedTime') is not None:
            self.checked_time = m.get('CheckedTime')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('ReviewSummary') is not None:
            self.review_summary = m.get('ReviewSummary')
        if m.get('SQLContent') is not None:
            self.sqlcontent = m.get('SQLContent')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('SQLName') is not None:
            self.sqlname = m.get('SQLName')
        if m.get('SQLReviewQueryKey') is not None:
            self.sqlreview_query_key = m.get('SQLReviewQueryKey')
        if m.get('SqlHash') is not None:
            self.sql_hash = m.get('SqlHash')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        return self


class ListSQLReviewOriginSQLResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        origin_sqllist: List[ListSQLReviewOriginSQLResponseBodyOriginSQLList] = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned if the request failed.
        self.error_message = error_message
        # The information about the parsed SQL statements.
        self.origin_sqllist = origin_sqllist
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: Valid values:
        # 
        # *   true
        # *   false
        self.success = success
        # The number of SQL statements in the file.
        self.total_count = total_count

    def validate(self):
        if self.origin_sqllist:
            for k in self.origin_sqllist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['OriginSQLList'] = []
        if self.origin_sqllist is not None:
            for k in self.origin_sqllist:
                result['OriginSQLList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.origin_sqllist = []
        if m.get('OriginSQLList') is not None:
            for k in m.get('OriginSQLList'):
                temp_model = ListSQLReviewOriginSQLResponseBodyOriginSQLList()
                self.origin_sqllist.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSQLReviewOriginSQLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSQLReviewOriginSQLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSQLReviewOriginSQLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListScenariosRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListScenariosResponseBodyScenarioList(TeaModel):
    def __init__(
        self,
        creator_id: str = None,
        description: str = None,
        id: int = None,
        scenario_name: str = None,
    ):
        # The ID of the user who created the business scenario.
        self.creator_id = creator_id
        # The description of the business scenario.
        self.description = description
        # The ID of the business scenario.
        self.id = id
        # The name of the business scenario.
        self.scenario_name = scenario_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.scenario_name is not None:
            result['ScenarioName'] = self.scenario_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ScenarioName') is not None:
            self.scenario_name = m.get('ScenarioName')
        return self


class ListScenariosResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        scenario_list: List[ListScenariosResponseBodyScenarioList] = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The details of the returned business scenarios.
        self.scenario_list = scenario_list
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.scenario_list:
            for k in self.scenario_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ScenarioList'] = []
        if self.scenario_list is not None:
            for k in self.scenario_list:
                result['ScenarioList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.scenario_list = []
        if m.get('ScenarioList') is not None:
            for k in m.get('ScenarioList'):
                temp_model = ListScenariosResponseBodyScenarioList()
                self.scenario_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListScenariosResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListScenariosResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListScenariosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSensitiveColumnInfoRequest(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        instance_id: int = None,
        page_number: int = None,
        page_size: int = None,
        schema_name: str = None,
        table_name: str = None,
        tid: int = None,
    ):
        self.column_name = column_name
        # This parameter is required.
        self.instance_id = instance_id
        self.page_number = page_number
        self.page_size = page_size
        self.schema_name = schema_name
        self.table_name = table_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule(TeaModel):
    def __init__(
        self,
        rule_id: int = None,
        rule_name: str = None,
    ):
        self.rule_id = rule_id
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule(TeaModel):
    def __init__(
        self,
        rule_id: int = None,
        rule_name: str = None,
    ):
        self.rule_id = rule_id
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList(TeaModel):
    def __init__(
        self,
        semi_desensitization_rule: List[ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule] = None,
    ):
        self.semi_desensitization_rule = semi_desensitization_rule

    def validate(self):
        if self.semi_desensitization_rule:
            for k in self.semi_desensitization_rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SemiDesensitizationRule'] = []
        if self.semi_desensitization_rule is not None:
            for k in self.semi_desensitization_rule:
                result['SemiDesensitizationRule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.semi_desensitization_rule = []
        if m.get('SemiDesensitizationRule') is not None:
            for k in m.get('SemiDesensitizationRule'):
                temp_model = ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule()
                self.semi_desensitization_rule.append(temp_model.from_map(k))
        return self


class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn(TeaModel):
    def __init__(
        self,
        category_name: str = None,
        column_name: str = None,
        default_desensitization_rule: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule = None,
        instance_id: int = None,
        is_plain: bool = None,
        sample_data: str = None,
        schema_name: str = None,
        security_level: str = None,
        semi_desensitization_rule_list: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList = None,
        table_name: str = None,
        user_sensitivity_level: str = None,
    ):
        self.category_name = category_name
        self.column_name = column_name
        self.default_desensitization_rule = default_desensitization_rule
        self.instance_id = instance_id
        self.is_plain = is_plain
        self.sample_data = sample_data
        self.schema_name = schema_name
        self.security_level = security_level
        self.semi_desensitization_rule_list = semi_desensitization_rule_list
        self.table_name = table_name
        self.user_sensitivity_level = user_sensitivity_level

    def validate(self):
        if self.default_desensitization_rule:
            self.default_desensitization_rule.validate()
        if self.semi_desensitization_rule_list:
            self.semi_desensitization_rule_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_name is not None:
            result['CategoryName'] = self.category_name
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.default_desensitization_rule is not None:
            result['DefaultDesensitizationRule'] = self.default_desensitization_rule.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.is_plain is not None:
            result['IsPlain'] = self.is_plain
        if self.sample_data is not None:
            result['SampleData'] = self.sample_data
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.semi_desensitization_rule_list is not None:
            result['SemiDesensitizationRuleList'] = self.semi_desensitization_rule_list.to_map()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.user_sensitivity_level is not None:
            result['UserSensitivityLevel'] = self.user_sensitivity_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryName') is not None:
            self.category_name = m.get('CategoryName')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DefaultDesensitizationRule') is not None:
            temp_model = ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule()
            self.default_desensitization_rule = temp_model.from_map(m['DefaultDesensitizationRule'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IsPlain') is not None:
            self.is_plain = m.get('IsPlain')
        if m.get('SampleData') is not None:
            self.sample_data = m.get('SampleData')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('SemiDesensitizationRuleList') is not None:
            temp_model = ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList()
            self.semi_desensitization_rule_list = temp_model.from_map(m['SemiDesensitizationRuleList'])
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('UserSensitivityLevel') is not None:
            self.user_sensitivity_level = m.get('UserSensitivityLevel')
        return self


class ListSensitiveColumnInfoResponseBodySensitiveColumnList(TeaModel):
    def __init__(
        self,
        sensitive_column: List[ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn] = None,
    ):
        self.sensitive_column = sensitive_column

    def validate(self):
        if self.sensitive_column:
            for k in self.sensitive_column:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SensitiveColumn'] = []
        if self.sensitive_column is not None:
            for k in self.sensitive_column:
                result['SensitiveColumn'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.sensitive_column = []
        if m.get('SensitiveColumn') is not None:
            for k in m.get('SensitiveColumn'):
                temp_model = ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn()
                self.sensitive_column.append(temp_model.from_map(k))
        return self


class ListSensitiveColumnInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sensitive_column_list: ListSensitiveColumnInfoResponseBodySensitiveColumnList = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.sensitive_column_list = sensitive_column_list
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.sensitive_column_list:
            self.sensitive_column_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sensitive_column_list is not None:
            result['SensitiveColumnList'] = self.sensitive_column_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SensitiveColumnList') is not None:
            temp_model = ListSensitiveColumnInfoResponseBodySensitiveColumnList()
            self.sensitive_column_list = temp_model.from_map(m['SensitiveColumnList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSensitiveColumnInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSensitiveColumnInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSensitiveColumnInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSensitiveColumnsRequest(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        db_id: int = None,
        logic: bool = None,
        page_number: int = None,
        page_size: int = None,
        schema_name: str = None,
        security_level: str = None,
        table_name: str = None,
        tid: int = None,
    ):
        # The name of the field. You can call the [ListColumns](https://help.aliyun.com/document_detail/141870.html) operation to query the name of the field.
        self.column_name = column_name
        # The ID of the database. You can call the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
        # 
        # >  You can also call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to query the ID of the physical database and the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to query the ID of a logical database.
        self.db_id = db_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   true: The database is a logical database.
        # *   false: The database is a physical database.
        self.logic = logic
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The name of the database. You can call the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to query the name of the database.
        # 
        # >  You can also call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to query the name of a physical database and the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to query the name of a logical database.
        self.schema_name = schema_name
        # The sensitivity level of the field. Valid values:
        # 
        # *   SENSITIVE: medium sensitivity level
        # *   CONFIDENTIAL: high sensitivity level
        self.security_level = security_level
        # The name of the table. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to query the ID of the table.
        self.table_name = table_name
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn(TeaModel):
    def __init__(
        self,
        column_count: int = None,
        column_name: str = None,
        function_type: str = None,
        schema_name: str = None,
        security_level: str = None,
        table_name: str = None,
    ):
        # The number of sensitive fields.
        self.column_count = column_count
        # The name of the field.
        self.column_name = column_name
        # The type of the de-identification algorithm. Valid values:
        # 
        # *   DEFAULT: All characters are masked. This is the default value.
        # *   FIX_POS: The characters at specific positions are masked.
        # *   FIX_CHAR: Specific characters are masked.
        self.function_type = function_type
        # The name of the database.
        self.schema_name = schema_name
        # The sensitivity level of the field. Valid values:
        # 
        # *   SENSITIVE
        # *   CONFIDENTIAL
        self.security_level = security_level
        # The name of the table.
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_count is not None:
            result['ColumnCount'] = self.column_count
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnCount') is not None:
            self.column_count = m.get('ColumnCount')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListSensitiveColumnsResponseBodySensitiveColumnList(TeaModel):
    def __init__(
        self,
        sensitive_column: List[ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn] = None,
    ):
        self.sensitive_column = sensitive_column

    def validate(self):
        if self.sensitive_column:
            for k in self.sensitive_column:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SensitiveColumn'] = []
        if self.sensitive_column is not None:
            for k in self.sensitive_column:
                result['SensitiveColumn'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.sensitive_column = []
        if m.get('SensitiveColumn') is not None:
            for k in m.get('SensitiveColumn'):
                temp_model = ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn()
                self.sensitive_column.append(temp_model.from_map(k))
        return self


class ListSensitiveColumnsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sensitive_column_list: ListSensitiveColumnsResponseBodySensitiveColumnList = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The sensitive fields.
        self.sensitive_column_list = sensitive_column_list
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success
        # The total number of returned entries.
        self.total_count = total_count

    def validate(self):
        if self.sensitive_column_list:
            self.sensitive_column_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sensitive_column_list is not None:
            result['SensitiveColumnList'] = self.sensitive_column_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SensitiveColumnList') is not None:
            temp_model = ListSensitiveColumnsResponseBodySensitiveColumnList()
            self.sensitive_column_list = temp_model.from_map(m['SensitiveColumnList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSensitiveColumnsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSensitiveColumnsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSensitiveColumnsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSensitiveColumnsDetailRequest(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        db_id: int = None,
        logic: bool = None,
        schema_name: str = None,
        table_name: str = None,
        tid: int = None,
    ):
        # The name of the field. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the name of the field.
        # 
        # >  You can also call the [ListColumns](https://help.aliyun.com/document_detail/141870.html) operation to obtain the name of the field.
        # 
        # This parameter is required.
        self.column_name = column_name
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To obtain the ID of a physical database, call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
        # *   To obtain the ID of a logical database, call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
        self.db_id = db_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic
        # The name of the database. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the name of the database.
        # 
        # > * You can also call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the name of a physical database.
        # > * You can also call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the name of a logical database.
        # 
        # This parameter is required.
        self.schema_name = schema_name
        # The name of the table. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the name of the table.
        # 
        # >  You can also call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to obtain the name of the table.
        # 
        # This parameter is required.
        self.table_name = table_name
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail(TeaModel):
    def __init__(
        self,
        column_description: str = None,
        column_name: str = None,
        column_type: str = None,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        schema_name: str = None,
        search_name: str = None,
        table_name: str = None,
    ):
        # The description of the field.
        self.column_description = column_description
        # The name of the field.
        self.column_name = column_name
        # The data type of the field.
        self.column_type = column_type
        # The ID of the database.
        self.db_id = db_id
        # The type of the database.
        self.db_type = db_type
        # The type of the environment to which the database belongs.
        self.env_type = env_type
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        self.logic = logic
        # The name of the database.
        self.schema_name = schema_name
        # The name that is used to search for the database.
        self.search_name = search_name
        # The name of the table.
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_description is not None:
            result['ColumnDescription'] = self.column_description
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnDescription') is not None:
            self.column_description = m.get('ColumnDescription')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList(TeaModel):
    def __init__(
        self,
        sensitive_columns_detail: List[ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail] = None,
    ):
        self.sensitive_columns_detail = sensitive_columns_detail

    def validate(self):
        if self.sensitive_columns_detail:
            for k in self.sensitive_columns_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SensitiveColumnsDetail'] = []
        if self.sensitive_columns_detail is not None:
            for k in self.sensitive_columns_detail:
                result['SensitiveColumnsDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.sensitive_columns_detail = []
        if m.get('SensitiveColumnsDetail') is not None:
            for k in m.get('SensitiveColumnsDetail'):
                temp_model = ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail()
                self.sensitive_columns_detail.append(temp_model.from_map(k))
        return self


class ListSensitiveColumnsDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sensitive_columns_detail_list: ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The details of the sensitive field.
        self.sensitive_columns_detail_list = sensitive_columns_detail_list
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        if self.sensitive_columns_detail_list:
            self.sensitive_columns_detail_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sensitive_columns_detail_list is not None:
            result['SensitiveColumnsDetailList'] = self.sensitive_columns_detail_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SensitiveColumnsDetailList') is not None:
            temp_model = ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList()
            self.sensitive_columns_detail_list = temp_model.from_map(m['SensitiveColumnsDetailList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListSensitiveColumnsDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSensitiveColumnsDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSensitiveColumnsDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSensitiveDataAuditLogRequest(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        db_name: str = None,
        end_time: str = None,
        module_name: str = None,
        op_user_name: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time: str = None,
        table_name: str = None,
        tid: int = None,
    ):
        # The name of the column that contains sensitive data.
        self.column_name = column_name
        # The name of the database that stores the sensitive data.
        self.db_name = db_name
        # The end of the time range for which you want to query the audit logs for sensitive information. Specify the time in the yyyy-MM-DD HH:mm:ss format.
        self.end_time = end_time
        # The function module whose audit logs you want to query for sensitive data. If you do not specify this parameter, all audit logs are queried. Valid values:
        # 
        # *   **SQL_CONSOLE**: data query
        # *   **SQL_CONSOLE_EXPORT**: query result export
        # *   **DATA_CHANGE**: data change
        # *   **DATA_EXPORT**: data export
        self.module_name = module_name
        # The username of the requester.
        self.op_user_name = op_user_name
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page. Example: 100
        self.page_size = page_size
        # The beginning of the time range for which you want to query the audit logs for sensitive information. Specify the time in the yyyy-MM-DD HH:mm:ss format.
        self.start_time = start_time
        # The name of the table that stores the sensitive data.
        self.table_name = table_name
        # The ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.op_user_name is not None:
            result['OpUserName'] = self.op_user_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('OpUserName') is not None:
            self.op_user_name = m.get('OpUserName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        column_permission_type: str = None,
        desensitization_rule: str = None,
        security_level: str = None,
        table_name: str = None,
    ):
        # The name of the column that contains sensitive data.
        self.column_name = column_name
        # The permission that the user has on the column. Valid values:
        # 
        # *   **No permission**\
        # *   **Partial redaction**\
        # *   **Plaintext**\
        # *   **Change**\
        # *   **Enable data masking**\
        # *   **Disable data masking**\
        self.column_permission_type = column_permission_type
        # The algorithm used for data masking.
        self.desensitization_rule = desensitization_rule
        # The sensitivity level of the data. Valid values:
        # 
        # *   **Low**\
        # *   **Medium**\
        # *   **High**\
        self.security_level = security_level
        # The name of the table that stores the sensitive data.
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_permission_type is not None:
            result['ColumnPermissionType'] = self.column_permission_type
        if self.desensitization_rule is not None:
            result['DesensitizationRule'] = self.desensitization_rule
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnPermissionType') is not None:
            self.column_permission_type = m.get('ColumnPermissionType')
        if m.get('DesensitizationRule') is not None:
            self.desensitization_rule = m.get('DesensitizationRule')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList(TeaModel):
    def __init__(
        self,
        db_display_name: str = None,
        instance_id: int = None,
        module_name: str = None,
        op_time: str = None,
        sensitive_data_log: List[ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog] = None,
        target_name: str = None,
        user_id: int = None,
        user_name: str = None,
    ):
        # The name of the database that stores the sensitive data.
        self.db_display_name = db_display_name
        # The ID of the instance.
        self.instance_id = instance_id
        # The name of the function module whose audit logs were queried.
        self.module_name = module_name
        # The time when the operation was performed. The time is in the yyyy-MM-DD HH:mm:ss format.
        self.op_time = op_time
        # The logs for sensitive data.
        self.sensitive_data_log = sensitive_data_log
        # The details of the object on which the operation was performed. The value of this parameter is in one of the following formats:
        # 
        # *   Object name - object ID
        # *   Object name (object ID)
        self.target_name = target_name
        # The user ID of the requester.
        self.user_id = user_id
        # The username of the requester.
        self.user_name = user_name

    def validate(self):
        if self.sensitive_data_log:
            for k in self.sensitive_data_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_display_name is not None:
            result['DbDisplayName'] = self.db_display_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        result['SensitiveDataLog'] = []
        if self.sensitive_data_log is not None:
            for k in self.sensitive_data_log:
                result['SensitiveDataLog'].append(k.to_map() if k else None)
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbDisplayName') is not None:
            self.db_display_name = m.get('DbDisplayName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        self.sensitive_data_log = []
        if m.get('SensitiveDataLog') is not None:
            for k in m.get('SensitiveDataLog'):
                temp_model = ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog()
                self.sensitive_data_log.append(temp_model.from_map(k))
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListSensitiveDataAuditLogResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sensitive_data_audit_log_list: List[ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList] = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The audit logs for sensitive data.
        self.sensitive_data_audit_log_list = sensitive_data_audit_log_list
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.sensitive_data_audit_log_list:
            for k in self.sensitive_data_audit_log_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SensitiveDataAuditLogList'] = []
        if self.sensitive_data_audit_log_list is not None:
            for k in self.sensitive_data_audit_log_list:
                result['SensitiveDataAuditLogList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sensitive_data_audit_log_list = []
        if m.get('SensitiveDataAuditLogList') is not None:
            for k in m.get('SensitiveDataAuditLogList'):
                temp_model = ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList()
                self.sensitive_data_audit_log_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSensitiveDataAuditLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSensitiveDataAuditLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSensitiveDataAuditLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSensitivityLevelRequest(TeaModel):
    def __init__(
        self,
        template_id: int = None,
        template_type: str = None,
        tid: int = None,
    ):
        # The ID of the classification template. You can call the [ListClassificationTemplates](https://help.aliyun.com/document_detail/460613.html) operation to query the ID of the classification template.
        self.template_id = template_id
        # The type of the classification template. You can call the [ListClassificationTemplates](https://help.aliyun.com/document_detail/460613.html) operation to query the type of the classification template.
        # 
        # Valid values:
        # 
        # *   USER_DEFINE: a custom template.
        # *   INNER: a built-in template.
        self.template_type = template_type
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) in the topic "Manage DMS tenants."
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSensitivityLevelResponseBodySensitivityLevelList(TeaModel):
    def __init__(
        self,
        is_plain: bool = None,
        name: str = None,
        template_id: str = None,
        template_type: str = None,
    ):
        # Indicates whether the fields of the sensitive level are displayed in plaintext.
        self.is_plain = is_plain
        # The name of the sensitive level.
        self.name = name
        # The ID of the classification template.
        self.template_id = template_id
        # The type of the classification template. Valid values:
        # 
        # *   **INNER**: a built-in template.
        # *   **USER_DEFINE**: a custom template.
        self.template_type = template_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_plain is not None:
            result['IsPlain'] = self.is_plain
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsPlain') is not None:
            self.is_plain = m.get('IsPlain')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class ListSensitivityLevelResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sensitivity_level_list: List[ListSensitivityLevelResponseBodySensitivityLevelList] = None,
        success: bool = None,
    ):
        # The status code.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # The sensitivity levels.
        self.sensitivity_level_list = sensitivity_level_list
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.sensitivity_level_list:
            for k in self.sensitivity_level_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SensitivityLevelList'] = []
        if self.sensitivity_level_list is not None:
            for k in self.sensitivity_level_list:
                result['SensitivityLevelList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sensitivity_level_list = []
        if m.get('SensitivityLevelList') is not None:
            for k in m.get('SensitivityLevelList'):
                temp_model = ListSensitivityLevelResponseBodySensitivityLevelList()
                self.sensitivity_level_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListSensitivityLevelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSensitivityLevelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSensitivityLevelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListStandardGroupsRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListStandardGroupsResponseBodyStandardGroupList(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        description: str = None,
        group_id: int = None,
        group_mode: str = None,
        group_name: str = None,
        last_mender_id: int = None,
    ):
        # The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        self.db_type = db_type
        # The description of the security rule set.
        self.description = description
        # The ID of the security rule set.
        self.group_id = group_id
        # The control mode. Valid values:
        # 
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        # *   **COMMON**: Security Collaboration
        self.group_mode = group_mode
        # The name of the security rule set.
        self.group_name = group_name
        # The ID of the user who queries the security sets.
        self.last_mender_id = last_mender_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.last_mender_id is not None:
            result['LastMenderId'] = self.last_mender_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LastMenderId') is not None:
            self.last_mender_id = m.get('LastMenderId')
        return self


class ListStandardGroupsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        standard_group_list: List[ListStandardGroupsResponseBodyStandardGroupList] = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The security rule sets returned.
        self.standard_group_list = standard_group_list
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.standard_group_list:
            for k in self.standard_group_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StandardGroupList'] = []
        if self.standard_group_list is not None:
            for k in self.standard_group_list:
                result['StandardGroupList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.standard_group_list = []
        if m.get('StandardGroupList') is not None:
            for k in m.get('StandardGroupList'):
                temp_model = ListStandardGroupsResponseBodyStandardGroupList()
                self.standard_group_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListStandardGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListStandardGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListStandardGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTableColumnsRequest(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        table_name: str = None,
        table_schema_name: str = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.db_id = db_id
        # This parameter is required.
        self.table_name = table_name
        self.table_schema_name = table_schema_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_schema_name is not None:
            result['TableSchemaName'] = self.table_schema_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableSchemaName') is not None:
            self.table_schema_name = m.get('TableSchemaName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTableColumnsResponseBodyColumnListColumn(TeaModel):
    def __init__(
        self,
        auto_increment: bool = None,
        column_id: str = None,
        column_name: str = None,
        column_type: str = None,
        data_length: int = None,
        data_precision: int = None,
        data_scale: int = None,
        default_value: str = None,
        description: str = None,
        function_type: str = None,
        nullable: bool = None,
        security_level: str = None,
        sensitive: bool = None,
    ):
        self.auto_increment = auto_increment
        self.column_id = column_id
        self.column_name = column_name
        self.column_type = column_type
        self.data_length = data_length
        self.data_precision = data_precision
        self.data_scale = data_scale
        self.default_value = default_value
        self.description = description
        self.function_type = function_type
        self.nullable = nullable
        self.security_level = security_level
        self.sensitive = sensitive

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_increment is not None:
            result['AutoIncrement'] = self.auto_increment
        if self.column_id is not None:
            result['ColumnId'] = self.column_id
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.data_length is not None:
            result['DataLength'] = self.data_length
        if self.data_precision is not None:
            result['DataPrecision'] = self.data_precision
        if self.data_scale is not None:
            result['DataScale'] = self.data_scale
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.description is not None:
            result['Description'] = self.description
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.nullable is not None:
            result['Nullable'] = self.nullable
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.sensitive is not None:
            result['Sensitive'] = self.sensitive
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoIncrement') is not None:
            self.auto_increment = m.get('AutoIncrement')
        if m.get('ColumnId') is not None:
            self.column_id = m.get('ColumnId')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DataLength') is not None:
            self.data_length = m.get('DataLength')
        if m.get('DataPrecision') is not None:
            self.data_precision = m.get('DataPrecision')
        if m.get('DataScale') is not None:
            self.data_scale = m.get('DataScale')
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('Nullable') is not None:
            self.nullable = m.get('Nullable')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('Sensitive') is not None:
            self.sensitive = m.get('Sensitive')
        return self


class ListTableColumnsResponseBodyColumnList(TeaModel):
    def __init__(
        self,
        column: List[ListTableColumnsResponseBodyColumnListColumn] = None,
    ):
        self.column = column

    def validate(self):
        if self.column:
            for k in self.column:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Column'] = []
        if self.column is not None:
            for k in self.column:
                result['Column'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.column = []
        if m.get('Column') is not None:
            for k in m.get('Column'):
                temp_model = ListTableColumnsResponseBodyColumnListColumn()
                self.column.append(temp_model.from_map(k))
        return self


class ListTableColumnsResponseBody(TeaModel):
    def __init__(
        self,
        column_list: ListTableColumnsResponseBodyColumnList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.column_list = column_list
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.column_list:
            self.column_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_list is not None:
            result['ColumnList'] = self.column_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnList') is not None:
            temp_model = ListTableColumnsResponseBodyColumnList()
            self.column_list = temp_model.from_map(m['ColumnList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListTableColumnsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTableColumnsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTableColumnsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTablesRequest(TeaModel):
    def __init__(
        self,
        database_id: str = None,
        page_number: int = None,
        page_size: int = None,
        return_guid: bool = None,
        search_name: str = None,
        tid: int = None,
    ):
        # The ID of the physical database. You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the ID of the physical database.
        # 
        # This parameter is required.
        self.database_id = database_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # Specifies whether to return the GUID of a table. Valid values:
        # 
        # *   **true**: returns the GUID of a table.
        # *   **false**: does not return the GUID of a table.
        self.return_guid = return_guid
        # The name used to search for tables. Fuzzy search is supported.
        self.search_name = search_name
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.return_guid is not None:
            result['ReturnGuid'] = self.return_guid
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ReturnGuid') is not None:
            self.return_guid = m.get('ReturnGuid')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTablesResponseBodyTableListTableOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListTablesResponseBodyTableListTableOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListTablesResponseBodyTableListTable(TeaModel):
    def __init__(
        self,
        database_id: str = None,
        description: str = None,
        encoding: str = None,
        engine: str = None,
        num_rows: int = None,
        owner_id_list: ListTablesResponseBodyTableListTableOwnerIdList = None,
        owner_name_list: ListTablesResponseBodyTableListTableOwnerNameList = None,
        store_capacity: int = None,
        table_guid: str = None,
        table_id: str = None,
        table_name: str = None,
        table_schema_name: str = None,
        table_type: str = None,
    ):
        # The ID of the physical database.
        self.database_id = database_id
        # The description of the table.
        self.description = description
        # The encoding format of the table.
        self.encoding = encoding
        # The engine of the table.
        self.engine = engine
        # The number of rows in the table. This is a statistical value and does not indicate the actual number of rows.
        self.num_rows = num_rows
        # The ID list of the table owners.
        self.owner_id_list = owner_id_list
        # The nickname list of the table owners.
        self.owner_name_list = owner_name_list
        # The storage space that is occupied by the table. This is a statistical value and does not indicate the accurate storage space. Unit: MB.
        self.store_capacity = store_capacity
        # The GUID of the table in DMS.
        self.table_guid = table_guid
        # The ID of the table.
        self.table_id = table_id
        # The table name.
        self.table_name = table_name
        # The database in which the table resides.
        self.table_schema_name = table_schema_name
        # The type of the table. Default value: NORMAL.
        self.table_type = table_type

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.description is not None:
            result['Description'] = self.description
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.engine is not None:
            result['Engine'] = self.engine
        if self.num_rows is not None:
            result['NumRows'] = self.num_rows
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.store_capacity is not None:
            result['StoreCapacity'] = self.store_capacity
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_schema_name is not None:
            result['TableSchemaName'] = self.table_schema_name
        if self.table_type is not None:
            result['TableType'] = self.table_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('Engine') is not None:
            self.engine = m.get('Engine')
        if m.get('NumRows') is not None:
            self.num_rows = m.get('NumRows')
        if m.get('OwnerIdList') is not None:
            temp_model = ListTablesResponseBodyTableListTableOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListTablesResponseBodyTableListTableOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('StoreCapacity') is not None:
            self.store_capacity = m.get('StoreCapacity')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableSchemaName') is not None:
            self.table_schema_name = m.get('TableSchemaName')
        if m.get('TableType') is not None:
            self.table_type = m.get('TableType')
        return self


class ListTablesResponseBodyTableList(TeaModel):
    def __init__(
        self,
        table: List[ListTablesResponseBodyTableListTable] = None,
    ):
        self.table = table

    def validate(self):
        if self.table:
            for k in self.table:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Table'] = []
        if self.table is not None:
            for k in self.table:
                result['Table'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.table = []
        if m.get('Table') is not None:
            for k in m.get('Table'):
                temp_model = ListTablesResponseBodyTableListTable()
                self.table.append(temp_model.from_map(k))
        return self


class ListTablesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        table_list: ListTablesResponseBodyTableList = None,
        total_count: int = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The details of the tables.
        self.table_list = table_list
        # The total number of tables that meet the query conditions.
        self.total_count = total_count

    def validate(self):
        if self.table_list:
            self.table_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.table_list is not None:
            result['TableList'] = self.table_list.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TableList') is not None:
            temp_model = ListTablesResponseBodyTableList()
            self.table_list = temp_model.from_map(m['TableList'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTablesInCategoryRequest(TeaModel):
    def __init__(
        self,
        category_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.category_id = category_id
        # This parameter is required.
        self.page_number = page_number
        # This parameter is required.
        self.page_size = page_size
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTablesInCategoryResponseBodyEntityList(TeaModel):
    def __init__(
        self,
        meta_category_table_entity: List[MetaCategoryTableEntity] = None,
    ):
        self.meta_category_table_entity = meta_category_table_entity

    def validate(self):
        if self.meta_category_table_entity:
            for k in self.meta_category_table_entity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MetaCategoryTableEntity'] = []
        if self.meta_category_table_entity is not None:
            for k in self.meta_category_table_entity:
                result['MetaCategoryTableEntity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.meta_category_table_entity = []
        if m.get('MetaCategoryTableEntity') is not None:
            for k in m.get('MetaCategoryTableEntity'):
                temp_model = MetaCategoryTableEntity()
                self.meta_category_table_entity.append(temp_model.from_map(k))
        return self


class ListTablesInCategoryResponseBody(TeaModel):
    def __init__(
        self,
        entity_list: ListTablesInCategoryResponseBodyEntityList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.entity_list = entity_list
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.entity_list:
            self.entity_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_list is not None:
            result['EntityList'] = self.entity_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EntityList') is not None:
            temp_model = ListTablesInCategoryResponseBodyEntityList()
            self.entity_list = temp_model.from_map(m['EntityList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTablesInCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTablesInCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTablesInCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowResponseBodyTaskFlowListTaskFlow(TeaModel):
    def __init__(
        self,
        creator_id: str = None,
        creator_nick_name: str = None,
        dag_owner_nick_name: str = None,
        deploy_id: int = None,
        id: int = None,
        latest_instance_status: int = None,
        latest_instance_time: str = None,
        status: int = None,
    ):
        # The ID of the user who creates the task flow.
        self.creator_id = creator_id
        # The name of the user who creates the task flow.
        self.creator_nick_name = creator_nick_name
        # The name of the task flow owner.
        self.dag_owner_nick_name = dag_owner_nick_name
        # The ID of the latest deployment record.
        self.deploy_id = deploy_id
        # The ID of the task flow.
        self.id = id
        # The status of the latest execution. Valid values:
        # 
        # *   **0**: invalid.
        # *   **1**: scheduling disabled.
        # *   **2**: waiting to be scheduled.
        self.latest_instance_status = latest_instance_status
        # The time when the latest execution record was generated.
        self.latest_instance_time = latest_instance_time
        # The status of the task flow. Valid values:
        # 
        # *   **0**: The task flow is invalid.
        # *   **1**: Scheduling is disabled for the task flow.
        # *   **2**: The task flow is waiting to be scheduled.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick_name is not None:
            result['CreatorNickName'] = self.creator_nick_name
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.id is not None:
            result['Id'] = self.id
        if self.latest_instance_status is not None:
            result['LatestInstanceStatus'] = self.latest_instance_status
        if self.latest_instance_time is not None:
            result['LatestInstanceTime'] = self.latest_instance_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNickName') is not None:
            self.creator_nick_name = m.get('CreatorNickName')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LatestInstanceStatus') is not None:
            self.latest_instance_status = m.get('LatestInstanceStatus')
        if m.get('LatestInstanceTime') is not None:
            self.latest_instance_time = m.get('LatestInstanceTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListTaskFlowResponseBodyTaskFlowList(TeaModel):
    def __init__(
        self,
        task_flow: List[ListTaskFlowResponseBodyTaskFlowListTaskFlow] = None,
    ):
        self.task_flow = task_flow

    def validate(self):
        if self.task_flow:
            for k in self.task_flow:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskFlow'] = []
        if self.task_flow is not None:
            for k in self.task_flow:
                result['TaskFlow'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_flow = []
        if m.get('TaskFlow') is not None:
            for k in m.get('TaskFlow'):
                temp_model = ListTaskFlowResponseBodyTaskFlowListTaskFlow()
                self.task_flow.append(temp_model.from_map(k))
        return self


class ListTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        task_flow_list: ListTaskFlowResponseBodyTaskFlowList = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The information about the task flows returned.
        self.task_flow_list = task_flow_list

    def validate(self):
        if self.task_flow_list:
            self.task_flow_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_flow_list is not None:
            result['TaskFlowList'] = self.task_flow_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskFlowList') is not None:
            temp_model = ListTaskFlowResponseBodyTaskFlowList()
            self.task_flow_list = temp_model.from_map(m['TaskFlowList'])
        return self


class ListTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowConstantsRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowConstantsResponseBodyDagConstantsDagConstant(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The constant key.
        self.key = key
        # The constant value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListTaskFlowConstantsResponseBodyDagConstants(TeaModel):
    def __init__(
        self,
        dag_constant: List[ListTaskFlowConstantsResponseBodyDagConstantsDagConstant] = None,
    ):
        self.dag_constant = dag_constant

    def validate(self):
        if self.dag_constant:
            for k in self.dag_constant:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DagConstant'] = []
        if self.dag_constant is not None:
            for k in self.dag_constant:
                result['DagConstant'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dag_constant = []
        if m.get('DagConstant') is not None:
            for k in m.get('DagConstant'):
                temp_model = ListTaskFlowConstantsResponseBodyDagConstantsDagConstant()
                self.dag_constant.append(temp_model.from_map(k))
        return self


class ListTaskFlowConstantsResponseBody(TeaModel):
    def __init__(
        self,
        dag_constants: ListTaskFlowConstantsResponseBodyDagConstants = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # A list of constant key-value pairs for the task flow.
        self.dag_constants = dag_constants
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.dag_constants:
            self.dag_constants.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_constants is not None:
            result['DagConstants'] = self.dag_constants.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagConstants') is not None:
            temp_model = ListTaskFlowConstantsResponseBodyDagConstants()
            self.dag_constants = temp_model.from_map(m['DagConstants'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListTaskFlowConstantsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowConstantsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowConstantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowCooperatorsRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator(TeaModel):
    def __init__(
        self,
        email: str = None,
        login_name: str = None,
        nick_name: str = None,
        user_id: str = None,
    ):
        # The email address of the user.
        self.email = email
        # The username.
        self.login_name = login_name
        # The alias of the user.
        self.nick_name = nick_name
        # userId.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.email is not None:
            result['Email'] = self.email
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListTaskFlowCooperatorsResponseBodyCooperatorList(TeaModel):
    def __init__(
        self,
        cooperator: List[ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator] = None,
    ):
        self.cooperator = cooperator

    def validate(self):
        if self.cooperator:
            for k in self.cooperator:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Cooperator'] = []
        if self.cooperator is not None:
            for k in self.cooperator:
                result['Cooperator'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cooperator = []
        if m.get('Cooperator') is not None:
            for k in m.get('Cooperator'):
                temp_model = ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator()
                self.cooperator.append(temp_model.from_map(k))
        return self


class ListTaskFlowCooperatorsResponseBody(TeaModel):
    def __init__(
        self,
        cooperator_list: ListTaskFlowCooperatorsResponseBodyCooperatorList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The users that are involved in the task flow.
        self.cooperator_list = cooperator_list
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.cooperator_list:
            self.cooperator_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cooperator_list is not None:
            result['CooperatorList'] = self.cooperator_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CooperatorList') is not None:
            temp_model = ListTaskFlowCooperatorsResponseBodyCooperatorList()
            self.cooperator_list = temp_model.from_map(m['CooperatorList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListTaskFlowCooperatorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowCooperatorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowCooperatorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowEdgesByConditionRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        id: int = None,
        node_end: int = None,
        node_from: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the task flow edge.
        self.id = id
        # The ID of the end node on the edge.
        self.node_end = node_end
        # The ID of the start node on the edge.
        self.node_from = node_from
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowEdgesByConditionResponseBodyEdgesEdge(TeaModel):
    def __init__(
        self,
        id: int = None,
        node_end: int = None,
        node_from: int = None,
    ):
        # The ID of the task flow edge.
        self.id = id
        # The ID of the end node on the edge.
        self.node_end = node_end
        # The ID of the start node on the edge.
        self.node_from = node_from

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class ListTaskFlowEdgesByConditionResponseBodyEdges(TeaModel):
    def __init__(
        self,
        edge: List[ListTaskFlowEdgesByConditionResponseBodyEdgesEdge] = None,
    ):
        self.edge = edge

    def validate(self):
        if self.edge:
            for k in self.edge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Edge'] = []
        if self.edge is not None:
            for k in self.edge:
                result['Edge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.edge = []
        if m.get('Edge') is not None:
            for k in m.get('Edge'):
                temp_model = ListTaskFlowEdgesByConditionResponseBodyEdgesEdge()
                self.edge.append(temp_model.from_map(k))
        return self


class ListTaskFlowEdgesByConditionResponseBody(TeaModel):
    def __init__(
        self,
        edges: ListTaskFlowEdgesByConditionResponseBodyEdges = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The list of task flow edges.
        self.edges = edges
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.edges:
            self.edges.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edges is not None:
            result['Edges'] = self.edges.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Edges') is not None:
            temp_model = ListTaskFlowEdgesByConditionResponseBodyEdges()
            self.edges = temp_model.from_map(m['Edges'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListTaskFlowEdgesByConditionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowEdgesByConditionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowEdgesByConditionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowInstanceRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        page_index: int = None,
        page_size: int = None,
        start_time_begin: str = None,
        start_time_end: str = None,
        status: int = None,
        tid: int = None,
        trigger_type: int = None,
        use_biz_date: bool = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the ID of the task flow.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page_index = page_index
        # The number of entries to return on each page.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The beginning of the time range to query the execution records of the task flow. Specify the time in the yyyy-MM-DD format.
        self.start_time_begin = start_time_begin
        # The end of the time range to query the execution records of the task flow. Specify the time in the yyyy-MM-DD format.
        self.start_time_end = start_time_end
        # The running status of the task node. Valid values:
        # 
        # - **0**: Waiting for scheduling
        # 
        # - **1**: Running
        # 
        # - **2**: Suspend
        # 
        # - **3**: Failed to run
        # 
        # - **4**: Run successfully
        # 
        # - **5**: Completed
        self.status = status
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid
        # The mode in which the task flow is triggered. Valid values:
        # 
        # *   **0**: The task flow is automatically triggered based on periodic scheduling.
        # *   **1**: The task flow is manually triggered.
        self.trigger_type = trigger_type
        # Adjust filter conditions:
        # 
        # - true: StartTimeBegin and StartTimeEnd are the time range for filtering services.
        # 
        # - false: StartTimeBegin and StartTimeEnd are the time range for the task to run.
        self.use_biz_date = use_biz_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time_begin is not None:
            result['StartTimeBegin'] = self.start_time_begin
        if self.start_time_end is not None:
            result['StartTimeEnd'] = self.start_time_end
        if self.status is not None:
            result['Status'] = self.status
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.use_biz_date is not None:
            result['UseBizDate'] = self.use_biz_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTimeBegin') is not None:
            self.start_time_begin = m.get('StartTimeBegin')
        if m.get('StartTimeEnd') is not None:
            self.start_time_end = m.get('StartTimeEnd')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('UseBizDate') is not None:
            self.use_biz_date = m.get('UseBizDate')
        return self


class ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance(TeaModel):
    def __init__(
        self,
        business_time: str = None,
        dag_id: str = None,
        dag_name: str = None,
        dag_version: str = None,
        end_time: str = None,
        history_dag_id: int = None,
        id: int = None,
        message: str = None,
        owner_name: str = None,
        status: int = None,
        trigger_type: int = None,
        start_time: str = None,
    ):
        # The business time of the task flow. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.business_time = business_time
        # The ID of the task flow.
        self.dag_id = dag_id
        # The name of the task flow.
        self.dag_name = dag_name
        # The version of the task flow.
        self.dag_version = dag_version
        # The time when the execution of the task flow was complete. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.end_time = end_time
        # The ID of the previously published version of the task flow.
        self.history_dag_id = history_dag_id
        # The ID of the execution record.
        self.id = id
        # The description of the task.
        self.message = message
        # The name of the task flow owner.
        self.owner_name = owner_name
        # The status of the task flow. Valid values:
        # 
        # *   **0**: The task flow is waiting to be scheduled.
        # *   **1**: The task flow is being executed.
        # *   **2**: The task flow is paused.
        # *   **3**: The task flow failed.
        # *   **4**: The task flow is executed.
        # *   **5**: The task flow is complete.
        self.status = status
        # The mode in which the task flow is triggered. Valid values:
        # 
        # *   **0**: The task flow is automatically triggered based on periodic scheduling.
        # *   **1**: The task flow is manually triggered.
        self.trigger_type = trigger_type
        # The time when the execution of the task flow was start. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_time is not None:
            result['BusinessTime'] = self.business_time
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_version is not None:
            result['DagVersion'] = self.dag_version
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.history_dag_id is not None:
            result['HistoryDagId'] = self.history_dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.owner_name is not None:
            result['OwnerName'] = self.owner_name
        if self.status is not None:
            result['Status'] = self.status
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessTime') is not None:
            self.business_time = m.get('BusinessTime')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagVersion') is not None:
            self.dag_version = m.get('DagVersion')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('HistoryDagId') is not None:
            self.history_dag_id = m.get('HistoryDagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('OwnerName') is not None:
            self.owner_name = m.get('OwnerName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ListTaskFlowInstanceResponseBodyDAGInstanceList(TeaModel):
    def __init__(
        self,
        daginstance: List[ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance] = None,
    ):
        self.daginstance = daginstance

    def validate(self):
        if self.daginstance:
            for k in self.daginstance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DAGInstance'] = []
        if self.daginstance is not None:
            for k in self.daginstance:
                result['DAGInstance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.daginstance = []
        if m.get('DAGInstance') is not None:
            for k in m.get('DAGInstance'):
                temp_model = ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance()
                self.daginstance.append(temp_model.from_map(k))
        return self


class ListTaskFlowInstanceResponseBody(TeaModel):
    def __init__(
        self,
        daginstance_list: ListTaskFlowInstanceResponseBodyDAGInstanceList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The information about the execution records returned.
        self.daginstance_list = daginstance_list
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success
        # The total number of execution records returned.
        self.total_count = total_count

    def validate(self):
        if self.daginstance_list:
            self.daginstance_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.daginstance_list is not None:
            result['DAGInstanceList'] = self.daginstance_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DAGInstanceList') is not None:
            temp_model = ListTaskFlowInstanceResponseBodyDAGInstanceList()
            self.daginstance_list = temp_model.from_map(m['DAGInstanceList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTaskFlowInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowTimeVariablesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable(TeaModel):
    def __init__(
        self,
        name: str = None,
        pattern: str = None,
    ):
        # The name of the time variable.
        self.name = name
        # The format of the time variable.
        self.pattern = pattern

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        return self


class ListTaskFlowTimeVariablesResponseBodyTimeVariables(TeaModel):
    def __init__(
        self,
        time_variable: List[ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable] = None,
    ):
        self.time_variable = time_variable

    def validate(self):
        if self.time_variable:
            for k in self.time_variable:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TimeVariable'] = []
        if self.time_variable is not None:
            for k in self.time_variable:
                result['TimeVariable'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.time_variable = []
        if m.get('TimeVariable') is not None:
            for k in m.get('TimeVariable'):
                temp_model = ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable()
                self.time_variable.append(temp_model.from_map(k))
        return self


class ListTaskFlowTimeVariablesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        time_variables: ListTaskFlowTimeVariablesResponseBodyTimeVariables = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The time variables for the task flow.
        self.time_variables = time_variables

    def validate(self):
        if self.time_variables:
            self.time_variables.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TimeVariables') is not None:
            temp_model = ListTaskFlowTimeVariablesResponseBodyTimeVariables()
            self.time_variables = temp_model.from_map(m['TimeVariables'])
        return self


class ListTaskFlowTimeVariablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowTimeVariablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowTimeVariablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowsByPageRequest(TeaModel):
    def __init__(
        self,
        dag_id_list: List[int] = None,
        page_index: int = None,
        page_size: int = None,
        scenario_id: int = None,
        search_key: str = None,
        tid: int = None,
    ):
        # Filter condition, task flow ID list.
        self.dag_id_list = dag_id_list
        # The number of the page to return.
        self.page_index = page_index
        # The number of entries to return on each page.
        self.page_size = page_size
        # Filter condition, application scenario ID.
        self.scenario_id = scenario_id
        # The keyword that is used to search for task flow names.
        self.search_key = search_key
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id_list is not None:
            result['DagIdList'] = self.dag_id_list
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagIdList') is not None:
            self.dag_id_list = m.get('DagIdList')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowsByPageShrinkRequest(TeaModel):
    def __init__(
        self,
        dag_id_list_shrink: str = None,
        page_index: int = None,
        page_size: int = None,
        scenario_id: int = None,
        search_key: str = None,
        tid: int = None,
    ):
        # Filter condition, task flow ID list.
        self.dag_id_list_shrink = dag_id_list_shrink
        # The number of the page to return.
        self.page_index = page_index
        # The number of entries to return on each page.
        self.page_size = page_size
        # Filter condition, application scenario ID.
        self.scenario_id = scenario_id
        # The keyword that is used to search for task flow names.
        self.search_key = search_key
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id_list_shrink is not None:
            result['DagIdList'] = self.dag_id_list_shrink
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagIdList') is not None:
            self.dag_id_list_shrink = m.get('DagIdList')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow(TeaModel):
    def __init__(
        self,
        creator_id: str = None,
        creator_nick_name: str = None,
        cron_begin_date: str = None,
        cron_end_date: str = None,
        cron_str: str = None,
        cron_switch: bool = None,
        cron_type: int = None,
        dag_name: str = None,
        dag_owner_id: str = None,
        dag_owner_nick_name: str = None,
        deploy_id: int = None,
        description: str = None,
        id: int = None,
        latest_instance_status: int = None,
        latest_instance_time: str = None,
        scenario_id: str = None,
        schedule_param: str = None,
        status: int = None,
        time_zone_id: str = None,
        trigger_type: int = None,
    ):
        # The ID of the user who created the task flow.
        self.creator_id = creator_id
        # The username of the user who created the task flow.
        self.creator_nick_name = creator_nick_name
        # The start time of scheduled scheduling. The task flow is not scheduled before this point in time.
        self.cron_begin_date = cron_begin_date
        # The end time of scheduled scheduling. The task flow is not scheduled after this point in time.
        self.cron_end_date = cron_end_date
        # Scheduled Cron.
        self.cron_str = cron_str
        # Whether to enable scheduled scheduling.
        self.cron_switch = cron_switch
        # Scheduling cycle type. Valid values:
        # - **2**: Hourly scheduling
        # - **3**: Daily scheduling
        # - **4**: Weekly scheduling
        # - **5**: Monthly scheduling
        self.cron_type = cron_type
        # The name of the task flow.
        self.dag_name = dag_name
        # The user ID of the task flow owner.
        self.dag_owner_id = dag_owner_id
        # The username of the owner of the task flow.
        self.dag_owner_nick_name = dag_owner_nick_name
        # The ID of the last deployment record of the task flow.
        self.deploy_id = deploy_id
        # The description of the task flow.
        self.description = description
        # The ID of the task flow.
        self.id = id
        # The status of the last execution of the task flow. Valid values:
        # 
        # *   **0**: invalid
        # *   **1**: scheduling disabled
        # *   **2**: waiting to be scheduled
        self.latest_instance_status = latest_instance_status
        # The time when the last execution record was created.
        self.latest_instance_time = latest_instance_time
        # The ID of the application scenario.
        self.scenario_id = scenario_id
        # Event scheduling configuration, JSON string format.
        self.schedule_param = schedule_param
        # The status of the task flow. Valid values:
        # 
        # *   **0**: invalid
        # *   **1**: scheduling disabled
        # *   **2**: waiting to be scheduled
        self.status = status
        # Time zone setting. Default value: East 8(Asia/Shanghai).
        self.time_zone_id = time_zone_id
        # The trigger type. Valid values:
        # - **0**: Periodic scheduling
        # - **1**: Run manually
        self.trigger_type = trigger_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick_name is not None:
            result['CreatorNickName'] = self.creator_nick_name
        if self.cron_begin_date is not None:
            result['CronBeginDate'] = self.cron_begin_date
        if self.cron_end_date is not None:
            result['CronEndDate'] = self.cron_end_date
        if self.cron_str is not None:
            result['CronStr'] = self.cron_str
        if self.cron_switch is not None:
            result['CronSwitch'] = self.cron_switch
        if self.cron_type is not None:
            result['CronType'] = self.cron_type
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.latest_instance_status is not None:
            result['LatestInstanceStatus'] = self.latest_instance_status
        if self.latest_instance_time is not None:
            result['LatestInstanceTime'] = self.latest_instance_time
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.schedule_param is not None:
            result['ScheduleParam'] = self.schedule_param
        if self.status is not None:
            result['Status'] = self.status
        if self.time_zone_id is not None:
            result['TimeZoneId'] = self.time_zone_id
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNickName') is not None:
            self.creator_nick_name = m.get('CreatorNickName')
        if m.get('CronBeginDate') is not None:
            self.cron_begin_date = m.get('CronBeginDate')
        if m.get('CronEndDate') is not None:
            self.cron_end_date = m.get('CronEndDate')
        if m.get('CronStr') is not None:
            self.cron_str = m.get('CronStr')
        if m.get('CronSwitch') is not None:
            self.cron_switch = m.get('CronSwitch')
        if m.get('CronType') is not None:
            self.cron_type = m.get('CronType')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LatestInstanceStatus') is not None:
            self.latest_instance_status = m.get('LatestInstanceStatus')
        if m.get('LatestInstanceTime') is not None:
            self.latest_instance_time = m.get('LatestInstanceTime')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('ScheduleParam') is not None:
            self.schedule_param = m.get('ScheduleParam')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TimeZoneId') is not None:
            self.time_zone_id = m.get('TimeZoneId')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class ListTaskFlowsByPageResponseBodyTaskFlowList(TeaModel):
    def __init__(
        self,
        task_flow: List[ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow] = None,
    ):
        self.task_flow = task_flow

    def validate(self):
        if self.task_flow:
            for k in self.task_flow:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskFlow'] = []
        if self.task_flow is not None:
            for k in self.task_flow:
                result['TaskFlow'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_flow = []
        if m.get('TaskFlow') is not None:
            for k in m.get('TaskFlow'):
                temp_model = ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow()
                self.task_flow.append(temp_model.from_map(k))
        return self


class ListTaskFlowsByPageResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        task_flow_list: ListTaskFlowsByPageResponseBodyTaskFlowList = None,
        total_count: int = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The details of the returned task flows.
        self.task_flow_list = task_flow_list
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.task_flow_list:
            self.task_flow_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_flow_list is not None:
            result['TaskFlowList'] = self.task_flow_list.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskFlowList') is not None:
            temp_model = ListTaskFlowsByPageResponseBodyTaskFlowList()
            self.task_flow_list = temp_model.from_map(m['TaskFlowList'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTaskFlowsByPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowsByPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowsByPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTasksInTaskFlowRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTasksInTaskFlowResponseBodyTasksTask(TeaModel):
    def __init__(
        self,
        graph_param: str = None,
        node_config: str = None,
        node_content: str = None,
        node_id: str = None,
        node_name: str = None,
        node_output: str = None,
        node_type: str = None,
        time_variables: str = None,
    ):
        # The position of the node on the Directed Acyclic Graph (DAG).
        self.graph_param = graph_param
        # The advanced configuration for the node.
        self.node_config = node_config
        # The configuration for the node.
        self.node_content = node_content
        # The ID of the node.
        self.node_id = node_id
        # The name of the node.
        self.node_name = node_name
        # The output variables for the task.
        self.node_output = node_output
        # The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](https://help.aliyun.com/document_detail/424705.html).
        self.node_type = node_type
        # The time variables configured for the node.
        self.time_variables = time_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.graph_param is not None:
            result['GraphParam'] = self.graph_param
        if self.node_config is not None:
            result['NodeConfig'] = self.node_config
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_output is not None:
            result['NodeOutput'] = self.node_output
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GraphParam') is not None:
            self.graph_param = m.get('GraphParam')
        if m.get('NodeConfig') is not None:
            self.node_config = m.get('NodeConfig')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeOutput') is not None:
            self.node_output = m.get('NodeOutput')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class ListTasksInTaskFlowResponseBodyTasks(TeaModel):
    def __init__(
        self,
        task: List[ListTasksInTaskFlowResponseBodyTasksTask] = None,
    ):
        self.task = task

    def validate(self):
        if self.task:
            for k in self.task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Task'] = []
        if self.task is not None:
            for k in self.task:
                result['Task'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task = []
        if m.get('Task') is not None:
            for k in m.get('Task'):
                temp_model = ListTasksInTaskFlowResponseBodyTasksTask()
                self.task.append(temp_model.from_map(k))
        return self


class ListTasksInTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tasks: ListTasksInTaskFlowResponseBodyTasks = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The tasks in the task flow.
        self.tasks = tasks

    def validate(self):
        if self.tasks:
            self.tasks.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tasks is not None:
            result['Tasks'] = self.tasks.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tasks') is not None:
            temp_model = ListTasksInTaskFlowResponseBodyTasks()
            self.tasks = temp_model.from_map(m['Tasks'])
        return self


class ListTasksInTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTasksInTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTasksInTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserPermissionsRequest(TeaModel):
    def __init__(
        self,
        database_name: str = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        page_number: int = None,
        page_size: int = None,
        perm_type: str = None,
        search_key: str = None,
        tid: int = None,
        user_id: str = None,
    ):
        # The name of the database.
        self.database_name = database_name
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        self.db_type = db_type
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   product: production environment
        # *   dev: development environment
        # *   pre: staging environment
        # *   test: test environment
        # *   sit: SIT environment
        # *   uat: user acceptance testing (UAT) environment
        # *   pet: stress testing environment
        # *   stag: STAG environment
        self.env_type = env_type
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   true: The database is a logical database.
        # *   false: The database is a physical database.
        self.logic = logic
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The permissions on a specific type of resources that you want to query. Valid values:
        # 
        # *   DATABASE: permissions on databases
        # *   TABLE: permissions on tables
        # *   COLUMN: permissions on fields
        # *   INSTANCE: permissions on instances
        # 
        # This parameter is required.
        self.perm_type = perm_type
        # The keyword used in the query. For example, if you want to query permissions on an instance, you can specify the endpoint of the instance, such as rm-bp144d5ky4l4r****.
        self.search_key = search_key
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid
        # The ID of the user. You can call the [GetUser](https://help.aliyun.com/document_detail/147098.html) or [ListUsers](https://help.aliyun.com/document_detail/141938.html) operation to query the ID of the user.
        # 
        # >  The user ID is different from the ID of your Alibaba Cloud account.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail(TeaModel):
    def __init__(
        self,
        create_date: str = None,
        expire_date: str = None,
        extra_data: str = None,
        origin_from: str = None,
        perm_type: str = None,
        user_access_id: str = None,
    ):
        # The time when the permissions were granted.
        self.create_date = create_date
        # The time when the permissions expire.
        self.expire_date = expire_date
        # This parameter is reserved.
        self.extra_data = extra_data
        # The user who grants the permissions.
        self.origin_from = origin_from
        # The type of the permissions. Valid values:
        # 
        # *   QUERY: the query permissions
        # *   EXPORT: the export permissions
        # *   CORRECT: the change permissions
        self.perm_type = perm_type
        # The ID of the authorization record.
        self.user_access_id = user_access_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_date is not None:
            result['CreateDate'] = self.create_date
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.extra_data is not None:
            result['ExtraData'] = self.extra_data
        if self.origin_from is not None:
            result['OriginFrom'] = self.origin_from
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.user_access_id is not None:
            result['UserAccessId'] = self.user_access_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateDate') is not None:
            self.create_date = m.get('CreateDate')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('ExtraData') is not None:
            self.extra_data = m.get('ExtraData')
        if m.get('OriginFrom') is not None:
            self.origin_from = m.get('OriginFrom')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('UserAccessId') is not None:
            self.user_access_id = m.get('UserAccessId')
        return self


class ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails(TeaModel):
    def __init__(
        self,
        perm_detail: List[ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail] = None,
    ):
        self.perm_detail = perm_detail

    def validate(self):
        if self.perm_detail:
            for k in self.perm_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PermDetail'] = []
        if self.perm_detail is not None:
            for k in self.perm_detail:
                result['PermDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.perm_detail = []
        if m.get('PermDetail') is not None:
            for k in m.get('PermDetail'):
                temp_model = ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail()
                self.perm_detail.append(temp_model.from_map(k))
        return self


class ListUserPermissionsResponseBodyUserPermissionsUserPermission(TeaModel):
    def __init__(
        self,
        alias: str = None,
        column_name: str = None,
        db_id: str = None,
        db_type: str = None,
        ds_type: str = None,
        env_type: str = None,
        host: str = None,
        instance_id: str = None,
        logic: bool = None,
        perm_details: ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails = None,
        port: int = None,
        schema_name: str = None,
        search_name: str = None,
        table_id: str = None,
        table_name: str = None,
        user_id: str = None,
        user_nick_name: str = None,
    ):
        # The alias of the instance.
        self.alias = alias
        # The name of the field.
        self.column_name = column_name
        # The ID of the database.
        self.db_id = db_id
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://www.alibabacloud.com/help/en/data-management-service/latest/dbtype-parameter).
        self.db_type = db_type
        # The permissions on a specific type of objects that are granted to the user. Valid values: 
        # 
        # - DATABASE: permissions on physical databases
        # - LOGIC_DATABASE: permissions on logical databases
        # - TABLE: permissions on physical tables
        # - LOGIC_TABLE: permissions on logical tables
        self.ds_type = ds_type
        # The type of the environment to which the database belongs. Valid values:
        # 
        # - product: production environment
        # - dev: development environment
        # - pre: staging environment
        # - test: test environment
        # - sit: SIT environment
        # - uat: UAT environment
        # - pet: stress testing environment
        # - stag: STAG environment
        self.env_type = env_type
        # The endpoint that is used to connect the database.
        self.host = host
        # The ID of the instance.
        self.instance_id = instance_id
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   true: The database is a logical database.
        # *   false: The database is a physical database.
        self.logic = logic
        # The details of permissions.
        self.perm_details = perm_details
        # The port that is used to connect to the instance.
        self.port = port
        # The name of the database.
        self.schema_name = schema_name
        # The name that is used to search for the database.
        self.search_name = search_name
        # The ID of the table.
        self.table_id = table_id
        # The name of the table.
        self.table_name = table_name
        # The ID of the user.
        self.user_id = user_id
        # The nickname of the user.
        self.user_nick_name = user_nick_name

    def validate(self):
        if self.perm_details:
            self.perm_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.perm_details is not None:
            result['PermDetails'] = self.perm_details.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick_name is not None:
            result['UserNickName'] = self.user_nick_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermDetails') is not None:
            temp_model = ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails()
            self.perm_details = temp_model.from_map(m['PermDetails'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNickName') is not None:
            self.user_nick_name = m.get('UserNickName')
        return self


class ListUserPermissionsResponseBodyUserPermissions(TeaModel):
    def __init__(
        self,
        user_permission: List[ListUserPermissionsResponseBodyUserPermissionsUserPermission] = None,
    ):
        self.user_permission = user_permission

    def validate(self):
        if self.user_permission:
            for k in self.user_permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserPermission'] = []
        if self.user_permission is not None:
            for k in self.user_permission:
                result['UserPermission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user_permission = []
        if m.get('UserPermission') is not None:
            for k in m.get('UserPermission'):
                temp_model = ListUserPermissionsResponseBodyUserPermissionsUserPermission()
                self.user_permission.append(temp_model.from_map(k))
        return self


class ListUserPermissionsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
        user_permissions: ListUserPermissionsResponseBodyUserPermissions = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success
        # The total number of entries that meet the query conditions.
        self.total_count = total_count
        # The details of the permissions that the user has.
        self.user_permissions = user_permissions

    def validate(self):
        if self.user_permissions:
            self.user_permissions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_permissions is not None:
            result['UserPermissions'] = self.user_permissions.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserPermissions') is not None:
            temp_model = ListUserPermissionsResponseBodyUserPermissions()
            self.user_permissions = temp_model.from_map(m['UserPermissions'])
        return self


class ListUserPermissionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUserPermissionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserPermissionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserTenantsRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListUserTenantsResponseBodyTenantList(TeaModel):
    def __init__(
        self,
        status: str = None,
        tenant_name: str = None,
        tid: int = None,
    ):
        # The status of the tenant. Valid values:
        # 
        # *   **ACTIVE**: The tenant is used to access DMS.
        # *   **IN_ACTIVE**: The tenant is not used.
        self.status = status
        # The name of the tenant.
        self.tenant_name = tenant_name
        # The ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListUserTenantsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tenant_list: List[ListUserTenantsResponseBodyTenantList] = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success
        # The details of the tenants that were returned.
        self.tenant_list = tenant_list

    def validate(self):
        if self.tenant_list:
            for k in self.tenant_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TenantList'] = []
        if self.tenant_list is not None:
            for k in self.tenant_list:
                result['TenantList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.tenant_list = []
        if m.get('TenantList') is not None:
            for k in m.get('TenantList'):
                temp_model = ListUserTenantsResponseBodyTenantList()
                self.tenant_list.append(temp_model.from_map(k))
        return self


class ListUserTenantsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUserTenantsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserTenantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUsersRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        role: str = None,
        search_key: str = None,
        tid: int = None,
        user_state: str = None,
    ):
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        # 
        # **\
        # 
        # Valid values: 10, 20, 50, and 100.**** Default value: 10.
        self.page_size = page_size
        # The role that is assigned to the user. Valid values:
        # 
        # *   **USER**: a regular user.
        # *   **DBA** : a database administrator (DBA).
        # *   **ADMIN**: a Data Management (DMS) administrator.
        # *   **SECURITY_ADMIN**: a security administrator.
        # *   **STRUCT_READ_ONLY**: a schema read-only user.
        # 
        # >  To check your role, move the pointer over the profile picture in the upper-right corner of the DMS console.
        self.role = role
        # The search keyword. Fuzzy match is supported.
        self.search_key = search_key
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
        self.tid = tid
        # The status of the user. Valid values:
        # 
        # *   **NORMAL**: The user is normal.
        # *   **DISABLE**: The user is disabled.
        # *   **DELETE**: The user is deleted.
        self.user_state = user_state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.role is not None:
            result['Role'] = self.role
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_state is not None:
            result['UserState'] = self.user_state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        return self


class ListUsersResponseBodyUserListUserRoleIdList(TeaModel):
    def __init__(
        self,
        role_ids: List[int] = None,
    ):
        self.role_ids = role_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_ids is not None:
            result['RoleIds'] = self.role_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoleIds') is not None:
            self.role_ids = m.get('RoleIds')
        return self


class ListUsersResponseBodyUserListUserRoleNameList(TeaModel):
    def __init__(
        self,
        role_names: List[str] = None,
    ):
        self.role_names = role_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_names is not None:
            result['RoleNames'] = self.role_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoleNames') is not None:
            self.role_names = m.get('RoleNames')
        return self


class ListUsersResponseBodyUserListUser(TeaModel):
    def __init__(
        self,
        cur_execute_count: int = None,
        cur_result_count: int = None,
        ding_robot: str = None,
        email: str = None,
        last_login_time: str = None,
        max_execute_count: int = None,
        max_result_count: int = None,
        mobile: str = None,
        nick_name: str = None,
        notification_mode: str = None,
        parent_uid: str = None,
        role_id_list: ListUsersResponseBodyUserListUserRoleIdList = None,
        role_name_list: ListUsersResponseBodyUserListUserRoleNameList = None,
        signature_method: str = None,
        state: str = None,
        uid: str = None,
        user_id: str = None,
        webhook: str = None,
    ):
        # The number of queries that were performed on the current day.
        self.cur_execute_count = cur_execute_count
        # The number of rows that were queried on the current day.
        self.cur_result_count = cur_result_count
        # The DingTalk chatbot URL that is used to receive notifications.
        # 
        # > 
        # 
        # *   The system returns this parameter if you have set a DingTalk chatbot URL in the console. To set a DingTalk chatbot URL in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # 
        # *   The system does not return this parameter if you have not set a DingTalk chatbot URL.
        self.ding_robot = ding_robot
        # The email address that is used to receive notifications.
        # 
        # > 
        # 
        # *   The system returns this parameter if you have set an email address in the console. To set an email address in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # 
        # *   The system does not return this parameter if you have not set an email address.
        self.email = email
        # The time when the user last logged on to the console.
        self.last_login_time = last_login_time
        # The maximum number of queries that can be performed on the current day.
        self.max_execute_count = max_execute_count
        # The maximum number of rows that can be queried on the current day.
        self.max_result_count = max_result_count
        # The mobile phone number of the user.
        # 
        # > 
        # 
        # *   The system returns this parameter if you have set a mobile phone number in the console. To set a mobile phone number in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # 
        # *   The system does not return this parameter if you have not set a mobile phone number.
        self.mobile = mobile
        # The nickname of the user.
        self.nick_name = nick_name
        # The notification method. The system returns one or more values. Valid values:
        # 
        # *   **SMS**: text message
        # *   **EMAIL**: email.
        # *   **DINGDING**: DingTalk.
        # *   **DINGROBOT**: DingTalk chatbot.
        # *   **WEBHOOK**: webhook.
        self.notification_mode = notification_mode
        # The ID of the Alibaba Cloud account of the user.
        self.parent_uid = parent_uid
        # The IDs of the roles.
        self.role_id_list = role_id_list
        # The names of roles.
        self.role_name_list = role_name_list
        # The signature method that is used to secure connections when a webhook URL is used. Valid values:
        # 
        # *   **NONE**: no signature.
        # *   **HMAC_SHA1**: HMAC_SHA1.
        self.signature_method = signature_method
        # The status of the user. Valid values:
        # 
        # *   **NORMAL**: The user is normal.
        # *   **DISABLE**: The user is disabled.
        # *   **DELETE**: The user is deleted.
        self.state = state
        # The ID of the Alibaba Cloud account.
        self.uid = uid
        # The ID of the user.
        self.user_id = user_id
        # The webhook URL that is used to receive notifications.
        # 
        # > 
        # 
        # *   If you have set a webhook URL, DMS sends notifications to the specified URL.
        # 
        # *   The system does not return this parameter if you have not set a webhook URL.
        self.webhook = webhook

    def validate(self):
        if self.role_id_list:
            self.role_id_list.validate()
        if self.role_name_list:
            self.role_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cur_execute_count is not None:
            result['CurExecuteCount'] = self.cur_execute_count
        if self.cur_result_count is not None:
            result['CurResultCount'] = self.cur_result_count
        if self.ding_robot is not None:
            result['DingRobot'] = self.ding_robot
        if self.email is not None:
            result['Email'] = self.email
        if self.last_login_time is not None:
            result['LastLoginTime'] = self.last_login_time
        if self.max_execute_count is not None:
            result['MaxExecuteCount'] = self.max_execute_count
        if self.max_result_count is not None:
            result['MaxResultCount'] = self.max_result_count
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.notification_mode is not None:
            result['NotificationMode'] = self.notification_mode
        if self.parent_uid is not None:
            result['ParentUid'] = self.parent_uid
        if self.role_id_list is not None:
            result['RoleIdList'] = self.role_id_list.to_map()
        if self.role_name_list is not None:
            result['RoleNameList'] = self.role_name_list.to_map()
        if self.signature_method is not None:
            result['SignatureMethod'] = self.signature_method
        if self.state is not None:
            result['State'] = self.state
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurExecuteCount') is not None:
            self.cur_execute_count = m.get('CurExecuteCount')
        if m.get('CurResultCount') is not None:
            self.cur_result_count = m.get('CurResultCount')
        if m.get('DingRobot') is not None:
            self.ding_robot = m.get('DingRobot')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('LastLoginTime') is not None:
            self.last_login_time = m.get('LastLoginTime')
        if m.get('MaxExecuteCount') is not None:
            self.max_execute_count = m.get('MaxExecuteCount')
        if m.get('MaxResultCount') is not None:
            self.max_result_count = m.get('MaxResultCount')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('NotificationMode') is not None:
            self.notification_mode = m.get('NotificationMode')
        if m.get('ParentUid') is not None:
            self.parent_uid = m.get('ParentUid')
        if m.get('RoleIdList') is not None:
            temp_model = ListUsersResponseBodyUserListUserRoleIdList()
            self.role_id_list = temp_model.from_map(m['RoleIdList'])
        if m.get('RoleNameList') is not None:
            temp_model = ListUsersResponseBodyUserListUserRoleNameList()
            self.role_name_list = temp_model.from_map(m['RoleNameList'])
        if m.get('SignatureMethod') is not None:
            self.signature_method = m.get('SignatureMethod')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class ListUsersResponseBodyUserList(TeaModel):
    def __init__(
        self,
        user: List[ListUsersResponseBodyUserListUser] = None,
    ):
        self.user = user

    def validate(self):
        if self.user:
            for k in self.user:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['User'] = []
        if self.user is not None:
            for k in self.user:
                result['User'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user = []
        if m.get('User') is not None:
            for k in m.get('User'):
                temp_model = ListUsersResponseBodyUserListUser()
                self.user.append(temp_model.from_map(k))
        return self


class ListUsersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
        user_list: ListUsersResponseBodyUserList = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The total number of entries returned.
        self.total_count = total_count
        # The details of users.
        self.user_list = user_list

    def validate(self):
        if self.user_list:
            self.user_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_list is not None:
            result['UserList'] = self.user_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserList') is not None:
            temp_model = ListUsersResponseBodyUserList()
            self.user_list = temp_model.from_map(m['UserList'])
        return self


class ListUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkFlowNodesRequest(TeaModel):
    def __init__(
        self,
        search_name: str = None,
        tid: int = None,
    ):
        # The name that is used to search for approval nodes.
        self.search_name = search_name
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser(TeaModel):
    def __init__(
        self,
        nick_name: str = None,
        real_name: str = None,
        user_id: int = None,
    ):
        # The nickname of the approver.
        self.nick_name = nick_name
        # The real name of the approver.
        self.real_name = real_name
        # The ID of the approver. The ID is different from the ID of the Alibaba Cloud account of the approver.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.real_name is not None:
            result['RealName'] = self.real_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('RealName') is not None:
            self.real_name = m.get('RealName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers(TeaModel):
    def __init__(
        self,
        audit_user: List[ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser] = None,
    ):
        self.audit_user = audit_user

    def validate(self):
        if self.audit_user:
            for k in self.audit_user:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuditUser'] = []
        if self.audit_user is not None:
            for k in self.audit_user:
                result['AuditUser'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audit_user = []
        if m.get('AuditUser') is not None:
            for k in m.get('AuditUser'):
                temp_model = ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser()
                self.audit_user.append(temp_model.from_map(k))
        return self


class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode(TeaModel):
    def __init__(
        self,
        audit_users: ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers = None,
        comment: str = None,
        create_user_id: int = None,
        create_user_nick_name: str = None,
        node_id: int = None,
        node_name: str = None,
        node_type: str = None,
    ):
        # The details about approvers.
        self.audit_users = audit_users
        # The description of the approval template.
        self.comment = comment
        # The ID of the creator. This ID is different from the ID of the Alibaba Cloud account of the creator.
        self.create_user_id = create_user_id
        # The name of the user who creates the approval node.
        self.create_user_nick_name = create_user_nick_name
        # The ID of the approval node.
        self.node_id = node_id
        # The name of the approval node.
        self.node_name = node_name
        # The type of the approval node. Valid values:
        # 
        # *   SYS: The approval node is predefined by the system.
        # *   USER_LIST: The approval node is created by a user.
        self.node_type = node_type

    def validate(self):
        if self.audit_users:
            self.audit_users.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_users is not None:
            result['AuditUsers'] = self.audit_users.to_map()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.create_user_nick_name is not None:
            result['CreateUserNickName'] = self.create_user_nick_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditUsers') is not None:
            temp_model = ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers()
            self.audit_users = temp_model.from_map(m['AuditUsers'])
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('CreateUserNickName') is not None:
            self.create_user_nick_name = m.get('CreateUserNickName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        return self


class ListWorkFlowNodesResponseBodyWorkflowNodes(TeaModel):
    def __init__(
        self,
        workflow_node: List[ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode] = None,
    ):
        self.workflow_node = workflow_node

    def validate(self):
        if self.workflow_node:
            for k in self.workflow_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkflowNode'] = []
        if self.workflow_node is not None:
            for k in self.workflow_node:
                result['WorkflowNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.workflow_node = []
        if m.get('WorkflowNode') is not None:
            for k in m.get('WorkflowNode'):
                temp_model = ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode()
                self.workflow_node.append(temp_model.from_map(k))
        return self


class ListWorkFlowNodesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        workflow_nodes: ListWorkFlowNodesResponseBodyWorkflowNodes = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success
        # The details of approval nodes.
        self.workflow_nodes = workflow_nodes

    def validate(self):
        if self.workflow_nodes:
            self.workflow_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.workflow_nodes is not None:
            result['WorkflowNodes'] = self.workflow_nodes.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('WorkflowNodes') is not None:
            temp_model = ListWorkFlowNodesResponseBodyWorkflowNodes()
            self.workflow_nodes = temp_model.from_map(m['WorkflowNodes'])
        return self


class ListWorkFlowNodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkFlowNodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkFlowNodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkFlowTemplatesRequest(TeaModel):
    def __init__(
        self,
        search_name: str = None,
        tid: int = None,
    ):
        # The name that is used to query approval templates.
        self.search_name = search_name
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode(TeaModel):
    def __init__(
        self,
        comment: str = None,
        create_user_id: int = None,
        node_id: int = None,
        node_name: str = None,
        node_type: str = None,
        position: int = None,
        template_id: int = None,
    ):
        # The description of the approval node.
        self.comment = comment
        # The ID of the creator.
        self.create_user_id = create_user_id
        # The ID of the approval node.
        self.node_id = node_id
        # The name of the approval node.
        self.node_name = node_name
        # The type of the approval node. Valid values:
        # 
        # *   SYS: The approval node is predefined by the system.
        # *   USER_LIST: The approval node is created by a user.
        self.node_type = node_type
        # The position of the approval node.
        self.position = position
        # The ID of the template.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.position is not None:
            result['Position'] = self.position
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes(TeaModel):
    def __init__(
        self,
        workflow_node: List[ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode] = None,
    ):
        self.workflow_node = workflow_node

    def validate(self):
        if self.workflow_node:
            for k in self.workflow_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkflowNode'] = []
        if self.workflow_node is not None:
            for k in self.workflow_node:
                result['WorkflowNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.workflow_node = []
        if m.get('WorkflowNode') is not None:
            for k in m.get('WorkflowNode'):
                temp_model = ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode()
                self.workflow_node.append(temp_model.from_map(k))
        return self


class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate(TeaModel):
    def __init__(
        self,
        comment: str = None,
        create_user_id: int = None,
        enabled: str = None,
        is_system: int = None,
        template_id: int = None,
        template_name: str = None,
        workflow_nodes: ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes = None,
    ):
        # The description of the approval template.
        self.comment = comment
        # The ID of the creator.
        self.create_user_id = create_user_id
        # Indicates whether the approval template is enabled. Valid values:
        # 
        # *   Y: The approval template is enabled.
        # *   N: The approval template is disabled.
        self.enabled = enabled
        # Indicates whether the approval template is predefined by the system. Valid values:
        # 
        # *   1: The approval template is predefined by the system.
        # *   0: The approval template is not predefined by the system.
        self.is_system = is_system
        # The ID of the approval template.
        self.template_id = template_id
        # The name of the approval template.
        self.template_name = template_name
        # The details of approval nodes.
        self.workflow_nodes = workflow_nodes

    def validate(self):
        if self.workflow_nodes:
            self.workflow_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.is_system is not None:
            result['IsSystem'] = self.is_system
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.workflow_nodes is not None:
            result['WorkflowNodes'] = self.workflow_nodes.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('IsSystem') is not None:
            self.is_system = m.get('IsSystem')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('WorkflowNodes') is not None:
            temp_model = ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes()
            self.workflow_nodes = temp_model.from_map(m['WorkflowNodes'])
        return self


class ListWorkFlowTemplatesResponseBodyWorkFlowTemplates(TeaModel):
    def __init__(
        self,
        work_flow_template: List[ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate] = None,
    ):
        self.work_flow_template = work_flow_template

    def validate(self):
        if self.work_flow_template:
            for k in self.work_flow_template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkFlowTemplate'] = []
        if self.work_flow_template is not None:
            for k in self.work_flow_template:
                result['WorkFlowTemplate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.work_flow_template = []
        if m.get('WorkFlowTemplate') is not None:
            for k in m.get('WorkFlowTemplate'):
                temp_model = ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate()
                self.work_flow_template.append(temp_model.from_map(k))
        return self


class ListWorkFlowTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        work_flow_templates: ListWorkFlowTemplatesResponseBodyWorkFlowTemplates = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success
        # The approval templates.
        self.work_flow_templates = work_flow_templates

    def validate(self):
        if self.work_flow_templates:
            self.work_flow_templates.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.work_flow_templates is not None:
            result['WorkFlowTemplates'] = self.work_flow_templates.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('WorkFlowTemplates') is not None:
            temp_model = ListWorkFlowTemplatesResponseBodyWorkFlowTemplates()
            self.work_flow_templates = temp_model.from_map(m['WorkFlowTemplates'])
        return self


class ListWorkFlowTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkFlowTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkFlowTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MakeTaskFlowInstanceSuccessRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_instance_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to query the execution record ID.
        # 
        # This parameter is required.
        self.dag_instance_id = dag_instance_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class MakeTaskFlowInstanceSuccessResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MakeTaskFlowInstanceSuccessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MakeTaskFlowInstanceSuccessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MakeTaskFlowInstanceSuccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDataCorrectExecSQLRequest(TeaModel):
    def __init__(
        self,
        exec_sql: str = None,
        order_id: int = None,
        real_login_user_uid: str = None,
        tid: int = None,
    ):
        # The new SQL script.
        # 
        # This parameter is required.
        self.exec_sql = exec_sql
        # The ID of the data change ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        self.real_login_user_uid = real_login_user_uid
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exec_sql is not None:
            result['ExecSQL'] = self.exec_sql
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExecSQL') is not None:
            self.exec_sql = m.get('ExecSQL')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ModifyDataCorrectExecSQLResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyDataCorrectExecSQLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyDataCorrectExecSQLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDataCorrectExecSQLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDesensitizationStrategyRequest(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        db_id: int = None,
        is_default: bool = None,
        is_logic: bool = None,
        is_reset: bool = None,
        rule_id: int = None,
        schema_name: str = None,
        table_name: str = None,
        tid: int = None,
    ):
        # The name of the field. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the field name.
        # 
        # >  You can also call the [ListColumns](https://help.aliyun.com/document_detail/141870.html) operation to obtain the field name.
        # 
        # This parameter is required.
        self.column_name = column_name
        # The ID of the database. You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to obtain the ID.
        # 
        # This parameter is required.
        self.db_id = db_id
        # The desensitization algorithm of the field setting. The default value is false. The values are as follows:
        # 
        # - **true**: default desensitization algorithm.
        # 
        # - **false** :semi-desensitization algorithm.
        self.is_default = is_default
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a physical database.
        # *   **false**: The database is a logical database.
        # 
        # This parameter is required.
        self.is_logic = is_logic
        # Specifies whether to reset the masking rule. Valid value:
        # 
        # *   **true**: Reset the masking rule.
        # *   **false**: Do not reset the masking rule. This is the default value.
        self.is_reset = is_reset
        # The ID of the masking rule.
        self.rule_id = rule_id
        # The name of the database. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the database name.
        # 
        # > 
        # 
        # *   If the database is a physical database, you can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the database name.
        # 
        # *   If the database is a logical database, you can call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the name of the database.
        # 
        # This parameter is required.
        self.schema_name = schema_name
        # The name of the table. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the table name.
        # 
        # >  You can also call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to obtain the table name.
        # 
        # This parameter is required.
        self.table_name = table_name
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) in the topic "Manage DMS tenants."
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.is_logic is not None:
            result['IsLogic'] = self.is_logic
        if self.is_reset is not None:
            result['IsReset'] = self.is_reset
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('IsLogic') is not None:
            self.is_logic = m.get('IsLogic')
        if m.get('IsReset') is not None:
            self.is_reset = m.get('IsReset')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ModifyDesensitizationStrategyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: bool = None,
        success: bool = None,
    ):
        # The status code.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # The returned result.
        self.result = result
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyDesensitizationStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyDesensitizationStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDesensitizationStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceRequest(TeaModel):
    def __init__(
        self,
        data_link_name: str = None,
        database_password: str = None,
        database_user: str = None,
        dba_id: int = None,
        ddl_online: int = None,
        ecs_instance_id: str = None,
        ecs_region: str = None,
        enable_sell_common: str = None,
        enable_sell_sitd: str = None,
        enable_sell_stable: str = None,
        enable_sell_trust: str = None,
        env_type: str = None,
        export_timeout: int = None,
        host: str = None,
        instance_alias: str = None,
        instance_id: str = None,
        instance_source: str = None,
        instance_type: str = None,
        network_type: str = None,
        port: int = None,
        query_timeout: int = None,
        safe_rule: str = None,
        sid: str = None,
        skip_test: bool = None,
        template_id: int = None,
        template_type: str = None,
        tid: int = None,
        use_dsql: int = None,
        use_ssl: int = None,
        vpc_id: str = None,
    ):
        self.data_link_name = data_link_name
        self.database_password = database_password
        self.database_user = database_user
        self.dba_id = dba_id
        self.ddl_online = ddl_online
        self.ecs_instance_id = ecs_instance_id
        self.ecs_region = ecs_region
        self.enable_sell_common = enable_sell_common
        self.enable_sell_sitd = enable_sell_sitd
        self.enable_sell_stable = enable_sell_stable
        self.enable_sell_trust = enable_sell_trust
        self.env_type = env_type
        self.export_timeout = export_timeout
        self.host = host
        self.instance_alias = instance_alias
        # This parameter is required.
        self.instance_id = instance_id
        self.instance_source = instance_source
        self.instance_type = instance_type
        self.network_type = network_type
        self.port = port
        self.query_timeout = query_timeout
        self.safe_rule = safe_rule
        self.sid = sid
        self.skip_test = skip_test
        self.template_id = template_id
        self.template_type = template_type
        self.tid = tid
        self.use_dsql = use_dsql
        self.use_ssl = use_ssl
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.enable_sell_common is not None:
            result['EnableSellCommon'] = self.enable_sell_common
        if self.enable_sell_sitd is not None:
            result['EnableSellSitd'] = self.enable_sell_sitd
        if self.enable_sell_stable is not None:
            result['EnableSellStable'] = self.enable_sell_stable
        if self.enable_sell_trust is not None:
            result['EnableSellTrust'] = self.enable_sell_trust
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule is not None:
            result['SafeRule'] = self.safe_rule
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.skip_test is not None:
            result['SkipTest'] = self.skip_test
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.use_ssl is not None:
            result['UseSsl'] = self.use_ssl
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnableSellCommon') is not None:
            self.enable_sell_common = m.get('EnableSellCommon')
        if m.get('EnableSellSitd') is not None:
            self.enable_sell_sitd = m.get('EnableSellSitd')
        if m.get('EnableSellStable') is not None:
            self.enable_sell_stable = m.get('EnableSellStable')
        if m.get('EnableSellTrust') is not None:
            self.enable_sell_trust = m.get('EnableSellTrust')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRule') is not None:
            self.safe_rule = m.get('SafeRule')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('SkipTest') is not None:
            self.skip_test = m.get('SkipTest')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('UseSsl') is not None:
            self.use_ssl = m.get('UseSsl')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ModifyInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveTaskFlowToScenarioRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        scenario_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the business scenario to which you want to migrate your task flow. If this parameter is set to the default value or a value that is less than or equal to 0, the task flow is migrated to the default business scenario.
        self.scenario_id = scenario_id
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class MoveTaskFlowToScenarioResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MoveTaskFlowToScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MoveTaskFlowToScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveTaskFlowToScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OfflineTaskFlowRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class OfflineTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class OfflineTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OfflineTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OfflineTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PauseDataCorrectSQLJobRequest(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        order_id: int = None,
        tid: int = None,
        type: str = None,
    ):
        # The ID of the SQL task. You can call the [GetDataCorrectTaskDetail](https://help.aliyun.com/document_detail/208481.html) or [ListDBTaskSQLJob](https://help.aliyun.com/document_detail/207049.html) operation to obtain the value of this parameter.
        # 
        # >  If Type is set to SINGLE, you must pass in the value of JobId to confirm the ID of the SQL task that you want to pause.
        self.job_id = job_id
        # The ID of the data change ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the data change ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid
        # The type of the pause operation. Valid values:
        # 
        # *   ALL: pauses all SQL tasks.
        # *   SINGLE: pauses a single SQL task.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class PauseDataCorrectSQLJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PauseDataCorrectSQLJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PauseDataCorrectSQLJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PauseDataCorrectSQLJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PauseDataExportJobRequest(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        order_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.job_id = job_id
        # This parameter is required.
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class PauseDataExportJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PauseDataExportJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PauseDataExportJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PauseDataExportJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PreviewWorkflowRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser(TeaModel):
    def __init__(
        self,
        nick_name: str = None,
        real_name: str = None,
        user_id: int = None,
    ):
        self.nick_name = nick_name
        self.real_name = real_name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.real_name is not None:
            result['RealName'] = self.real_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('RealName') is not None:
            self.real_name = m.get('RealName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList(TeaModel):
    def __init__(
        self,
        audit_user: List[PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser] = None,
    ):
        self.audit_user = audit_user

    def validate(self):
        if self.audit_user:
            for k in self.audit_user:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuditUser'] = []
        if self.audit_user is not None:
            for k in self.audit_user:
                result['AuditUser'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audit_user = []
        if m.get('AuditUser') is not None:
            for k in m.get('AuditUser'):
                temp_model = PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser()
                self.audit_user.append(temp_model.from_map(k))
        return self


class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode(TeaModel):
    def __init__(
        self,
        audit_user_list: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList = None,
        comment: str = None,
        node_name: str = None,
        node_type: str = None,
    ):
        self.audit_user_list = audit_user_list
        self.comment = comment
        self.node_name = node_name
        self.node_type = node_type

    def validate(self):
        if self.audit_user_list:
            self.audit_user_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_user_list is not None:
            result['AuditUserList'] = self.audit_user_list.to_map()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditUserList') is not None:
            temp_model = PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList()
            self.audit_user_list = temp_model.from_map(m['AuditUserList'])
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        return self


class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList(TeaModel):
    def __init__(
        self,
        workflow_node: List[PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode] = None,
    ):
        self.workflow_node = workflow_node

    def validate(self):
        if self.workflow_node:
            for k in self.workflow_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkflowNode'] = []
        if self.workflow_node is not None:
            for k in self.workflow_node:
                result['WorkflowNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.workflow_node = []
        if m.get('WorkflowNode') is not None:
            for k in m.get('WorkflowNode'):
                temp_model = PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode()
                self.workflow_node.append(temp_model.from_map(k))
        return self


class PreviewWorkflowResponseBodyWorkflowDetail(TeaModel):
    def __init__(
        self,
        comment: str = None,
        wf_cate_name: str = None,
        workflow_node_list: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList = None,
    ):
        self.comment = comment
        self.wf_cate_name = wf_cate_name
        self.workflow_node_list = workflow_node_list

    def validate(self):
        if self.workflow_node_list:
            self.workflow_node_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.wf_cate_name is not None:
            result['WfCateName'] = self.wf_cate_name
        if self.workflow_node_list is not None:
            result['WorkflowNodeList'] = self.workflow_node_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('WfCateName') is not None:
            self.wf_cate_name = m.get('WfCateName')
        if m.get('WorkflowNodeList') is not None:
            temp_model = PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList()
            self.workflow_node_list = temp_model.from_map(m['WorkflowNodeList'])
        return self


class PreviewWorkflowResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        workflow_detail: PreviewWorkflowResponseBodyWorkflowDetail = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.workflow_detail = workflow_detail

    def validate(self):
        if self.workflow_detail:
            self.workflow_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.workflow_detail is not None:
            result['WorkflowDetail'] = self.workflow_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('WorkflowDetail') is not None:
            temp_model = PreviewWorkflowResponseBodyWorkflowDetail()
            self.workflow_detail = temp_model.from_map(m['WorkflowDetail'])
        return self


class PreviewWorkflowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PreviewWorkflowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PreviewWorkflowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublishAndDeployTaskFlowRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
        version_comments: str = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid
        # The description of the version.
        self.version_comments = version_comments

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.version_comments is not None:
            result['VersionComments'] = self.version_comments
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('VersionComments') is not None:
            self.version_comments = m.get('VersionComments')
        return self


class PublishAndDeployTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        deploy_id: int = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the deployment record.
        self.deploy_id = deploy_id
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PublishAndDeployTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PublishAndDeployTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublishAndDeployTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDataTrackResultDownloadStatusRequest(TeaModel):
    def __init__(
        self,
        download_key_id: str = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the download key, which is used to identify the parsing progress of data tracking logs. You can call the DownloadDataTrackResult operation to query the ID of the key.
        # 
        # This parameter is required.
        self.download_key_id = download_key_id
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_key_id is not None:
            result['DownloadKeyId'] = self.download_key_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadKeyId') is not None:
            self.download_key_id = m.get('DownloadKeyId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class QueryDataTrackResultDownloadStatusResponseBodyStatusResult(TeaModel):
    def __init__(
        self,
        download_status: str = None,
        download_url: str = None,
        status_desc: str = None,
        total_count: int = None,
    ):
        # The status of the download task. Valid values:
        # 
        # *   **INIT**: The download task is being initialized.
        # *   **LISTING**: The download task is in a transient intermediate state during the initialization.
        # *   **DOWNLOADING**: The download task is being processed.
        # *   **DOWNLOAD_SUCCESS**: The download task was successfully processed.
        # *   **DOWNLOAD_FAIL**: The download task failed.
        self.download_status = download_status
        # The URL that is used to download data tracking logs. This parameter is returned only when the value of DownloadStatus is DOWNLOAD_SUCCESS.
        self.download_url = download_url
        # The description of the state.
        self.status_desc = status_desc
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_status is not None:
            result['DownloadStatus'] = self.download_status
        if self.download_url is not None:
            result['DownloadUrl'] = self.download_url
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadStatus') is not None:
            self.download_status = m.get('DownloadStatus')
        if m.get('DownloadUrl') is not None:
            self.download_url = m.get('DownloadUrl')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class QueryDataTrackResultDownloadStatusResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        status_result: QueryDataTrackResultDownloadStatusResponseBodyStatusResult = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The information about the download progress.
        self.status_result = status_result
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.status_result:
            self.status_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_result is not None:
            result['StatusResult'] = self.status_result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusResult') is not None:
            temp_model = QueryDataTrackResultDownloadStatusResponseBodyStatusResult()
            self.status_result = temp_model.from_map(m['StatusResult'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDataTrackResultDownloadStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDataTrackResultDownloadStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDataTrackResultDownloadStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReDeployLhDagVersionRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_version: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the ID of the task flow.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the task flow version. You can call the [ListDAGVersions](https://help.aliyun.com/document_detail/424682.html) operation to obtain the ID of the task flow version.
        self.dag_version = dag_version
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_version is not None:
            result['DagVersion'] = self.dag_version
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagVersion') is not None:
            self.dag_version = m.get('DagVersion')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ReDeployLhDagVersionResponseBody(TeaModel):
    def __init__(
        self,
        deploy_id: int = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the deployment record.
        self.deploy_id = deploy_id
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReDeployLhDagVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReDeployLhDagVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReDeployLhDagVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReRunTaskFlowInstanceRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_instance_id: int = None,
        dag_version: str = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to query the execution record ID.
        # 
        # This parameter is required.
        self.dag_instance_id = dag_instance_id
        # The version number of the task flow. You can call the ListTaskFlowVersions operation to query the version number of the task flow.
        self.dag_version = dag_version
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.dag_version is not None:
            result['DagVersion'] = self.dag_version
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('DagVersion') is not None:
            self.dag_version = m.get('DagVersion')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ReRunTaskFlowInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReRunTaskFlowInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReRunTaskFlowInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReRunTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RedeployDifyInstanceRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        data_region: str = None,
        dry_run: str = None,
        workspace_id: str = None,
    ):
        self.client_token = client_token
        self.data_region = data_region
        self.dry_run = dry_run
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RedeployDifyInstanceResponseBodyData(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        status: str = None,
        workspace_id: str = None,
    ):
        self.instance_id = instance_id
        self.status = status
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.status is not None:
            result['Status'] = self.status
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RedeployDifyInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RedeployDifyInstanceResponseBodyData = None,
        error_code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_code = error_code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RedeployDifyInstanceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RedeployDifyInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RedeployDifyInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RedeployDifyInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefundPayAsYouGoOrderRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        order_id: str = None,
        tid: int = None,
    ):
        # The instance ID in the sales order.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The order ID of the order for the pay-as-you-go resource. You can call the ListEffectiveOrders operation to query the order ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class RefundPayAsYouGoOrderResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RefundPayAsYouGoOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RefundPayAsYouGoOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefundPayAsYouGoOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterInstanceRequest(TeaModel):
    def __init__(
        self,
        data_link_name: str = None,
        database_password: str = None,
        database_user: str = None,
        dba_uid: int = None,
        dba_uid_by_string: str = None,
        ddl_online: int = None,
        ecs_instance_id: str = None,
        ecs_region: str = None,
        enable_sell_sitd: str = None,
        env_type: str = None,
        export_timeout: int = None,
        host: str = None,
        instance_alias: str = None,
        instance_source: str = None,
        instance_type: str = None,
        network_type: str = None,
        port: int = None,
        query_timeout: int = None,
        resource_group: str = None,
        safe_rule: str = None,
        sid: str = None,
        skip_test: bool = None,
        template_id: int = None,
        template_type: str = None,
        tid: int = None,
        use_dsql: int = None,
        vpc_id: str = None,
    ):
        # The name of the database link for cross-database queries.
        # 
        # > 
        # 
        # *   This parameter is required if UseDsql is set to 1.
        # 
        # *   The name can contain only lowercase letters and underscores (_).
        # 
        # *   The name must be unique within a tenant.
        self.data_link_name = data_link_name
        # The password that is used to log on to the database.
        # 
        # This parameter is required.
        self.database_password = database_password
        # The account that is used to log on to the database.
        # 
        # This parameter is required.
        self.database_user = database_user
        # The ID of the user who assumes the DBA role of the database instance. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the user ID.
        # 
        # This parameter is required.
        self.dba_uid = dba_uid
        # The ID of the user who assumes the DBA role of the database instance. If the user ID is a non-numeric value such as a role or an account, you can use this parameter to replace DbaUid.
        self.dba_uid_by_string = dba_uid_by_string
        # Specifies whether to enable the lock-free schema change feature for the database instance. Valid values:
        # 
        # *   **0**: disables the lock-free schema change feature.
        # *   **1**: uses the online DDL of MySQL first.
        # *   **2**: uses the lock-free schema change feature of DMS first.
        # 
        # > Supported database types: ApsaraDB RDS for MySQL, PolarDB for MySQL, ApsaraDB MyBase for MySQL, and third-party MySQL databases.
        self.ddl_online = ddl_online
        # The ID of the ECS instance on which the database instance is deployed.
        # 
        # > This parameter is required if the InstanceSource parameter is set to ECS_OWN.
        self.ecs_instance_id = ecs_instance_id
        # The ID of the region in which the database instance resides.
        # 
        # > This parameter is required if the InstanceSource parameter is set to RDS, ECS_OWN, or VPC_IDC.
        self.ecs_region = ecs_region
        # *   **Y:** enables the sensitive data protection feature
        # *   **NULL or other:** disables the sensitive data protection feature
        self.enable_sell_sitd = enable_sell_sitd
        # The type of the environment in which the database instance is deployed. Valid values:
        # 
        # *   product: production environment
        # *   dev: development environment
        # *   pre: pre-release environment
        # *   test: test environment
        # *   sit: system integration testing (SIT) environment
        # *   uat: user acceptance testing (UAT) environment
        # *   pet: stress testing environment
        # *   stag: staging environment
        # 
        # This parameter is required.
        self.env_type = env_type
        # The timeout period for exporting data from the database instance. Unit: seconds.
        # 
        # This parameter is required.
        self.export_timeout = export_timeout
        # The host address that is used to connect to the database instance.
        # 
        # This parameter is required.
        self.host = host
        # The alias of the database instance. Specify an alias that can help you identify the database instance in DMS.
        # 
        # This parameter is required.
        self.instance_alias = instance_alias
        # The source of the database instance. Valid values:
        # 
        # *   **PUBLIC_OWN:** a self-managed database instance that is deployed on the Internet
        # *   **RDS:** an ApsaraDB RDS instance
        # *   **ECS_OWN:** a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
        # *   **VPC_IDC:** a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
        # 
        # This parameter is required.
        self.instance_source = instance_source
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        # 
        # This parameter is required.
        self.instance_type = instance_type
        # The network type of the database instance. Valid values:
        # 
        # *   **CLASSIC:** classic network
        # *   **VPC:** VPC
        # 
        # This parameter is required.
        self.network_type = network_type
        # The port that is used to connect to the database instance.
        # 
        # This parameter is required.
        self.port = port
        # The timeout period for querying data in the database instance. Unit: seconds.
        # 
        # This parameter is required.
        self.query_timeout = query_timeout
        self.resource_group = resource_group
        # The name of the security rule set (GroupName) for the database instance. You can call the [ListStandardGroups](https://help.aliyun.com/document_detail/417891.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the name of the security rule set.
        # 
        # This parameter is required.
        self.safe_rule = safe_rule
        # The system ID (SID) of the database.
        # 
        # > This parameter is required if the InstanceType parameter is set to ORACLE.
        self.sid = sid
        # Specifies whether to skip the connectivity test. Valid values:
        # 
        # *   **true:** skips the connectivity test
        # *   **false:** does not skip the connectivity test
        self.skip_test = skip_test
        # The ID of the classification template. You can call the [ListClassificationTemplates](https://help.aliyun.com/document_detail/460613.html) operation to query the template ID.
        self.template_id = template_id
        # The type of the classification template. You can call the [ListClassificationTemplates](https://help.aliyun.com/document_detail/460613.html) operation to query the template type.
        self.template_type = template_type
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid
        # Specifies whether to enable the cross-database query feature for the database instance. Valid values:
        # 
        # *   **0**: disables the cross-database query feature.
        # *   **1**: enables the cross-database query feature.
        # 
        # > Supported database types: MySQL, SQL Server, PostgreSQL, PolarDB for PostgreSQL (compatible with Oracle), and ApsaraDB for Redis.
        self.use_dsql = use_dsql
        # The ID of the VPC to which the database instance belongs.
        # 
        # > This parameter is required if the InstanceSource parameter is set to VPC_IDC.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_uid is not None:
            result['DbaUid'] = self.dba_uid
        if self.dba_uid_by_string is not None:
            result['DbaUidByString'] = self.dba_uid_by_string
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.enable_sell_sitd is not None:
            result['EnableSellSitd'] = self.enable_sell_sitd
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.resource_group is not None:
            result['ResourceGroup'] = self.resource_group
        if self.safe_rule is not None:
            result['SafeRule'] = self.safe_rule
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.skip_test is not None:
            result['SkipTest'] = self.skip_test
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaUid') is not None:
            self.dba_uid = m.get('DbaUid')
        if m.get('DbaUidByString') is not None:
            self.dba_uid_by_string = m.get('DbaUidByString')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnableSellSitd') is not None:
            self.enable_sell_sitd = m.get('EnableSellSitd')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('ResourceGroup') is not None:
            self.resource_group = m.get('ResourceGroup')
        if m.get('SafeRule') is not None:
            self.safe_rule = m.get('SafeRule')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('SkipTest') is not None:
            self.skip_test = m.get('SkipTest')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class RegisterInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true:** The request was successful.
        # *   **false:** The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RegisterInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RegisterInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterUserRequest(TeaModel):
    def __init__(
        self,
        mobile: str = None,
        role_names: str = None,
        tid: int = None,
        uid: str = None,
        user_nick: str = None,
    ):
        # The mobile number of the user.
        self.mobile = mobile
        # The role that you want to assign to the user. Valid values:
        # 
        # *   **USER**: a regular user role
        # *   **DBA**: a database administrator (DBA) role
        # *   **ADMIN**: a DMS administrator role
        # *   **SECURITY_ADMIN**: a security administrator role
        # 
        # >  If you do not specify this parameter, the regular user role is assigned to the user by default. You can assign one or more roles to the user. Separate multiple roles with commas (,).
        self.role_names = role_names
        # The ID of the tenant.
        # 
        # >  To query ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid
        # The UID of the Alibaba Cloud account of the user that you want to register.
        # 
        # This parameter is required.
        self.uid = uid
        # The nickname of the user.
        self.user_nick = user_nick

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.role_names is not None:
            result['RoleNames'] = self.role_names
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('RoleNames') is not None:
            self.role_names = m.get('RoleNames')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class RegisterUserResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RegisterUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RegisterUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveDataExportJobRequest(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        order_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.job_id = job_id
        # This parameter is required.
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class RemoveDataExportJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RemoveDataExportJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveDataExportJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveDataExportJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveTableFromCategoryRequest(TeaModel):
    def __init__(
        self,
        category_id: int = None,
        db_id: int = None,
        table_name: str = None,
        table_schema_name: str = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.category_id = category_id
        # This parameter is required.
        self.db_id = db_id
        # This parameter is required.
        self.table_name = table_name
        self.table_schema_name = table_schema_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_schema_name is not None:
            result['TableSchemaName'] = self.table_schema_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableSchemaName') is not None:
            self.table_schema_name = m.get('TableSchemaName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class RemoveTableFromCategoryResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RemoveTableFromCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveTableFromCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveTableFromCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartDataCorrectSQLJobRequest(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        order_id: int = None,
        real_login_user_uid: str = None,
        tid: int = None,
        type: str = None,
    ):
        # The ID of the SQL task. You can call the [GetDataCorrectTaskDetail](https://help.aliyun.com/document_detail/208481.html) and [ListDBTaskSQLJob](https://help.aliyun.com/document_detail/207049.html) operations to obtain the value of this parameter.
        # 
        # If the Type parameter is set to SINGLE, you must pass the value of the JobId parameter to confirm the ID of the SQL task that you want to rerun.
        self.job_id = job_id
        # The ID of the data change ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the data change ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        self.real_login_user_uid = real_login_user_uid
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid
        # The type of the rerun operation. Valid values:
        # 
        # *   **ALL**: reruns all SQL tasks.
        # *   **SINGLE**: reruns a single SQL task.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RestartDataCorrectSQLJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RestartDataCorrectSQLJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartDataCorrectSQLJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartDataCorrectSQLJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartDataExportJobRequest(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        order_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.job_id = job_id
        # This parameter is required.
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class RestartDataExportJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RestartDataExportJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartDataExportJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartDataExportJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResumeTaskFlowInstanceRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_instance_id: int = None,
        dag_version: str = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to query the execution record ID.
        # 
        # This parameter is required.
        self.dag_instance_id = dag_instance_id
        # The version number of the task flow. You can call the [ListDAGVersions](https://help.aliyun.com/document_detail/424682.html) operation to query the version number.
        self.dag_version = dag_version
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.dag_version is not None:
            result['DagVersion'] = self.dag_version
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('DagVersion') is not None:
            self.dag_version = m.get('DagVersion')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ResumeTaskFlowInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ResumeTaskFlowInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResumeTaskFlowInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResumeTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RetryDataCorrectPreCheckRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        real_login_user_uid: str = None,
        tid: int = None,
    ):
        # The ID of the data change ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the data change ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        self.real_login_user_uid = real_login_user_uid
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class RetryDataCorrectPreCheckResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RetryDataCorrectPreCheckResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RetryDataCorrectPreCheckResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RetryDataCorrectPreCheckResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RevokeTemplateAuthorityRequest(TeaModel):
    def __init__(
        self,
        template_id: int = None,
        tid: int = None,
        user_ids: str = None,
    ):
        # The ID of the permission template.
        # 
        # This parameter is required.
        self.template_id = template_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid
        # The IDs of users from whom you want to revoke permissions by using a permission template.
        # 
        # This parameter is required.
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class RevokeTemplateAuthorityResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: bool = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the permissions were revoked from the users.
        self.result = result
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RevokeTemplateAuthorityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RevokeTemplateAuthorityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RevokeTemplateAuthorityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RevokeUserPermissionRequest(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        ds_type: str = None,
        instance_id: int = None,
        logic: bool = None,
        perm_types: str = None,
        table_id: str = None,
        table_name: str = None,
        tid: int = None,
        user_access_id: str = None,
        user_id: str = None,
    ):
        # The database ID. The database can be a physical database or a logical database.
        # 
        # *   To query the ID of a physical database, call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
        # *   To query the ID of a logical database, call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
        self.db_id = db_id
        # The type of the object on which you want to revoke permissions from a user. Valid values:
        # 
        # *   **INSTANCE**: instances.
        # *   **DATABASE**: physical databases.
        # *   **LOGIC_DATABASE**: logical databases.
        # *   **TABLE**: physical tables.
        # *   **LOGIC_TABLE**: logical tables.
        # 
        # This parameter is required.
        self.ds_type = ds_type
        # The database instance ID. You must specify this parameter if you revoke a permission from the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the ID of the database instance.
        self.instance_id = instance_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        # 
        # > 
        # 
        # *   If the database is a logical database, set this parameter to **true**.
        # 
        # *   If the database is a physical database, set this parameter to **false**.
        self.logic = logic
        # The type of the permissions. Valid values:
        # 
        # *   **QUERY**: query permissions.
        # *   **EXPORT**: export permissions.
        # *   **CORRECT**: change permissions.
        # *   **LOGIN**: logon permissions.
        # *   **PERF**: query permissions on the performance details of an instance.
        # 
        # This parameter is required.
        self.perm_types = perm_types
        # The table ID. You must specify this parameter if you revoke a permission from the table. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to query the table ID.
        self.table_id = table_id
        # The name of the table. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to query the table name.
        self.table_name = table_name
        # The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid
        # The permission ID. You can call the [ListUserPermission](https://help.aliyun.com/document_detail/146957.html) operation to query the permission ID.
        # 
        # This parameter is required.
        self.user_access_id = user_access_id
        # The user ID. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to query the ID of the user.
        # 
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.perm_types is not None:
            result['PermTypes'] = self.perm_types
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_access_id is not None:
            result['UserAccessId'] = self.user_access_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermTypes') is not None:
            self.perm_types = m.get('PermTypes')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserAccessId') is not None:
            self.user_access_id = m.get('UserAccessId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RevokeUserPermissionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RevokeUserPermissionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RevokeUserPermissionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RevokeUserPermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchDataTrackResultRequestColumnFilter(TeaModel):
    def __init__(
        self,
        between_end: str = None,
        between_start: str = None,
        column_name: str = None,
        in_list: List[str] = None,
        operator: str = None,
        value: str = None,
    ):
        # The end value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
        self.between_end = between_end
        # The start value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
        self.between_start = between_start
        # The name of the column.
        self.column_name = column_name
        # The IN list used in the filter condition. This parameter takes effect only when Operator is set to IN or NOT_IN.
        self.in_list = in_list
        # The type of the operator used to configure the filter condition. Valid values:
        # 
        # *   **EQUAL**: retrieves the column whose value is equal to the specified value.
        # *   **NOT_EQUAL**: retrieves the column whose value is not equal to the specified value.
        # *   **IN**: retrieves the column whose value is in the IN list.
        # *   **BETWEEN**: retrieves the column whose value is in the specified range.
        # *   **LESS**: retrieves the column whose value is less than the specified value.
        # *   **MORE**: retrieves the column whose value is greater than the specified value.
        # *   **NOT_IN**: retrieves the column whose value is not in the IN list.
        self.operator = operator
        # The value used in the filter condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.between_end is not None:
            result['BetweenEnd'] = self.between_end
        if self.between_start is not None:
            result['BetweenStart'] = self.between_start
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.in_list is not None:
            result['InList'] = self.in_list
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BetweenEnd') is not None:
            self.between_end = m.get('BetweenEnd')
        if m.get('BetweenStart') is not None:
            self.between_start = m.get('BetweenStart')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('InList') is not None:
            self.in_list = m.get('InList')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchDataTrackResultRequest(TeaModel):
    def __init__(
        self,
        column_filter: SearchDataTrackResultRequestColumnFilter = None,
        filter_end_time: str = None,
        filter_start_time: str = None,
        filter_table_list: List[str] = None,
        filter_type_list: List[str] = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The condition to filter columns.
        self.column_filter = column_filter
        # The end time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
        self.filter_end_time = filter_end_time
        # The start time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
        self.filter_start_time = filter_start_time
        # The names of the tables for which you want to track data operations.
        self.filter_table_list = filter_table_list
        # The types of data operations that you want to track.
        self.filter_type_list = filter_type_list
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        if self.column_filter:
            self.column_filter.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_filter is not None:
            result['ColumnFilter'] = self.column_filter.to_map()
        if self.filter_end_time is not None:
            result['FilterEndTime'] = self.filter_end_time
        if self.filter_start_time is not None:
            result['FilterStartTime'] = self.filter_start_time
        if self.filter_table_list is not None:
            result['FilterTableList'] = self.filter_table_list
        if self.filter_type_list is not None:
            result['FilterTypeList'] = self.filter_type_list
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnFilter') is not None:
            temp_model = SearchDataTrackResultRequestColumnFilter()
            self.column_filter = temp_model.from_map(m['ColumnFilter'])
        if m.get('FilterEndTime') is not None:
            self.filter_end_time = m.get('FilterEndTime')
        if m.get('FilterStartTime') is not None:
            self.filter_start_time = m.get('FilterStartTime')
        if m.get('FilterTableList') is not None:
            self.filter_table_list = m.get('FilterTableList')
        if m.get('FilterTypeList') is not None:
            self.filter_type_list = m.get('FilterTypeList')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SearchDataTrackResultShrinkRequest(TeaModel):
    def __init__(
        self,
        column_filter_shrink: str = None,
        filter_end_time: str = None,
        filter_start_time: str = None,
        filter_table_list_shrink: str = None,
        filter_type_list_shrink: str = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The condition to filter columns.
        self.column_filter_shrink = column_filter_shrink
        # The end time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
        self.filter_end_time = filter_end_time
        # The start time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
        self.filter_start_time = filter_start_time
        # The names of the tables for which you want to track data operations.
        self.filter_table_list_shrink = filter_table_list_shrink
        # The types of data operations that you want to track.
        self.filter_type_list_shrink = filter_type_list_shrink
        # The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_filter_shrink is not None:
            result['ColumnFilter'] = self.column_filter_shrink
        if self.filter_end_time is not None:
            result['FilterEndTime'] = self.filter_end_time
        if self.filter_start_time is not None:
            result['FilterStartTime'] = self.filter_start_time
        if self.filter_table_list_shrink is not None:
            result['FilterTableList'] = self.filter_table_list_shrink
        if self.filter_type_list_shrink is not None:
            result['FilterTypeList'] = self.filter_type_list_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnFilter') is not None:
            self.column_filter_shrink = m.get('ColumnFilter')
        if m.get('FilterEndTime') is not None:
            self.filter_end_time = m.get('FilterEndTime')
        if m.get('FilterStartTime') is not None:
            self.filter_start_time = m.get('FilterStartTime')
        if m.get('FilterTableList') is not None:
            self.filter_table_list_shrink = m.get('FilterTableList')
        if m.get('FilterTypeList') is not None:
            self.filter_type_list_shrink = m.get('FilterTypeList')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SearchDataTrackResultResponseBodyTrackResultEventList(TeaModel):
    def __init__(
        self,
        data_after: List[str] = None,
        data_before: List[str] = None,
        event_id: int = None,
        event_length: int = None,
        event_timestamp: str = None,
        event_type: str = None,
        roll_sql: str = None,
    ):
        # The data records after you perform data operations in the database.
        self.data_after = data_after
        # The data records before you perform data operations in the database.
        self.data_before = data_before
        # The ID of the event.
        self.event_id = event_id
        # The length of the event content. Unit: bytes.
        self.event_length = event_length
        # The event time.
        self.event_timestamp = event_timestamp
        # The type of the event. Valid values:
        # 
        # *   **WRITE_ROWS**: indicates an INSERT operation.
        # *   **UPDATE_ROWS**: indicates an UPDATE operation.
        # *   **DELETE_ROWS**: indicates a DELETE operation.
        # *   **EXT_WRITE_ROWS**: indicates an INSERT operation, which is equivalent to WRITE_ROWS.
        # *   **EXT_UPDATE_ROWS**: indicates an UPDATE operation, which is equivalent to UPDATE_ROWS.
        # *   **EXT_DELETE_ROWS**: indicates a DELETE operation, which is equivalent to DELETE_ROWS.
        self.event_type = event_type
        # The SQL statements used to roll back the data change.
        self.roll_sql = roll_sql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_after is not None:
            result['DataAfter'] = self.data_after
        if self.data_before is not None:
            result['DataBefore'] = self.data_before
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.event_length is not None:
            result['EventLength'] = self.event_length
        if self.event_timestamp is not None:
            result['EventTimestamp'] = self.event_timestamp
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.roll_sql is not None:
            result['RollSQL'] = self.roll_sql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataAfter') is not None:
            self.data_after = m.get('DataAfter')
        if m.get('DataBefore') is not None:
            self.data_before = m.get('DataBefore')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('EventLength') is not None:
            self.event_length = m.get('EventLength')
        if m.get('EventTimestamp') is not None:
            self.event_timestamp = m.get('EventTimestamp')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('RollSQL') is not None:
            self.roll_sql = m.get('RollSQL')
        return self


class SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        column_position: int = None,
        column_type: str = None,
        fictive: bool = None,
    ):
        # The name of the column.
        self.column_name = column_name
        # The position of the column.
        self.column_position = column_position
        # The data type of the column. Examples: BIGINT, INT, and VARCHAR.
        self.column_type = column_type
        # Indicates whether the column is a virtual column. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.fictive = fictive

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_position is not None:
            result['ColumnPosition'] = self.column_position
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.fictive is not None:
            result['Fictive'] = self.fictive
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnPosition') is not None:
            self.column_position = m.get('ColumnPosition')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('Fictive') is not None:
            self.fictive = m.get('Fictive')
        return self


class SearchDataTrackResultResponseBodyTrackResultTableInfoList(TeaModel):
    def __init__(
        self,
        columns: List[SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns] = None,
        description: str = None,
        schema_name: str = None,
        table_name: str = None,
    ):
        # The information about columns.
        self.columns = columns
        # The description of the column.
        self.description = description
        # The name of the database.
        self.schema_name = schema_name
        # The name of the table.
        self.table_name = table_name

    def validate(self):
        if self.columns:
            for k in self.columns:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Columns'] = []
        if self.columns is not None:
            for k in self.columns:
                result['Columns'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.columns = []
        if m.get('Columns') is not None:
            for k in m.get('Columns'):
                temp_model = SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns()
                self.columns.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class SearchDataTrackResultResponseBodyTrackResult(TeaModel):
    def __init__(
        self,
        event_list: List[SearchDataTrackResultResponseBodyTrackResultEventList] = None,
        table_info_list: List[SearchDataTrackResultResponseBodyTrackResultTableInfoList] = None,
        total_count: int = None,
    ):
        # The details of the event logs.
        self.event_list = event_list
        # The metadata of tables for which you track data operations.
        self.table_info_list = table_info_list
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.event_list:
            for k in self.event_list:
                if k:
                    k.validate()
        if self.table_info_list:
            for k in self.table_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventList'] = []
        if self.event_list is not None:
            for k in self.event_list:
                result['EventList'].append(k.to_map() if k else None)
        result['TableInfoList'] = []
        if self.table_info_list is not None:
            for k in self.table_info_list:
                result['TableInfoList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event_list = []
        if m.get('EventList') is not None:
            for k in m.get('EventList'):
                temp_model = SearchDataTrackResultResponseBodyTrackResultEventList()
                self.event_list.append(temp_model.from_map(k))
        self.table_info_list = []
        if m.get('TableInfoList') is not None:
            for k in m.get('TableInfoList'):
                temp_model = SearchDataTrackResultResponseBodyTrackResultTableInfoList()
                self.table_info_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchDataTrackResultResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        track_result: SearchDataTrackResultResponseBodyTrackResult = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The parsing result of the data tracking task.
        self.track_result = track_result

    def validate(self):
        if self.track_result:
            self.track_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.track_result is not None:
            result['TrackResult'] = self.track_result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TrackResult') is not None:
            temp_model = SearchDataTrackResultResponseBodyTrackResult()
            self.track_result = temp_model.from_map(m['TrackResult'])
        return self


class SearchDataTrackResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchDataTrackResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchDataTrackResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchDatabaseRequest(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        env_type: str = None,
        page_number: int = None,
        page_size: int = None,
        search_key: str = None,
        search_range: str = None,
        search_target: str = None,
        tid: int = None,
    ):
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        self.db_type = db_type
        # The environment type of the database. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
        self.env_type = env_type
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The keyword that is used to search for databases.
        self.search_key = search_key
        # The query range based on permissions. Valid values:
        # 
        # *   **HAS_PERMSSION**: searches for databases on which the current user has permissions.
        # *   **OWNER**: searches for databases owned by the current user.
        # *   **MY_FOCUS**: searches for databases that the current user follows.
        # *   **UNKNOWN**: searches for all databases.
        self.search_range = search_range
        # The category of the database. Valid values:
        # 
        # *   **DB**: single database or logical database.
        # *   **SINGLE_DB**: single database.
        # *   **LOGIC_DB**: logical database.
        self.search_target = search_target
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.search_range is not None:
            result['SearchRange'] = self.search_range
        if self.search_target is not None:
            result['SearchTarget'] = self.search_target
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SearchRange') is not None:
            self.search_range = m.get('SearchRange')
        if m.get('SearchTarget') is not None:
            self.search_target = m.get('SearchTarget')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class SearchDatabaseResponseBodySearchDatabaseListSearchDatabase(TeaModel):
    def __init__(
        self,
        alias: str = None,
        catalog_name: str = None,
        database_id: str = None,
        datalink_name: str = None,
        db_type: str = None,
        dba_id: str = None,
        encoding: str = None,
        env_type: str = None,
        host: str = None,
        logic: bool = None,
        owner_id_list: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList = None,
        owner_name_list: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList = None,
        port: int = None,
        schema_name: str = None,
        search_name: str = None,
        sid: str = None,
    ):
        # The alias of the database.
        self.alias = alias
        # The name of the catalog to which the database belongs.
        # 
        # > If the type of the database engine is PostgreSQL, the name of the database is displayed.
        self.catalog_name = catalog_name
        # The ID of the database.
        self.database_id = database_id
        # The name of the data link for cross-database queries.
        self.datalink_name = datalink_name
        # The type of the database engine.
        self.db_type = db_type
        # The ID of the user who assumes the database administrator (DBA) role.
        self.dba_id = dba_id
        # The encoding method of the database.
        self.encoding = encoding
        # The environment type of the database. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
        self.env_type = env_type
        # The endpoint of the instance in which the database resides.
        self.host = host
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        self.logic = logic
        # The IDs of the owners of the databases.
        self.owner_id_list = owner_id_list
        # The nicknames of the database owners.
        self.owner_name_list = owner_name_list
        # The port of the instance in which the database resides.
        self.port = port
        # The name of the database.
        self.schema_name = schema_name
        # The name that is used to search for the database.
        self.search_name = search_name
        # The system ID (SID) of the instance in which the database resides.
        self.sid = sid

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.datalink_name is not None:
            result['DatalinkName'] = self.datalink_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sid is not None:
            result['Sid'] = self.sid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatalinkName') is not None:
            self.datalink_name = m.get('DatalinkName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        return self


class SearchDatabaseResponseBodySearchDatabaseList(TeaModel):
    def __init__(
        self,
        search_database: List[SearchDatabaseResponseBodySearchDatabaseListSearchDatabase] = None,
    ):
        self.search_database = search_database

    def validate(self):
        if self.search_database:
            for k in self.search_database:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchDatabase'] = []
        if self.search_database is not None:
            for k in self.search_database:
                result['SearchDatabase'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.search_database = []
        if m.get('SearchDatabase') is not None:
            for k in m.get('SearchDatabase'):
                temp_model = SearchDatabaseResponseBodySearchDatabaseListSearchDatabase()
                self.search_database.append(temp_model.from_map(k))
        return self


class SearchDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        search_database_list: SearchDatabaseResponseBodySearchDatabaseList = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The information about the databases.
        self.search_database_list = search_database_list
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.search_database_list:
            self.search_database_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.search_database_list is not None:
            result['SearchDatabaseList'] = self.search_database_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SearchDatabaseList') is not None:
            temp_model = SearchDatabaseResponseBodySearchDatabaseList()
            self.search_database_list = temp_model.from_map(m['SearchDatabaseList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchTableRequest(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        env_type: str = None,
        page_number: int = None,
        page_size: int = None,
        return_guid: bool = None,
        search_key: str = None,
        search_range: str = None,
        search_target: str = None,
        tid: int = None,
    ):
        # The type of database. Valid values:
        # 
        # *   **MySQL**\
        # *   **SQLServer**\
        # *   **PostgreSQL**\
        # *   **Oracle**\
        # *   **DRDS**\
        # *   **OceanBase**\
        # *   **Mongo**\
        # *   **Redis**\
        self.db_type = db_type
        # The type of the environment to which databases belong. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
        self.env_type = env_type
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # Specifies whether to return the GUID of each table.
        self.return_guid = return_guid
        # The keyword that is used to query tables.
        self.search_key = search_key
        # The scope of tables that you want to query. Valid values:
        # 
        # *   **HAS_PERMSSION**: the tables on which the current account has permissions.
        # *   **OWNER**: the tables owned by the current account.
        # *   **MY_FOCUS**: the tables that the current account follows.
        # *   **UNKNOWN**: all tables.
        self.search_range = search_range
        # The type of table that you want to query. Valid values:
        # 
        # *   **TABLE**: physical and logical tables
        # *   **SINGLE_TABLE**: physical tables
        # *   **LOGIC_TABLE**: logical tables
        self.search_target = search_target
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.return_guid is not None:
            result['ReturnGuid'] = self.return_guid
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.search_range is not None:
            result['SearchRange'] = self.search_range
        if self.search_target is not None:
            result['SearchTarget'] = self.search_target
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ReturnGuid') is not None:
            self.return_guid = m.get('ReturnGuid')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SearchRange') is not None:
            self.search_range = m.get('SearchRange')
        if m.get('SearchTarget') is not None:
            self.search_target = m.get('SearchTarget')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SearchTableResponseBodySearchTableListSearchTableOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class SearchTableResponseBodySearchTableListSearchTableOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class SearchTableResponseBodySearchTableListSearchTable(TeaModel):
    def __init__(
        self,
        dbsearch_name: str = None,
        database_id: str = None,
        db_name: str = None,
        db_type: str = None,
        description: str = None,
        encoding: str = None,
        engine: str = None,
        env_type: str = None,
        logic: bool = None,
        owner_id_list: SearchTableResponseBodySearchTableListSearchTableOwnerIdList = None,
        owner_name_list: SearchTableResponseBodySearchTableListSearchTableOwnerNameList = None,
        table_guid: str = None,
        table_id: str = None,
        table_name: str = None,
        table_schema_name: str = None,
    ):
        # The name that is used to search for the database to which the table belongs.
        self.dbsearch_name = dbsearch_name
        # The ID of the database to which the table belongs.
        self.database_id = database_id
        # The name of the database.
        self.db_name = db_name
        # The type of the database. Valid values:
        # 
        # *   **MySQL**\
        # *   **SQLServer**\
        # *   **PostgreSQL**\
        # *   **Oracle**\
        # *   **DRDS**\
        # *   **OceanBase**\
        # *   **Mongo**\
        # *   **Redis**\
        self.db_type = db_type
        # The description of the table.
        self.description = description
        # The encoding format of the table.
        self.encoding = encoding
        # The engine of the table.
        self.engine = engine
        # The type of the environment to which the database belongs.
        self.env_type = env_type
        # Indicates whether the table is a logical table. Valid values:
        # 
        # *   **true**: The table is a logical table.
        # *   **false**: The table is not a logical table.
        self.logic = logic
        # The IDs of the table owners.
        self.owner_id_list = owner_id_list
        # The nicknames of the table owners.
        self.owner_name_list = owner_name_list
        # The GUID of the table.
        self.table_guid = table_guid
        # The ID of the table.
        self.table_id = table_id
        # The name of the table.
        self.table_name = table_name
        # The name of the database to which the table belongs.
        self.table_schema_name = table_schema_name

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbsearch_name is not None:
            result['DBSearchName'] = self.dbsearch_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.engine is not None:
            result['Engine'] = self.engine
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_schema_name is not None:
            result['TableSchemaName'] = self.table_schema_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBSearchName') is not None:
            self.dbsearch_name = m.get('DBSearchName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('Engine') is not None:
            self.engine = m.get('Engine')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = SearchTableResponseBodySearchTableListSearchTableOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = SearchTableResponseBodySearchTableListSearchTableOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableSchemaName') is not None:
            self.table_schema_name = m.get('TableSchemaName')
        return self


class SearchTableResponseBodySearchTableList(TeaModel):
    def __init__(
        self,
        search_table: List[SearchTableResponseBodySearchTableListSearchTable] = None,
    ):
        self.search_table = search_table

    def validate(self):
        if self.search_table:
            for k in self.search_table:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchTable'] = []
        if self.search_table is not None:
            for k in self.search_table:
                result['SearchTable'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.search_table = []
        if m.get('SearchTable') is not None:
            for k in m.get('SearchTable'):
                temp_model = SearchTableResponseBodySearchTableListSearchTable()
                self.search_table.append(temp_model.from_map(k))
        return self


class SearchTableResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        search_table_list: SearchTableResponseBodySearchTableList = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The details of the tables.
        self.search_table_list = search_table_list
        # Indicates whether the request was successful.
        self.success = success
        # The total number of entries that are returned.
        self.total_count = total_count

    def validate(self):
        if self.search_table_list:
            self.search_table_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.search_table_list is not None:
            result['SearchTableList'] = self.search_table_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SearchTableList') is not None:
            temp_model = SearchTableResponseBodySearchTableList()
            self.search_table_list = temp_model.from_map(m['SearchTableList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetOwnersRequest(TeaModel):
    def __init__(
        self,
        owner_ids: str = None,
        owner_type: str = None,
        resource_id: str = None,
        tid: int = None,
    ):
        # The ID of the user whom you want to specify as an owner. Separate multiple IDs with commas (,). You can call the [GetUser](https://help.aliyun.com/document_detail/147098.html) or [ListUsers](https://help.aliyun.com/document_detail/141938.html) operation to query the ID of the user.
        # 
        # >  The value of the OwnerIds parameter is that of the UserId parameter.
        # 
        # This parameter is required.
        self.owner_ids = owner_ids
        # The type of the owner. Valid values:
        # 
        # *   INSTANCE: an owner of an instance.
        # *   DATABASE: an owner of a physical database.
        # *   LOGIC_DATABASE: an owner of a logical database.
        # *   TABLE: an owner of a physical table.
        # *   LOGIC_TABLE: an owner of a logical table.
        # 
        # This parameter is required.
        self.owner_type = owner_type
        # The ID of the resource. The ID of the resource varies with the owner type. The owner types and resource IDs have the following mappings:
        # 
        # *   INSTANCE: the ID of an instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to query the ID of the instance.
        # *   DATABASE: the ID of a physical database. You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to query the ID of the physical database.
        # *   LOGIC_DATABASE: the ID of a logical database. You can call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to query the ID of the logical database.
        # *   TABLE: the ID of a physical table. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to query the ID of the physical table.
        # *   LOGIC_DATABASE: the ID of a logical table. You can call the [ListLogicTables](https://help.aliyun.com/document_detail/141875.html) operation to query the ID of the logical table.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_type is not None:
            result['OwnerType'] = self.owner_type
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerType') is not None:
            self.owner_type = m.get('OwnerType')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SetOwnersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   true: The request is successful.
        # *   false: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetOwnersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetOwnersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetOwnersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetWorkflowExtraInfoRequest(TeaModel):
    def __init__(
        self,
        render_add_approval_node: bool = None,
        render_agree: bool = None,
        render_cancel: bool = None,
        render_reject: bool = None,
        render_transfer: bool = None,
        thirdparty_workflow_comment: str = None,
        thirdparty_workflow_url: str = None,
        tid: int = None,
        workflow_instance_id: int = None,
    ):
        self.render_add_approval_node = render_add_approval_node
        self.render_agree = render_agree
        self.render_cancel = render_cancel
        self.render_reject = render_reject
        self.render_transfer = render_transfer
        self.thirdparty_workflow_comment = thirdparty_workflow_comment
        self.thirdparty_workflow_url = thirdparty_workflow_url
        self.tid = tid
        # This parameter is required.
        self.workflow_instance_id = workflow_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.render_add_approval_node is not None:
            result['RenderAddApprovalNode'] = self.render_add_approval_node
        if self.render_agree is not None:
            result['RenderAgree'] = self.render_agree
        if self.render_cancel is not None:
            result['RenderCancel'] = self.render_cancel
        if self.render_reject is not None:
            result['RenderReject'] = self.render_reject
        if self.render_transfer is not None:
            result['RenderTransfer'] = self.render_transfer
        if self.thirdparty_workflow_comment is not None:
            result['ThirdpartyWorkflowComment'] = self.thirdparty_workflow_comment
        if self.thirdparty_workflow_url is not None:
            result['ThirdpartyWorkflowUrl'] = self.thirdparty_workflow_url
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RenderAddApprovalNode') is not None:
            self.render_add_approval_node = m.get('RenderAddApprovalNode')
        if m.get('RenderAgree') is not None:
            self.render_agree = m.get('RenderAgree')
        if m.get('RenderCancel') is not None:
            self.render_cancel = m.get('RenderCancel')
        if m.get('RenderReject') is not None:
            self.render_reject = m.get('RenderReject')
        if m.get('RenderTransfer') is not None:
            self.render_transfer = m.get('RenderTransfer')
        if m.get('ThirdpartyWorkflowComment') is not None:
            self.thirdparty_workflow_comment = m.get('ThirdpartyWorkflowComment')
        if m.get('ThirdpartyWorkflowUrl') is not None:
            self.thirdparty_workflow_url = m.get('ThirdpartyWorkflowUrl')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class SetWorkflowExtraInfoResponseBody(TeaModel):
    def __init__(
        self,
        data: bool = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data = data
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetWorkflowExtraInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetWorkflowExtraInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetWorkflowExtraInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SimplyAddInstanceRequest(TeaModel):
    def __init__(
        self,
        database_password: str = None,
        database_user: str = None,
        host: str = None,
        instance_id: str = None,
        instance_region: str = None,
        port: int = None,
    ):
        # This parameter is required.
        self.database_password = database_password
        # This parameter is required.
        self.database_user = database_user
        self.host = host
        self.instance_id = instance_id
        self.instance_region = instance_region
        self.port = port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_region is not None:
            result['InstanceRegion'] = self.instance_region
        if self.port is not None:
            result['Port'] = self.port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceRegion') is not None:
            self.instance_region = m.get('InstanceRegion')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        return self


class SimplyAddInstanceResponseBodyInstance(TeaModel):
    def __init__(
        self,
        host: str = None,
        instance_id: str = None,
        port: str = None,
    ):
        self.host = host
        self.instance_id = instance_id
        self.port = port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.port is not None:
            result['Port'] = self.port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        return self


class SimplyAddInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        instance: SimplyAddInstanceResponseBodyInstance = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.instance = instance
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.instance:
            self.instance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance is not None:
            result['Instance'] = self.instance.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Instance') is not None:
            temp_model = SimplyAddInstanceResponseBodyInstance()
            self.instance = temp_model.from_map(m['Instance'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SimplyAddInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SimplyAddInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SimplyAddInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SkipDataCorrectRowCheckRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        real_login_user_uid: str = None,
        reason: str = None,
        tid: int = None,
    ):
        # The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
        # 
        # This parameter is required.
        self.order_id = order_id
        self.real_login_user_uid = real_login_user_uid
        # The reason for skipping the verification on the number of rows in the precheck for data change.
        # 
        # This parameter is required.
        self.reason = reason
        # The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SkipDataCorrectRowCheckResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SkipDataCorrectRowCheckResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SkipDataCorrectRowCheckResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SkipDataCorrectRowCheckResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopTaskFlowInstanceRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_instance_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to query the execution record ID.
        # 
        # This parameter is required.
        self.dag_instance_id = dag_instance_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class StopTaskFlowInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StopTaskFlowInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopTaskFlowInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitOrderApprovalRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        real_login_user_uid: str = None,
        tid: int = None,
    ):
        # The ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the Alibaba Cloud account that is used to call the API operation.
        self.real_login_user_uid = real_login_user_uid
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.real_login_user_uid is not None:
            result['RealLoginUserUid'] = self.real_login_user_uid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RealLoginUserUid') is not None:
            self.real_login_user_uid = m.get('RealLoginUserUid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SubmitOrderApprovalResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitOrderApprovalResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitOrderApprovalResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitOrderApprovalResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitStructSyncOrderApprovalRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket.
        # 
        # This parameter is required.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SubmitStructSyncOrderApprovalResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        workflow_instance_id: int = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success
        # The ID of the approval process.
        self.workflow_instance_id = workflow_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class SubmitStructSyncOrderApprovalResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitStructSyncOrderApprovalResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitStructSyncOrderApprovalResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SuspendDataExportJobRequest(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        order_id: int = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.job_id = job_id
        # This parameter is required.
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SuspendDataExportJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SuspendDataExportJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SuspendDataExportJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SuspendDataExportJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SuspendTaskFlowInstanceRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_instance_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to query the execution record ID.
        # 
        # This parameter is required.
        self.dag_instance_id = dag_instance_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SuspendTaskFlowInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SuspendTaskFlowInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SuspendTaskFlowInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SuspendTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SyncDatabaseMetaRequest(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        logic: bool = None,
        tid: int = None,
    ):
        # The ID of the database.
        # 
        # This parameter is required.
        self.db_id = db_id
        # Specifies whether the database is a logical database.
        self.logic = logic
        # The ID of the tenant.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SyncDatabaseMetaResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SyncDatabaseMetaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SyncDatabaseMetaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SyncDatabaseMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SyncInstanceMetaRequest(TeaModel):
    def __init__(
        self,
        ignore_table: bool = None,
        instance_id: str = None,
        tid: int = None,
    ):
        # Specifies whether to skip synchronization for the metadata of table dictionaries. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.ignore_table = ignore_table
        # The ID of the instance.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the Manage DMS tenants topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_table is not None:
            result['IgnoreTable'] = self.ignore_table
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IgnoreTable') is not None:
            self.ignore_table = m.get('IgnoreTable')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SyncInstanceMetaResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Details about the topology of the data table.
        self.error_code = error_code
        # The error code returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SyncInstanceMetaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SyncInstanceMetaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SyncInstanceMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TryRunTaskFlowRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
    ):
        self.dag_id = dag_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        return self


class TryRunTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        instance_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.instance_id = instance_id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class TryRunTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TryRunTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TryRunTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAbacPolicyRequest(TeaModel):
    def __init__(
        self,
        abac_policy_content: str = None,
        abac_policy_desc: str = None,
        abac_policy_id: int = None,
        abac_policy_name: str = None,
        tid: int = None,
    ):
        self.abac_policy_content = abac_policy_content
        self.abac_policy_desc = abac_policy_desc
        # This parameter is required.
        self.abac_policy_id = abac_policy_id
        self.abac_policy_name = abac_policy_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abac_policy_content is not None:
            result['AbacPolicyContent'] = self.abac_policy_content
        if self.abac_policy_desc is not None:
            result['AbacPolicyDesc'] = self.abac_policy_desc
        if self.abac_policy_id is not None:
            result['AbacPolicyId'] = self.abac_policy_id
        if self.abac_policy_name is not None:
            result['AbacPolicyName'] = self.abac_policy_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AbacPolicyContent') is not None:
            self.abac_policy_content = m.get('AbacPolicyContent')
        if m.get('AbacPolicyDesc') is not None:
            self.abac_policy_desc = m.get('AbacPolicyDesc')
        if m.get('AbacPolicyId') is not None:
            self.abac_policy_id = m.get('AbacPolicyId')
        if m.get('AbacPolicyName') is not None:
            self.abac_policy_name = m.get('AbacPolicyName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateAbacPolicyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        update_policy_result: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.update_policy_result = update_policy_result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.update_policy_result is not None:
            result['UpdatePolicyResult'] = self.update_policy_result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('UpdatePolicyResult') is not None:
            self.update_policy_result = m.get('UpdatePolicyResult')
        return self


class UpdateAbacPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAbacPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAbacPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAuthorityTemplateRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        template_id: int = None,
        tid: int = None,
    ):
        # The description of the permission template.
        # 
        # >  You must specify the Name or Description parameter. Otherwise, the API call fails.
        # 
        # This parameter is required.
        self.description = description
        # The name of the permission template.
        # 
        # >  You must specify the Name or Description parameter. Otherwise, the API call fails.
        # 
        # This parameter is required.
        self.name = name
        # The ID of the permission template.
        # 
        # This parameter is required.
        self.template_id = template_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateAuthorityTemplateResponseBodyAuthorityTemplateView(TeaModel):
    def __init__(
        self,
        creator_id: int = None,
        description: str = None,
        name: str = None,
        template_id: int = None,
    ):
        # The ID of the user who created the permission template.
        self.creator_id = creator_id
        # The description of the permission template.
        self.description = description
        # The name of the permission template.
        self.name = name
        # The ID of the permission template.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateAuthorityTemplateResponseBody(TeaModel):
    def __init__(
        self,
        authority_template_view: UpdateAuthorityTemplateResponseBodyAuthorityTemplateView = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tid: int = None,
    ):
        # The details of the permission template.
        self.authority_template_view = authority_template_view
        # The error code.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The ID of the tenant.
        self.tid = tid

    def validate(self):
        if self.authority_template_view:
            self.authority_template_view.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authority_template_view is not None:
            result['AuthorityTemplateView'] = self.authority_template_view.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthorityTemplateView') is not None:
            temp_model = UpdateAuthorityTemplateResponseBodyAuthorityTemplateView()
            self.authority_template_view = temp_model.from_map(m['AuthorityTemplateView'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateAuthorityTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAuthorityTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAuthorityTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDataLakeDatabaseRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        description: str = None,
        location: str = None,
        parameters: Dict[str, str] = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.description = description
        # This parameter is required.
        self.location = location
        self.parameters = parameters
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.description is not None:
            result['Description'] = self.description
        if self.location is not None:
            result['Location'] = self.location
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateDataLakeDatabaseShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        description: str = None,
        location: str = None,
        parameters_shrink: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        self.description = description
        # This parameter is required.
        self.location = location
        self.parameters_shrink = parameters_shrink
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.description is not None:
            result['Description'] = self.description
        if self.location is not None:
            result['Location'] = self.location
        if self.parameters_shrink is not None:
            result['Parameters'] = self.parameters_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Parameters') is not None:
            self.parameters_shrink = m.get('Parameters')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateDataLakeDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        database: DLDatabase = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.database = database
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.database:
            self.database.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Database') is not None:
            temp_model = DLDatabase()
            self.database = temp_model.from_map(m['Database'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDataLakeDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDataLakeDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDataLakeDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDataLakeFunctionRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        function_input: DLFunctionInput = None,
        function_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.function_input = function_input
        # This parameter is required.
        self.function_name = function_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        if self.function_input:
            self.function_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.function_input is not None:
            result['FunctionInput'] = self.function_input.to_map()
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('FunctionInput') is not None:
            temp_model = DLFunctionInput()
            self.function_input = temp_model.from_map(m['FunctionInput'])
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateDataLakeFunctionShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        function_input_shrink: str = None,
        function_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.function_input_shrink = function_input_shrink
        # This parameter is required.
        self.function_name = function_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.function_input_shrink is not None:
            result['FunctionInput'] = self.function_input_shrink
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('FunctionInput') is not None:
            self.function_input_shrink = m.get('FunctionInput')
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateDataLakeFunctionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        function: DLFunction = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.function = function
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.function:
            self.function.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.function is not None:
            result['Function'] = self.function.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Function') is not None:
            temp_model = DLFunction()
            self.function = temp_model.from_map(m['Function'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDataLakeFunctionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDataLakeFunctionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDataLakeFunctionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDataLakePartitionRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        partition_input: DLPartitionInput = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.partition_input = partition_input
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        if self.partition_input:
            self.partition_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.partition_input is not None:
            result['PartitionInput'] = self.partition_input.to_map()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('PartitionInput') is not None:
            temp_model = DLPartitionInput()
            self.partition_input = temp_model.from_map(m['PartitionInput'])
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateDataLakePartitionShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        partition_input_shrink: str = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.partition_input_shrink = partition_input_shrink
        # This parameter is required.
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.partition_input_shrink is not None:
            result['PartitionInput'] = self.partition_input_shrink
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('PartitionInput') is not None:
            self.partition_input_shrink = m.get('PartitionInput')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateDataLakePartitionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDataLakePartitionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDataLakePartitionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDataLakePartitionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDataLakeTableRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        table_input: OpenStructDLTableInput = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.table_input = table_input
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        if self.table_input:
            self.table_input.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.table_input is not None:
            result['TableInput'] = self.table_input.to_map()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('TableInput') is not None:
            temp_model = OpenStructDLTableInput()
            self.table_input = temp_model.from_map(m['TableInput'])
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateDataLakeTableShrinkRequest(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        data_region: str = None,
        db_name: str = None,
        table_input_shrink: str = None,
        table_name: str = None,
        tid: int = None,
        workspace_id: int = None,
    ):
        # This parameter is required.
        self.catalog_name = catalog_name
        # This parameter is required.
        self.data_region = data_region
        # This parameter is required.
        self.db_name = db_name
        # This parameter is required.
        self.table_input_shrink = table_input_shrink
        self.table_name = table_name
        self.tid = tid
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.data_region is not None:
            result['DataRegion'] = self.data_region
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.table_input_shrink is not None:
            result['TableInput'] = self.table_input_shrink
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DataRegion') is not None:
            self.data_region = m.get('DataRegion')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('TableInput') is not None:
            self.table_input_shrink = m.get('TableInput')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateDataLakeTableResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        table: DLTable = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.table = table

    def validate(self):
        if self.table:
            self.table.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.table is not None:
            result['Table'] = self.table.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Table') is not None:
            temp_model = DLTable()
            self.table = temp_model.from_map(m['Table'])
        return self


class UpdateDataLakeTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDataLakeTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDataLakeTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateInstanceRequest(TeaModel):
    def __init__(
        self,
        data_link_name: str = None,
        database_password: str = None,
        database_user: str = None,
        dba_id: str = None,
        ddl_online: int = None,
        ecs_instance_id: str = None,
        ecs_region: str = None,
        enable_sell_sitd: str = None,
        env_type: str = None,
        export_timeout: int = None,
        host: str = None,
        instance_alias: str = None,
        instance_id: str = None,
        instance_source: str = None,
        instance_type: str = None,
        port: int = None,
        query_timeout: int = None,
        safe_rule_id: str = None,
        sid: str = None,
        skip_test: bool = None,
        template_id: int = None,
        template_type: str = None,
        tid: int = None,
        use_dsql: int = None,
        vpc_id: str = None,
    ):
        # The name of the database link for cross-database queries.
        # 
        # > 
        # 
        # *   This parameter is required if UseDsql is set to 1.
        # 
        # *   The name can contain only lowercase letters and underscores (_).
        # 
        # *   The name must be unique within a tenant.
        self.data_link_name = data_link_name
        # The password that is used to log on to the database.
        # 
        # This parameter is required.
        self.database_password = database_password
        # The account that is used to log on to the database.
        # 
        # This parameter is required.
        self.database_user = database_user
        # The ID of the user who assumes the database administrator (DBA) role of the database instance. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the user ID.
        # 
        # This parameter is required.
        self.dba_id = dba_id
        # Specifies whether to enable the lock-free schema change feature for the database instance. Valid values:
        # 
        # *   **0:** disables the lock-free schema change feature.
        # *   **1**: uses the online DDL of MySQL first.
        # *   **2**: uses the lock-free schema change feature of DMS first.
        self.ddl_online = ddl_online
        # The ID of the ECS instance on which the database instance is deployed.
        # 
        # > This parameter is required if the InstanceSource parameter is set to ECS_OWN.
        self.ecs_instance_id = ecs_instance_id
        # The ID of the region in which the database instance resides.
        # 
        # > This parameter is required if InstanceSource is set to RDS, ECS_OWN, and VPC_IDC.
        self.ecs_region = ecs_region
        # *   **Y:** enables the sensitive data protection feature
        # *   **N:** disables the sensitive data protection feature
        # *   **NULL or other:** does not update the status of the sensitive data protection feature
        self.enable_sell_sitd = enable_sell_sitd
        # The type of the environment in which the database instance is deployed. Valid values:
        # 
        # *   **product:** production environment
        # *   **dev:** development environment
        # *   **pre:** pre-release environment
        # *   **test:** test environment
        # *   **sit:** system integration testing (SIT) environment
        # *   **uat:** user acceptance testing (UAT) environment
        # *   **pet:** stress testing environment
        # *   **stag:** staging environment
        # 
        # This parameter is required.
        self.env_type = env_type
        # The timeout period for exporting data from the database instance.
        # 
        # This parameter is required.
        self.export_timeout = export_timeout
        # The host address that is used to connect to the database instance.
        # 
        # This parameter is required.
        self.host = host
        # The alias of the database instance. Specify an alias that can help you identify the database instance in DMS.
        # 
        # This parameter is required.
        self.instance_alias = instance_alias
        # The ID of the database instance. You can call the [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the instance ID.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The source of the database instance. Valid values:
        # 
        # *   **PUBLIC_OWN:** a self-managed database instance that is deployed on the Internet
        # *   **RDS:** an ApsaraDB RDS instance
        # *   **ECS_OWN:** a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
        # *   **VPC_IDC:** a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
        # 
        # This parameter is required.
        self.instance_source = instance_source
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
        # 
        # This parameter is required.
        self.instance_type = instance_type
        # The port that is used to connect to the database instance.
        # 
        # This parameter is required.
        self.port = port
        # The timeout period for querying data in the database instance.
        # 
        # This parameter is required.
        self.query_timeout = query_timeout
        # The name of the security rule set (GroupName) for the instance. You can call the [ListStandardGroups](https://help.aliyun.com/document_detail/417891.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the name of the security rule set.
        # 
        # This parameter is required.
        self.safe_rule_id = safe_rule_id
        # The system ID (SID) of the database instance.
        # 
        # > This parameter is required if the InstanceType parameter is set to ORACLE.
        self.sid = sid
        # Specifies whether to skip the connectivity test. Valid values:
        # 
        # *   **true:** skips the connectivity test
        # *   **false:** does not skip the connectivity test
        self.skip_test = skip_test
        # The ID of the classification template. You can call the [ListClassificationTemplates](https://help.aliyun.com/document_detail/460613.html) operation to query the template ID.
        self.template_id = template_id
        # The type of the classification template. You can call the [ListClassificationTemplates](https://help.aliyun.com/document_detail/460613.html) operation to query the template type.
        self.template_type = template_type
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
        self.tid = tid
        # Specifies whether to enable the cross-database query feature for the database instance. Valid values:
        # 
        # *   **0**: disables the cross-database query feature.
        # *   **1**: enables the cross-database query feature.
        # 
        # > Supported database types: MySQL, SQL Server, PostgreSQL, PolarDB for PostgreSQL (compatible with Oracle), and ApsaraDB for Redis.
        self.use_dsql = use_dsql
        # The ID of the VPC to which the database instance belongs.
        # 
        # > This parameter is required if the InstanceSource parameter is set to VPC_IDC.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.enable_sell_sitd is not None:
            result['EnableSellSitd'] = self.enable_sell_sitd
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule_id is not None:
            result['SafeRuleId'] = self.safe_rule_id
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.skip_test is not None:
            result['SkipTest'] = self.skip_test
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnableSellSitd') is not None:
            self.enable_sell_sitd = m.get('EnableSellSitd')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRuleId') is not None:
            self.safe_rule_id = m.get('SafeRuleId')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('SkipTest') is not None:
            self.skip_test = m.get('SkipTest')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class UpdateInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true:** The request was successful.
        # *   **false:** The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMetaCategoryRequest(TeaModel):
    def __init__(
        self,
        category_id: int = None,
        name: str = None,
        tid: int = None,
    ):
        # This parameter is required.
        self.category_id = category_id
        self.name = name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.name is not None:
            result['Name'] = self.name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateMetaCategoryResponseBody(TeaModel):
    def __init__(
        self,
        category: MetaCategory = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.category = category
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.category:
            self.category.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            temp_model = MetaCategory()
            self.category = temp_model.from_map(m['Category'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateMetaCategoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMetaCategoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMetaCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSLARulesRequestSlaRuleList(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        interval_minutes: int = None,
        node_id: int = None,
        type: int = None,
    ):
        # The ID of the task flow.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The timeout period. Unit: minutes.
        # 
        # This parameter is required.
        self.interval_minutes = interval_minutes
        # The ID of the task node.
        self.node_id = node_id
        # The rule type. Valid values:
        # 
        # *   **0**: SLA rules for task flows
        # *   **1**: SLA rules for nodes
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.interval_minutes is not None:
            result['IntervalMinutes'] = self.interval_minutes
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('IntervalMinutes') is not None:
            self.interval_minutes = m.get('IntervalMinutes')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateSLARulesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        sla_rule_list: List[UpdateSLARulesRequestSlaRuleList] = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The list of SLA rules.
        self.sla_rule_list = sla_rule_list
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        if self.sla_rule_list:
            for k in self.sla_rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        result['SlaRuleList'] = []
        if self.sla_rule_list is not None:
            for k in self.sla_rule_list:
                result['SlaRuleList'].append(k.to_map() if k else None)
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        self.sla_rule_list = []
        if m.get('SlaRuleList') is not None:
            for k in m.get('SlaRuleList'):
                temp_model = UpdateSLARulesRequestSlaRuleList()
                self.sla_rule_list.append(temp_model.from_map(k))
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateSLARulesShrinkRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        sla_rule_list_shrink: str = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The list of SLA rules.
        self.sla_rule_list_shrink = sla_rule_list_shrink
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.sla_rule_list_shrink is not None:
            result['SlaRuleList'] = self.sla_rule_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('SlaRuleList') is not None:
            self.sla_rule_list_shrink = m.get('SlaRuleList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateSLARulesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateSLARulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSLARulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSLARulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateScenarioRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        scenario_id: str = None,
        scenario_name: str = None,
        tid: int = None,
    ):
        # The description of the business scenario.
        self.description = description
        # The ID of the business scenario.
        # 
        # This parameter is required.
        self.scenario_id = scenario_id
        # The name of the business scenario.
        # 
        # This parameter is required.
        self.scenario_name = scenario_name
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.scenario_name is not None:
            result['ScenarioName'] = self.scenario_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('ScenarioName') is not None:
            self.scenario_name = m.get('ScenarioName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateScenarioResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateStandardGroupRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        group_id: int = None,
        group_name: str = None,
        tid: int = None,
    ):
        # The description of the security rule set.
        # 
        # This parameter is required.
        self.description = description
        # The security rule set ID. You can call the [ListStandardGroups](https://help.aliyun.com/document_detail/465940.html) operation to obtain the ID of the security rule set.
        # 
        # This parameter is required.
        self.group_id = group_id
        # The name of the security rule set.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The tenant ID.
        # 
        # >  To view the tenant ID, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateStandardGroupResponseBodyStandardGroup(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        description: str = None,
        group_id: int = None,
        group_mode: str = None,
        group_name: str = None,
        last_mender_id: int = None,
    ):
        # The type of the database for which the security rules are used.
        self.db_type = db_type
        # The description of the security rule set.
        self.description = description
        # The security rule set ID.
        self.group_id = group_id
        # The control mode. Valid values:
        # 
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        # *   **COMMON**: Security Collaboration
        self.group_mode = group_mode
        # The name of the security rule set.
        self.group_name = group_name
        # The ID of the user who last modified the security rules.
        self.last_mender_id = last_mender_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.last_mender_id is not None:
            result['LastMenderId'] = self.last_mender_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LastMenderId') is not None:
            self.last_mender_id = m.get('LastMenderId')
        return self


class UpdateStandardGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        standard_group: UpdateStandardGroupResponseBodyStandardGroup = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The request ID. You can use the request ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # The information about the security rule set.
        self.standard_group = standard_group
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StandardGroup') is not None:
            temp_model = UpdateStandardGroupResponseBodyStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateStandardGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateStandardGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateStandardGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskConfigRequest(TeaModel):
    def __init__(
        self,
        node_config: str = None,
        node_id: str = None,
        tid: int = None,
    ):
        # The advanced configuration for the node. The value of this parameter must be a JSON string.
        # 
        # This parameter is required.
        self.node_config = node_config
        # The ID of the task node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
        # 
        # This parameter is required.
        self.node_id = node_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_config is not None:
            result['NodeConfig'] = self.node_config
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeConfig') is not None:
            self.node_config = m.get('NodeConfig')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskConfigResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskContentRequest(TeaModel):
    def __init__(
        self,
        node_content: str = None,
        node_id: str = None,
        tid: int = None,
    ):
        # The node configurations after modification.
        self.node_content = node_content
        # The ID of the task node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
        # 
        # This parameter is required.
        self.node_id = node_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the ["View information about the current tenant"](https://help.aliyun.com/document_detail/181330.html) section of the Manage DMS tenants topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskContentResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskContentV2Request(TeaModel):
    def __init__(
        self,
        node_content: str = None,
        node_id: str = None,
    ):
        self.node_content = node_content
        self.node_id = node_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        return self


class UpdateTaskContentV2ResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskContentV2Response(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskContentV2ResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskContentV2ResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowConstantsRequestDagConstants(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key name of a constant for the task flow.
        self.key = key
        # The key value of a constant for the task flow.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateTaskFlowConstantsRequest(TeaModel):
    def __init__(
        self,
        dag_constants: List[UpdateTaskFlowConstantsRequestDagConstants] = None,
        dag_id: int = None,
        tid: int = None,
    ):
        # The constants for the task flow.
        self.dag_constants = dag_constants
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        if self.dag_constants:
            for k in self.dag_constants:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DagConstants'] = []
        if self.dag_constants is not None:
            for k in self.dag_constants:
                result['DagConstants'].append(k.to_map() if k else None)
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dag_constants = []
        if m.get('DagConstants') is not None:
            for k in m.get('DagConstants'):
                temp_model = UpdateTaskFlowConstantsRequestDagConstants()
                self.dag_constants.append(temp_model.from_map(k))
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowConstantsShrinkRequest(TeaModel):
    def __init__(
        self,
        dag_constants_shrink: str = None,
        dag_id: int = None,
        tid: int = None,
    ):
        # The constants for the task flow.
        self.dag_constants_shrink = dag_constants_shrink
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_constants_shrink is not None:
            result['DagConstants'] = self.dag_constants_shrink
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagConstants') is not None:
            self.dag_constants_shrink = m.get('DagConstants')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowConstantsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowConstantsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowConstantsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowConstantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowCooperatorsRequest(TeaModel):
    def __init__(
        self,
        cooperator_ids: List[str] = None,
        dag_id: int = None,
        tid: int = None,
    ):
        # The IDs of the users who are involved in the task flow to be updated.
        self.cooperator_ids = cooperator_ids
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cooperator_ids is not None:
            result['CooperatorIds'] = self.cooperator_ids
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CooperatorIds') is not None:
            self.cooperator_ids = m.get('CooperatorIds')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowCooperatorsShrinkRequest(TeaModel):
    def __init__(
        self,
        cooperator_ids_shrink: str = None,
        dag_id: int = None,
        tid: int = None,
    ):
        # The IDs of the users who are involved in the task flow to be updated.
        self.cooperator_ids_shrink = cooperator_ids_shrink
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cooperator_ids_shrink is not None:
            result['CooperatorIds'] = self.cooperator_ids_shrink
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CooperatorIds') is not None:
            self.cooperator_ids_shrink = m.get('CooperatorIds')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowCooperatorsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowCooperatorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowCooperatorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowCooperatorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowEdgesRequestEdges(TeaModel):
    def __init__(
        self,
        id: int = None,
        node_end: int = None,
        node_from: int = None,
    ):
        # The ID of the task flow edge.
        # 
        # This parameter is required.
        self.id = id
        # The ID of the end node of the edge.
        # 
        # This parameter is required.
        self.node_end = node_end
        # The ID of the start node of the edge.
        # 
        # This parameter is required.
        self.node_from = node_from

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class UpdateTaskFlowEdgesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        edges: List[UpdateTaskFlowEdgesRequestEdges] = None,
        tid: int = None,
    ):
        # The task flow ID. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The list of updated task flow edges.
        # 
        # This parameter is required.
        self.edges = edges
        # The tenant ID.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        if self.edges:
            for k in self.edges:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        result['Edges'] = []
        if self.edges is not None:
            for k in self.edges:
                result['Edges'].append(k.to_map() if k else None)
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        self.edges = []
        if m.get('Edges') is not None:
            for k in m.get('Edges'):
                temp_model = UpdateTaskFlowEdgesRequestEdges()
                self.edges.append(temp_model.from_map(k))
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowEdgesShrinkRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        edges_shrink: str = None,
        tid: int = None,
    ):
        # The task flow ID. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The list of updated task flow edges.
        # 
        # This parameter is required.
        self.edges_shrink = edges_shrink
        # The tenant ID.
        # 
        # > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.edges_shrink is not None:
            result['Edges'] = self.edges_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Edges') is not None:
            self.edges_shrink = m.get('Edges')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowEdgesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowEdgesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowEdgesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowEdgesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowNameAndDescRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_name: str = None,
        description: str = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The new name that you want to specify for the task flow.
        # 
        # This parameter is required.
        self.dag_name = dag_name
        # The description that you want to specify for the task flow.
        self.description = description
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.description is not None:
            result['Description'] = self.description
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowNameAndDescResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowNameAndDescResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowNameAndDescResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowNameAndDescResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowNotificationRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_notification_fail: bool = None,
        dag_notification_sla: bool = None,
        dag_notification_success: bool = None,
        tid: int = None,
    ):
        # The unique ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # Specifies whether to enable notifications for failed task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
        # 
        # This parameter is required.
        self.dag_notification_fail = dag_notification_fail
        # Specifies whether to enable SLA global notifications for task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
        # 
        # This parameter is required.
        self.dag_notification_sla = dag_notification_sla
        # Specifies whether to enable notifications for successful task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
        # 
        # This parameter is required.
        self.dag_notification_success = dag_notification_success
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_notification_fail is not None:
            result['DagNotificationFail'] = self.dag_notification_fail
        if self.dag_notification_sla is not None:
            result['DagNotificationSla'] = self.dag_notification_sla
        if self.dag_notification_success is not None:
            result['DagNotificationSuccess'] = self.dag_notification_success
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagNotificationFail') is not None:
            self.dag_notification_fail = m.get('DagNotificationFail')
        if m.get('DagNotificationSla') is not None:
            self.dag_notification_sla = m.get('DagNotificationSla')
        if m.get('DagNotificationSuccess') is not None:
            self.dag_notification_success = m.get('DagNotificationSuccess')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowNotificationResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowNotificationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowNotificationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowNotificationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowOwnerRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        new_owner_id: str = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The user ID of the new owner. You can call the [GetUser](https://help.aliyun.com/document_detail/147098.html) or [ListUsers](https://help.aliyun.com/document_detail/141938.html) operation to query the user ID.
        # 
        # This parameter is required.
        self.new_owner_id = new_owner_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.new_owner_id is not None:
            result['NewOwnerId'] = self.new_owner_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('NewOwnerId') is not None:
            self.new_owner_id = m.get('NewOwnerId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowOwnerResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowOwnerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowOwnerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowOwnerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowRelationsRequestEdges(TeaModel):
    def __init__(
        self,
        id: int = None,
        node_end: int = None,
        node_from: int = None,
    ):
        # The ID of the task flow edge.
        self.id = id
        # The ID of the end node on the edge.
        self.node_end = node_end
        # The ID of the start node on the edge.
        self.node_from = node_from

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class UpdateTaskFlowRelationsRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        edges: List[UpdateTaskFlowRelationsRequestEdges] = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The list of task flow edges to be updated.
        self.edges = edges
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        if self.edges:
            for k in self.edges:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        result['Edges'] = []
        if self.edges is not None:
            for k in self.edges:
                result['Edges'].append(k.to_map() if k else None)
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        self.edges = []
        if m.get('Edges') is not None:
            for k in m.get('Edges'):
                temp_model = UpdateTaskFlowRelationsRequestEdges()
                self.edges.append(temp_model.from_map(k))
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowRelationsShrinkRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        edges_shrink: str = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The list of task flow edges to be updated.
        self.edges_shrink = edges_shrink
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.edges_shrink is not None:
            result['Edges'] = self.edges_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Edges') is not None:
            self.edges_shrink = m.get('Edges')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowRelationsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowRelationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowRelationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowRelationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowScheduleRequest(TeaModel):
    def __init__(
        self,
        cron_begin_date: str = None,
        cron_end_date: str = None,
        cron_str: str = None,
        cron_type: str = None,
        dag_id: int = None,
        schedule_param: str = None,
        schedule_switch: bool = None,
        tid: int = None,
        time_zone_id: str = None,
        trigger_type: str = None,
    ):
        # The start of the time range for scheduling.
        self.cron_begin_date = cron_begin_date
        # The end of the time range for scheduling.
        self.cron_end_date = cron_end_date
        # The cron expression for timed scheduling.
        self.cron_str = cron_str
        # The type of the scheduling cycle. Valid values:
        # 
        # *   **MINUTE**: scheduling by minute
        # *   **HOUR**: scheduling by hour
        # *   **DAY**: scheduling by day
        # *   **WEEK**: scheduling by week
        # *   **MONTH**: scheduling by month
        self.cron_type = cron_type
        # The ID of the task flow.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The event scheduling configuration. The value of this parameter is a JSON string.
        # 
        # This parameter is required.
        self.schedule_param = schedule_param
        # Specifies whether to enable scheduling. Valid values:
        # 
        # *   **Enable**\
        # *   **Disable**\
        # 
        # This parameter is required.
        self.schedule_switch = schedule_switch
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid
        # The time zone. The default time zone is UTC+8 (Asia/Shanghai).
        self.time_zone_id = time_zone_id
        # The mode in which the task flow is triggered. Valid values:
        # 
        # *   **Cron**: The task flow is triggered based on timed scheduling.
        # *   **Event**: The task flow is triggered by events.
        # 
        # This parameter is required.
        self.trigger_type = trigger_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron_begin_date is not None:
            result['CronBeginDate'] = self.cron_begin_date
        if self.cron_end_date is not None:
            result['CronEndDate'] = self.cron_end_date
        if self.cron_str is not None:
            result['CronStr'] = self.cron_str
        if self.cron_type is not None:
            result['CronType'] = self.cron_type
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.schedule_param is not None:
            result['ScheduleParam'] = self.schedule_param
        if self.schedule_switch is not None:
            result['ScheduleSwitch'] = self.schedule_switch
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.time_zone_id is not None:
            result['TimeZoneId'] = self.time_zone_id
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CronBeginDate') is not None:
            self.cron_begin_date = m.get('CronBeginDate')
        if m.get('CronEndDate') is not None:
            self.cron_end_date = m.get('CronEndDate')
        if m.get('CronStr') is not None:
            self.cron_str = m.get('CronStr')
        if m.get('CronType') is not None:
            self.cron_type = m.get('CronType')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('ScheduleParam') is not None:
            self.schedule_param = m.get('ScheduleParam')
        if m.get('ScheduleSwitch') is not None:
            self.schedule_switch = m.get('ScheduleSwitch')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TimeZoneId') is not None:
            self.time_zone_id = m.get('TimeZoneId')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class UpdateTaskFlowScheduleResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowTimeVariablesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
        time_variables: str = None,
    ):
        # The ID of the task node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
        # 
        # This parameter is required.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid
        # The time variables for the task flow.
        # 
        # This parameter is required.
        self.time_variables = time_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class UpdateTaskFlowTimeVariablesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowTimeVariablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowTimeVariablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowTimeVariablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskNameRequest(TeaModel):
    def __init__(
        self,
        node_id: str = None,
        node_name: str = None,
        tid: int = None,
    ):
        # The ID of the node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
        # 
        # This parameter is required.
        self.node_id = node_id
        # The name of the node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node name.
        # 
        # This parameter is required.
        self.node_name = node_name
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskNameResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskOutputRequest(TeaModel):
    def __init__(
        self,
        node_id: str = None,
        node_output: str = None,
        tid: int = None,
    ):
        # The ID of the node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
        # 
        # This parameter is required.
        self.node_id = node_id
        # The output variables for the task.
        self.node_output = node_output
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_output is not None:
            result['NodeOutput'] = self.node_output
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeOutput') is not None:
            self.node_output = m.get('NodeOutput')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskOutputResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskOutputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskOutputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskOutputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskTimeVariablesRequest(TeaModel):
    def __init__(
        self,
        node_id: str = None,
        tid: int = None,
        time_variables: str = None,
    ):
        # The ID of the task node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
        # 
        # This parameter is required.
        self.node_id = node_id
        # The ID of the tenant.
        # 
        # > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid
        # The time variables configured for the node. The value of this parameter must be a JSON string.
        # 
        # This parameter is required.
        self.time_variables = time_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class UpdateTaskTimeVariablesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskTimeVariablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskTimeVariablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskTimeVariablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateUserRequest(TeaModel):
    def __init__(
        self,
        max_execute_count: int = None,
        max_result_count: int = None,
        mobile: str = None,
        role_names: str = None,
        tid: int = None,
        uid: int = None,
        uid_string: str = None,
        user_nick: str = None,
    ):
        # The maximum number of queries that can be performed each day.
        self.max_execute_count = max_execute_count
        # The maximum number of rows that can be queried each day.
        self.max_result_count = max_result_count
        # The DingTalk ID or mobile number of the user.
        self.mobile = mobile
        # The roles that the user assumes. For more information about the valid values, see the Request parameters section in the [UpdateUser](https://help.aliyun.com/document_detail/465812.html) topic.
        self.role_names = role_names
        # The ID of the tenant.
        # 
        # > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
        self.tid = tid
        # The Alibaba Cloud unique ID (UID) of the user to update.
        # 
        # This parameter is required.
        self.uid = uid
        # The UID of the String type. If you specify this parameter, the UID of the Long type is replaced.
        self.uid_string = uid_string
        # The nickname of the user.
        self.user_nick = user_nick

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_execute_count is not None:
            result['MaxExecuteCount'] = self.max_execute_count
        if self.max_result_count is not None:
            result['MaxResultCount'] = self.max_result_count
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.role_names is not None:
            result['RoleNames'] = self.role_names
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.uid_string is not None:
            result['UidString'] = self.uid_string
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxExecuteCount') is not None:
            self.max_execute_count = m.get('MaxExecuteCount')
        if m.get('MaxResultCount') is not None:
            self.max_result_count = m.get('MaxResultCount')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('RoleNames') is not None:
            self.role_names = m.get('RoleNames')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UidString') is not None:
            self.uid_string = m.get('UidString')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class UpdateUserResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request succeeded.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


