# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict, Any


class AsyncTaskVO(TeaModel):
    def __init__(
        self,
        dataset_id: str = None,
        id: int = None,
        remark: str = None,
        task_name: str = None,
        task_status: int = None,
        task_type: int = None,
        user_id: int = None,
    ):
        self.dataset_id = dataset_id
        self.id = id
        self.remark = remark
        self.task_name = task_name
        self.task_status = task_status
        self.task_type = task_type
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.id is not None:
            result['Id'] = self.id
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ProjectDetailsLiteVO(TeaModel):
    def __init__(
        self,
        id: int = None,
        project_name: str = None,
    ):
        self.id = id
        self.project_name = project_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        return self


class DatasetItemVO(TeaModel):
    def __init__(
        self,
        async_task_list: List[AsyncTaskVO] = None,
        dataset_status: int = None,
        dataset_type: int = None,
        digest: str = None,
        file_system: str = None,
        id: str = None,
        key_name: str = None,
        more_info: str = None,
        path: str = None,
        projects_linked: List[ProjectDetailsLiteVO] = None,
        recent_task_status: int = None,
        remark: str = None,
        schema: str = None,
        table_name: str = None,
        url: str = None,
    ):
        self.async_task_list = async_task_list
        self.dataset_status = dataset_status
        self.dataset_type = dataset_type
        self.digest = digest
        self.file_system = file_system
        self.id = id
        self.key_name = key_name
        self.more_info = more_info
        self.path = path
        self.projects_linked = projects_linked
        self.recent_task_status = recent_task_status
        self.remark = remark
        self.schema = schema
        self.table_name = table_name
        self.url = url

    def validate(self):
        if self.async_task_list:
            for k in self.async_task_list:
                if k:
                    k.validate()
        if self.projects_linked:
            for k in self.projects_linked:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AsyncTaskList'] = []
        if self.async_task_list is not None:
            for k in self.async_task_list:
                result['AsyncTaskList'].append(k.to_map() if k else None)
        if self.dataset_status is not None:
            result['DatasetStatus'] = self.dataset_status
        if self.dataset_type is not None:
            result['DatasetType'] = self.dataset_type
        if self.digest is not None:
            result['Digest'] = self.digest
        if self.file_system is not None:
            result['FileSystem'] = self.file_system
        if self.id is not None:
            result['Id'] = self.id
        if self.key_name is not None:
            result['KeyName'] = self.key_name
        if self.more_info is not None:
            result['MoreInfo'] = self.more_info
        if self.path is not None:
            result['Path'] = self.path
        result['ProjectsLinked'] = []
        if self.projects_linked is not None:
            for k in self.projects_linked:
                result['ProjectsLinked'].append(k.to_map() if k else None)
        if self.recent_task_status is not None:
            result['RecentTaskStatus'] = self.recent_task_status
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.schema is not None:
            result['Schema'] = self.schema
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.async_task_list = []
        if m.get('AsyncTaskList') is not None:
            for k in m.get('AsyncTaskList'):
                temp_model = AsyncTaskVO()
                self.async_task_list.append(temp_model.from_map(k))
        if m.get('DatasetStatus') is not None:
            self.dataset_status = m.get('DatasetStatus')
        if m.get('DatasetType') is not None:
            self.dataset_type = m.get('DatasetType')
        if m.get('Digest') is not None:
            self.digest = m.get('Digest')
        if m.get('FileSystem') is not None:
            self.file_system = m.get('FileSystem')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('KeyName') is not None:
            self.key_name = m.get('KeyName')
        if m.get('MoreInfo') is not None:
            self.more_info = m.get('MoreInfo')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        self.projects_linked = []
        if m.get('ProjectsLinked') is not None:
            for k in m.get('ProjectsLinked'):
                temp_model = ProjectDetailsLiteVO()
                self.projects_linked.append(temp_model.from_map(k))
        if m.get('RecentTaskStatus') is not None:
            self.recent_task_status = m.get('RecentTaskStatus')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('Schema') is not None:
            self.schema = m.get('Schema')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetTableDataKeyVO(TeaModel):
    def __init__(
        self,
        col_name: str = None,
        db_name: str = None,
        mek_id: int = None,
        schema_name: str = None,
        tbl_name: str = None,
        user_name: str = None,
    ):
        self.col_name = col_name
        self.db_name = db_name
        self.mek_id = mek_id
        self.schema_name = schema_name
        self.tbl_name = tbl_name
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.col_name is not None:
            result['ColName'] = self.col_name
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.mek_id is not None:
            result['MekId'] = self.mek_id
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.tbl_name is not None:
            result['TblName'] = self.tbl_name
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColName') is not None:
            self.col_name = m.get('ColName')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('MekId') is not None:
            self.mek_id = m.get('MekId')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TblName') is not None:
            self.tbl_name = m.get('TblName')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ImportMasterKeyVO(TeaModel):
    def __init__(
        self,
        encrypt_mek_data_base_64: str = None,
        mek_id: int = None,
        project_id: List[int] = None,
    ):
        self.encrypt_mek_data_base_64 = encrypt_mek_data_base_64
        self.mek_id = mek_id
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encrypt_mek_data_base_64 is not None:
            result['EncryptMekDataBase64'] = self.encrypt_mek_data_base_64
        if self.mek_id is not None:
            result['MekId'] = self.mek_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EncryptMekDataBase64') is not None:
            self.encrypt_mek_data_base_64 = m.get('EncryptMekDataBase64')
        if m.get('MekId') is not None:
            self.mek_id = m.get('MekId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class StsApplyVO(TeaModel):
    def __init__(
        self,
        aliyun_id: str = None,
        duration: int = None,
    ):
        self.aliyun_id = aliyun_id
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_id is not None:
            result['AliyunId'] = self.aliyun_id
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunId') is not None:
            self.aliyun_id = m.get('AliyunId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class StsTokenVO(TeaModel):
    def __init__(
        self,
        access_key_id: str = None,
        access_key_secret: str = None,
        expiration: str = None,
        security_token: str = None,
    ):
        self.access_key_id = access_key_id
        self.access_key_secret = access_key_secret
        self.expiration = expiration
        self.security_token = security_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key_id is not None:
            result['AccessKeyId'] = self.access_key_id
        if self.access_key_secret is not None:
            result['AccessKeySecret'] = self.access_key_secret
        if self.expiration is not None:
            result['Expiration'] = self.expiration
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKeyId') is not None:
            self.access_key_id = m.get('AccessKeyId')
        if m.get('AccessKeySecret') is not None:
            self.access_key_secret = m.get('AccessKeySecret')
        if m.get('Expiration') is not None:
            self.expiration = m.get('Expiration')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        return self


class TeeEvidenceVO(TeaModel):
    def __init__(
        self,
        cipher_suite: str = None,
        enclave_data: str = None,
        encrypt_public_key_pem: str = None,
        encrypt_public_key_type: str = None,
        modified_date: str = None,
        public_key: str = None,
        public_key_ra_base_64: str = None,
        public_key_ra_type: str = None,
        quote_report: str = None,
        sign_public_key_pem: str = None,
        sign_public_key_type: str = None,
        trusted_mr_enclave: List[str] = None,
    ):
        self.cipher_suite = cipher_suite
        self.enclave_data = enclave_data
        self.encrypt_public_key_pem = encrypt_public_key_pem
        self.encrypt_public_key_type = encrypt_public_key_type
        self.modified_date = modified_date
        self.public_key = public_key
        self.public_key_ra_base_64 = public_key_ra_base_64
        self.public_key_ra_type = public_key_ra_type
        self.quote_report = quote_report
        self.sign_public_key_pem = sign_public_key_pem
        self.sign_public_key_type = sign_public_key_type
        self.trusted_mr_enclave = trusted_mr_enclave

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cipher_suite is not None:
            result['CipherSuite'] = self.cipher_suite
        if self.enclave_data is not None:
            result['EnclaveData'] = self.enclave_data
        if self.encrypt_public_key_pem is not None:
            result['EncryptPublicKeyPem'] = self.encrypt_public_key_pem
        if self.encrypt_public_key_type is not None:
            result['EncryptPublicKeyType'] = self.encrypt_public_key_type
        if self.modified_date is not None:
            result['ModifiedDate'] = self.modified_date
        if self.public_key is not None:
            result['PublicKey'] = self.public_key
        if self.public_key_ra_base_64 is not None:
            result['PublicKeyRaBase64'] = self.public_key_ra_base_64
        if self.public_key_ra_type is not None:
            result['PublicKeyRaType'] = self.public_key_ra_type
        if self.quote_report is not None:
            result['QuoteReport'] = self.quote_report
        if self.sign_public_key_pem is not None:
            result['SignPublicKeyPem'] = self.sign_public_key_pem
        if self.sign_public_key_type is not None:
            result['SignPublicKeyType'] = self.sign_public_key_type
        if self.trusted_mr_enclave is not None:
            result['TrustedMrEnclave'] = self.trusted_mr_enclave
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CipherSuite') is not None:
            self.cipher_suite = m.get('CipherSuite')
        if m.get('EnclaveData') is not None:
            self.enclave_data = m.get('EnclaveData')
        if m.get('EncryptPublicKeyPem') is not None:
            self.encrypt_public_key_pem = m.get('EncryptPublicKeyPem')
        if m.get('EncryptPublicKeyType') is not None:
            self.encrypt_public_key_type = m.get('EncryptPublicKeyType')
        if m.get('ModifiedDate') is not None:
            self.modified_date = m.get('ModifiedDate')
        if m.get('PublicKey') is not None:
            self.public_key = m.get('PublicKey')
        if m.get('PublicKeyRaBase64') is not None:
            self.public_key_ra_base_64 = m.get('PublicKeyRaBase64')
        if m.get('PublicKeyRaType') is not None:
            self.public_key_ra_type = m.get('PublicKeyRaType')
        if m.get('QuoteReport') is not None:
            self.quote_report = m.get('QuoteReport')
        if m.get('SignPublicKeyPem') is not None:
            self.sign_public_key_pem = m.get('SignPublicKeyPem')
        if m.get('SignPublicKeyType') is not None:
            self.sign_public_key_type = m.get('SignPublicKeyType')
        if m.get('TrustedMrEnclave') is not None:
            self.trusted_mr_enclave = m.get('TrustedMrEnclave')
        return self


class UsersDetailsVO(TeaModel):
    def __init__(
        self,
        approval_signature_base_64: str = None,
        approval_sql_template: str = None,
        approval_status: str = None,
        creator: int = None,
        data_ready: int = None,
        id: int = None,
        mekid: int = None,
        path_prefix: str = None,
        result_party: int = None,
        uid: str = None,
        user_confirmed: int = None,
        user_name: str = None,
        user_public_key_pem: str = None,
    ):
        self.approval_signature_base_64 = approval_signature_base_64
        self.approval_sql_template = approval_sql_template
        self.approval_status = approval_status
        self.creator = creator
        self.data_ready = data_ready
        self.id = id
        self.mekid = mekid
        self.path_prefix = path_prefix
        self.result_party = result_party
        self.uid = uid
        self.user_confirmed = user_confirmed
        self.user_name = user_name
        self.user_public_key_pem = user_public_key_pem

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.approval_signature_base_64 is not None:
            result['ApprovalSignatureBase64'] = self.approval_signature_base_64
        if self.approval_sql_template is not None:
            result['ApprovalSqlTemplate'] = self.approval_sql_template
        if self.approval_status is not None:
            result['ApprovalStatus'] = self.approval_status
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.data_ready is not None:
            result['DataReady'] = self.data_ready
        if self.id is not None:
            result['Id'] = self.id
        if self.mekid is not None:
            result['Mekid'] = self.mekid
        if self.path_prefix is not None:
            result['PathPrefix'] = self.path_prefix
        if self.result_party is not None:
            result['ResultParty'] = self.result_party
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_confirmed is not None:
            result['UserConfirmed'] = self.user_confirmed
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_public_key_pem is not None:
            result['UserPublicKeyPem'] = self.user_public_key_pem
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApprovalSignatureBase64') is not None:
            self.approval_signature_base_64 = m.get('ApprovalSignatureBase64')
        if m.get('ApprovalSqlTemplate') is not None:
            self.approval_sql_template = m.get('ApprovalSqlTemplate')
        if m.get('ApprovalStatus') is not None:
            self.approval_status = m.get('ApprovalStatus')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('DataReady') is not None:
            self.data_ready = m.get('DataReady')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Mekid') is not None:
            self.mekid = m.get('Mekid')
        if m.get('PathPrefix') is not None:
            self.path_prefix = m.get('PathPrefix')
        if m.get('ResultParty') is not None:
            self.result_party = m.get('ResultParty')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserConfirmed') is not None:
            self.user_confirmed = m.get('UserConfirmed')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserPublicKeyPem') is not None:
            self.user_public_key_pem = m.get('UserPublicKeyPem')
        return self


class AddDesensitizationRuleRequest(TeaModel):
    def __init__(
        self,
        function_params: List[Dict[str, str]] = None,
        function_type: str = None,
        rule_description: str = None,
        rule_name: str = None,
        rule_type: str = None,
        tid: int = None,
    ):
        self.function_params = function_params
        # The type of the masking algorithm.
        self.function_type = function_type
        # The description of the rule.
        self.rule_description = rule_description
        # The name of the rule.
        self.rule_name = rule_name
        # The masking algorithm.
        self.rule_type = rule_type
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_params is not None:
            result['FunctionParams'] = self.function_params
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.rule_description is not None:
            result['RuleDescription'] = self.rule_description
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionParams') is not None:
            self.function_params = m.get('FunctionParams')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('RuleDescription') is not None:
            self.rule_description = m.get('RuleDescription')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddDesensitizationRuleResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        rule_id: int = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The ID generated for the masking rule.
        self.rule_id = rule_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddDesensitizationRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDesensitizationRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDesensitizationRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLhMembersRequestMembers(TeaModel):
    def __init__(
        self,
        roles: List[str] = None,
        user_id: int = None,
    ):
        # The role. Valid values:
        # 
        # *   **ADMIN**: workspace administrator. You can add a workspace administrator only as a DMS administrator or a DBA.
        # *   **MEMBER**: workspace member.
        # *   **DEVELOPER**: task flow developer. Only a workspace member can be added as a task flow developer.
        self.roles = roles
        # The ID of the user to be added. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.roles is not None:
            result['Roles'] = self.roles
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Roles') is not None:
            self.roles = m.get('Roles')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class AddLhMembersRequest(TeaModel):
    def __init__(
        self,
        members: List[AddLhMembersRequestMembers] = None,
        object_id: int = None,
        object_type: int = None,
        tid: int = None,
    ):
        # The information about the users to be added.
        self.members = members
        # The ID of the object.
        # 
        # *   If the object is a workspace, you can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
        # *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
        self.object_id = object_id
        # The type of the object. Valid values:
        # 
        # *   **0**: workspace
        # *   **1**: task flow
        self.object_type = object_type
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Members'] = []
        if self.members is not None:
            for k in self.members:
                result['Members'].append(k.to_map() if k else None)
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.members = []
        if m.get('Members') is not None:
            for k in m.get('Members'):
                temp_model = AddLhMembersRequestMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddLhMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        members_shrink: str = None,
        object_id: int = None,
        object_type: int = None,
        tid: int = None,
    ):
        # The information about the users to be added.
        self.members_shrink = members_shrink
        # The ID of the object.
        # 
        # *   If the object is a workspace, you can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
        # *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
        self.object_id = object_id
        # The type of the object. Valid values:
        # 
        # *   **0**: workspace
        # *   **1**: task flow
        self.object_type = object_type
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.members_shrink is not None:
            result['Members'] = self.members_shrink
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Members') is not None:
            self.members_shrink = m.get('Members')
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddLhMembersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddLhMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLhMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLhMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddLogicTableRouteConfigRequest(TeaModel):
    def __init__(
        self,
        route_expr: str = None,
        route_key: str = None,
        table_id: int = None,
        tid: int = None,
    ):
        # The routing algorithm expression. For more information about how to configure a routing algorithm expression, see [Configure a routing algorithm](https://www.alibabacloud.com/help/en/data-management-service/latest/configure-a-routing-algorithm).
        self.route_expr = route_expr
        # The unique key of the routing algorithm. 
        # 
        # > - You can create a custom unique key for the routing algorithm. No requirements are imposed on custom unique keys.
        # - The unique key of the routing algorithm in the same logical table must be unique.
        self.route_key = route_key
        # The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
        self.table_id = table_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_expr is not None:
            result['RouteExpr'] = self.route_expr
        if self.route_key is not None:
            result['RouteKey'] = self.route_key
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RouteExpr') is not None:
            self.route_expr = m.get('RouteExpr')
        if m.get('RouteKey') is not None:
            self.route_key = m.get('RouteKey')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddLogicTableRouteConfigResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddLogicTableRouteConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddLogicTableRouteConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddLogicTableRouteConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTaskFlowEdgesRequestEdges(TeaModel):
    def __init__(
        self,
        node_end: int = None,
        node_from: int = None,
    ):
        self.node_end = node_end
        self.node_from = node_from

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class AddTaskFlowEdgesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        edges: List[AddTaskFlowEdgesRequestEdges] = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.edges = edges
        self.tid = tid

    def validate(self):
        if self.edges:
            for k in self.edges:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        result['Edges'] = []
        if self.edges is not None:
            for k in self.edges:
                result['Edges'].append(k.to_map() if k else None)
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        self.edges = []
        if m.get('Edges') is not None:
            for k in m.get('Edges'):
                temp_model = AddTaskFlowEdgesRequestEdges()
                self.edges.append(temp_model.from_map(k))
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddTaskFlowEdgesShrinkRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        edges_shrink: str = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.edges_shrink = edges_shrink
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.edges_shrink is not None:
            result['Edges'] = self.edges_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Edges') is not None:
            self.edges_shrink = m.get('Edges')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class AddTaskFlowEdgesResponseBodyEdgeIds(TeaModel):
    def __init__(
        self,
        edge_id: List[int] = None,
    ):
        self.edge_id = edge_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edge_id is not None:
            result['EdgeId'] = self.edge_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EdgeId') is not None:
            self.edge_id = m.get('EdgeId')
        return self


class AddTaskFlowEdgesResponseBody(TeaModel):
    def __init__(
        self,
        edge_ids: AddTaskFlowEdgesResponseBodyEdgeIds = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.edge_ids = edge_ids
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.edge_ids:
            self.edge_ids.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edge_ids is not None:
            result['EdgeIds'] = self.edge_ids.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EdgeIds') is not None:
            temp_model = AddTaskFlowEdgesResponseBodyEdgeIds()
            self.edge_ids = temp_model.from_map(m['EdgeIds'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddTaskFlowEdgesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddTaskFlowEdgesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTaskFlowEdgesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ApproveOrderRequest(TeaModel):
    def __init__(
        self,
        approval_type: str = None,
        comment: str = None,
        tid: int = None,
        workflow_instance_id: int = None,
    ):
        # The action that you want to perform on the ticket. Valid values:
        # 
        # *   AGREE: approve
        # *   CANCEL: cancel
        # *   REJECT: reject
        self.approval_type = approval_type
        # The description of the ticket.
        self.comment = comment
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid
        # The ID of the approval process. You can call the [GetOrderBaseInfo](~~144642~~) operation to obtain the ID of the approval process.
        self.workflow_instance_id = workflow_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.approval_type is not None:
            result['ApprovalType'] = self.approval_type
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApprovalType') is not None:
            self.approval_type = m.get('ApprovalType')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class ApproveOrderResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ApproveOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ApproveOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ApproveOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BackFillRequest(TeaModel):
    def __init__(
        self,
        asc: bool = None,
        back_fill_date: str = None,
        back_fill_date_begin: str = None,
        back_fill_date_end: str = None,
        dag_id: int = None,
        history_dag_id: int = None,
        interval: int = None,
        is_trigger_sub_tree: bool = None,
        start_node_ids: List[int] = None,
        tid: int = None,
    ):
        # The running sequence of task flows for data backfill. Valid values:
        # 
        # *   **0**: reverse chronological order.
        # *   **1**: chronological order. This is the default value.
        self.asc = asc
        # The date for the data to be backfilled. This parameter is required if you specify a date for data backfill.
        self.back_fill_date = back_fill_date
        # The start date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
        self.back_fill_date_begin = back_fill_date_begin
        # The end date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
        self.back_fill_date_end = back_fill_date_end
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The ID of the historical task flow.
        self.history_dag_id = history_dag_id
        # The interval at which data backfill is performed. Unit: hours. Minimum value: 1. Default value: 24.
        self.interval = interval
        # Specifies whether to run descendant nodes. Default value: true.
        self.is_trigger_sub_tree = is_trigger_sub_tree
        # The number of nodes for which you want to backfill data.
        self.start_node_ids = start_node_ids
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.back_fill_date is not None:
            result['BackFillDate'] = self.back_fill_date
        if self.back_fill_date_begin is not None:
            result['BackFillDateBegin'] = self.back_fill_date_begin
        if self.back_fill_date_end is not None:
            result['BackFillDateEnd'] = self.back_fill_date_end
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.history_dag_id is not None:
            result['HistoryDagId'] = self.history_dag_id
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.is_trigger_sub_tree is not None:
            result['IsTriggerSubTree'] = self.is_trigger_sub_tree
        if self.start_node_ids is not None:
            result['StartNodeIds'] = self.start_node_ids
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('BackFillDate') is not None:
            self.back_fill_date = m.get('BackFillDate')
        if m.get('BackFillDateBegin') is not None:
            self.back_fill_date_begin = m.get('BackFillDateBegin')
        if m.get('BackFillDateEnd') is not None:
            self.back_fill_date_end = m.get('BackFillDateEnd')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('HistoryDagId') is not None:
            self.history_dag_id = m.get('HistoryDagId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IsTriggerSubTree') is not None:
            self.is_trigger_sub_tree = m.get('IsTriggerSubTree')
        if m.get('StartNodeIds') is not None:
            self.start_node_ids = m.get('StartNodeIds')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class BackFillShrinkRequest(TeaModel):
    def __init__(
        self,
        asc: bool = None,
        back_fill_date: str = None,
        back_fill_date_begin: str = None,
        back_fill_date_end: str = None,
        dag_id: int = None,
        history_dag_id: int = None,
        interval: int = None,
        is_trigger_sub_tree: bool = None,
        start_node_ids_shrink: str = None,
        tid: int = None,
    ):
        # The running sequence of task flows for data backfill. Valid values:
        # 
        # *   **0**: reverse chronological order.
        # *   **1**: chronological order. This is the default value.
        self.asc = asc
        # The date for the data to be backfilled. This parameter is required if you specify a date for data backfill.
        self.back_fill_date = back_fill_date
        # The start date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
        self.back_fill_date_begin = back_fill_date_begin
        # The end date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
        self.back_fill_date_end = back_fill_date_end
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The ID of the historical task flow.
        self.history_dag_id = history_dag_id
        # The interval at which data backfill is performed. Unit: hours. Minimum value: 1. Default value: 24.
        self.interval = interval
        # Specifies whether to run descendant nodes. Default value: true.
        self.is_trigger_sub_tree = is_trigger_sub_tree
        # The number of nodes for which you want to backfill data.
        self.start_node_ids_shrink = start_node_ids_shrink
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.back_fill_date is not None:
            result['BackFillDate'] = self.back_fill_date
        if self.back_fill_date_begin is not None:
            result['BackFillDateBegin'] = self.back_fill_date_begin
        if self.back_fill_date_end is not None:
            result['BackFillDateEnd'] = self.back_fill_date_end
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.history_dag_id is not None:
            result['HistoryDagId'] = self.history_dag_id
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.is_trigger_sub_tree is not None:
            result['IsTriggerSubTree'] = self.is_trigger_sub_tree
        if self.start_node_ids_shrink is not None:
            result['StartNodeIds'] = self.start_node_ids_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('BackFillDate') is not None:
            self.back_fill_date = m.get('BackFillDate')
        if m.get('BackFillDateBegin') is not None:
            self.back_fill_date_begin = m.get('BackFillDateBegin')
        if m.get('BackFillDateEnd') is not None:
            self.back_fill_date_end = m.get('BackFillDateEnd')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('HistoryDagId') is not None:
            self.history_dag_id = m.get('HistoryDagId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IsTriggerSubTree') is not None:
            self.is_trigger_sub_tree = m.get('IsTriggerSubTree')
        if m.get('StartNodeIds') is not None:
            self.start_node_ids_shrink = m.get('StartNodeIds')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class BackFillResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        node_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the node.
        self.node_id = node_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BackFillResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BackFillResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BackFillResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BuyPayAsYouGoOrderRequest(TeaModel):
    def __init__(
        self,
        commodity_type: str = None,
        ins_num: int = None,
        tid: int = None,
        version_type: str = None,
    ):
        self.commodity_type = commodity_type
        self.ins_num = ins_num
        self.tid = tid
        self.version_type = version_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_type is not None:
            result['CommodityType'] = self.commodity_type
        if self.ins_num is not None:
            result['InsNum'] = self.ins_num
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.version_type is not None:
            result['VersionType'] = self.version_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityType') is not None:
            self.commodity_type = m.get('CommodityType')
        if m.get('InsNum') is not None:
            self.ins_num = m.get('InsNum')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('VersionType') is not None:
            self.version_type = m.get('VersionType')
        return self


class BuyPayAsYouGoOrderResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        instance_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.instance_id = instance_id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BuyPayAsYouGoOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BuyPayAsYouGoOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BuyPayAsYouGoOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeColumnSecLevelRequest(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        db_id: int = None,
        is_logic: bool = None,
        new_level: str = None,
        schema_name: str = None,
        table_name: str = None,
        tid: int = None,
    ):
        # The name of the field. You can call the [ListSensitiveColumns](~~188103~~) operation to query the name of the field.
        # 
        # >  You can also call the [ListColumns](~~141870~~) operation to query the name of the field.
        self.column_name = column_name
        # The ID of the database. You can call the [SearchDatabase](~~141876~~) operation to query the ID of the database.
        # 
        # >  You can also call the [ListDatabases](~~141873~~) operation to query the ID of a physical database and the [ListLogicDatabases](~~141874~~) operation to query the ID of a logical database.
        self.db_id = db_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   true: The database is a physical database.
        # *   false: The database is a logical database.
        self.is_logic = is_logic
        # The new sensitivity level of the field that you want to specify. Valid values:
        # 
        # *   INNER: low sensitivity level
        # *   SENSITIVE: medium sensitivity level
        # *   CONFIDENTIAL: high sensitivity level
        self.new_level = new_level
        # The name of the database. You can call the [ListSensitiveColumns](~~188103~~) operation to query the name of the database.
        # 
        # *   You can also call the [SearchDatabase](~~141876~~) operation to query the name of the database.
        # *   You can also call the [ListDatabases](~~141873~~) operation to query the name of a physical database and the [ListLogicDatabases](~~141874~~) operation to query the name of a logical database.
        self.schema_name = schema_name
        # The name of the table. You can call the [ListSensitiveColumns](~~188103~~) operation to query the name of the table.
        # 
        # >  You can also call the [ListTables](~~141878~~) operation to query the name of the table.
        self.table_name = table_name
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.is_logic is not None:
            result['IsLogic'] = self.is_logic
        if self.new_level is not None:
            result['NewLevel'] = self.new_level
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('IsLogic') is not None:
            self.is_logic = m.get('IsLogic')
        if m.get('NewLevel') is not None:
            self.new_level = m.get('NewLevel')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ChangeColumnSecLevelResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   true: The request is successful.
        # *   false: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ChangeColumnSecLevelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeColumnSecLevelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeColumnSecLevelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeLhDagOwnerRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        owner_user_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
        self.dag_id = dag_id
        # The ID of the user to be specified as the new owner of the task flow. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
        self.owner_user_id = owner_user_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.owner_user_id is not None:
            result['OwnerUserId'] = self.owner_user_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('OwnerUserId') is not None:
            self.owner_user_id = m.get('OwnerUserId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ChangeLhDagOwnerResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ChangeLhDagOwnerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeLhDagOwnerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeLhDagOwnerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CloseOrderRequest(TeaModel):
    def __init__(
        self,
        close_reason: str = None,
        order_id: int = None,
        tid: int = None,
    ):
        self.close_reason = close_reason
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.close_reason is not None:
            result['CloseReason'] = self.close_reason
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CloseReason') is not None:
            self.close_reason = m.get('CloseReason')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CloseOrderResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CloseOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CloseOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CloseOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataCorrectOrderRequestParamDbItemList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
    ):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To obtain the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
        # *   To obtain the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
        self.db_id = db_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateDataCorrectOrderRequestParam(TeaModel):
    def __init__(
        self,
        attachment_name: str = None,
        classify: str = None,
        db_item_list: List[CreateDataCorrectOrderRequestParamDbItemList] = None,
        estimate_affect_rows: int = None,
        exec_mode: str = None,
        exec_sql: str = None,
        rollback_attachment_name: str = None,
        rollback_sql: str = None,
        rollback_sql_type: str = None,
        sql_type: str = None,
    ):
        # The key of the attachment that contains the SQL statements used to change data. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        # 
        # >  This parameter is required if you set the **SqlType** parameter to **ATTACHMENT**.
        self.attachment_name = attachment_name
        # The reason for the data change.
        self.classify = classify
        # The databases in which you want to change data.
        self.db_item_list = db_item_list
        # The estimated number of data rows to be affected by the data change.
        self.estimate_affect_rows = estimate_affect_rows
        # The execution mode of the ticket after the ticket is approved. Valid values:
        # 
        # *   **COMMITOR**: The data change is performed by the user who submits the ticket.
        # *   **AUTO**: The data change is automatically performed after the ticket is approved.
        # *   **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
        self.exec_mode = exec_mode
        # The SQL statements that you want to execute to change data.
        # 
        # >  This parameter is required if you set the **SqlType** parameter to **TEXT**.
        self.exec_sql = exec_sql
        # The key of the attachment that contains the SQL statements used to roll back the data change. You can call the [GetUserUploadFileJob](~~206069~~) operation to the attachment key from the value of the AttachmentKey parameter.
        # 
        # >  This parameter is required if you set the **RollbackSqlType** parameter to **ATTACHMENT**.
        self.rollback_attachment_name = rollback_attachment_name
        # The SQL statements used to roll back the data change.
        # 
        # > 
        # *   This parameter is required if you set the **RollbackSqlType** parameter to **TEXT**.
        self.rollback_sql = rollback_sql
        # The format of the SQL statements used to roll back the data change. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment
        self.rollback_sql_type = rollback_sql_type
        # The format of the SQL statements used to change data. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment
        self.sql_type = sql_type

    def validate(self):
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_name is not None:
            result['AttachmentName'] = self.attachment_name
        if self.classify is not None:
            result['Classify'] = self.classify
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.estimate_affect_rows is not None:
            result['EstimateAffectRows'] = self.estimate_affect_rows
        if self.exec_mode is not None:
            result['ExecMode'] = self.exec_mode
        if self.exec_sql is not None:
            result['ExecSQL'] = self.exec_sql
        if self.rollback_attachment_name is not None:
            result['RollbackAttachmentName'] = self.rollback_attachment_name
        if self.rollback_sql is not None:
            result['RollbackSQL'] = self.rollback_sql
        if self.rollback_sql_type is not None:
            result['RollbackSqlType'] = self.rollback_sql_type
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentName') is not None:
            self.attachment_name = m.get('AttachmentName')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateDataCorrectOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('EstimateAffectRows') is not None:
            self.estimate_affect_rows = m.get('EstimateAffectRows')
        if m.get('ExecMode') is not None:
            self.exec_mode = m.get('ExecMode')
        if m.get('ExecSQL') is not None:
            self.exec_sql = m.get('ExecSQL')
        if m.get('RollbackAttachmentName') is not None:
            self.rollback_attachment_name = m.get('RollbackAttachmentName')
        if m.get('RollbackSQL') is not None:
            self.rollback_sql = m.get('RollbackSQL')
        if m.get('RollbackSqlType') is not None:
            self.rollback_sql_type = m.get('RollbackSqlType')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        return self


class CreateDataCorrectOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param: CreateDataCorrectOrderRequestParam = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key
        # The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
        self.comment = comment
        # The parameters of the ticket.
        self.param = param
        # The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataCorrectOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataCorrectOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param_shrink: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key
        # The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
        self.comment = comment
        # The parameters of the ticket.
        self.param_shrink = param_shrink
        # The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataCorrectOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the ticket.
        self.create_order_result = create_order_result
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataCorrectOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataCorrectOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataCorrectOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataCronClearOrderRequestParamCronClearItemList(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        filter_sql: str = None,
        remain_days: int = None,
        table_name: str = None,
        time_unit: str = None,
    ):
        # The name of the field.
        self.column_name = column_name
        # The filter conditions.
        self.filter_sql = filter_sql
        # The retention period of the historical data. Unit: days. For example, if you set the parameter to 7, DMS deletes the data that is retained for more than seven days.
        self.remain_days = remain_days
        # The name of the table. You can call the [ListTables](~~141878~~) operation to query the name of the table.
        self.table_name = table_name
        # The type of time granularity. If the ColumnName parameter specifies a field of a time type, this parameter is required. Valid values:
        # 
        # *   **MILLISECONDS**: milliseconds
        # *   **SECONDS**: seconds
        self.time_unit = time_unit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.filter_sql is not None:
            result['FilterSQL'] = self.filter_sql
        if self.remain_days is not None:
            result['RemainDays'] = self.remain_days
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.time_unit is not None:
            result['TimeUnit'] = self.time_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('FilterSQL') is not None:
            self.filter_sql = m.get('FilterSQL')
        if m.get('RemainDays') is not None:
            self.remain_days = m.get('RemainDays')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TimeUnit') is not None:
            self.time_unit = m.get('TimeUnit')
        return self


class CreateDataCronClearOrderRequestParamDbItemList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
    ):
        # The ID of the database. You can call the [SearchDatabases](~~141876~~) operation to query the ID of the database.
        self.db_id = db_id
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        self.logic = logic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateDataCronClearOrderRequestParam(TeaModel):
    def __init__(
        self,
        classify: str = None,
        cron_clear_item_list: List[CreateDataCronClearOrderRequestParamCronClearItemList] = None,
        cron_format: str = None,
        db_item_list: List[CreateDataCronClearOrderRequestParamDbItemList] = None,
        duration_hour: int = None,
        specify_duration: bool = None,
    ):
        # The reason for the data change.
        self.classify = classify
        # The tables for which you want to clear historical data.
        self.cron_clear_item_list = cron_clear_item_list
        # The crontab expression that you can use to run the task at a specified time. For more information, see [Crontab expression](~~206581~~).
        self.cron_format = cron_format
        # The databases for which you want to clear historical data.
        self.db_item_list = db_item_list
        # The amount of time taken to run the task. Unit: hours.
        # 
        # >  If the **specifyDuration** parameter is set to **true**, this parameter is required.
        self.duration_hour = duration_hour
        # Specifies whether to specify an end time for the task. Valid values:
        # 
        # *   **true**: specifies an end time for the task. The task is automatically suspended after this end time.
        # *   **false**: does not specify an end time for the task. The task is stopped after the historical data is cleared.
        self.specify_duration = specify_duration

    def validate(self):
        if self.cron_clear_item_list:
            for k in self.cron_clear_item_list:
                if k:
                    k.validate()
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.classify is not None:
            result['Classify'] = self.classify
        result['CronClearItemList'] = []
        if self.cron_clear_item_list is not None:
            for k in self.cron_clear_item_list:
                result['CronClearItemList'].append(k.to_map() if k else None)
        if self.cron_format is not None:
            result['CronFormat'] = self.cron_format
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.duration_hour is not None:
            result['DurationHour'] = self.duration_hour
        if self.specify_duration is not None:
            result['specifyDuration'] = self.specify_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.cron_clear_item_list = []
        if m.get('CronClearItemList') is not None:
            for k in m.get('CronClearItemList'):
                temp_model = CreateDataCronClearOrderRequestParamCronClearItemList()
                self.cron_clear_item_list.append(temp_model.from_map(k))
        if m.get('CronFormat') is not None:
            self.cron_format = m.get('CronFormat')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateDataCronClearOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('DurationHour') is not None:
            self.duration_hour = m.get('DurationHour')
        if m.get('specifyDuration') is not None:
            self.specify_duration = m.get('specifyDuration')
        return self


class CreateDataCronClearOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param: CreateDataCronClearOrderRequestParam = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        # The key of the attachment for the ticket. The attachment provides more instructions for this operation.
        # 
        # You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
        self.attachment_key = attachment_key
        # The purpose or objective of the data change. This reduces unnecessary communication.
        self.comment = comment
        # The parameters of the ticket.
        self.param = param
        # The stakeholders of this operation. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than Data Management (DMS) administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list
        # The ID of the tenant.
        # 
        # >  The ID of the tenant is displayed when you move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the Manage DMS tenants topic.
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataCronClearOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataCronClearOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param_shrink: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The key of the attachment for the ticket. The attachment provides more instructions for this operation.
        # 
        # You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
        self.attachment_key = attachment_key
        # The purpose or objective of the data change. This reduces unnecessary communication.
        self.comment = comment
        # The parameters of the ticket.
        self.param_shrink = param_shrink
        # The stakeholders of this operation. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than Data Management (DMS) administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink
        # The ID of the tenant.
        # 
        # >  The ID of the tenant is displayed when you move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the Manage DMS tenants topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataCronClearOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the ticket.
        self.create_order_result = create_order_result
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataCronClearOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataCronClearOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataCronClearOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataImportOrderRequestParamDbItemList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
    ):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To obtain the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
        # *   To obtain the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
        self.db_id = db_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        # 
        # >  If you set this parameter to **true**, the database that you specify must be a logical database.
        self.logic = logic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateDataImportOrderRequestParam(TeaModel):
    def __init__(
        self,
        attachment_name: str = None,
        classify: str = None,
        csv_first_row_is_column_def: bool = None,
        db_item_list: List[CreateDataImportOrderRequestParamDbItemList] = None,
        file_encoding: str = None,
        file_type: str = None,
        ignore_error: bool = None,
        import_mode: str = None,
        insert_type: str = None,
        rollback_attachment_name: str = None,
        rollback_sql: str = None,
        rollback_sql_type: str = None,
        table_name: str = None,
    ):
        # The key of the attachment that contains the SQL statements used to import data. You can call the [GetUserUploadFileJob](~~206069~~) operation to the attachment key from the value of the AttachmentKey parameter.
        self.attachment_name = attachment_name
        # The reason for the data import.
        self.classify = classify
        # The type of the CSV file. Valid values:
        # 
        # *   **true**: The first row in the CSV file contains field names.
        # *   **false**: The first row in the CSV file contains data.
        # 
        # >  This parameter is required if you set the **FileType** parameter to **CSV**.
        self.csv_first_row_is_column_def = csv_first_row_is_column_def
        # The database to which you want to import data. You can specify only one database.
        self.db_item_list = db_item_list
        # The encoding algorithm to be used by the destination database. Valid values:
        # 
        # *   **AUTO**: automatic identification
        # *   **UTF-8**: UTF-8 encoding
        # *   **GBK**: GBK encoding
        # *   **ISO-8859-1**: ISO-8859-1 encoding
        self.file_encoding = file_encoding
        # The format of the file for the data import. Valid values:
        # 
        # *   **SQL**: an SQL file
        # *   **CSV**: a CSV file
        self.file_type = file_type
        # Specifies whether to skip an error that occurs. Valid values:
        # 
        # *   **true**: skips the error and continues to execute SQL statements.
        # *   **false**: stops executing SQL statements.
        self.ignore_error = ignore_error
        # The import mode. Valid values:
        # 
        # *   **FAST_MODE**: In the Execute step, the uploaded file is read and SQL statements are executed to import data to the specified destination database. Compared with the security mode, this mode can be used to import data in a less secure but more efficient manner.
        # *   **SAFE_MODE**: In the Precheck step, the uploaded file is parsed, and SQL statements or CSV file data is cached. In the Execute step, the cached SQL statements are read and executed to import data, or the cached CSV file data is read and imported to the specified destination database. This mode can be used to import data in a more secure but less efficient manner.
        self.import_mode = import_mode
        # The mode in which the data in the CSV format is to be written to the destination table. Valid values:
        # 
        # *   **INSERT**: The database checks the primary key when data is written. If a duplicate primary key value exists, an error message is returned.
        # *   **INSERT_IGNORE**: If the imported data contains data records that are the same as those in the destination table, the new data records are ignored.
        # *   **REPLACE_INTO**: If the imported data contains a row that has the same value for the primary key or unique index as one row in the destination table, the database deletes the existing row and inserts the new row into the destination table.
        # 
        # >  This parameter is required if you set the **FileType** parameter to **CSV**.
        self.insert_type = insert_type
        # The key of the attachment that contains the SQL statements used to roll back the data import. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        # 
        # >  This parameter is required if you set the **RollbackSqlType** parameter to **ATTACHMENT**.
        self.rollback_attachment_name = rollback_attachment_name
        # The SQL statements used to roll back the data import.
        # 
        # >  This parameter is required if you set the **RollbackSqlType** parameter to **TEXT**.
        self.rollback_sql = rollback_sql
        # The format of the SQL statements used to roll back the data import. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment
        self.rollback_sql_type = rollback_sql_type
        # The destination table to which you want to import the data in the CSV format.
        # 
        # >  This parameter is required if you set the **FileType** parameter to **CSV**.
        self.table_name = table_name

    def validate(self):
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_name is not None:
            result['AttachmentName'] = self.attachment_name
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.csv_first_row_is_column_def is not None:
            result['CsvFirstRowIsColumnDef'] = self.csv_first_row_is_column_def
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.file_encoding is not None:
            result['FileEncoding'] = self.file_encoding
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.ignore_error is not None:
            result['IgnoreError'] = self.ignore_error
        if self.import_mode is not None:
            result['ImportMode'] = self.import_mode
        if self.insert_type is not None:
            result['InsertType'] = self.insert_type
        if self.rollback_attachment_name is not None:
            result['RollbackAttachmentName'] = self.rollback_attachment_name
        if self.rollback_sql is not None:
            result['RollbackSQL'] = self.rollback_sql
        if self.rollback_sql_type is not None:
            result['RollbackSqlType'] = self.rollback_sql_type
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentName') is not None:
            self.attachment_name = m.get('AttachmentName')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('CsvFirstRowIsColumnDef') is not None:
            self.csv_first_row_is_column_def = m.get('CsvFirstRowIsColumnDef')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateDataImportOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('FileEncoding') is not None:
            self.file_encoding = m.get('FileEncoding')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('IgnoreError') is not None:
            self.ignore_error = m.get('IgnoreError')
        if m.get('ImportMode') is not None:
            self.import_mode = m.get('ImportMode')
        if m.get('InsertType') is not None:
            self.insert_type = m.get('InsertType')
        if m.get('RollbackAttachmentName') is not None:
            self.rollback_attachment_name = m.get('RollbackAttachmentName')
        if m.get('RollbackSQL') is not None:
            self.rollback_sql = m.get('RollbackSQL')
        if m.get('RollbackSqlType') is not None:
            self.rollback_sql_type = m.get('RollbackSqlType')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class CreateDataImportOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param: CreateDataImportOrderRequestParam = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key
        # The purpose or objective of the data import. This parameter is used to help reduce unnecessary communication.
        self.comment = comment
        # The parameters of the ticket.
        self.param = param
        # The stakeholders of the data import. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateDataImportOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataImportOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param_shrink: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key
        # The purpose or objective of the data import. This parameter is used to help reduce unnecessary communication.
        self.comment = comment
        # The parameters of the ticket.
        self.param_shrink = param_shrink
        # The stakeholders of the data import. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateDataImportOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the ticket.
        self.create_order_result = create_order_result
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataImportOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataImportOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataImportOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFreeLockCorrectOrderRequestParamDbItemList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
    ):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To obtain the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
        # *   To obtain the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
        self.db_id = db_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class CreateFreeLockCorrectOrderRequestParam(TeaModel):
    def __init__(
        self,
        attachment_name: str = None,
        classify: str = None,
        db_item_list: List[CreateFreeLockCorrectOrderRequestParamDbItemList] = None,
        exec_mode: str = None,
        exec_sql: str = None,
        rollback_attachment_name: str = None,
        rollback_sql: str = None,
        rollback_sql_type: str = None,
        sql_type: str = None,
    ):
        # The key of the attachment that contains the SQL statements used to change data. This parameter is not supported.
        self.attachment_name = attachment_name
        # The reason for the data change.
        self.classify = classify
        # The databases in which you want to change data.
        self.db_item_list = db_item_list
        # The execution mode of the ticket after the ticket is approved. Valid values:
        # 
        # *   **COMMITOR**: The data change is performed by the user who submits the ticket.
        # *   **AUTO**: The data change is automatically performed after the ticket is approved.
        # *   **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
        self.exec_mode = exec_mode
        # The SQL statements that you want to execute to change data.
        self.exec_sql = exec_sql
        # The key of the attachment that contains the SQL statements used to roll back the data change.
        self.rollback_attachment_name = rollback_attachment_name
        # The SQL statements used to roll back the data change.
        self.rollback_sql = rollback_sql
        # The format of the SQL statements used to roll back the data change. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment. This value is not supported.
        self.rollback_sql_type = rollback_sql_type
        # The format of the SQL statements used to change data. Valid values:
        # 
        # *   **TEXT**: text
        # *   **ATTACHMENT**: attachment. This value is not supported.
        self.sql_type = sql_type

    def validate(self):
        if self.db_item_list:
            for k in self.db_item_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_name is not None:
            result['AttachmentName'] = self.attachment_name
        if self.classify is not None:
            result['Classify'] = self.classify
        result['DbItemList'] = []
        if self.db_item_list is not None:
            for k in self.db_item_list:
                result['DbItemList'].append(k.to_map() if k else None)
        if self.exec_mode is not None:
            result['ExecMode'] = self.exec_mode
        if self.exec_sql is not None:
            result['ExecSQL'] = self.exec_sql
        if self.rollback_attachment_name is not None:
            result['RollbackAttachmentName'] = self.rollback_attachment_name
        if self.rollback_sql is not None:
            result['RollbackSQL'] = self.rollback_sql
        if self.rollback_sql_type is not None:
            result['RollbackSqlType'] = self.rollback_sql_type
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentName') is not None:
            self.attachment_name = m.get('AttachmentName')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        self.db_item_list = []
        if m.get('DbItemList') is not None:
            for k in m.get('DbItemList'):
                temp_model = CreateFreeLockCorrectOrderRequestParamDbItemList()
                self.db_item_list.append(temp_model.from_map(k))
        if m.get('ExecMode') is not None:
            self.exec_mode = m.get('ExecMode')
        if m.get('ExecSQL') is not None:
            self.exec_sql = m.get('ExecSQL')
        if m.get('RollbackAttachmentName') is not None:
            self.rollback_attachment_name = m.get('RollbackAttachmentName')
        if m.get('RollbackSQL') is not None:
            self.rollback_sql = m.get('RollbackSQL')
        if m.get('RollbackSqlType') is not None:
            self.rollback_sql_type = m.get('RollbackSqlType')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        return self


class CreateFreeLockCorrectOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param: CreateFreeLockCorrectOrderRequestParam = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key
        # The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
        self.comment = comment
        # The parameters of the ticket.
        self.param = param
        # The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list = related_user_list
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateFreeLockCorrectOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateFreeLockCorrectOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param_shrink: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        # The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
        self.attachment_key = attachment_key
        # The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
        self.comment = comment
        # The parameters of the ticket.
        self.param_shrink = param_shrink
        # The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
        self.related_user_list_shrink = related_user_list_shrink
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateFreeLockCorrectOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the ticket.
        self.create_order_result = create_order_result
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateFreeLockCorrectOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFreeLockCorrectOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFreeLockCorrectOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLakeHouseSpaceRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        dev_db_id: str = None,
        dw_db_type: str = None,
        mode: str = None,
        prod_db_id: str = None,
        space_config: str = None,
        space_name: str = None,
        tid: int = None,
    ):
        # The description of the workspace.
        self.description = description
        # The ID of the development database. You can call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the ID.
        self.dev_db_id = dev_db_id
        # The type of the database. Valid values:
        # 
        # *   **14**: AnalyticDB for MySQL
        # *   **18**: AnalyticDB for PostgreSQL
        self.dw_db_type = dw_db_type
        # The mode in which the workspace runs. Valid values:
        # 
        # *   **0**: basic mode. This mode is unavailable.
        # *   **1**: standard mode.
        self.mode = mode
        # The ID of the production database. You can call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the ID.
        self.prod_db_id = prod_db_id
        # The configuration of the workspace. Valid values:
        # 
        # *   **skipManualRunCheck**: No security rule check is required in the trial run phase.
        # *   **skipPublishApprove**: No approval is required for publishing and O\&M.
        self.space_config = space_config
        # The name of the workspace.
        self.space_name = space_name
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_db_id is not None:
            result['DevDbId'] = self.dev_db_id
        if self.dw_db_type is not None:
            result['DwDbType'] = self.dw_db_type
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.prod_db_id is not None:
            result['ProdDbId'] = self.prod_db_id
        if self.space_config is not None:
            result['SpaceConfig'] = self.space_config
        if self.space_name is not None:
            result['SpaceName'] = self.space_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevDbId') is not None:
            self.dev_db_id = m.get('DevDbId')
        if m.get('DwDbType') is not None:
            self.dw_db_type = m.get('DwDbType')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('ProdDbId') is not None:
            self.prod_db_id = m.get('ProdDbId')
        if m.get('SpaceConfig') is not None:
            self.space_config = m.get('SpaceConfig')
        if m.get('SpaceName') is not None:
            self.space_name = m.get('SpaceName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateLakeHouseSpaceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        space_id: int = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The ID of the workspace.
        self.space_id = space_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateLakeHouseSpaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLakeHouseSpaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLakeHouseSpaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLogicDatabaseRequest(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_ids: List[int] = None,
        tid: int = None,
    ):
        # The alias of the logical database.
        self.alias = alias
        # The IDs of the physical databases that compose the logical database. You can specify one or more database IDs. You can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the physical databases.
        self.database_ids = database_ids
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseIds') is not None:
            self.database_ids = m.get('DatabaseIds')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateLogicDatabaseShrinkRequest(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_ids_shrink: str = None,
        tid: int = None,
    ):
        # The alias of the logical database.
        self.alias = alias
        # The IDs of the physical databases that compose the logical database. You can specify one or more database IDs. You can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the physical databases.
        self.database_ids_shrink = database_ids_shrink
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_ids_shrink is not None:
            result['DatabaseIds'] = self.database_ids_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseIds') is not None:
            self.database_ids_shrink = m.get('DatabaseIds')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateLogicDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        logic_db_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the logical database.
        self.logic_db_id = logic_db_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateLogicDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLogicDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLogicDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        plugin_param: Dict[str, Any] = None,
        plugin_type: str = None,
        related_user_list: str = None,
        tid: int = None,
    ):
        # The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
        self.attachment_key = attachment_key
        # The description of the ticket to be created.
        self.comment = comment
        # The ticket creation parameter. The value is a JSON string. The value of this parameter differs based on the type of the ticket. For more information, see the **PluginParam parameter** section in this topic.
        self.plugin_param = plugin_param
        # The type of the ticket. For more information, see [PluginType parameter](~~429109~~).
        self.plugin_type = plugin_type
        # The IDs of the stakeholders that are involved in the ticket. Separate multiple IDs with commas (,).
        self.related_user_list = related_user_list
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.plugin_param is not None:
            result['PluginParam'] = self.plugin_param
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('PluginParam') is not None:
            self.plugin_param = m.get('PluginParam')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        plugin_param_shrink: str = None,
        plugin_type: str = None,
        related_user_list: str = None,
        tid: int = None,
    ):
        # The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
        self.attachment_key = attachment_key
        # The description of the ticket to be created.
        self.comment = comment
        # The ticket creation parameter. The value is a JSON string. The value of this parameter differs based on the type of the ticket. For more information, see the **PluginParam parameter** section in this topic.
        self.plugin_param_shrink = plugin_param_shrink
        # The type of the ticket. For more information, see [PluginType parameter](~~429109~~).
        self.plugin_type = plugin_type
        # The IDs of the stakeholders that are involved in the ticket. Separate multiple IDs with commas (,).
        self.related_user_list = related_user_list
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.plugin_param_shrink is not None:
            result['PluginParam'] = self.plugin_param_shrink
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('PluginParam') is not None:
            self.plugin_param_shrink = m.get('PluginParam')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateOrderResponseBodyCreateOrderResult(TeaModel):
    def __init__(
        self,
        order_ids: List[int] = None,
    ):
        self.order_ids = order_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_ids is not None:
            result['OrderIds'] = self.order_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderIds') is not None:
            self.order_ids = m.get('OrderIds')
        return self


class CreateOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: CreateOrderResponseBodyCreateOrderResult = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the ticket.
        self.create_order_result = create_order_result
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.create_order_result:
            self.create_order_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            temp_model = CreateOrderResponseBodyCreateOrderResult()
            self.create_order_result = temp_model.from_map(m['CreateOrderResult'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProxyRequest(TeaModel):
    def __init__(
        self,
        instance_id: int = None,
        password: str = None,
        tid: int = None,
        username: str = None,
    ):
        # The ID of the database instance. You can call the [ListInstances](https://www.alibabacloud.com/help/en/data-management-service/latest/listinstances) or [GetInstance](https://www.alibabacloud.com/help/en/data-management-service/latest/getinstance) operation to query the database instance ID.
        self.instance_id = instance_id
        # The password of the database account.
        self.password = password
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid
        # The username of the database account.
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.password is not None:
            result['Password'] = self.password
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class CreateProxyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        proxy_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the secure access proxy.
        self.proxy_id = proxy_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateProxyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProxyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProxyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProxyAccessRequest(TeaModel):
    def __init__(
        self,
        indep_account: str = None,
        indep_password: str = None,
        proxy_id: int = None,
        tid: int = None,
        user_id: int = None,
    ):
        # The database account.
        self.indep_account = indep_account
        # The password that is used to log on to the database.
        self.indep_password = indep_password
        # The ID of the security protection agent. You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) or [GetProxy](https://www.alibabacloud.com/help/en/data-management-service/latest/getproxy) operation to obtain this parameter.
        self.proxy_id = proxy_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
        self.tid = tid
        # The ID of the user. You can call the [ListUsers](https://www.alibabacloud.com/help/en/data-management-service/latest/listusers) or [GetUser](https://www.alibabacloud.com/help/en/data-management-service/latest/getuser) operation to obtain this parameter.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.indep_account is not None:
            result['IndepAccount'] = self.indep_account
        if self.indep_password is not None:
            result['IndepPassword'] = self.indep_password
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndepAccount') is not None:
            self.indep_account = m.get('IndepAccount')
        if m.get('IndepPassword') is not None:
            self.indep_password = m.get('IndepPassword')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CreateProxyAccessResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        proxy_access_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned to the query task.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique.
        self.proxy_access_id = proxy_access_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateProxyAccessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProxyAccessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProxyAccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePublishGroupTaskRequest(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
        order_id: int = None,
        plan_time: str = None,
        publish_strategy: str = None,
        tid: int = None,
    ):
        self.db_id = db_id
        self.logic = logic
        self.order_id = order_id
        self.plan_time = plan_time
        self.publish_strategy = publish_strategy
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.plan_time is not None:
            result['PlanTime'] = self.plan_time
        if self.publish_strategy is not None:
            result['PublishStrategy'] = self.publish_strategy
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PlanTime') is not None:
            self.plan_time = m.get('PlanTime')
        if m.get('PublishStrategy') is not None:
            self.publish_strategy = m.get('PublishStrategy')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreatePublishGroupTaskResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        task_id: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CreatePublishGroupTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePublishGroupTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePublishGroupTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSQLReviewOrderRequestParam(TeaModel):
    def __init__(
        self,
        attachment_key_list: List[str] = None,
        db_id: int = None,
        project_name: str = None,
    ):
        self.attachment_key_list = attachment_key_list
        self.db_id = db_id
        self.project_name = project_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key_list is not None:
            result['AttachmentKeyList'] = self.attachment_key_list
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.project_name is not None:
            result['ProjectName'] = self.project_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKeyList') is not None:
            self.attachment_key_list = m.get('AttachmentKeyList')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('ProjectName') is not None:
            self.project_name = m.get('ProjectName')
        return self


class CreateSQLReviewOrderRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        param: CreateSQLReviewOrderRequestParam = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        self.comment = comment
        self.param = param
        self.related_user_list = related_user_list
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateSQLReviewOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateSQLReviewOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        comment: str = None,
        param_shrink: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        self.comment = comment
        self.param_shrink = param_shrink
        self.related_user_list_shrink = related_user_list_shrink
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateSQLReviewOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.create_order_result = create_order_result
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSQLReviewOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSQLReviewOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSQLReviewOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateScenarioRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        scenario_name: str = None,
        tid: int = None,
    ):
        # The description of the business scenario.
        self.description = description
        # The name of the business scenario.
        self.scenario_name = scenario_name
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.scenario_name is not None:
            result['ScenarioName'] = self.scenario_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ScenarioName') is not None:
            self.scenario_name = m.get('ScenarioName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateScenarioResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        scenario_id: int = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The ID of the business scenario.
        self.scenario_id = scenario_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateStandardGroupRequest(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        description: str = None,
        group_name: str = None,
        tid: int = None,
    ):
        # The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type
        # The description of the security rule set.
        self.description = description
        # The name of the security rule set.
        self.group_name = group_name
        # The ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateStandardGroupResponseBodyStandardGroup(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        description: str = None,
        group_mode: str = None,
        group_name: str = None,
        last_mender_id: int = None,
    ):
        # The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type
        # The description of the security rule set.
        self.description = description
        # The control mode. Valid values:
        # 
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        # *   **COMMON**: Security Collaboration
        self.group_mode = group_mode
        # The name of the security rule set.
        self.group_name = group_name
        # The ID of the user who creates the security rule set.
        self.last_mender_id = last_mender_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.last_mender_id is not None:
            result['LastMenderId'] = self.last_mender_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LastMenderId') is not None:
            self.last_mender_id = m.get('LastMenderId')
        return self


class CreateStandardGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        standard_group: CreateStandardGroupResponseBodyStandardGroup = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The created security rule set.
        self.standard_group = standard_group
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StandardGroup') is not None:
            temp_model = CreateStandardGroupResponseBodyStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateStandardGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateStandardGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateStandardGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateStructSyncOrderRequestParamSource(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_search_name: str = None,
        logic: bool = None,
        version_id: str = None,
    ):
        self.db_id = db_id
        self.db_search_name = db_search_name
        self.logic = logic
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_search_name is not None:
            result['DbSearchName'] = self.db_search_name
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbSearchName') is not None:
            self.db_search_name = m.get('DbSearchName')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class CreateStructSyncOrderRequestParamTableInfoList(TeaModel):
    def __init__(
        self,
        source_table_name: str = None,
        target_table_name: str = None,
    ):
        self.source_table_name = source_table_name
        self.target_table_name = target_table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        if self.target_table_name is not None:
            result['TargetTableName'] = self.target_table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        if m.get('TargetTableName') is not None:
            self.target_table_name = m.get('TargetTableName')
        return self


class CreateStructSyncOrderRequestParamTarget(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_search_name: str = None,
        logic: bool = None,
        version_id: str = None,
    ):
        self.db_id = db_id
        self.db_search_name = db_search_name
        self.logic = logic
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_search_name is not None:
            result['DbSearchName'] = self.db_search_name
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbSearchName') is not None:
            self.db_search_name = m.get('DbSearchName')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class CreateStructSyncOrderRequestParam(TeaModel):
    def __init__(
        self,
        ignore_error: bool = None,
        source: CreateStructSyncOrderRequestParamSource = None,
        table_info_list: List[CreateStructSyncOrderRequestParamTableInfoList] = None,
        target: CreateStructSyncOrderRequestParamTarget = None,
    ):
        self.ignore_error = ignore_error
        self.source = source
        self.table_info_list = table_info_list
        self.target = target

    def validate(self):
        if self.source:
            self.source.validate()
        if self.table_info_list:
            for k in self.table_info_list:
                if k:
                    k.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_error is not None:
            result['IgnoreError'] = self.ignore_error
        if self.source is not None:
            result['Source'] = self.source.to_map()
        result['TableInfoList'] = []
        if self.table_info_list is not None:
            for k in self.table_info_list:
                result['TableInfoList'].append(k.to_map() if k else None)
        if self.target is not None:
            result['Target'] = self.target.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IgnoreError') is not None:
            self.ignore_error = m.get('IgnoreError')
        if m.get('Source') is not None:
            temp_model = CreateStructSyncOrderRequestParamSource()
            self.source = temp_model.from_map(m['Source'])
        self.table_info_list = []
        if m.get('TableInfoList') is not None:
            for k in m.get('TableInfoList'):
                temp_model = CreateStructSyncOrderRequestParamTableInfoList()
                self.table_info_list.append(temp_model.from_map(k))
        if m.get('Target') is not None:
            temp_model = CreateStructSyncOrderRequestParamTarget()
            self.target = temp_model.from_map(m['Target'])
        return self


class CreateStructSyncOrderRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param: CreateStructSyncOrderRequestParam = None,
        related_user_list: List[int] = None,
        tid: int = None,
    ):
        self.attachment_key = attachment_key
        self.comment = comment
        self.param = param
        self.related_user_list = related_user_list
        self.tid = tid

    def validate(self):
        if self.param:
            self.param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param is not None:
            result['Param'] = self.param.to_map()
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            temp_model = CreateStructSyncOrderRequestParam()
            self.param = temp_model.from_map(m['Param'])
        if m.get('RelatedUserList') is not None:
            self.related_user_list = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateStructSyncOrderShrinkRequest(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        comment: str = None,
        param_shrink: str = None,
        related_user_list_shrink: str = None,
        tid: int = None,
    ):
        self.attachment_key = attachment_key
        self.comment = comment
        self.param_shrink = param_shrink
        self.related_user_list_shrink = related_user_list_shrink
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.param_shrink is not None:
            result['Param'] = self.param_shrink
        if self.related_user_list_shrink is not None:
            result['RelatedUserList'] = self.related_user_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Param') is not None:
            self.param_shrink = m.get('Param')
        if m.get('RelatedUserList') is not None:
            self.related_user_list_shrink = m.get('RelatedUserList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateStructSyncOrderResponseBody(TeaModel):
    def __init__(
        self,
        create_order_result: List[int] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.create_order_result = create_order_result
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_order_result is not None:
            result['CreateOrderResult'] = self.create_order_result
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateOrderResult') is not None:
            self.create_order_result = m.get('CreateOrderResult')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateStructSyncOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateStructSyncOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateStructSyncOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTaskRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        graph_param: str = None,
        node_content: str = None,
        node_name: str = None,
        node_output: str = None,
        node_type: str = None,
        tid: int = None,
        time_variables: str = None,
    ):
        self.dag_id = dag_id
        self.graph_param = graph_param
        self.node_content = node_content
        self.node_name = node_name
        self.node_output = node_output
        self.node_type = node_type
        self.tid = tid
        self.time_variables = time_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.graph_param is not None:
            result['GraphParam'] = self.graph_param
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_output is not None:
            result['NodeOutput'] = self.node_output
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('GraphParam') is not None:
            self.graph_param = m.get('GraphParam')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeOutput') is not None:
            self.node_output = m.get('NodeOutput')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class CreateTaskResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        node_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.node_id = node_id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTaskFlowRequest(TeaModel):
    def __init__(
        self,
        dag_name: str = None,
        description: str = None,
        scenario_id: int = None,
        tid: int = None,
    ):
        # The name of the task flow.
        self.dag_name = dag_name
        # The description of the task flow.
        self.description = description
        # The ID of the scenario.
        self.scenario_id = scenario_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.description is not None:
            result['Description'] = self.description
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class CreateTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the task flow.
        self.dag_id = dag_id
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUploadFileJobRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        file_source: str = None,
        tid: int = None,
        upload_url: str = None,
    ):
        # The name of the attachment file.
        # 
        # >  The file name must end with .txt or .sql. For example, the file name can be test.txt or test.sql.
        self.file_name = file_name
        # The purpose of the attachment file. Valid values:
        # 
        # *   **datacorrect**: The file is uploaded to change data.
        # *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
        # *   **big-file**: The file is uploaded to import multiple data records at a time.
        # *   **sqlreview**: The file is uploaded for SQL review.
        self.file_source = file_source
        # The ID of the tenant.
        # 
        # >  You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid
        # The URL of the attachment file. The URL must be an HTTP URL or an HTTPS URL.
        # 
        # >  You can upload the attachment file to an Object Storage Service (OSS) bucket and obtain the URL of the file in the OSS console. For more information, see [Share objects](~~195674~~).
        self.upload_url = upload_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_source is not None:
            result['FileSource'] = self.file_source
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.upload_url is not None:
            result['UploadURL'] = self.upload_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSource') is not None:
            self.file_source = m.get('FileSource')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UploadURL') is not None:
            self.upload_url = m.get('UploadURL')
        return self


class CreateUploadFileJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        job_key: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The key of the task.
        # 
        # >  You can call the [GetUserUploadFileJob](~~206069~~) operation to query the progress and details of the task.
        self.job_key = job_key
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_key is not None:
            result['JobKey'] = self.job_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobKey') is not None:
            self.job_key = m.get('JobKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateUploadFileJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUploadFileJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUploadFileJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUploadOSSFileJobRequestUploadTarget(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        endpoint: str = None,
        object_name: str = None,
    ):
        self.bucket_name = bucket_name
        self.endpoint = endpoint
        self.object_name = object_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.object_name is not None:
            result['ObjectName'] = self.object_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('ObjectName') is not None:
            self.object_name = m.get('ObjectName')
        return self


class CreateUploadOSSFileJobRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        file_source: str = None,
        tid: int = None,
        upload_target: CreateUploadOSSFileJobRequestUploadTarget = None,
    ):
        self.file_name = file_name
        self.file_source = file_source
        self.tid = tid
        self.upload_target = upload_target

    def validate(self):
        if self.upload_target:
            self.upload_target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_source is not None:
            result['FileSource'] = self.file_source
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.upload_target is not None:
            result['UploadTarget'] = self.upload_target.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSource') is not None:
            self.file_source = m.get('FileSource')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UploadTarget') is not None:
            temp_model = CreateUploadOSSFileJobRequestUploadTarget()
            self.upload_target = temp_model.from_map(m['UploadTarget'])
        return self


class CreateUploadOSSFileJobShrinkRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        file_source: str = None,
        tid: int = None,
        upload_target_shrink: str = None,
    ):
        self.file_name = file_name
        self.file_source = file_source
        self.tid = tid
        self.upload_target_shrink = upload_target_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_source is not None:
            result['FileSource'] = self.file_source
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.upload_target_shrink is not None:
            result['UploadTarget'] = self.upload_target_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSource') is not None:
            self.file_source = m.get('FileSource')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UploadTarget') is not None:
            self.upload_target_shrink = m.get('UploadTarget')
        return self


class CreateUploadOSSFileJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        job_key: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.job_key = job_key
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_key is not None:
            result['JobKey'] = self.job_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobKey') is not None:
            self.job_key = m.get('JobKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateUploadOSSFileJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUploadOSSFileJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUploadOSSFileJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInstanceRequest(TeaModel):
    def __init__(
        self,
        host: str = None,
        port: int = None,
        sid: str = None,
        tid: int = None,
    ):
        # The endpoint of the database instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to obtain the endpoint.
        self.host = host
        # The port number that is used to connect to the database instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to obtain the port number.
        self.port = port
        # The system ID (SID) of the database instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to obtain the SID.
        self.sid = sid
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLakeHouseSpaceRequest(TeaModel):
    def __init__(
        self,
        space_id: int = None,
        tid: int = None,
    ):
        # The ID of the workspace. You can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
        self.space_id = space_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLakeHouseSpaceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   true: The request is successful.
        # *   false: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLakeHouseSpaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLakeHouseSpaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLakeHouseSpaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLhMembersRequest(TeaModel):
    def __init__(
        self,
        member_ids: List[int] = None,
        object_id: int = None,
        object_type: int = None,
        tid: int = None,
    ):
        # The ID of the user to be removed. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
        self.member_ids = member_ids
        # The ID of the object.
        # 
        # *   If the object is a workspace, you can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
        # *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
        self.object_id = object_id
        # The type of the object. Valid values:
        # 
        # *   **0**: workspace
        # *   **1**: task flow
        self.object_type = object_type
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_ids is not None:
            result['MemberIds'] = self.member_ids
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberIds') is not None:
            self.member_ids = m.get('MemberIds')
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLhMembersShrinkRequest(TeaModel):
    def __init__(
        self,
        member_ids_shrink: str = None,
        object_id: int = None,
        object_type: int = None,
        tid: int = None,
    ):
        # The ID of the user to be removed. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
        self.member_ids_shrink = member_ids_shrink
        # The ID of the object.
        # 
        # *   If the object is a workspace, you can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
        # *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
        self.object_id = object_id
        # The type of the object. Valid values:
        # 
        # *   **0**: workspace
        # *   **1**: task flow
        self.object_type = object_type
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_ids_shrink is not None:
            result['MemberIds'] = self.member_ids_shrink
        if self.object_id is not None:
            result['ObjectId'] = self.object_id
        if self.object_type is not None:
            result['ObjectType'] = self.object_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MemberIds') is not None:
            self.member_ids_shrink = m.get('MemberIds')
        if m.get('ObjectId') is not None:
            self.object_id = m.get('ObjectId')
        if m.get('ObjectType') is not None:
            self.object_type = m.get('ObjectType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLhMembersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLhMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLhMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLhMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLogicDatabaseRequest(TeaModel):
    def __init__(
        self,
        logic_db_id: int = None,
        tid: int = None,
    ):
        # The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the ID of the logical database.
        self.logic_db_id = logic_db_id
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLogicDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLogicDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLogicDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLogicDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLogicTableRouteConfigRequest(TeaModel):
    def __init__(
        self,
        route_key: str = None,
        table_id: int = None,
        tid: int = None,
    ):
        # The unique key of the routing algorithm. You can call the [ListLogicTableRouteConfig](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictablerouteconfig) operation to query the unique key.
        self.route_key = route_key
        # The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
        self.table_id = table_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_key is not None:
            result['RouteKey'] = self.route_key
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RouteKey') is not None:
            self.route_key = m.get('RouteKey')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteLogicTableRouteConfigResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLogicTableRouteConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteLogicTableRouteConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLogicTableRouteConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProxyRequest(TeaModel):
    def __init__(
        self,
        proxy_id: int = None,
        tid: int = None,
    ):
        # The ID of the security protection agent. You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) or [GetProxy](https://www.alibabacloud.com/help/en/data-management-service/latest/getproxy) operation to obtain this parameter.
        self.proxy_id = proxy_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteProxyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned to the query task.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteProxyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProxyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProxyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProxyAccessRequest(TeaModel):
    def __init__(
        self,
        proxy_access_id: int = None,
        tid: int = None,
    ):
        # The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique. You can call the [ListProxyAccesses](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxyaccesses) operation to obtain this parameter.
        self.proxy_access_id = proxy_access_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteProxyAccessResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned to the query task.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteProxyAccessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProxyAccessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProxyAccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteScenarioRequest(TeaModel):
    def __init__(
        self,
        scenario_id: int = None,
        tid: int = None,
    ):
        # The ID of the business scenario.
        self.scenario_id = scenario_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteScenarioResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTaskRequest(TeaModel):
    def __init__(
        self,
        node_id: str = None,
        tid: int = None,
    ):
        # The ID of the node you want to delete.
        self.node_id = node_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteTaskResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTaskFlowRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
        self.dag_id = dag_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTaskFlowEdgesByConditionRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        id: int = None,
        node_end: int = None,
        node_from: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The ID of the task flow edge to delete.
        self.id = id
        # The ID of the end node of the edge to delete.
        self.node_end = node_end
        # The ID of the start node on the edge to delete.
        self.node_from = node_from
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class DeleteTaskFlowEdgesByConditionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTaskFlowEdgesByConditionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTaskFlowEdgesByConditionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTaskFlowEdgesByConditionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUserRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
        uid: str = None,
    ):
        self.tid = tid
        self.uid = uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        return self


class DeleteUserResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableUserRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
        uid: str = None,
    ):
        self.tid = tid
        self.uid = uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        return self


class DisableUserResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DisableUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EditLogicDatabaseRequest(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_ids: List[int] = None,
        logic_db_id: int = None,
        tid: int = None,
    ):
        # - The alias of the logical database. If you want to change the alias, specify a new alias.
        # - If you do not need to change the alias of the logical database, call the [GetLogicDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/getlogicdatabase) or [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the alias of the logical database.
        self.alias = alias
        # - The IDs of the physical databases that compose the logical database. If you want to change the physical databases, you can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the new physical databases that you want to specify.
        # - If you do not want to change the physical databases, you can call the [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the IDs of the physical databases that compose the logical database.
        self.database_ids = database_ids
        # The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) operation to query the ID of the logical database.
        self.logic_db_id = logic_db_id
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseIds') is not None:
            self.database_ids = m.get('DatabaseIds')
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class EditLogicDatabaseShrinkRequest(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_ids_shrink: str = None,
        logic_db_id: int = None,
        tid: int = None,
    ):
        # - The alias of the logical database. If you want to change the alias, specify a new alias.
        # - If you do not need to change the alias of the logical database, call the [GetLogicDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/getlogicdatabase) or [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the alias of the logical database.
        self.alias = alias
        # - The IDs of the physical databases that compose the logical database. If you want to change the physical databases, you can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the new physical databases that you want to specify.
        # - If you do not want to change the physical databases, you can call the [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the IDs of the physical databases that compose the logical database.
        self.database_ids_shrink = database_ids_shrink
        # The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) operation to query the ID of the logical database.
        self.logic_db_id = logic_db_id
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_ids_shrink is not None:
            result['DatabaseIds'] = self.database_ids_shrink
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseIds') is not None:
            self.database_ids_shrink = m.get('DatabaseIds')
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class EditLogicDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EditLogicDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EditLogicDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EditLogicDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableUserRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
        uid: str = None,
    ):
        self.tid = tid
        self.uid = uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        return self


class EnableUserResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteDataCorrectRequest(TeaModel):
    def __init__(
        self,
        action_detail: Dict[str, Any] = None,
        order_id: int = None,
        tid: str = None,
    ):
        # The parameters that are required to perform the data change.
        # 
        # ```
        # 
        # json
        # "actionDetail" : {
        #     "startTime" :"2021-07-01 00:00:00", // Specify the start time to change data. If you want to immediately change data, you do not need to set this parameter. 
        #     "endTime" : "2021-07-01 01:00:00", // Specify the end time to change data. If you want to immediately change data, you do not need to set this parameter. 
        #     "transaction" : false, // Specify whether to change data as a transaction. 
        #     "backupData" : true // Specify whether to back up data. 
        #   }
        # ```
        self.action_detail = action_detail
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the ticket.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail is not None:
            result['ActionDetail'] = self.action_detail
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteDataCorrectShrinkRequest(TeaModel):
    def __init__(
        self,
        action_detail_shrink: str = None,
        order_id: int = None,
        tid: str = None,
    ):
        # The parameters that are required to perform the data change.
        # 
        # ```
        # 
        # json
        # "actionDetail" : {
        #     "startTime" :"2021-07-01 00:00:00", // Specify the start time to change data. If you want to immediately change data, you do not need to set this parameter. 
        #     "endTime" : "2021-07-01 01:00:00", // Specify the end time to change data. If you want to immediately change data, you do not need to set this parameter. 
        #     "transaction" : false, // Specify whether to change data as a transaction. 
        #     "backupData" : true // Specify whether to back up data. 
        #   }
        # ```
        self.action_detail_shrink = action_detail_shrink
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the ticket.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail_shrink is not None:
            result['ActionDetail'] = self.action_detail_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail_shrink = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteDataCorrectResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteDataCorrectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteDataCorrectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteDataCorrectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteDataExportRequest(TeaModel):
    def __init__(
        self,
        action_detail: Dict[str, Any] = None,
        order_id: int = None,
        tid: int = None,
    ):
        self.action_detail = action_detail
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail is not None:
            result['ActionDetail'] = self.action_detail
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteDataExportShrinkRequest(TeaModel):
    def __init__(
        self,
        action_detail_shrink: str = None,
        order_id: int = None,
        tid: int = None,
    ):
        self.action_detail_shrink = action_detail_shrink
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail_shrink is not None:
            result['ActionDetail'] = self.action_detail_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail_shrink = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteDataExportResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteDataExportResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteDataExportResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteDataExportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteScriptRequest(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
        script: str = None,
        tid: int = None,
    ):
        # The ID of the database.
        # 
        # >  This parameter is equivalent to the DatabaseId parameter in the SearchDatabase, ListDatabases, and GetDatabase operations. You can call one of these operations to obtain the required database ID. For more information, see [SearchDatabase](~~141876~~), [ListDatabases](~~141873~~), and [GetDatabase](~~141869~~).
        self.db_id = db_id
        # Specifies whether the database is a logical database.
        self.logic = logic
        # The SQL statements to be executed. Data query language (DQL) statements, data definition language (DDL) statements, and data manipulation language (DML) statements are supported. The control mode of the instance that you want to query determines whether you can execute DDL and DML statements.
        self.script = script
        # The ID of the tenant.
        # 
        # >  To obtain the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Tenant information](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.script is not None:
            result['Script'] = self.script
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Script') is not None:
            self.script = m.get('Script')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteScriptResponseBodyResults(TeaModel):
    def __init__(
        self,
        column_names: List[str] = None,
        message: str = None,
        row_count: int = None,
        rows: List[Dict[str, Any]] = None,
        success: bool = None,
    ):
        # The fields that are queried after the SQL statement is executed.
        self.column_names = column_names
        # The error message that is returned if the SQL statement fails to be executed. For example, an error message is returned because the SQL statement is invalid.
        self.message = message
        # The total number of entries that are returned.
        self.row_count = row_count
        # The rows that are queried after the SQL statement is executed.
        self.rows = rows
        # Indicates whether the SQL statement is executed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_names is not None:
            result['ColumnNames'] = self.column_names
        if self.message is not None:
            result['Message'] = self.message
        if self.row_count is not None:
            result['RowCount'] = self.row_count
        if self.rows is not None:
            result['Rows'] = self.rows
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnNames') is not None:
            self.column_names = m.get('ColumnNames')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RowCount') is not None:
            self.row_count = m.get('RowCount')
        if m.get('Rows') is not None:
            self.rows = m.get('Rows')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteScriptResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        results: List[ExecuteScriptResponseBodyResults] = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message about the gateway.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The results of the SQL statements that are executed, in the format of an array. Each entry in the array indicates the result of an SQL statement.
        self.results = results
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.results:
            for k in self.results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Results'] = []
        if self.results is not None:
            for k in self.results:
                result['Results'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.results = []
        if m.get('Results') is not None:
            for k in m.get('Results'):
                temp_model = ExecuteScriptResponseBodyResults()
                self.results.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteScriptResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteScriptResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteScriptResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteStructSyncRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ExecuteStructSyncResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExecuteStructSyncResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteStructSyncResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteStructSyncResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetApprovalDetailRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
        workflow_instance_id: int = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid
        # The ID of the approval process. You can call the [GetOrderBaseInfo](~~144642~~) operation to query the ID of the approval process.
        self.workflow_instance_id = workflow_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler(TeaModel):
    def __init__(
        self,
        id: int = None,
        nick_name: str = None,
    ):
        # The ID of the user.
        self.id = id
        # The nickname of the user.
        self.nick_name = nick_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        return self


class GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers(TeaModel):
    def __init__(
        self,
        current_handler: List[GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler] = None,
    ):
        self.current_handler = current_handler

    def validate(self):
        if self.current_handler:
            for k in self.current_handler:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CurrentHandler'] = []
        if self.current_handler is not None:
            for k in self.current_handler:
                result['CurrentHandler'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.current_handler = []
        if m.get('CurrentHandler') is not None:
            for k in m.get('CurrentHandler'):
                temp_model = GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler()
                self.current_handler.append(temp_model.from_map(k))
        return self


class GetApprovalDetailResponseBodyApprovalDetailReasonList(TeaModel):
    def __init__(
        self,
        reasons: List[str] = None,
    ):
        self.reasons = reasons

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reasons is not None:
            result['Reasons'] = self.reasons
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Reasons') is not None:
            self.reasons = m.get('Reasons')
        return self


class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList(TeaModel):
    def __init__(
        self,
        audit_user_ids: List[str] = None,
    ):
        self.audit_user_ids = audit_user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_user_ids is not None:
            result['AuditUserIds'] = self.audit_user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditUserIds') is not None:
            self.audit_user_ids = m.get('AuditUserIds')
        return self


class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode(TeaModel):
    def __init__(
        self,
        audit_user_id_list: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList = None,
        node_name: str = None,
        operate_comment: str = None,
        operate_time: str = None,
        operator_id: int = None,
        workflow_ins_code: str = None,
    ):
        # The IDs of the approvers.
        self.audit_user_id_list = audit_user_id_list
        # The name of the approval node.
        self.node_name = node_name
        # The remarks of the approval.
        self.operate_comment = operate_comment
        # The time when the ticket was submitted.
        self.operate_time = operate_time
        # The ID of the user who submitted the ticket.
        self.operator_id = operator_id
        # The approval status of the ticket. Valid values:
        # 
        # *   **AUDITING**: The ticket is being processed.
        # *   **REJECT**: The ticket was rejected.
        # *   **CANCEL**: The ticket was revoked.
        # *   **APPROVED**: The ticket was approved.
        self.workflow_ins_code = workflow_ins_code

    def validate(self):
        if self.audit_user_id_list:
            self.audit_user_id_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_user_id_list is not None:
            result['AuditUserIdList'] = self.audit_user_id_list.to_map()
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.operate_comment is not None:
            result['OperateComment'] = self.operate_comment
        if self.operate_time is not None:
            result['OperateTime'] = self.operate_time
        if self.operator_id is not None:
            result['OperatorId'] = self.operator_id
        if self.workflow_ins_code is not None:
            result['WorkflowInsCode'] = self.workflow_ins_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditUserIdList') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList()
            self.audit_user_id_list = temp_model.from_map(m['AuditUserIdList'])
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('OperateComment') is not None:
            self.operate_comment = m.get('OperateComment')
        if m.get('OperateTime') is not None:
            self.operate_time = m.get('OperateTime')
        if m.get('OperatorId') is not None:
            self.operator_id = m.get('OperatorId')
        if m.get('WorkflowInsCode') is not None:
            self.workflow_ins_code = m.get('WorkflowInsCode')
        return self


class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes(TeaModel):
    def __init__(
        self,
        workflow_node: List[GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode] = None,
    ):
        self.workflow_node = workflow_node

    def validate(self):
        if self.workflow_node:
            for k in self.workflow_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkflowNode'] = []
        if self.workflow_node is not None:
            for k in self.workflow_node:
                result['WorkflowNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.workflow_node = []
        if m.get('WorkflowNode') is not None:
            for k in m.get('WorkflowNode'):
                temp_model = GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode()
                self.workflow_node.append(temp_model.from_map(k))
        return self


class GetApprovalDetailResponseBodyApprovalDetail(TeaModel):
    def __init__(
        self,
        audit_id: int = None,
        create_time: str = None,
        current_handlers: GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers = None,
        description: str = None,
        order_id: int = None,
        order_type: str = None,
        reason_list: GetApprovalDetailResponseBodyApprovalDetailReasonList = None,
        template_id: int = None,
        title: str = None,
        workflow_ins_code: str = None,
        workflow_nodes: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes = None,
    ):
        # The ID of the approval process.
        self.audit_id = audit_id
        # The time when the approval process was created.
        self.create_time = create_time
        # The information about the approver.
        self.current_handlers = current_handlers
        # The description of the approval process.
        self.description = description
        # The ID of the ticket.
        self.order_id = order_id
        # The type of the ticket. Valid values:
        # 
        # - **NDDL**: The ticket is used to change the schema design.
        # - **DATA_TRACK**: The ticket is used to track data.
        # - **TABLE_SYNC**: The ticket is used to synchronize databases and tables.
        # - **PERM_APPLY**: The ticket is used to apply for permissions.
        # - **DATA_EXPORT**: The ticket is used to export data.
        # - **DATA_CORRECT**: The ticket is used to change data.
        # - **OWNER_APPLY**: The ticket is used to apply for the owner role of a resource.
        # - **SENSITIVITY**: The ticket is used to change column sensitivity levels.
        self.order_type = order_type
        # The reason for the approval.
        self.reason_list = reason_list
        # The ID of the approval template.
        self.template_id = template_id
        # The title of the approval process.
        self.title = title
        # The approval status of the ticket. Valid values:
        # 
        # - **AUDITING**: The ticket is being processed.
        # - **REJECT**: The ticket was rejected.
        # - **CANCEL**: The ticket was revoked.
        # - **APPROVED**: The ticket was approved.
        # 
        # >  If an approval process contains multiple approval nodes, this parameter is returned for each approval node.
        self.workflow_ins_code = workflow_ins_code
        # The details of approval nodes.
        self.workflow_nodes = workflow_nodes

    def validate(self):
        if self.current_handlers:
            self.current_handlers.validate()
        if self.reason_list:
            self.reason_list.validate()
        if self.workflow_nodes:
            self.workflow_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_id is not None:
            result['AuditId'] = self.audit_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.current_handlers is not None:
            result['CurrentHandlers'] = self.current_handlers.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.reason_list is not None:
            result['ReasonList'] = self.reason_list.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.title is not None:
            result['Title'] = self.title
        if self.workflow_ins_code is not None:
            result['WorkflowInsCode'] = self.workflow_ins_code
        if self.workflow_nodes is not None:
            result['WorkflowNodes'] = self.workflow_nodes.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditId') is not None:
            self.audit_id = m.get('AuditId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CurrentHandlers') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers()
            self.current_handlers = temp_model.from_map(m['CurrentHandlers'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('ReasonList') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetailReasonList()
            self.reason_list = temp_model.from_map(m['ReasonList'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('WorkflowInsCode') is not None:
            self.workflow_ins_code = m.get('WorkflowInsCode')
        if m.get('WorkflowNodes') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes()
            self.workflow_nodes = temp_model.from_map(m['WorkflowNodes'])
        return self


class GetApprovalDetailResponseBody(TeaModel):
    def __init__(
        self,
        approval_detail: GetApprovalDetailResponseBodyApprovalDetail = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The approval details of the ticket.
        self.approval_detail = approval_detail
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        if self.approval_detail:
            self.approval_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.approval_detail is not None:
            result['ApprovalDetail'] = self.approval_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApprovalDetail') is not None:
            temp_model = GetApprovalDetailResponseBodyApprovalDetail()
            self.approval_detail = temp_model.from_map(m['ApprovalDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetApprovalDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetApprovalDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetApprovalDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDBTaskSQLJobLogRequest(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        tid: int = None,
    ):
        # The ID of the SQL task. You can call the [ListDBTaskSQLJob](~~207049~~) operation to query the ID of the SQL task.
        self.job_id = job_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDBTaskSQLJobLogResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        log: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The log that records the scheduling details.
        self.log = log
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.log is not None:
            result['Log'] = self.log
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Log') is not None:
            self.log = m.get('Log')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDBTaskSQLJobLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDBTaskSQLJobLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDBTaskSQLJobLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDBTopologyRequest(TeaModel):
    def __init__(
        self,
        logic_db_id: int = None,
        tid: int = None,
    ):
        self.logic_db_id = logic_db_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        instance_id: int = None,
        instance_resource_id: str = None,
        instance_source: str = None,
        region_id: str = None,
        schema_name: str = None,
        search_name: str = None,
    ):
        self.catalog_name = catalog_name
        self.db_id = db_id
        self.db_type = db_type
        self.env_type = env_type
        self.instance_id = instance_id
        self.instance_resource_id = instance_resource_id
        self.instance_source = instance_source
        self.region_id = region_id
        self.schema_name = schema_name
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_resource_id is not None:
            result['InstanceResourceId'] = self.instance_resource_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceResourceId') is not None:
            self.instance_resource_id = m.get('InstanceResourceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetDBTopologyResponseBodyDBTopology(TeaModel):
    def __init__(
        self,
        alias: str = None,
        dbtopology_info_list: List[GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList] = None,
        db_type: str = None,
        env_type: str = None,
        logic_db_id: int = None,
        logic_db_name: str = None,
        search_name: str = None,
    ):
        self.alias = alias
        self.dbtopology_info_list = dbtopology_info_list
        self.db_type = db_type
        self.env_type = env_type
        self.logic_db_id = logic_db_id
        self.logic_db_name = logic_db_name
        self.search_name = search_name

    def validate(self):
        if self.dbtopology_info_list:
            for k in self.dbtopology_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        result['DBTopologyInfoList'] = []
        if self.dbtopology_info_list is not None:
            for k in self.dbtopology_info_list:
                result['DBTopologyInfoList'].append(k.to_map() if k else None)
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic_db_id is not None:
            result['LogicDbId'] = self.logic_db_id
        if self.logic_db_name is not None:
            result['LogicDbName'] = self.logic_db_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        self.dbtopology_info_list = []
        if m.get('DBTopologyInfoList') is not None:
            for k in m.get('DBTopologyInfoList'):
                temp_model = GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList()
                self.dbtopology_info_list.append(temp_model.from_map(k))
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('LogicDbId') is not None:
            self.logic_db_id = m.get('LogicDbId')
        if m.get('LogicDbName') is not None:
            self.logic_db_name = m.get('LogicDbName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetDBTopologyResponseBody(TeaModel):
    def __init__(
        self,
        dbtopology: GetDBTopologyResponseBodyDBTopology = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.dbtopology = dbtopology
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.dbtopology:
            self.dbtopology.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtopology is not None:
            result['DBTopology'] = self.dbtopology.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBTopology') is not None:
            temp_model = GetDBTopologyResponseBodyDBTopology()
            self.dbtopology = temp_model.from_map(m['DBTopology'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDBTopologyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDBTopologyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDBTopologyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectBackupFilesRequest(TeaModel):
    def __init__(
        self,
        action_detail: Dict[str, Any] = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The parameters that are required to perform the operation. You do not need to specify this parameter.
        self.action_detail = action_detail
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail is not None:
            result['ActionDetail'] = self.action_detail
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectBackupFilesShrinkRequest(TeaModel):
    def __init__(
        self,
        action_detail_shrink: str = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The parameters that are required to perform the operation. You do not need to specify this parameter.
        self.action_detail_shrink = action_detail_shrink
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_detail_shrink is not None:
            result['ActionDetail'] = self.action_detail_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionDetail') is not None:
            self.action_detail_shrink = m.get('ActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles(TeaModel):
    def __init__(
        self,
        file_url: List[str] = None,
    ):
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class GetDataCorrectBackupFilesResponseBody(TeaModel):
    def __init__(
        self,
        data_correct_backup_files: GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The download URL of the backup file for the ticket.
        self.data_correct_backup_files = data_correct_backup_files
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.data_correct_backup_files:
            self.data_correct_backup_files.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_correct_backup_files is not None:
            result['DataCorrectBackupFiles'] = self.data_correct_backup_files.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataCorrectBackupFiles') is not None:
            temp_model = GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles()
            self.data_correct_backup_files = temp_model.from_map(m['DataCorrectBackupFiles'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectBackupFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCorrectBackupFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectBackupFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        search_name: str = None,
    ):
        # The ID of the database.
        self.db_id = db_id
        # The engine of the database.
        self.db_type = db_type
        # The type of the environment to which the database belongs. Valid values:
        # 
        # - product: production environment
        # - dev: development environment
        # - pre: staging environment
        # - test: test environment
        # - sit: system integration testing (SIT) environment
        # - uat: user acceptance testing (UAT) environment
        # - pet: stress testing environment
        # - stag: STAG environment
        self.env_type = env_type
        # Indicates whether the database is a logical database. Valid values:
        # 
        # - **true**: The database is a logical database.
        # - **false**: The database is a physical database.
        self.logic = logic
        # The name that is used to search for the database.
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList(TeaModel):
    def __init__(
        self,
        database: List[GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase] = None,
    ):
        self.database = database

    def validate(self):
        if self.database:
            for k in self.database:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Database'] = []
        if self.database is not None:
            for k in self.database:
                result['Database'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.database = []
        if m.get('Database') is not None:
            for k in m.get('Database'):
                temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase()
                self.database.append(temp_model.from_map(k))
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail(TeaModel):
    def __init__(
        self,
        actual_affect_rows: int = None,
        attachment_name: str = None,
        classify: str = None,
        estimate_affect_rows: int = None,
        exe_sql: str = None,
        ignore_affect_rows: bool = None,
        ignore_affect_rows_reason: str = None,
        rb_attachment_name: str = None,
        rb_sql: str = None,
        rb_sqltype: str = None,
        sql_type: str = None,
    ):
        # The number of affected rows that is obtained by the precheck.
        self.actual_affect_rows = actual_affect_rows
        # The name of the attachment that contains the SQL statements used to change data.
        self.attachment_name = attachment_name
        # The category of the reason for the data change.
        self.classify = classify
        # The estimated number of affected rows.
        self.estimate_affect_rows = estimate_affect_rows
        # The executed SQL statements.
        self.exe_sql = exe_sql
        # Indicates whether the precheck result is ignored. Valid values:
        # 
        # - **true**: The precheck result is ignored.
        # - **false**: The precheck result is not ignored.
        self.ignore_affect_rows = ignore_affect_rows
        # The reason why the precheck result is ignored.
        self.ignore_affect_rows_reason = ignore_affect_rows_reason
        # The name of the attachment that contains the SQL statements used to roll back the data change.
        self.rb_attachment_name = rb_attachment_name
        # The SQL statements used to roll back the data change.
        self.rb_sql = rb_sql
        # The format of the SQL statements used to roll back the data change. Valid values:
        # 
        # - **TEXT**: text
        # - **ATTACHMENT**: attachment
        self.rb_sqltype = rb_sqltype
        # The format of the SQL statements used to change data. Valid values:
        # 
        # - **TEXT**: text
        # - **ATTACHMENT**: attachment
        self.sql_type = sql_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_affect_rows is not None:
            result['ActualAffectRows'] = self.actual_affect_rows
        if self.attachment_name is not None:
            result['AttachmentName'] = self.attachment_name
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.estimate_affect_rows is not None:
            result['EstimateAffectRows'] = self.estimate_affect_rows
        if self.exe_sql is not None:
            result['ExeSQL'] = self.exe_sql
        if self.ignore_affect_rows is not None:
            result['IgnoreAffectRows'] = self.ignore_affect_rows
        if self.ignore_affect_rows_reason is not None:
            result['IgnoreAffectRowsReason'] = self.ignore_affect_rows_reason
        if self.rb_attachment_name is not None:
            result['RbAttachmentName'] = self.rb_attachment_name
        if self.rb_sql is not None:
            result['RbSQL'] = self.rb_sql
        if self.rb_sqltype is not None:
            result['RbSQLType'] = self.rb_sqltype
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualAffectRows') is not None:
            self.actual_affect_rows = m.get('ActualAffectRows')
        if m.get('AttachmentName') is not None:
            self.attachment_name = m.get('AttachmentName')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('EstimateAffectRows') is not None:
            self.estimate_affect_rows = m.get('EstimateAffectRows')
        if m.get('ExeSQL') is not None:
            self.exe_sql = m.get('ExeSQL')
        if m.get('IgnoreAffectRows') is not None:
            self.ignore_affect_rows = m.get('IgnoreAffectRows')
        if m.get('IgnoreAffectRowsReason') is not None:
            self.ignore_affect_rows_reason = m.get('IgnoreAffectRowsReason')
        if m.get('RbAttachmentName') is not None:
            self.rb_attachment_name = m.get('RbAttachmentName')
        if m.get('RbSQL') is not None:
            self.rb_sql = m.get('RbSQL')
        if m.get('RbSQLType') is not None:
            self.rb_sqltype = m.get('RbSQLType')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO(TeaModel):
    def __init__(
        self,
        check_status: str = None,
        check_step: str = None,
        user_tip: str = None,
    ):
        # The status of the precheck. Valid values:
        # 
        # *   **WAITING**: The ticket is pending precheck.
        # *   **RUNNING**: The ticket is being prechecked.
        # *   **SUCCESS**: The ticket passes the precheck.
        # *   **FAIL**: The ticket fails the precheck.
        self.check_status = check_status
        # The check step of the precheck. Valid values:
        # 
        # *   **SQL_PARSE**: The system checks the syntax of the SQL statement.
        # *   **SQL_TYPE_CHECK**: The system checks the type of the SQL statement.
        # *   **PERMISSION_CHECK**: The system checks the permissions required for the data change.
        # *   **ROW_CHECK**: The system checks the number of affected rows.
        self.check_step = check_step
        # The message that indicates a check step.
        self.user_tip = user_tip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_status is not None:
            result['CheckStatus'] = self.check_status
        if self.check_step is not None:
            result['CheckStep'] = self.check_step
        if self.user_tip is not None:
            result['UserTip'] = self.user_tip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckStatus') is not None:
            self.check_status = m.get('CheckStatus')
        if m.get('CheckStep') is not None:
            self.check_step = m.get('CheckStep')
        if m.get('UserTip') is not None:
            self.user_tip = m.get('UserTip')
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail(TeaModel):
    def __init__(
        self,
        task_check_do: List[GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO] = None,
    ):
        self.task_check_do = task_check_do

    def validate(self):
        if self.task_check_do:
            for k in self.task_check_do:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskCheckDO'] = []
        if self.task_check_do is not None:
            for k in self.task_check_do:
                result['TaskCheckDO'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_check_do = []
        if m.get('TaskCheckDO') is not None:
            for k in m.get('TaskCheckDO'):
                temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO()
                self.task_check_do.append(temp_model.from_map(k))
        return self


class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail(TeaModel):
    def __init__(
        self,
        database_list: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList = None,
        exec_mode: str = None,
        order_detail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail = None,
        pre_check_detail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail = None,
        status: str = None,
    ):
        # The information about the database in which data is changed.
        self.database_list = database_list
        # The execution mode of the ticket after the ticket is approved. Valid values:
        # 
        # - **COMMITOR**: The data change is performed by the user who submits the ticket.
        # - **AUTO**: The data change is automatically performed after the ticket is approved.
        # - **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
        self.exec_mode = exec_mode
        # The details of the ticket.
        self.order_detail = order_detail
        # The precheck details of the ticket.
        self.pre_check_detail = pre_check_detail
        # The status of the ticket. Valid values:
        # 
        # - **new**: The ticket is created.
        # - **precheck**: The ticket is being prechecked.
        # - **precheck_fail**: The ticket fails the precheck.
        # - **precheck_success**: The ticket passes the precheck and waits to be submitted for approval.
        # - **toaudit**: The ticket is being reviewed.
        # - **Approved**: The ticket is approved.
        # - **reject**: The ticket is rejected.
        # - **waiting**: The ticket is submitted and waits to be scheduled.
        # - **processing**: The ticket is being executed.
        # - **success**: The ticket is executed.
        # - **closed**: The ticket is closed.
        self.status = status

    def validate(self):
        if self.database_list:
            self.database_list.validate()
        if self.order_detail:
            self.order_detail.validate()
        if self.pre_check_detail:
            self.pre_check_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_list is not None:
            result['DatabaseList'] = self.database_list.to_map()
        if self.exec_mode is not None:
            result['ExecMode'] = self.exec_mode
        if self.order_detail is not None:
            result['OrderDetail'] = self.order_detail.to_map()
        if self.pre_check_detail is not None:
            result['PreCheckDetail'] = self.pre_check_detail.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseList') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList()
            self.database_list = temp_model.from_map(m['DatabaseList'])
        if m.get('ExecMode') is not None:
            self.exec_mode = m.get('ExecMode')
        if m.get('OrderDetail') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail()
            self.order_detail = temp_model.from_map(m['OrderDetail'])
        if m.get('PreCheckDetail') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail()
            self.pre_check_detail = temp_model.from_map(m['PreCheckDetail'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetDataCorrectOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        data_correct_order_detail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The information about the data change ticket.
        self.data_correct_order_detail = data_correct_order_detail
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - **true**: The request is successful.
        # - **false**: The request fails.
        self.success = success

    def validate(self):
        if self.data_correct_order_detail:
            self.data_correct_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_correct_order_detail is not None:
            result['DataCorrectOrderDetail'] = self.data_correct_order_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataCorrectOrderDetail') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail()
            self.data_correct_order_detail = temp_model.from_map(m['DataCorrectOrderDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCorrectOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectRollbackFileRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectRollbackFileResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        file_url: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.file_url = file_url
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectRollbackFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCorrectRollbackFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectRollbackFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectSQLFileRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectSQLFileResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        file_url: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.file_url = file_url
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectSQLFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCorrectSQLFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectSQLFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCorrectTaskDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail(TeaModel):
    def __init__(
        self,
        actual_affect_rows: int = None,
        create_time: str = None,
        dbtask_group_id: int = None,
        job_status: str = None,
    ):
        self.actual_affect_rows = actual_affect_rows
        self.create_time = create_time
        self.dbtask_group_id = dbtask_group_id
        self.job_status = job_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_affect_rows is not None:
            result['ActualAffectRows'] = self.actual_affect_rows
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.job_status is not None:
            result['jobStatus'] = self.job_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualAffectRows') is not None:
            self.actual_affect_rows = m.get('ActualAffectRows')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('jobStatus') is not None:
            self.job_status = m.get('jobStatus')
        return self


class GetDataCorrectTaskDetailResponseBody(TeaModel):
    def __init__(
        self,
        data_correct_task_detail: GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data_correct_task_detail = data_correct_task_detail
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data_correct_task_detail:
            self.data_correct_task_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_correct_task_detail is not None:
            result['DataCorrectTaskDetail'] = self.data_correct_task_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataCorrectTaskDetail') is not None:
            temp_model = GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail()
            self.data_correct_task_detail = temp_model.from_map(m['DataCorrectTaskDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCorrectTaskDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCorrectTaskDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCorrectTaskDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCronClearConfigRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCronClearConfigResponseBodyDataCronClearConfig(TeaModel):
    def __init__(
        self,
        cron_call_times: str = None,
        cron_format: str = None,
        cron_last_call_start_time: str = None,
        cron_next_call_time: str = None,
        cron_status: str = None,
        current_clear_task_count: int = None,
        duration: str = None,
        optimize_table_after_every_clear_times: int = None,
    ):
        self.cron_call_times = cron_call_times
        self.cron_format = cron_format
        self.cron_last_call_start_time = cron_last_call_start_time
        self.cron_next_call_time = cron_next_call_time
        self.cron_status = cron_status
        self.current_clear_task_count = current_clear_task_count
        self.duration = duration
        self.optimize_table_after_every_clear_times = optimize_table_after_every_clear_times

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron_call_times is not None:
            result['CronCallTimes'] = self.cron_call_times
        if self.cron_format is not None:
            result['CronFormat'] = self.cron_format
        if self.cron_last_call_start_time is not None:
            result['CronLastCallStartTime'] = self.cron_last_call_start_time
        if self.cron_next_call_time is not None:
            result['CronNextCallTime'] = self.cron_next_call_time
        if self.cron_status is not None:
            result['CronStatus'] = self.cron_status
        if self.current_clear_task_count is not None:
            result['CurrentClearTaskCount'] = self.current_clear_task_count
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.optimize_table_after_every_clear_times is not None:
            result['OptimizeTableAfterEveryClearTimes'] = self.optimize_table_after_every_clear_times
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CronCallTimes') is not None:
            self.cron_call_times = m.get('CronCallTimes')
        if m.get('CronFormat') is not None:
            self.cron_format = m.get('CronFormat')
        if m.get('CronLastCallStartTime') is not None:
            self.cron_last_call_start_time = m.get('CronLastCallStartTime')
        if m.get('CronNextCallTime') is not None:
            self.cron_next_call_time = m.get('CronNextCallTime')
        if m.get('CronStatus') is not None:
            self.cron_status = m.get('CronStatus')
        if m.get('CurrentClearTaskCount') is not None:
            self.current_clear_task_count = m.get('CurrentClearTaskCount')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('OptimizeTableAfterEveryClearTimes') is not None:
            self.optimize_table_after_every_clear_times = m.get('OptimizeTableAfterEveryClearTimes')
        return self


class GetDataCronClearConfigResponseBody(TeaModel):
    def __init__(
        self,
        data_cron_clear_config: GetDataCronClearConfigResponseBodyDataCronClearConfig = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data_cron_clear_config = data_cron_clear_config
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data_cron_clear_config:
            self.data_cron_clear_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_cron_clear_config is not None:
            result['DataCronClearConfig'] = self.data_cron_clear_config.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataCronClearConfig') is not None:
            temp_model = GetDataCronClearConfigResponseBodyDataCronClearConfig()
            self.data_cron_clear_config = temp_model.from_map(m['DataCronClearConfig'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataCronClearConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCronClearConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCronClearConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataCronClearTaskDetailListRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.page_number = page_number
        self.page_size = page_size
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList(TeaModel):
    def __init__(
        self,
        actual_affect_rows: int = None,
        create_time: str = None,
        dbtask_group_id: int = None,
        job_status: str = None,
    ):
        self.actual_affect_rows = actual_affect_rows
        self.create_time = create_time
        self.dbtask_group_id = dbtask_group_id
        self.job_status = job_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_affect_rows is not None:
            result['ActualAffectRows'] = self.actual_affect_rows
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.job_status is not None:
            result['jobStatus'] = self.job_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualAffectRows') is not None:
            self.actual_affect_rows = m.get('ActualAffectRows')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('jobStatus') is not None:
            self.job_status = m.get('jobStatus')
        return self


class GetDataCronClearTaskDetailListResponseBody(TeaModel):
    def __init__(
        self,
        data_cron_clear_task_detail_list: List[GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.data_cron_clear_task_detail_list = data_cron_clear_task_detail_list
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data_cron_clear_task_detail_list:
            for k in self.data_cron_clear_task_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataCronClearTaskDetailList'] = []
        if self.data_cron_clear_task_detail_list is not None:
            for k in self.data_cron_clear_task_detail_list:
                result['DataCronClearTaskDetailList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_cron_clear_task_detail_list = []
        if m.get('DataCronClearTaskDetailList') is not None:
            for k in m.get('DataCronClearTaskDetailList'):
                temp_model = GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList()
                self.data_cron_clear_task_detail_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetDataCronClearTaskDetailListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataCronClearTaskDetailListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataCronClearTaskDetailListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataExportDownloadURLRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataExportDownloadURLResponseBodyDownloadURLResult(TeaModel):
    def __init__(
        self,
        has_result: bool = None,
        tip_message: str = None,
        url: str = None,
    ):
        # Indicates whether export results are available for download. Valid values:
        # 
        # *   **true**: Export results are available for download.
        # *   **false**: No export results are available for download.
        self.has_result = has_result
        # The message that indicates an exception.
        self.tip_message = tip_message
        # The download URL of the file that records the export results for the ticket.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_result is not None:
            result['HasResult'] = self.has_result
        if self.tip_message is not None:
            result['TipMessage'] = self.tip_message
        if self.url is not None:
            result['URL'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HasResult') is not None:
            self.has_result = m.get('HasResult')
        if m.get('TipMessage') is not None:
            self.tip_message = m.get('TipMessage')
        if m.get('URL') is not None:
            self.url = m.get('URL')
        return self


class GetDataExportDownloadURLResponseBody(TeaModel):
    def __init__(
        self,
        download_urlresult: GetDataExportDownloadURLResponseBodyDownloadURLResult = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details about the download URL of the file that records the export results for the ticket.
        self.download_urlresult = download_urlresult
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.download_urlresult:
            self.download_urlresult.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_urlresult is not None:
            result['DownloadURLResult'] = self.download_urlresult.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadURLResult') is not None:
            temp_model = GetDataExportDownloadURLResponseBodyDownloadURLResult()
            self.download_urlresult = temp_model.from_map(m['DownloadURLResult'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataExportDownloadURLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataExportDownloadURLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataExportDownloadURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataExportOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo(TeaModel):
    def __init__(
        self,
        job_status: str = None,
        pre_check_id: int = None,
    ):
        self.job_status = job_status
        self.pre_check_id = pre_check_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.pre_check_id is not None:
            result['PreCheckId'] = self.pre_check_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('PreCheckId') is not None:
            self.pre_check_id = m.get('PreCheckId')
        return self


class GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail(TeaModel):
    def __init__(
        self,
        actual_affect_rows: int = None,
        classify: str = None,
        database: str = None,
        db_id: int = None,
        env_type: str = None,
        exe_sql: str = None,
        ignore_affect_rows: bool = None,
        ignore_affect_rows_reason: str = None,
        logic: bool = None,
    ):
        self.actual_affect_rows = actual_affect_rows
        self.classify = classify
        self.database = database
        self.db_id = db_id
        self.env_type = env_type
        self.exe_sql = exe_sql
        self.ignore_affect_rows = ignore_affect_rows
        self.ignore_affect_rows_reason = ignore_affect_rows_reason
        self.logic = logic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_affect_rows is not None:
            result['ActualAffectRows'] = self.actual_affect_rows
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.database is not None:
            result['Database'] = self.database
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.exe_sql is not None:
            result['ExeSQL'] = self.exe_sql
        if self.ignore_affect_rows is not None:
            result['IgnoreAffectRows'] = self.ignore_affect_rows
        if self.ignore_affect_rows_reason is not None:
            result['IgnoreAffectRowsReason'] = self.ignore_affect_rows_reason
        if self.logic is not None:
            result['Logic'] = self.logic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActualAffectRows') is not None:
            self.actual_affect_rows = m.get('ActualAffectRows')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExeSQL') is not None:
            self.exe_sql = m.get('ExeSQL')
        if m.get('IgnoreAffectRows') is not None:
            self.ignore_affect_rows = m.get('IgnoreAffectRows')
        if m.get('IgnoreAffectRowsReason') is not None:
            self.ignore_affect_rows_reason = m.get('IgnoreAffectRowsReason')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        return self


class GetDataExportOrderDetailResponseBodyDataExportOrderDetail(TeaModel):
    def __init__(
        self,
        key_info: GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo = None,
        order_detail: GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail = None,
    ):
        self.key_info = key_info
        self.order_detail = order_detail

    def validate(self):
        if self.key_info:
            self.key_info.validate()
        if self.order_detail:
            self.order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_info is not None:
            result['KeyInfo'] = self.key_info.to_map()
        if self.order_detail is not None:
            result['OrderDetail'] = self.order_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyInfo') is not None:
            temp_model = GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo()
            self.key_info = temp_model.from_map(m['KeyInfo'])
        if m.get('OrderDetail') is not None:
            temp_model = GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail()
            self.order_detail = temp_model.from_map(m['OrderDetail'])
        return self


class GetDataExportOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        data_export_order_detail: GetDataExportOrderDetailResponseBodyDataExportOrderDetail = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.data_export_order_detail = data_export_order_detail
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data_export_order_detail:
            self.data_export_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_export_order_detail is not None:
            result['DataExportOrderDetail'] = self.data_export_order_detail.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataExportOrderDetail') is not None:
            temp_model = GetDataExportOrderDetailResponseBodyDataExportOrderDetail()
            self.data_export_order_detail = temp_model.from_map(m['DataExportOrderDetail'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataExportOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataExportOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataExportOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDatabaseRequest(TeaModel):
    def __init__(
        self,
        host: str = None,
        port: int = None,
        schema_name: str = None,
        sid: str = None,
        tid: int = None,
    ):
        # The endpoint that is used to connect to the database.
        self.host = host
        # The port that is used to connect to the database.
        self.port = port
        # The name of the database.
        self.schema_name = schema_name
        # The system identifier (SID) of the database.
        # 
        # >  The SID uniquely identifies an Oracle database. After a database is created, a SID is generated for the database.
        self.sid = sid
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetDatabaseResponseBodyDatabaseOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class GetDatabaseResponseBodyDatabaseOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class GetDatabaseResponseBodyDatabase(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        database_id: str = None,
        db_type: str = None,
        dba_id: str = None,
        dba_name: str = None,
        encoding: str = None,
        env_type: str = None,
        host: str = None,
        instance_id: str = None,
        owner_id_list: GetDatabaseResponseBodyDatabaseOwnerIdList = None,
        owner_name_list: GetDatabaseResponseBodyDatabaseOwnerNameList = None,
        port: int = None,
        schema_name: str = None,
        search_name: str = None,
        sid: str = None,
        state: str = None,
    ):
        # The name of the catalog to which the database belongs.
        self.catalog_name = catalog_name
        # The ID of the database.
        self.database_id = database_id
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type
        # The ID of the database administrator (DBA).
        self.dba_id = dba_id
        # The nickname of the DBA.
        self.dba_name = dba_name
        # The encoding format of the database.
        self.encoding = encoding
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: staging environment
        # *   **test**: test environment
        # *   **sit**: SIT environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: STAG environment
        self.env_type = env_type
        # The endpoint that is used to connect to the database.
        self.host = host
        # The ID of the instance.
        self.instance_id = instance_id
        # The IDs of the owners of the database.
        self.owner_id_list = owner_id_list
        # The names of the owners of the database.
        self.owner_name_list = owner_name_list
        # The port that is used to connect to the database.
        self.port = port
        # The name of the database.
        self.schema_name = schema_name
        # The keyword that is used to search for the database.
        self.search_name = search_name
        # The SID of the database.
        # 
        # >  The value of the parameter is returned only for Oracle databases.
        self.sid = sid
        # The status of the database. Valid values:
        # 
        # *   **NORMAL**: The database is running as expected.
        # *   **DISABLE**: The database is disabled.
        # *   **OFFLINE**: The database is unpublished.
        # *   **NOT_EXIST**: The database does not exist.
        self.state = state

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_name is not None:
            result['DbaName'] = self.dba_name
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaName') is not None:
            self.dba_name = m.get('DbaName')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerIdList') is not None:
            temp_model = GetDatabaseResponseBodyDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = GetDatabaseResponseBodyDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class GetDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        database: GetDatabaseResponseBodyDatabase = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details of the database.
        self.database = database
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        if self.database:
            self.database.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Database') is not None:
            temp_model = GetDatabaseResponseBodyDatabase()
            self.database = temp_model.from_map(m['Database'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInstanceRequest(TeaModel):
    def __init__(
        self,
        host: str = None,
        port: int = None,
        sid: str = None,
        tid: int = None,
    ):
        # The endpoint of the database instance. You can call the [ListInstances](~~141936~~) operation to obtain the endpoint.
        self.host = host
        # The port number that is used to connect to the database instance. You can call the [ListInstances](~~141936~~) operation to obtain the port number.
        self.port = port
        # The system ID (SID) of the database instance. You can call the [ListInstances](~~141936~~) operation to obtain the SID.
        self.sid = sid
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetInstanceResponseBodyInstanceOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class GetInstanceResponseBodyInstanceOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class GetInstanceResponseBodyInstanceStandardGroup(TeaModel):
    def __init__(
        self,
        group_mode: str = None,
        group_name: str = None,
    ):
        # The type of the control mode. Valid values:
        # 
        # *   **COMMON**: Security Collaboration
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        self.group_mode = group_mode
        # The name of the security rule set corresponding to the control mode.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class GetInstanceResponseBodyInstance(TeaModel):
    def __init__(
        self,
        data_link_name: str = None,
        database_password: str = None,
        database_user: str = None,
        dba_id: str = None,
        dba_nick_name: str = None,
        ddl_online: int = None,
        ecs_instance_id: str = None,
        ecs_region: str = None,
        env_type: str = None,
        export_timeout: int = None,
        host: str = None,
        instance_alias: str = None,
        instance_id: str = None,
        instance_source: str = None,
        instance_type: str = None,
        owner_id_list: GetInstanceResponseBodyInstanceOwnerIdList = None,
        owner_name_list: GetInstanceResponseBodyInstanceOwnerNameList = None,
        port: int = None,
        query_timeout: int = None,
        safe_rule_id: str = None,
        sell_sitd: str = None,
        sid: str = None,
        standard_group: GetInstanceResponseBodyInstanceStandardGroup = None,
        state: str = None,
        use_dsql: int = None,
        vpc_id: str = None,
    ):
        # The name of the database link for the database instance.
        self.data_link_name = data_link_name
        # The password that is used to log on to the database.
        self.database_password = database_password
        # The account that is used to log on to the database instance.
        self.database_user = database_user
        # The ID of the database administrator (DBA) for the database instance.
        self.dba_id = dba_id
        # The nickname of the DBA for the database instance.
        self.dba_nick_name = dba_nick_name
        # Indicates whether the lock-free schema change feature is enabled for the database instance.
        self.ddl_online = ddl_online
        # The ID of the Elastic Compute Service (ECS) instance on which the database instance is deployed.
        self.ecs_instance_id = ecs_instance_id
        # The ID of the region in which the database instance resides.
        self.ecs_region = ecs_region
        # The type of the environment to which the database instance belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: staging environment
        # *   **test**: test environment
        # *   **sit**: system integration testing (SIT) environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: STAG environment
        self.env_type = env_type
        # The timeout period for exporting data from the database instance.
        self.export_timeout = export_timeout
        # The host address that is used to connect to the database instance.
        self.host = host
        # The alias of the database instance.
        self.instance_alias = instance_alias
        # The ID of the database instance.
        self.instance_id = instance_id
        # The source of the database instance.
        self.instance_source = instance_source
        # The type of the database instance.
        self.instance_type = instance_type
        # The IDs of the owners for the database instance.
        self.owner_id_list = owner_id_list
        # The nicknames of the owners for the database instance.
        self.owner_name_list = owner_name_list
        # The port number that is used to connect to the database instance.
        self.port = port
        # The timeout period for querying data in the database instance.
        self.query_timeout = query_timeout
        # The ID of the security rule set for the database instance.
        self.safe_rule_id = safe_rule_id
        self.sell_sitd = sell_sitd
        # The SID of the database instance.
        self.sid = sid
        # The control mode of the database instance.
        self.standard_group = standard_group
        # The status of the database instance. Valid values:
        # 
        # *   **NORMAL**: normal
        # *   **DISABLE**: disabled
        self.state = state
        # Indicates whether the cross-database query feature is enabled for the database instance. Valid values:
        # 
        # *   **0**: disabled
        # *   **1**: enabled
        self.use_dsql = use_dsql
        # The ID of the virtual private cloud (VPC) to which the database instance belongs.
        self.vpc_id = vpc_id

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_nick_name is not None:
            result['DbaNickName'] = self.dba_nick_name
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule_id is not None:
            result['SafeRuleId'] = self.safe_rule_id
        if self.sell_sitd is not None:
            result['SellSitd'] = self.sell_sitd
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaNickName') is not None:
            self.dba_nick_name = m.get('DbaNickName')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerIdList') is not None:
            temp_model = GetInstanceResponseBodyInstanceOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = GetInstanceResponseBodyInstanceOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRuleId') is not None:
            self.safe_rule_id = m.get('SafeRuleId')
        if m.get('SellSitd') is not None:
            self.sell_sitd = m.get('SellSitd')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('StandardGroup') is not None:
            temp_model = GetInstanceResponseBodyInstanceStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class GetInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        instance: GetInstanceResponseBodyInstance = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The details of the database instance.
        self.instance = instance
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        if self.instance:
            self.instance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance is not None:
            result['Instance'] = self.instance.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Instance') is not None:
            temp_model = GetInstanceResponseBodyInstance()
            self.instance = temp_model.from_map(m['Instance'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetIntervalLimitOfSLARequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetIntervalLimitOfSLAResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        interval_limit: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.interval_limit = interval_limit
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.interval_limit is not None:
            result['IntervalLimit'] = self.interval_limit
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('IntervalLimit') is not None:
            self.interval_limit = m.get('IntervalLimit')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetIntervalLimitOfSLAResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetIntervalLimitOfSLAResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetIntervalLimitOfSLAResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLhSpaceByNameRequest(TeaModel):
    def __init__(
        self,
        space_name: str = None,
        tid: int = None,
    ):
        # The name of the workspace.
        self.space_name = space_name
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_name is not None:
            result['SpaceName'] = self.space_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SpaceName') is not None:
            self.space_name = m.get('SpaceName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetLhSpaceByNameResponseBodyLakehouseSpace(TeaModel):
    def __init__(
        self,
        creator_id: str = None,
        description: str = None,
        dev_db_id: int = None,
        dw_db_type: str = None,
        id: int = None,
        is_deleted: bool = None,
        mode: int = None,
        prod_db_id: int = None,
        space_config: str = None,
        space_name: str = None,
        tenant_id: str = None,
    ):
        # The ID of the user who creates the workspace.
        self.creator_id = creator_id
        # The description of the workspace.
        self.description = description
        # The ID of the development database.
        self.dev_db_id = dev_db_id
        # The type of the database. Valid values:
        # 
        # *   **14**: AnalyticDB for MySQL
        # *   **18**: AnalyticDB for PostgreSQL
        self.dw_db_type = dw_db_type
        # The ID of the workspace.
        self.id = id
        # Indicates whether the workspace is deleted. Valid values:
        # 
        # *   **true**: The workspace is deleted.
        # *   **false**: The workspace is not deleted.
        self.is_deleted = is_deleted
        # The mode in which the workspace runs. Valid values:
        # 
        # *   **0**: basic mode
        # *   **1**: standard mode
        self.mode = mode
        # The ID of the production database.
        self.prod_db_id = prod_db_id
        # The configuration of the workspace. Valid values:
        # 
        # *   **skipManualRunCheck**: No security rule check is required in the trial run phase.
        # *   **skipPublishApprove**: No approval is required for publishing and O\&M.
        self.space_config = space_config
        # The name of the workspace.
        self.space_name = space_name
        # The ID of the tenant to which the workspace belongs.
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.dev_db_id is not None:
            result['DevDbId'] = self.dev_db_id
        if self.dw_db_type is not None:
            result['DwDbType'] = self.dw_db_type
        if self.id is not None:
            result['Id'] = self.id
        if self.is_deleted is not None:
            result['IsDeleted'] = self.is_deleted
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.prod_db_id is not None:
            result['ProdDbId'] = self.prod_db_id
        if self.space_config is not None:
            result['SpaceConfig'] = self.space_config
        if self.space_name is not None:
            result['SpaceName'] = self.space_name
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DevDbId') is not None:
            self.dev_db_id = m.get('DevDbId')
        if m.get('DwDbType') is not None:
            self.dw_db_type = m.get('DwDbType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsDeleted') is not None:
            self.is_deleted = m.get('IsDeleted')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('ProdDbId') is not None:
            self.prod_db_id = m.get('ProdDbId')
        if m.get('SpaceConfig') is not None:
            self.space_config = m.get('SpaceConfig')
        if m.get('SpaceName') is not None:
            self.space_name = m.get('SpaceName')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class GetLhSpaceByNameResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        lakehouse_space: GetLhSpaceByNameResponseBodyLakehouseSpace = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The workspace for data warehouse development.
        self.lakehouse_space = lakehouse_space
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        if self.lakehouse_space:
            self.lakehouse_space.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.lakehouse_space is not None:
            result['LakehouseSpace'] = self.lakehouse_space.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LakehouseSpace') is not None:
            temp_model = GetLhSpaceByNameResponseBodyLakehouseSpace()
            self.lakehouse_space = temp_model.from_map(m['LakehouseSpace'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetLhSpaceByNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLhSpaceByNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLhSpaceByNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLogicDatabaseRequest(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        tid: int = None,
    ):
        # The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to obtain the ID of the logical database.
        self.db_id = db_id
        # The ID of the tenant. 
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds(TeaModel):
    def __init__(
        self,
        database_ids: List[int] = None,
    ):
        self.database_ids = database_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseIds') is not None:
            self.database_ids = m.get('DatabaseIds')
        return self


class GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class GetLogicDatabaseResponseBodyLogicDatabase(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_id: str = None,
        database_ids: GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        owner_id_list: GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList = None,
        owner_name_list: GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList = None,
        schema_name: str = None,
        search_name: str = None,
    ):
        # The alias of the logical database.
        self.alias = alias
        # The ID of the logical database.
        self.database_id = database_id
        self.database_ids = database_ids
        # The type of the database. For more information about the valid values of the DbType parameter, see [DbType parameter](https://www.alibabacloud.com/help/en/data-management-service/latest/dbtype-parameter).
        self.db_type = db_type
        # The type of the environment to which the database belongs. Valid values:
        # 
        # - product: production environment
        # - dev: development environment
        # - pre: staging environment
        # - test: test environment
        # - sit: SIT environment
        # - uat: user acceptance testing (UAT) environment
        # - pet: stress testing environment
        # - stag: STAG environment
        self.env_type = env_type
        # Indicates whether the database is a logical database. The return value is true.
        self.logic = logic
        # The IDs of the owners of the logical database.
        self.owner_id_list = owner_id_list
        # The names of the owners of the logical database.
        self.owner_name_list = owner_name_list
        # The name of the logical database.
        self.schema_name = schema_name
        # The name that is used to search for the logical database.
        self.search_name = search_name

    def validate(self):
        if self.database_ids:
            self.database_ids.validate()
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids.to_map()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatabaseIds') is not None:
            temp_model = GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds()
            self.database_ids = temp_model.from_map(m['DatabaseIds'])
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetLogicDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        logic_database: GetLogicDatabaseResponseBodyLogicDatabase = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The details about the logical database.
        self.logic_database = logic_database
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success

    def validate(self):
        if self.logic_database:
            self.logic_database.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_database is not None:
            result['LogicDatabase'] = self.logic_database.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicDatabase') is not None:
            temp_model = GetLogicDatabaseResponseBodyLogicDatabase()
            self.logic_database = temp_model.from_map(m['LogicDatabase'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetLogicDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLogicDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLogicDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMetaTableColumnRequest(TeaModel):
    def __init__(
        self,
        table_guid: str = None,
        tid: int = None,
    ):
        # The globally unique identifier (GUID) of the table in Data Management (DMS).
        # 
        # *   If the database to which the table belongs is a logical database, you can call the [ListLogicTables](~~141875~~) operation to obtain the value of this parameter.
        # *   If the database to which the table belongs is a physical database, you can call the [ListTables](~~141878~~) operation to obtain the value of this parameter.
        self.table_guid = table_guid
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetMetaTableColumnResponseBodyColumnList(TeaModel):
    def __init__(
        self,
        auto_increment: bool = None,
        column_id: str = None,
        column_name: str = None,
        column_type: str = None,
        data_length: int = None,
        data_precision: int = None,
        data_scale: int = None,
        description: str = None,
        nullable: bool = None,
        position: int = None,
        primary_key: str = None,
        security_level: str = None,
    ):
        # Indicates whether the field is an auto-increment field. Valid values:
        # 
        # *   **true**: The field is an auto-increment field.
        # *   **false**: The field is not an auto-increment field.
        self.auto_increment = auto_increment
        # The ID of the field.
        self.column_id = column_id
        # The name of the field.
        self.column_name = column_name
        # The data type of the field.
        # 
        # >  The returned data type is not unique. For example, the returned data type can be **bigint** or **int**.
        self.column_type = column_type
        # The length of the field.
        self.data_length = data_length
        # The precision of the field.
        self.data_precision = data_precision
        # The number of decimal places that the field shows.
        self.data_scale = data_scale
        # The description of the field.
        self.description = description
        # Indicates whether the field can be empty. Valid values:
        # 
        # *   **true**: The field can be empty.
        # *   **false**: The field cannot be empty.
        self.nullable = nullable
        # The position of the field in the table.
        self.position = position
        # Indicates whether the field is the primary key. Valid values:
        # 
        # *   **true**: The field is the primary key.
        # *   **false**: The field is not the primary key.
        self.primary_key = primary_key
        # The sensitivity level of the field. Valid values:
        # 
        # *   **INNER**: The field is not sensitive.
        # *   **SENSITIVE**: The field is sensitive.
        # *   **CONFIDENTIAL**: The field is confidential.
        # 
        # >  For more information, see [Sensitivity levels of fields](~~66091~~).
        self.security_level = security_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_increment is not None:
            result['AutoIncrement'] = self.auto_increment
        if self.column_id is not None:
            result['ColumnId'] = self.column_id
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.data_length is not None:
            result['DataLength'] = self.data_length
        if self.data_precision is not None:
            result['DataPrecision'] = self.data_precision
        if self.data_scale is not None:
            result['DataScale'] = self.data_scale
        if self.description is not None:
            result['Description'] = self.description
        if self.nullable is not None:
            result['Nullable'] = self.nullable
        if self.position is not None:
            result['Position'] = self.position
        if self.primary_key is not None:
            result['PrimaryKey'] = self.primary_key
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoIncrement') is not None:
            self.auto_increment = m.get('AutoIncrement')
        if m.get('ColumnId') is not None:
            self.column_id = m.get('ColumnId')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DataLength') is not None:
            self.data_length = m.get('DataLength')
        if m.get('DataPrecision') is not None:
            self.data_precision = m.get('DataPrecision')
        if m.get('DataScale') is not None:
            self.data_scale = m.get('DataScale')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Nullable') is not None:
            self.nullable = m.get('Nullable')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('PrimaryKey') is not None:
            self.primary_key = m.get('PrimaryKey')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        return self


class GetMetaTableColumnResponseBody(TeaModel):
    def __init__(
        self,
        column_list: List[GetMetaTableColumnResponseBodyColumnList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The details about fields in the table.
        self.column_list = column_list
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.column_list:
            for k in self.column_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ColumnList'] = []
        if self.column_list is not None:
            for k in self.column_list:
                result['ColumnList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.column_list = []
        if m.get('ColumnList') is not None:
            for k in m.get('ColumnList'):
                temp_model = GetMetaTableColumnResponseBodyColumnList()
                self.column_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetMetaTableColumnResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMetaTableColumnResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMetaTableColumnResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMetaTableDetailInfoRequest(TeaModel):
    def __init__(
        self,
        table_guid: str = None,
        tid: int = None,
    ):
        self.table_guid = table_guid
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetMetaTableDetailInfoResponseBodyDetailInfoColumnList(TeaModel):
    def __init__(
        self,
        auto_increment: bool = None,
        column_id: str = None,
        column_name: str = None,
        column_type: str = None,
        data_length: int = None,
        data_precision: int = None,
        data_scale: int = None,
        description: str = None,
        nullable: bool = None,
        position: str = None,
    ):
        self.auto_increment = auto_increment
        self.column_id = column_id
        self.column_name = column_name
        self.column_type = column_type
        self.data_length = data_length
        self.data_precision = data_precision
        self.data_scale = data_scale
        self.description = description
        self.nullable = nullable
        self.position = position

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_increment is not None:
            result['AutoIncrement'] = self.auto_increment
        if self.column_id is not None:
            result['ColumnId'] = self.column_id
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.data_length is not None:
            result['DataLength'] = self.data_length
        if self.data_precision is not None:
            result['DataPrecision'] = self.data_precision
        if self.data_scale is not None:
            result['DataScale'] = self.data_scale
        if self.description is not None:
            result['Description'] = self.description
        if self.nullable is not None:
            result['Nullable'] = self.nullable
        if self.position is not None:
            result['Position'] = self.position
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoIncrement') is not None:
            self.auto_increment = m.get('AutoIncrement')
        if m.get('ColumnId') is not None:
            self.column_id = m.get('ColumnId')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DataLength') is not None:
            self.data_length = m.get('DataLength')
        if m.get('DataPrecision') is not None:
            self.data_precision = m.get('DataPrecision')
        if m.get('DataScale') is not None:
            self.data_scale = m.get('DataScale')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Nullable') is not None:
            self.nullable = m.get('Nullable')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        return self


class GetMetaTableDetailInfoResponseBodyDetailInfoIndexList(TeaModel):
    def __init__(
        self,
        index_columns: List[str] = None,
        index_id: str = None,
        index_name: str = None,
        index_type: str = None,
        unique: bool = None,
    ):
        self.index_columns = index_columns
        self.index_id = index_id
        self.index_name = index_name
        self.index_type = index_type
        self.unique = unique

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_columns is not None:
            result['IndexColumns'] = self.index_columns
        if self.index_id is not None:
            result['IndexId'] = self.index_id
        if self.index_name is not None:
            result['IndexName'] = self.index_name
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        if self.unique is not None:
            result['Unique'] = self.unique
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndexColumns') is not None:
            self.index_columns = m.get('IndexColumns')
        if m.get('IndexId') is not None:
            self.index_id = m.get('IndexId')
        if m.get('IndexName') is not None:
            self.index_name = m.get('IndexName')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        if m.get('Unique') is not None:
            self.unique = m.get('Unique')
        return self


class GetMetaTableDetailInfoResponseBodyDetailInfo(TeaModel):
    def __init__(
        self,
        column_list: List[GetMetaTableDetailInfoResponseBodyDetailInfoColumnList] = None,
        index_list: List[GetMetaTableDetailInfoResponseBodyDetailInfoIndexList] = None,
    ):
        self.column_list = column_list
        self.index_list = index_list

    def validate(self):
        if self.column_list:
            for k in self.column_list:
                if k:
                    k.validate()
        if self.index_list:
            for k in self.index_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ColumnList'] = []
        if self.column_list is not None:
            for k in self.column_list:
                result['ColumnList'].append(k.to_map() if k else None)
        result['IndexList'] = []
        if self.index_list is not None:
            for k in self.index_list:
                result['IndexList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.column_list = []
        if m.get('ColumnList') is not None:
            for k in m.get('ColumnList'):
                temp_model = GetMetaTableDetailInfoResponseBodyDetailInfoColumnList()
                self.column_list.append(temp_model.from_map(k))
        self.index_list = []
        if m.get('IndexList') is not None:
            for k in m.get('IndexList'):
                temp_model = GetMetaTableDetailInfoResponseBodyDetailInfoIndexList()
                self.index_list.append(temp_model.from_map(k))
        return self


class GetMetaTableDetailInfoResponseBody(TeaModel):
    def __init__(
        self,
        detail_info: GetMetaTableDetailInfoResponseBodyDetailInfo = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.detail_info = detail_info
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.detail_info:
            self.detail_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.detail_info is not None:
            result['DetailInfo'] = self.detail_info.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DetailInfo') is not None:
            temp_model = GetMetaTableDetailInfoResponseBodyDetailInfo()
            self.detail_info = temp_model.from_map(m['DetailInfo'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetMetaTableDetailInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMetaTableDetailInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMetaTableDetailInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOnlineDDLProgressRequest(TeaModel):
    def __init__(
        self,
        job_detail_id: int = None,
        tid: int = None,
    ):
        self.job_detail_id = job_detail_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_detail_id is not None:
            result['JobDetailId'] = self.job_detail_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobDetailId') is not None:
            self.job_detail_id = m.get('JobDetailId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail(TeaModel):
    def __init__(
        self,
        clean_strategy: str = None,
        copy_chunk_mode: str = None,
        copy_chunk_size: int = None,
        copy_count: int = None,
        copy_total: int = None,
        cutover_fail_retry_times: int = None,
        cutover_lock_time_seconds: int = None,
        cutover_window_end_time: str = None,
        cutover_window_start_time: str = None,
        delay_seconds: int = None,
        job_status: str = None,
        progress_ratio: str = None,
        status_desc: str = None,
    ):
        self.clean_strategy = clean_strategy
        self.copy_chunk_mode = copy_chunk_mode
        self.copy_chunk_size = copy_chunk_size
        self.copy_count = copy_count
        self.copy_total = copy_total
        self.cutover_fail_retry_times = cutover_fail_retry_times
        self.cutover_lock_time_seconds = cutover_lock_time_seconds
        self.cutover_window_end_time = cutover_window_end_time
        self.cutover_window_start_time = cutover_window_start_time
        self.delay_seconds = delay_seconds
        self.job_status = job_status
        self.progress_ratio = progress_ratio
        self.status_desc = status_desc

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clean_strategy is not None:
            result['CleanStrategy'] = self.clean_strategy
        if self.copy_chunk_mode is not None:
            result['CopyChunkMode'] = self.copy_chunk_mode
        if self.copy_chunk_size is not None:
            result['CopyChunkSize'] = self.copy_chunk_size
        if self.copy_count is not None:
            result['CopyCount'] = self.copy_count
        if self.copy_total is not None:
            result['CopyTotal'] = self.copy_total
        if self.cutover_fail_retry_times is not None:
            result['CutoverFailRetryTimes'] = self.cutover_fail_retry_times
        if self.cutover_lock_time_seconds is not None:
            result['CutoverLockTimeSeconds'] = self.cutover_lock_time_seconds
        if self.cutover_window_end_time is not None:
            result['CutoverWindowEndTime'] = self.cutover_window_end_time
        if self.cutover_window_start_time is not None:
            result['CutoverWindowStartTime'] = self.cutover_window_start_time
        if self.delay_seconds is not None:
            result['DelaySeconds'] = self.delay_seconds
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.progress_ratio is not None:
            result['ProgressRatio'] = self.progress_ratio
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CleanStrategy') is not None:
            self.clean_strategy = m.get('CleanStrategy')
        if m.get('CopyChunkMode') is not None:
            self.copy_chunk_mode = m.get('CopyChunkMode')
        if m.get('CopyChunkSize') is not None:
            self.copy_chunk_size = m.get('CopyChunkSize')
        if m.get('CopyCount') is not None:
            self.copy_count = m.get('CopyCount')
        if m.get('CopyTotal') is not None:
            self.copy_total = m.get('CopyTotal')
        if m.get('CutoverFailRetryTimes') is not None:
            self.cutover_fail_retry_times = m.get('CutoverFailRetryTimes')
        if m.get('CutoverLockTimeSeconds') is not None:
            self.cutover_lock_time_seconds = m.get('CutoverLockTimeSeconds')
        if m.get('CutoverWindowEndTime') is not None:
            self.cutover_window_end_time = m.get('CutoverWindowEndTime')
        if m.get('CutoverWindowStartTime') is not None:
            self.cutover_window_start_time = m.get('CutoverWindowStartTime')
        if m.get('DelaySeconds') is not None:
            self.delay_seconds = m.get('DelaySeconds')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('ProgressRatio') is not None:
            self.progress_ratio = m.get('ProgressRatio')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        return self


class GetOnlineDDLProgressResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        online_ddltask_detail: GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.online_ddltask_detail = online_ddltask_detail
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.online_ddltask_detail:
            self.online_ddltask_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.online_ddltask_detail is not None:
            result['OnlineDDLTaskDetail'] = self.online_ddltask_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OnlineDDLTaskDetail') is not None:
            temp_model = GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail()
            self.online_ddltask_detail = temp_model.from_map(m['OnlineDDLTaskDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetOnlineDDLProgressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOnlineDDLProgressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOnlineDDLProgressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOpLogRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        module: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time: str = None,
        tid: int = None,
    ):
        # The end of the time range to query. Specify the time in the yyyy-MM-DD HH:mm:ss format.
        self.end_time = end_time
        # The functional module for which you want to query operation logs. If you do not specify this parameter, operation logs for all functional modules are returned. Valid values:
        # 
        # *   **PERMISSION**: permissions
        # *   **OWNER**: data owner
        # *   **SQL_CONSOLE**: data query
        # *   **SQL_CONSOLE_EXPORT**: query result export
        # *   **DATA_CHANGE**: data change
        # *   **DATA_EXPORT**: data export
        # *   **SQL_REVIEW**: SQL review
        # *   **DT_SYNC**: database and table synchronization
        # *   **DT_DETAIL**: database and table details
        # *   **DB_TASK**: task management
        # *   **INSTANCE_MANAGE**: instance management
        # *   **USER_MANAGE**: user management
        # *   **SECURITY_RULE**: security rule
        # *   **CONFIG_MANAGE**: configuration management
        # *   **RESOURCE_AUTH**: resource authorization
        # *   **ACCESS_WHITE_IP**: access IP address allowlist
        self.module = module
        # The number of the page to return. Pages start from page 1.
        self.page_number = page_number
        # The number of entries to return on each page. Valid values:
        # 
        # *   30
        # *   50
        # *   100
        self.page_size = page_size
        # The beginning of the time range to query. Specify the time in the yyyy-MM-DD HH:mm:ss format.
        self.start_time = start_time
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.module is not None:
            result['Module'] = self.module
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Module') is not None:
            self.module = m.get('Module')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOpLogResponseBodyOpLogDetailsOpLogDetail(TeaModel):
    def __init__(
        self,
        database: str = None,
        module: str = None,
        op_content: str = None,
        op_time: str = None,
        op_user_id: int = None,
        order_id: int = None,
        user_id: str = None,
        user_nick: str = None,
    ):
        # The endpoint of the database instance.
        # 
        # > *   This parameter is valid only for database instances of the LocalInstance type.
        # *   This parameter is valid only for operations on the functional modules related to tasks.
        self.database = database
        # The functional module for which the operation log is queried.
        self.module = module
        # The details of the operation.
        self.op_content = op_content
        # The time when the operation was performed.
        self.op_time = op_time
        # The ID of the user who performed the operation.
        self.op_user_id = op_user_id
        # The ID of the ticket or task.
        # 
        # >  This parameter is valid only for operations on the functional modules related to tasks and the task management module in system management.
        self.order_id = order_id
        # The UID of the Alibaba Cloud account.
        self.user_id = user_id
        # The display name of the user.
        self.user_nick = user_nick

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database
        if self.module is not None:
            result['Module'] = self.module
        if self.op_content is not None:
            result['OpContent'] = self.op_content
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        if self.op_user_id is not None:
            result['OpUserId'] = self.op_user_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Database') is not None:
            self.database = m.get('Database')
        if m.get('Module') is not None:
            self.module = m.get('Module')
        if m.get('OpContent') is not None:
            self.op_content = m.get('OpContent')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        if m.get('OpUserId') is not None:
            self.op_user_id = m.get('OpUserId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class GetOpLogResponseBodyOpLogDetails(TeaModel):
    def __init__(
        self,
        op_log_detail: List[GetOpLogResponseBodyOpLogDetailsOpLogDetail] = None,
    ):
        self.op_log_detail = op_log_detail

    def validate(self):
        if self.op_log_detail:
            for k in self.op_log_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OpLogDetail'] = []
        if self.op_log_detail is not None:
            for k in self.op_log_detail:
                result['OpLogDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.op_log_detail = []
        if m.get('OpLogDetail') is not None:
            for k in m.get('OpLogDetail'):
                temp_model = GetOpLogResponseBodyOpLogDetailsOpLogDetail()
                self.op_log_detail.append(temp_model.from_map(k))
        return self


class GetOpLogResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        op_log_details: GetOpLogResponseBodyOpLogDetails = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The details of the operation log.
        self.op_log_details = op_log_details
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - **true**: The request is successful.
        # - **false**: The request fails.
        self.success = success
        # The total number of operation logs that are returned.
        self.total_count = total_count

    def validate(self):
        if self.op_log_details:
            self.op_log_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.op_log_details is not None:
            result['OpLogDetails'] = self.op_log_details.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OpLogDetails') is not None:
            temp_model = GetOpLogResponseBodyOpLogDetails()
            self.op_log_details = temp_model.from_map(m['OpLogDetails'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetOpLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOpLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOpLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOrderAttachmentFileRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOrderAttachmentFileResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        file_url: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.file_url = file_url
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetOrderAttachmentFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOrderAttachmentFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOrderAttachmentFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOrderBaseInfoRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList(TeaModel):
    def __init__(
        self,
        user_ids: List[str] = None,
    ):
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_ids is not None:
            result['UserIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserIds') is not None:
            self.user_ids = m.get('UserIds')
        return self


class GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList(TeaModel):
    def __init__(
        self,
        user_nicks: List[str] = None,
    ):
        self.user_nicks = user_nicks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_nicks is not None:
            result['UserNicks'] = self.user_nicks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserNicks') is not None:
            self.user_nicks = m.get('UserNicks')
        return self


class GetOrderBaseInfoResponseBodyOrderBaseInfo(TeaModel):
    def __init__(
        self,
        comment: str = None,
        committer: str = None,
        committer_id: int = None,
        create_time: str = None,
        last_modify_time: str = None,
        order_id: int = None,
        plugin_type: str = None,
        related_user_list: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList = None,
        related_user_nick_list: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList = None,
        status_code: str = None,
        status_desc: str = None,
        workflow_instance_id: int = None,
        workflow_status_desc: str = None,
    ):
        self.comment = comment
        self.committer = committer
        self.committer_id = committer_id
        self.create_time = create_time
        self.last_modify_time = last_modify_time
        self.order_id = order_id
        self.plugin_type = plugin_type
        self.related_user_list = related_user_list
        self.related_user_nick_list = related_user_nick_list
        self.status_code = status_code
        self.status_desc = status_desc
        self.workflow_instance_id = workflow_instance_id
        self.workflow_status_desc = workflow_status_desc

    def validate(self):
        if self.related_user_list:
            self.related_user_list.validate()
        if self.related_user_nick_list:
            self.related_user_nick_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.committer is not None:
            result['Committer'] = self.committer
        if self.committer_id is not None:
            result['CommitterId'] = self.committer_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modify_time is not None:
            result['LastModifyTime'] = self.last_modify_time
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.related_user_list is not None:
            result['RelatedUserList'] = self.related_user_list.to_map()
        if self.related_user_nick_list is not None:
            result['RelatedUserNickList'] = self.related_user_nick_list.to_map()
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        if self.workflow_status_desc is not None:
            result['WorkflowStatusDesc'] = self.workflow_status_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Committer') is not None:
            self.committer = m.get('Committer')
        if m.get('CommitterId') is not None:
            self.committer_id = m.get('CommitterId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModifyTime') is not None:
            self.last_modify_time = m.get('LastModifyTime')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('RelatedUserList') is not None:
            temp_model = GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList()
            self.related_user_list = temp_model.from_map(m['RelatedUserList'])
        if m.get('RelatedUserNickList') is not None:
            temp_model = GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList()
            self.related_user_nick_list = temp_model.from_map(m['RelatedUserNickList'])
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        if m.get('WorkflowStatusDesc') is not None:
            self.workflow_status_desc = m.get('WorkflowStatusDesc')
        return self


class GetOrderBaseInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        order_base_info: GetOrderBaseInfoResponseBodyOrderBaseInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.order_base_info = order_base_info
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.order_base_info:
            self.order_base_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.order_base_info is not None:
            result['OrderBaseInfo'] = self.order_base_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OrderBaseInfo') is not None:
            temp_model = GetOrderBaseInfoResponseBodyOrderBaseInfo()
            self.order_base_info = temp_model.from_map(m['OrderBaseInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetOrderBaseInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOrderBaseInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOrderBaseInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOwnerApplyOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        env_type: str = None,
        owner_ids: List[int] = None,
        owner_nick_names: List[str] = None,
        search_name: str = None,
        table_name: str = None,
    ):
        self.db_type = db_type
        self.env_type = env_type
        self.owner_ids = owner_ids
        self.owner_nick_names = owner_nick_names
        self.search_name = search_name
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_nick_names is not None:
            result['OwnerNickNames'] = self.owner_nick_names
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerNickNames') is not None:
            self.owner_nick_names = m.get('OwnerNickNames')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources(TeaModel):
    def __init__(
        self,
        logic: bool = None,
        resource_detail: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail = None,
        target_id: str = None,
    ):
        self.logic = logic
        self.resource_detail = resource_detail
        self.target_id = target_id

    def validate(self):
        if self.resource_detail:
            self.resource_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.resource_detail is not None:
            result['ResourceDetail'] = self.resource_detail.to_map()
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('ResourceDetail') is not None:
            temp_model = GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail()
            self.resource_detail = temp_model.from_map(m['ResourceDetail'])
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        return self


class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail(TeaModel):
    def __init__(
        self,
        apply_type: str = None,
        resources: List[GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources] = None,
    ):
        self.apply_type = apply_type
        self.resources = resources

    def validate(self):
        if self.resources:
            for k in self.resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_type is not None:
            result['ApplyType'] = self.apply_type
        result['Resources'] = []
        if self.resources is not None:
            for k in self.resources:
                result['Resources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyType') is not None:
            self.apply_type = m.get('ApplyType')
        self.resources = []
        if m.get('Resources') is not None:
            for k in m.get('Resources'):
                temp_model = GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources()
                self.resources.append(temp_model.from_map(k))
        return self


class GetOwnerApplyOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        owner_apply_order_detail: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.owner_apply_order_detail = owner_apply_order_detail
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.owner_apply_order_detail:
            self.owner_apply_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.owner_apply_order_detail is not None:
            result['OwnerApplyOrderDetail'] = self.owner_apply_order_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OwnerApplyOrderDetail') is not None:
            temp_model = GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail()
            self.owner_apply_order_detail = temp_model.from_map(m['OwnerApplyOrderDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetOwnerApplyOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOwnerApplyOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOwnerApplyOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPermApplyOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        table_name: str = None,
    ):
        self.column_name = column_name
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        owner_ids: List[int] = None,
        owner_nick_names: List[str] = None,
        search_name: str = None,
    ):
        self.db_id = db_id
        self.db_type = db_type
        self.env_type = env_type
        self.logic = logic
        self.owner_ids = owner_ids
        self.owner_nick_names = owner_nick_names
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_nick_names is not None:
            result['OwnerNickNames'] = self.owner_nick_names
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerNickNames') is not None:
            self.owner_nick_names = m.get('OwnerNickNames')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        dba_id: int = None,
        dba_nick_name: str = None,
        env_type: str = None,
        host: str = None,
        instance_id: str = None,
        owner_ids: List[int] = None,
        owner_nick_name: List[str] = None,
        port: int = None,
        search_name: str = None,
    ):
        self.db_type = db_type
        self.dba_id = dba_id
        self.dba_nick_name = dba_nick_name
        self.env_type = env_type
        self.host = host
        self.instance_id = instance_id
        self.owner_ids = owner_ids
        self.owner_nick_name = owner_nick_name
        self.port = port
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_nick_name is not None:
            result['DbaNickName'] = self.dba_nick_name
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_nick_name is not None:
            result['OwnerNickName'] = self.owner_nick_name
        if self.port is not None:
            result['Port'] = self.port
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaNickName') is not None:
            self.dba_nick_name = m.get('DbaNickName')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerNickName') is not None:
            self.owner_nick_name = m.get('OwnerNickName')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo(TeaModel):
    def __init__(
        self,
        table_name: str = None,
    ):
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources(TeaModel):
    def __init__(
        self,
        column_info: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo = None,
        database_info: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo = None,
        instance_info: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo = None,
        table_info: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo = None,
    ):
        self.column_info = column_info
        self.database_info = database_info
        self.instance_info = instance_info
        self.table_info = table_info

    def validate(self):
        if self.column_info:
            self.column_info.validate()
        if self.database_info:
            self.database_info.validate()
        if self.instance_info:
            self.instance_info.validate()
        if self.table_info:
            self.table_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_info is not None:
            result['ColumnInfo'] = self.column_info.to_map()
        if self.database_info is not None:
            result['DatabaseInfo'] = self.database_info.to_map()
        if self.instance_info is not None:
            result['InstanceInfo'] = self.instance_info.to_map()
        if self.table_info is not None:
            result['TableInfo'] = self.table_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnInfo') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo()
            self.column_info = temp_model.from_map(m['ColumnInfo'])
        if m.get('DatabaseInfo') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo()
            self.database_info = temp_model.from_map(m['DatabaseInfo'])
        if m.get('InstanceInfo') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo()
            self.instance_info = temp_model.from_map(m['InstanceInfo'])
        if m.get('TableInfo') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo()
            self.table_info = temp_model.from_map(m['TableInfo'])
        return self


class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail(TeaModel):
    def __init__(
        self,
        apply_type: str = None,
        perm_type: int = None,
        resources: List[GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources] = None,
        seconds: int = None,
    ):
        self.apply_type = apply_type
        self.perm_type = perm_type
        self.resources = resources
        self.seconds = seconds

    def validate(self):
        if self.resources:
            for k in self.resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_type is not None:
            result['ApplyType'] = self.apply_type
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        result['Resources'] = []
        if self.resources is not None:
            for k in self.resources:
                result['Resources'].append(k.to_map() if k else None)
        if self.seconds is not None:
            result['Seconds'] = self.seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyType') is not None:
            self.apply_type = m.get('ApplyType')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        self.resources = []
        if m.get('Resources') is not None:
            for k in m.get('Resources'):
                temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources()
                self.resources.append(temp_model.from_map(k))
        if m.get('Seconds') is not None:
            self.seconds = m.get('Seconds')
        return self


class GetPermApplyOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        perm_apply_order_detail: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.perm_apply_order_detail = perm_apply_order_detail
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.perm_apply_order_detail:
            self.perm_apply_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.perm_apply_order_detail is not None:
            result['PermApplyOrderDetail'] = self.perm_apply_order_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PermApplyOrderDetail') is not None:
            temp_model = GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail()
            self.perm_apply_order_detail = temp_model.from_map(m['PermApplyOrderDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetPermApplyOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPermApplyOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPermApplyOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPhysicalDatabaseRequest(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        tid: int = None,
    ):
        self.db_id = db_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class GetPhysicalDatabaseResponseBodyDatabase(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        database_id: str = None,
        db_type: str = None,
        dba_id: str = None,
        dba_name: str = None,
        encoding: str = None,
        env_type: str = None,
        host: str = None,
        instance_id: str = None,
        owner_id_list: GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList = None,
        owner_name_list: GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList = None,
        port: int = None,
        schema_name: str = None,
        search_name: str = None,
        sid: str = None,
        state: str = None,
    ):
        self.catalog_name = catalog_name
        self.database_id = database_id
        self.db_type = db_type
        self.dba_id = dba_id
        self.dba_name = dba_name
        self.encoding = encoding
        self.env_type = env_type
        self.host = host
        self.instance_id = instance_id
        self.owner_id_list = owner_id_list
        self.owner_name_list = owner_name_list
        self.port = port
        self.schema_name = schema_name
        self.search_name = search_name
        self.sid = sid
        self.state = state

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_name is not None:
            result['DbaName'] = self.dba_name
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaName') is not None:
            self.dba_name = m.get('DbaName')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerIdList') is not None:
            temp_model = GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class GetPhysicalDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        database: GetPhysicalDatabaseResponseBodyDatabase = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.database = database
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.database:
            self.database.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database is not None:
            result['Database'] = self.database.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Database') is not None:
            temp_model = GetPhysicalDatabaseResponseBodyDatabase()
            self.database = temp_model.from_map(m['Database'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetPhysicalDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPhysicalDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPhysicalDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProxyRequest(TeaModel):
    def __init__(
        self,
        instance_id: int = None,
        proxy_id: int = None,
        tid: int = None,
    ):
        # The ID of the database instance. You can call the [ListInstances](https://www.alibabacloud.com/help/en/data-management-service/latest/listinstances) or [GetInstance](https://www.alibabacloud.com/help/en/data-management-service/latest/getinstance) operation to query the database instance ID.
        self.instance_id = instance_id
        # The ID of the secure access proxy. You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) operation to query the ID of the secure access proxy.
        self.proxy_id = proxy_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetProxyResponseBody(TeaModel):
    def __init__(
        self,
        creator_id: int = None,
        creator_name: str = None,
        error_code: str = None,
        error_message: str = None,
        https_port: int = None,
        instance_id: int = None,
        private_enable: bool = None,
        private_host: str = None,
        protocol_port: int = None,
        protocol_type: str = None,
        proxy_id: int = None,
        public_enable: bool = None,
        public_host: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the user who enabled the secure access proxy feature.
        self.creator_id = creator_id
        # The nickname of the user who enabled the secure access proxy feature.
        self.creator_name = creator_name
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The port that was used by HTTPS clients to connect to the database instance.
        self.https_port = https_port
        # The ID of the database instance.
        self.instance_id = instance_id
        # Indicates whether the internal endpoint is enabled. Default value: **true**.
        self.private_enable = private_enable
        # The internal endpoint.
        self.private_host = private_host
        self.protocol_port = protocol_port
        self.protocol_type = protocol_type
        # The ID of the secure access proxy.
        self.proxy_id = proxy_id
        # Indicates whether the public endpoint is enabled. Valid values:
        # 
        # - **true**: The public endpoint is enabled.
        # - **false**: The public endpoint is disabled.
        self.public_enable = public_enable
        # The public endpoint. A public endpoint is returned no matter whether the public endpoint is enabled or disabled.  
        # 
        # > - If the value of the PublicEnable parameter is **true**, a valid public endpoint that can be resolved by using Alibaba Cloud DNS (DNS) is returned.
        # - If the value of the PublicEnable parameter is **false**, an invalid public endpoint that cannot be resolved by using DNS is returned.
        self.public_host = public_host
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_name is not None:
            result['CreatorName'] = self.creator_name
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.https_port is not None:
            result['HttpsPort'] = self.https_port
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.private_enable is not None:
            result['PrivateEnable'] = self.private_enable
        if self.private_host is not None:
            result['PrivateHost'] = self.private_host
        if self.protocol_port is not None:
            result['ProtocolPort'] = self.protocol_port
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.public_enable is not None:
            result['PublicEnable'] = self.public_enable
        if self.public_host is not None:
            result['PublicHost'] = self.public_host
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorName') is not None:
            self.creator_name = m.get('CreatorName')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HttpsPort') is not None:
            self.https_port = m.get('HttpsPort')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PrivateEnable') is not None:
            self.private_enable = m.get('PrivateEnable')
        if m.get('PrivateHost') is not None:
            self.private_host = m.get('PrivateHost')
        if m.get('ProtocolPort') is not None:
            self.protocol_port = m.get('ProtocolPort')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('PublicEnable') is not None:
            self.public_enable = m.get('PublicEnable')
        if m.get('PublicHost') is not None:
            self.public_host = m.get('PublicHost')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetProxyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProxyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProxyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProxyAccessRequest(TeaModel):
    def __init__(
        self,
        proxy_access_id: int = None,
        tid: int = None,
    ):
        self.proxy_access_id = proxy_access_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetProxyAccessResponseBodyProxyAccess(TeaModel):
    def __init__(
        self,
        access_id: str = None,
        gmt_create: str = None,
        indep_account: str = None,
        instance_id: int = None,
        origin_info: str = None,
        proxy_access_id: int = None,
        proxy_id: int = None,
        user_id: int = None,
        user_name: str = None,
        user_uid: str = None,
    ):
        self.access_id = access_id
        self.gmt_create = gmt_create
        self.indep_account = indep_account
        self.instance_id = instance_id
        self.origin_info = origin_info
        self.proxy_access_id = proxy_access_id
        self.proxy_id = proxy_id
        self.user_id = user_id
        self.user_name = user_name
        self.user_uid = user_uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.indep_account is not None:
            result['IndepAccount'] = self.indep_account
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.origin_info is not None:
            result['OriginInfo'] = self.origin_info
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_uid is not None:
            result['UserUid'] = self.user_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('IndepAccount') is not None:
            self.indep_account = m.get('IndepAccount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OriginInfo') is not None:
            self.origin_info = m.get('OriginInfo')
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserUid') is not None:
            self.user_uid = m.get('UserUid')
        return self


class GetProxyAccessResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        proxy_access: GetProxyAccessResponseBodyProxyAccess = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.proxy_access = proxy_access
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.proxy_access:
            self.proxy_access.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.proxy_access is not None:
            result['ProxyAccess'] = self.proxy_access.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProxyAccess') is not None:
            temp_model = GetProxyAccessResponseBodyProxyAccess()
            self.proxy_access = temp_model.from_map(m['ProxyAccess'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetProxyAccessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProxyAccessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProxyAccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRuleNumLimitOfSLARequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetRuleNumLimitOfSLAResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        rule_num_limit: int = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # The maximum number of SLA rules.
        self.rule_num_limit = rule_num_limit
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_num_limit is not None:
            result['RuleNumLimit'] = self.rule_num_limit
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleNumLimit') is not None:
            self.rule_num_limit = m.get('RuleNumLimit')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRuleNumLimitOfSLAResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRuleNumLimitOfSLAResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRuleNumLimitOfSLAResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSQLReviewCheckResultStatusRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult(TeaModel):
    def __init__(
        self,
        check_not_pass: int = None,
        check_pass: int = None,
        force_not_pass: int = None,
        force_pass: int = None,
        new: int = None,
        unknown: int = None,
    ):
        self.check_not_pass = check_not_pass
        self.check_pass = check_pass
        self.force_not_pass = force_not_pass
        self.force_pass = force_pass
        self.new = new
        self.unknown = unknown

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_not_pass is not None:
            result['CheckNotPass'] = self.check_not_pass
        if self.check_pass is not None:
            result['CheckPass'] = self.check_pass
        if self.force_not_pass is not None:
            result['ForceNotPass'] = self.force_not_pass
        if self.force_pass is not None:
            result['ForcePass'] = self.force_pass
        if self.new is not None:
            result['New'] = self.new
        if self.unknown is not None:
            result['Unknown'] = self.unknown
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckNotPass') is not None:
            self.check_not_pass = m.get('CheckNotPass')
        if m.get('CheckPass') is not None:
            self.check_pass = m.get('CheckPass')
        if m.get('ForceNotPass') is not None:
            self.force_not_pass = m.get('ForceNotPass')
        if m.get('ForcePass') is not None:
            self.force_pass = m.get('ForcePass')
        if m.get('New') is not None:
            self.new = m.get('New')
        if m.get('Unknown') is not None:
            self.unknown = m.get('Unknown')
        return self


class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult(TeaModel):
    def __init__(
        self,
        must_improve: int = None,
        potential_issue: int = None,
        suggest_improve: int = None,
        table_index_suggest: int = None,
        use_dms_dml_unlock: int = None,
        use_dms_toolkit: int = None,
    ):
        self.must_improve = must_improve
        self.potential_issue = potential_issue
        self.suggest_improve = suggest_improve
        self.table_index_suggest = table_index_suggest
        self.use_dms_dml_unlock = use_dms_dml_unlock
        self.use_dms_toolkit = use_dms_toolkit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.must_improve is not None:
            result['MustImprove'] = self.must_improve
        if self.potential_issue is not None:
            result['PotentialIssue'] = self.potential_issue
        if self.suggest_improve is not None:
            result['SuggestImprove'] = self.suggest_improve
        if self.table_index_suggest is not None:
            result['TableIndexSuggest'] = self.table_index_suggest
        if self.use_dms_dml_unlock is not None:
            result['UseDmsDmlUnlock'] = self.use_dms_dml_unlock
        if self.use_dms_toolkit is not None:
            result['UseDmsToolkit'] = self.use_dms_toolkit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MustImprove') is not None:
            self.must_improve = m.get('MustImprove')
        if m.get('PotentialIssue') is not None:
            self.potential_issue = m.get('PotentialIssue')
        if m.get('SuggestImprove') is not None:
            self.suggest_improve = m.get('SuggestImprove')
        if m.get('TableIndexSuggest') is not None:
            self.table_index_suggest = m.get('TableIndexSuggest')
        if m.get('UseDmsDmlUnlock') is not None:
            self.use_dms_dml_unlock = m.get('UseDmsDmlUnlock')
        if m.get('UseDmsToolkit') is not None:
            self.use_dms_toolkit = m.get('UseDmsToolkit')
        return self


class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus(TeaModel):
    def __init__(
        self,
        check_status_result: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult = None,
        checked_count: int = None,
        sqlreview_result: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult = None,
        total_sqlcount: int = None,
    ):
        self.check_status_result = check_status_result
        self.checked_count = checked_count
        self.sqlreview_result = sqlreview_result
        self.total_sqlcount = total_sqlcount

    def validate(self):
        if self.check_status_result:
            self.check_status_result.validate()
        if self.sqlreview_result:
            self.sqlreview_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_status_result is not None:
            result['CheckStatusResult'] = self.check_status_result.to_map()
        if self.checked_count is not None:
            result['CheckedCount'] = self.checked_count
        if self.sqlreview_result is not None:
            result['SQLReviewResult'] = self.sqlreview_result.to_map()
        if self.total_sqlcount is not None:
            result['TotalSQLCount'] = self.total_sqlcount
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckStatusResult') is not None:
            temp_model = GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult()
            self.check_status_result = temp_model.from_map(m['CheckStatusResult'])
        if m.get('CheckedCount') is not None:
            self.checked_count = m.get('CheckedCount')
        if m.get('SQLReviewResult') is not None:
            temp_model = GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult()
            self.sqlreview_result = temp_model.from_map(m['SQLReviewResult'])
        if m.get('TotalSQLCount') is not None:
            self.total_sqlcount = m.get('TotalSQLCount')
        return self


class GetSQLReviewCheckResultStatusResponseBody(TeaModel):
    def __init__(
        self,
        check_result_status: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.check_result_status = check_result_status
        self.error_code = error_code
        self.error_message = error_message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.check_result_status:
            self.check_result_status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_result_status is not None:
            result['CheckResultStatus'] = self.check_result_status.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckResultStatus') is not None:
            temp_model = GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus()
            self.check_result_status = temp_model.from_map(m['CheckResultStatus'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSQLReviewCheckResultStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSQLReviewCheckResultStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSQLReviewCheckResultStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSQLReviewOptimizeDetailRequest(TeaModel):
    def __init__(
        self,
        sqlreview_query_key: str = None,
        tid: int = None,
    ):
        # The key that is used to query the details of optimization suggestions. You can call the [ListSQLReviewOriginSQL](~~257870~~) operation to query the key.
        self.sqlreview_query_key = sqlreview_query_key
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sqlreview_query_key is not None:
            result['SQLReviewQueryKey'] = self.sqlreview_query_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SQLReviewQueryKey') is not None:
            self.sqlreview_query_key = m.get('SQLReviewQueryKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts(TeaModel):
    def __init__(
        self,
        content: str = None,
        op_type: str = None,
        table_name: str = None,
    ):
        # The content of the SQL script.
        self.content = content
        # The purpose of the SQL script. The value is set to AddIndex.
        self.op_type = op_type
        # The name of the table.
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.op_type is not None:
            result['OpType'] = self.op_type
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('OpType') is not None:
            self.op_type = m.get('OpType')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults(TeaModel):
    def __init__(
        self,
        comments: str = None,
        feedback: str = None,
        messages: List[str] = None,
        rule_name: str = None,
        rule_type: str = None,
        scripts: List[GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts] = None,
    ):
        # The comment that is specified when you create the SQL review rule. For more information, see [SQL review optimization](~~194114~~).
        self.comments = comments
        # The optimization suggestion for the SQL statement. Valid values:
        # 
        # *   **MUST_IMPROVE**: The SQL statement must be improved.
        # *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
        # *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
        # *   **USEDMSTOOLKIT**: We recommend that you change schemas without locking tables.
        # *   **USEDMSDML_UNLOCK**: We recommend that you change data without locking tables.
        # *   **TABLEINDEXSUGGEST**: We recommend that you use SQL statements that use indexes.
        self.feedback = feedback
        # The review results.
        self.messages = messages
        # The name of the rule. For more information, see [SQL review optimization](~~194114~~).
        self.rule_name = rule_name
        # The type of the SQL review rule. Valid values:
        # 
        # *   **REVIEW**: a rule that is used to review SQL statements based on standards.
        # *   **OPTIMIZE**: a rule that is used to provide optimization suggestions.
        self.rule_type = rule_type
        # The SQL script for data changes.
        self.scripts = scripts

    def validate(self):
        if self.scripts:
            for k in self.scripts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comments is not None:
            result['Comments'] = self.comments
        if self.feedback is not None:
            result['Feedback'] = self.feedback
        if self.messages is not None:
            result['Messages'] = self.messages
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        result['Scripts'] = []
        if self.scripts is not None:
            for k in self.scripts:
                result['Scripts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comments') is not None:
            self.comments = m.get('Comments')
        if m.get('Feedback') is not None:
            self.feedback = m.get('Feedback')
        if m.get('Messages') is not None:
            self.messages = m.get('Messages')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        self.scripts = []
        if m.get('Scripts') is not None:
            for k in m.get('Scripts'):
                temp_model = GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts()
                self.scripts.append(temp_model.from_map(k))
        return self


class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult(TeaModel):
    def __init__(
        self,
        error_message: str = None,
        occur_error: bool = None,
        results: List[GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults] = None,
    ):
        # The error message returned.
        self.error_message = error_message
        # Indicates whether an error occurs. Valid values:
        # 
        # *   **true**: An error occurs.
        # *   **false**: No error occurs.
        self.occur_error = occur_error
        # The review results based on rules.
        self.results = results

    def validate(self):
        if self.results:
            for k in self.results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.occur_error is not None:
            result['OccurError'] = self.occur_error
        result['Results'] = []
        if self.results is not None:
            for k in self.results:
                result['Results'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OccurError') is not None:
            self.occur_error = m.get('OccurError')
        self.results = []
        if m.get('Results') is not None:
            for k in m.get('Results'):
                temp_model = GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults()
                self.results.append(temp_model.from_map(k))
        return self


class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        instance_id: int = None,
        quality_result: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult = None,
        query_key: str = None,
        sql_type: str = None,
    ):
        # The ID of the database.
        self.db_id = db_id
        # The ID of the instance to which the database belongs.
        self.instance_id = instance_id
        # The quality of the SQL statement.
        self.quality_result = quality_result
        # The key that is used to query the details of optimization suggestions.
        self.query_key = query_key
        # The type of the SQL statement. Valid values: DELETE, UPDATE, and ALTER_TABLE.
        self.sql_type = sql_type

    def validate(self):
        if self.quality_result:
            self.quality_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.quality_result is not None:
            result['QualityResult'] = self.quality_result.to_map()
        if self.query_key is not None:
            result['QueryKey'] = self.query_key
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('QualityResult') is not None:
            temp_model = GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult()
            self.quality_result = temp_model.from_map(m['QualityResult'])
        if m.get('QueryKey') is not None:
            self.query_key = m.get('QueryKey')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        return self


class GetSQLReviewOptimizeDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        optimize_detail: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The details of optimization suggestions for SQL statements.
        self.optimize_detail = optimize_detail
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.optimize_detail:
            self.optimize_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.optimize_detail is not None:
            result['OptimizeDetail'] = self.optimize_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('OptimizeDetail') is not None:
            temp_model = GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail()
            self.optimize_detail = temp_model.from_map(m['OptimizeDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSQLReviewOptimizeDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSQLReviewOptimizeDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSQLReviewOptimizeDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStructSyncExecSqlDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.page_number = page_number
        self.page_size = page_size
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail(TeaModel):
    def __init__(
        self,
        exec_sql: str = None,
        total_sql_count: int = None,
    ):
        self.exec_sql = exec_sql
        self.total_sql_count = total_sql_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exec_sql is not None:
            result['ExecSql'] = self.exec_sql
        if self.total_sql_count is not None:
            result['TotalSqlCount'] = self.total_sql_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExecSql') is not None:
            self.exec_sql = m.get('ExecSql')
        if m.get('TotalSqlCount') is not None:
            self.total_sql_count = m.get('TotalSqlCount')
        return self


class GetStructSyncExecSqlDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        struct_sync_exec_sql_detail: GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        # Id of the request
        self.request_id = request_id
        self.struct_sync_exec_sql_detail = struct_sync_exec_sql_detail
        self.success = success

    def validate(self):
        if self.struct_sync_exec_sql_detail:
            self.struct_sync_exec_sql_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.struct_sync_exec_sql_detail is not None:
            result['StructSyncExecSqlDetail'] = self.struct_sync_exec_sql_detail.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StructSyncExecSqlDetail') is not None:
            temp_model = GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail()
            self.struct_sync_exec_sql_detail = temp_model.from_map(m['StructSyncExecSqlDetail'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStructSyncExecSqlDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStructSyncExecSqlDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStructSyncExecSqlDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStructSyncJobAnalyzeResultRequest(TeaModel):
    def __init__(
        self,
        compare_type: str = None,
        order_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        self.compare_type = compare_type
        self.order_id = order_id
        self.page_number = page_number
        self.page_size = page_size
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.compare_type is not None:
            result['CompareType'] = self.compare_type
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CompareType') is not None:
            self.compare_type = m.get('CompareType')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList(TeaModel):
    def __init__(
        self,
        script: str = None,
        source_table_name: str = None,
        target_table_name: str = None,
    ):
        self.script = script
        self.source_table_name = source_table_name
        self.target_table_name = target_table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.script is not None:
            result['Script'] = self.script
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        if self.target_table_name is not None:
            result['TargetTableName'] = self.target_table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Script') is not None:
            self.script = m.get('Script')
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        if m.get('TargetTableName') is not None:
            self.target_table_name = m.get('TargetTableName')
        return self


class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList(TeaModel):
    def __init__(
        self,
        compare_type: str = None,
        count: int = None,
    ):
        self.compare_type = compare_type
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.compare_type is not None:
            result['CompareType'] = self.compare_type
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CompareType') is not None:
            self.compare_type = m.get('CompareType')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult(TeaModel):
    def __init__(
        self,
        result_list: List[GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList] = None,
        summary_list: List[GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList] = None,
    ):
        self.result_list = result_list
        self.summary_list = summary_list

    def validate(self):
        if self.result_list:
            for k in self.result_list:
                if k:
                    k.validate()
        if self.summary_list:
            for k in self.summary_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ResultList'] = []
        if self.result_list is not None:
            for k in self.result_list:
                result['ResultList'].append(k.to_map() if k else None)
        result['SummaryList'] = []
        if self.summary_list is not None:
            for k in self.summary_list:
                result['SummaryList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.result_list = []
        if m.get('ResultList') is not None:
            for k in m.get('ResultList'):
                temp_model = GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList()
                self.result_list.append(temp_model.from_map(k))
        self.summary_list = []
        if m.get('SummaryList') is not None:
            for k in m.get('SummaryList'):
                temp_model = GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList()
                self.summary_list.append(temp_model.from_map(k))
        return self


class GetStructSyncJobAnalyzeResultResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        struct_sync_job_analyze_result: GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.struct_sync_job_analyze_result = struct_sync_job_analyze_result
        self.success = success

    def validate(self):
        if self.struct_sync_job_analyze_result:
            self.struct_sync_job_analyze_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.struct_sync_job_analyze_result is not None:
            result['StructSyncJobAnalyzeResult'] = self.struct_sync_job_analyze_result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StructSyncJobAnalyzeResult') is not None:
            temp_model = GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult()
            self.struct_sync_job_analyze_result = temp_model.from_map(m['StructSyncJobAnalyzeResult'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStructSyncJobAnalyzeResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStructSyncJobAnalyzeResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStructSyncJobAnalyzeResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStructSyncJobDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the ticket.
        self.order_id = order_id
        # The ID of the tenant.
        # 
        # >  The ID of the tenant is displayed when you move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Tenant information](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStructSyncJobDetailResponseBodyStructSyncJobDetail(TeaModel):
    def __init__(
        self,
        dbtask_group_id: int = None,
        execute_count: int = None,
        job_status: str = None,
        message: str = None,
        security_rule: str = None,
        sql_count: int = None,
        table_analyzed: int = None,
        table_count: int = None,
    ):
        # The ID of the task queue.
        self.dbtask_group_id = dbtask_group_id
        # The number of SQL statements that have been executed.
        self.execute_count = execute_count
        # The status of the task. Valid values:
        # 
        # *   **NEW**: The task was created.
        # *   **COMPARING**: The schemas of tables were being compared.
        # *   **COMPARE_BREAK**: The schema comparison was interrupted.
        # *   **COMPARE_FINISH**: The schema comparison was complete.
        # *   **NOT_SCRIPTS**: The schema comparison was complete. No scripts were available.
        # *   **SUBMITED_DBTASK**: The task was submitted.
        # *   **DBTASK_SUCCESS**: The task was complete.
        # *   **SUBMITED_WORKFLOW**: The ticket was submitted for approval.
        # *   **WORKFLOW_SUCCESS**: The ticket was approved.
        self.job_status = job_status
        # The description of the task.
        self.message = message
        # The type of security rule. Valid values:
        # 
        # *   **CANNOT_SYNC**: The schema synchronization is not allowed.
        # *   **WITH_APPROVE**: The schema synchronization can be performed after the ticket is approved. You can call the [SubmitStructSyncOrderApproval](~~206166~~) operation to submit the ticket for approval.
        # *   **WITHOUT_APPROVE**: The schema synchronization can be performed without approval.
        self.security_rule = security_rule
        # The total number of SQL statements.
        self.sql_count = sql_count
        # The number of tables that have been analyzed.
        self.table_analyzed = table_analyzed
        # The total number of tables.
        self.table_count = table_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.execute_count is not None:
            result['ExecuteCount'] = self.execute_count
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.message is not None:
            result['Message'] = self.message
        if self.security_rule is not None:
            result['SecurityRule'] = self.security_rule
        if self.sql_count is not None:
            result['SqlCount'] = self.sql_count
        if self.table_analyzed is not None:
            result['TableAnalyzed'] = self.table_analyzed
        if self.table_count is not None:
            result['TableCount'] = self.table_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('ExecuteCount') is not None:
            self.execute_count = m.get('ExecuteCount')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('SecurityRule') is not None:
            self.security_rule = m.get('SecurityRule')
        if m.get('SqlCount') is not None:
            self.sql_count = m.get('SqlCount')
        if m.get('TableAnalyzed') is not None:
            self.table_analyzed = m.get('TableAnalyzed')
        if m.get('TableCount') is not None:
            self.table_count = m.get('TableCount')
        return self


class GetStructSyncJobDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        struct_sync_job_detail: GetStructSyncJobDetailResponseBodyStructSyncJobDetail = None,
        success: bool = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The details of the schema synchronization task.
        self.struct_sync_job_detail = struct_sync_job_detail
        # Indicates whether the call was successful.
        self.success = success

    def validate(self):
        if self.struct_sync_job_detail:
            self.struct_sync_job_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.struct_sync_job_detail is not None:
            result['StructSyncJobDetail'] = self.struct_sync_job_detail.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StructSyncJobDetail') is not None:
            temp_model = GetStructSyncJobDetailResponseBodyStructSyncJobDetail()
            self.struct_sync_job_detail = temp_model.from_map(m['StructSyncJobDetail'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStructSyncJobDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStructSyncJobDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStructSyncJobDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStructSyncOrderDetailRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        search_name: str = None,
    ):
        self.db_id = db_id
        self.db_type = db_type
        self.env_type = env_type
        self.logic = logic
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo(TeaModel):
    def __init__(
        self,
        version_id: str = None,
    ):
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList(TeaModel):
    def __init__(
        self,
        source_table_name: str = None,
        target_table_name: str = None,
    ):
        self.source_table_name = source_table_name
        self.target_table_name = target_table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_table_name is not None:
            result['SourceTableName'] = self.source_table_name
        if self.target_table_name is not None:
            result['TargetTableName'] = self.target_table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceTableName') is not None:
            self.source_table_name = m.get('SourceTableName')
        if m.get('TargetTableName') is not None:
            self.target_table_name = m.get('TargetTableName')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        search_name: str = None,
    ):
        self.db_id = db_id
        self.db_type = db_type
        self.env_type = env_type
        self.logic = logic
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo(TeaModel):
    def __init__(
        self,
        version_id: str = None,
    ):
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail(TeaModel):
    def __init__(
        self,
        ignore_error: bool = None,
        source_database_info: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo = None,
        source_type: str = None,
        source_version_info: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo = None,
        table_info_list: List[GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList] = None,
        target_database_info: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo = None,
        target_type: str = None,
        target_version_info: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo = None,
    ):
        self.ignore_error = ignore_error
        self.source_database_info = source_database_info
        self.source_type = source_type
        self.source_version_info = source_version_info
        self.table_info_list = table_info_list
        self.target_database_info = target_database_info
        self.target_type = target_type
        self.target_version_info = target_version_info

    def validate(self):
        if self.source_database_info:
            self.source_database_info.validate()
        if self.source_version_info:
            self.source_version_info.validate()
        if self.table_info_list:
            for k in self.table_info_list:
                if k:
                    k.validate()
        if self.target_database_info:
            self.target_database_info.validate()
        if self.target_version_info:
            self.target_version_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_error is not None:
            result['IgnoreError'] = self.ignore_error
        if self.source_database_info is not None:
            result['SourceDatabaseInfo'] = self.source_database_info.to_map()
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.source_version_info is not None:
            result['SourceVersionInfo'] = self.source_version_info.to_map()
        result['TableInfoList'] = []
        if self.table_info_list is not None:
            for k in self.table_info_list:
                result['TableInfoList'].append(k.to_map() if k else None)
        if self.target_database_info is not None:
            result['TargetDatabaseInfo'] = self.target_database_info.to_map()
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.target_version_info is not None:
            result['TargetVersionInfo'] = self.target_version_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IgnoreError') is not None:
            self.ignore_error = m.get('IgnoreError')
        if m.get('SourceDatabaseInfo') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo()
            self.source_database_info = temp_model.from_map(m['SourceDatabaseInfo'])
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('SourceVersionInfo') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo()
            self.source_version_info = temp_model.from_map(m['SourceVersionInfo'])
        self.table_info_list = []
        if m.get('TableInfoList') is not None:
            for k in m.get('TableInfoList'):
                temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList()
                self.table_info_list.append(temp_model.from_map(k))
        if m.get('TargetDatabaseInfo') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo()
            self.target_database_info = temp_model.from_map(m['TargetDatabaseInfo'])
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TargetVersionInfo') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo()
            self.target_version_info = temp_model.from_map(m['TargetVersionInfo'])
        return self


class GetStructSyncOrderDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        struct_sync_order_detail: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.struct_sync_order_detail = struct_sync_order_detail
        self.success = success

    def validate(self):
        if self.struct_sync_order_detail:
            self.struct_sync_order_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.struct_sync_order_detail is not None:
            result['StructSyncOrderDetail'] = self.struct_sync_order_detail.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StructSyncOrderDetail') is not None:
            temp_model = GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail()
            self.struct_sync_order_detail = temp_model.from_map(m['StructSyncOrderDetail'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStructSyncOrderDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStructSyncOrderDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStructSyncOrderDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTableDBTopologyRequest(TeaModel):
    def __init__(
        self,
        table_guid: str = None,
        tid: int = None,
    ):
        self.table_guid = table_guid
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList(TeaModel):
    def __init__(
        self,
        table_id: str = None,
        table_name: str = None,
        table_type: str = None,
    ):
        self.table_id = table_id
        self.table_name = table_name
        self.table_type = table_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_type is not None:
            result['TableType'] = self.table_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableType') is not None:
            self.table_type = m.get('TableType')
        return self


class GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        db_name: str = None,
        db_type: str = None,
        env_type: str = None,
        table_list: List[GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList] = None,
    ):
        self.db_id = db_id
        self.db_name = db_name
        self.db_type = db_type
        self.env_type = env_type
        self.table_list = table_list

    def validate(self):
        if self.table_list:
            for k in self.table_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        result['TableList'] = []
        if self.table_list is not None:
            for k in self.table_list:
                result['TableList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        self.table_list = []
        if m.get('TableList') is not None:
            for k in m.get('TableList'):
                temp_model = GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList()
                self.table_list.append(temp_model.from_map(k))
        return self


class GetTableDBTopologyResponseBodyDBTopologyDataSourceList(TeaModel):
    def __init__(
        self,
        database_list: List[GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList] = None,
        db_type: str = None,
        host: str = None,
        port: int = None,
        sid: str = None,
    ):
        self.database_list = database_list
        self.db_type = db_type
        self.host = host
        self.port = port
        self.sid = sid

    def validate(self):
        if self.database_list:
            for k in self.database_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DatabaseList'] = []
        if self.database_list is not None:
            for k in self.database_list:
                result['DatabaseList'].append(k.to_map() if k else None)
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.host is not None:
            result['Host'] = self.host
        if self.port is not None:
            result['Port'] = self.port
        if self.sid is not None:
            result['Sid'] = self.sid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.database_list = []
        if m.get('DatabaseList') is not None:
            for k in m.get('DatabaseList'):
                temp_model = GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList()
                self.database_list.append(temp_model.from_map(k))
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        return self


class GetTableDBTopologyResponseBodyDBTopology(TeaModel):
    def __init__(
        self,
        data_source_list: List[GetTableDBTopologyResponseBodyDBTopologyDataSourceList] = None,
        table_guid: str = None,
        table_name: str = None,
    ):
        self.data_source_list = data_source_list
        self.table_guid = table_guid
        self.table_name = table_name

    def validate(self):
        if self.data_source_list:
            for k in self.data_source_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataSourceList'] = []
        if self.data_source_list is not None:
            for k in self.data_source_list:
                result['DataSourceList'].append(k.to_map() if k else None)
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_source_list = []
        if m.get('DataSourceList') is not None:
            for k in m.get('DataSourceList'):
                temp_model = GetTableDBTopologyResponseBodyDBTopologyDataSourceList()
                self.data_source_list.append(temp_model.from_map(k))
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class GetTableDBTopologyResponseBody(TeaModel):
    def __init__(
        self,
        dbtopology: GetTableDBTopologyResponseBodyDBTopology = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.dbtopology = dbtopology
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.dbtopology:
            self.dbtopology.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtopology is not None:
            result['DBTopology'] = self.dbtopology.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBTopology') is not None:
            temp_model = GetTableDBTopologyResponseBodyDBTopology()
            self.dbtopology = temp_model.from_map(m['DBTopology'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTableDBTopologyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTableDBTopologyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTableDBTopologyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTableTopologyRequest(TeaModel):
    def __init__(
        self,
        table_guid: str = None,
        tid: int = None,
    ):
        self.table_guid = table_guid
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        db_name: str = None,
        db_search_name: str = None,
        db_type: str = None,
        instance_id: int = None,
        instance_resource_id: str = None,
        instance_source: str = None,
        region_id: str = None,
        table_count: int = None,
        table_name_expr: str = None,
        table_name_list: str = None,
    ):
        self.db_id = db_id
        self.db_name = db_name
        self.db_search_name = db_search_name
        self.db_type = db_type
        self.instance_id = instance_id
        self.instance_resource_id = instance_resource_id
        self.instance_source = instance_source
        self.region_id = region_id
        self.table_count = table_count
        self.table_name_expr = table_name_expr
        self.table_name_list = table_name_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.db_search_name is not None:
            result['DbSearchName'] = self.db_search_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_resource_id is not None:
            result['InstanceResourceId'] = self.instance_resource_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.table_count is not None:
            result['TableCount'] = self.table_count
        if self.table_name_expr is not None:
            result['TableNameExpr'] = self.table_name_expr
        if self.table_name_list is not None:
            result['TableNameList'] = self.table_name_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DbSearchName') is not None:
            self.db_search_name = m.get('DbSearchName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceResourceId') is not None:
            self.instance_resource_id = m.get('InstanceResourceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TableCount') is not None:
            self.table_count = m.get('TableCount')
        if m.get('TableNameExpr') is not None:
            self.table_name_expr = m.get('TableNameExpr')
        if m.get('TableNameList') is not None:
            self.table_name_list = m.get('TableNameList')
        return self


class GetTableTopologyResponseBodyTableTopology(TeaModel):
    def __init__(
        self,
        logic: bool = None,
        table_guid: str = None,
        table_name: str = None,
        table_topology_info_list: List[GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList] = None,
    ):
        self.logic = logic
        self.table_guid = table_guid
        self.table_name = table_name
        self.table_topology_info_list = table_topology_info_list

    def validate(self):
        if self.table_topology_info_list:
            for k in self.table_topology_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_name is not None:
            result['TableName'] = self.table_name
        result['TableTopologyInfoList'] = []
        if self.table_topology_info_list is not None:
            for k in self.table_topology_info_list:
                result['TableTopologyInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        self.table_topology_info_list = []
        if m.get('TableTopologyInfoList') is not None:
            for k in m.get('TableTopologyInfoList'):
                temp_model = GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList()
                self.table_topology_info_list.append(temp_model.from_map(k))
        return self


class GetTableTopologyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        table_topology: GetTableTopologyResponseBodyTableTopology = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.table_topology = table_topology

    def validate(self):
        if self.table_topology:
            self.table_topology.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.table_topology is not None:
            result['TableTopology'] = self.table_topology.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TableTopology') is not None:
            temp_model = GetTableTopologyResponseBodyTableTopology()
            self.table_topology = temp_model.from_map(m['TableTopology'])
        return self


class GetTableTopologyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTableTopologyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTableTopologyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskRequest(TeaModel):
    def __init__(
        self,
        node_id: int = None,
        tid: int = None,
    ):
        self.node_id = node_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTaskResponseBodyTask(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        graph_param: str = None,
        node_config: str = None,
        node_content: str = None,
        node_name: str = None,
        node_output: str = None,
        node_type: str = None,
        time_variables: str = None,
    ):
        self.dag_id = dag_id
        self.graph_param = graph_param
        self.node_config = node_config
        self.node_content = node_content
        self.node_name = node_name
        self.node_output = node_output
        self.node_type = node_type
        self.time_variables = time_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.graph_param is not None:
            result['GraphParam'] = self.graph_param
        if self.node_config is not None:
            result['NodeConfig'] = self.node_config
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_output is not None:
            result['NodeOutput'] = self.node_output
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('GraphParam') is not None:
            self.graph_param = m.get('GraphParam')
        if m.get('NodeConfig') is not None:
            self.node_config = m.get('NodeConfig')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeOutput') is not None:
            self.node_output = m.get('NodeOutput')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class GetTaskResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        task: GetTaskResponseBodyTask = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.task = task

    def validate(self):
        if self.task:
            self.task.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task is not None:
            result['Task'] = self.task.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Task') is not None:
            temp_model = GetTaskResponseBodyTask()
            self.task = temp_model.from_map(m['Task'])
        return self


class GetTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskFlowGraphRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        id: int = None,
        node_end: int = None,
        node_from: int = None,
    ):
        # The ID of the task flow.
        self.dag_id = dag_id
        # The ID of the task flow edge.
        self.id = id
        # The ID of the end node on the edge.
        self.node_end = node_end
        # The ID of the start node on the edge.
        self.node_from = node_from

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraphEdges(TeaModel):
    def __init__(
        self,
        edge: List[GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge] = None,
    ):
        self.edge = edge

    def validate(self):
        if self.edge:
            for k in self.edge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Edge'] = []
        if self.edge is not None:
            for k in self.edge:
                result['Edge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.edge = []
        if m.get('Edge') is not None:
            for k in m.get('Edge'):
                temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge()
                self.edge.append(temp_model.from_map(k))
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        graph_param: str = None,
        node_config: str = None,
        node_content: str = None,
        node_id: int = None,
        node_name: str = None,
        node_type: int = None,
        time_variables: str = None,
    ):
        # The ID of the task flow.
        self.dag_id = dag_id
        # The position of the node in the DAG.
        self.graph_param = graph_param
        # The advanced configuration of the node.
        self.node_config = node_config
        # The configuration of the node.
        self.node_content = node_content
        # The ID of the node.
        self.node_id = node_id
        # The name of the node.
        self.node_name = node_name
        # The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
        self.node_type = node_type
        # The time variables for the node.
        self.time_variables = time_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.graph_param is not None:
            result['GraphParam'] = self.graph_param
        if self.node_config is not None:
            result['NodeConfig'] = self.node_config
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('GraphParam') is not None:
            self.graph_param = m.get('GraphParam')
        if m.get('NodeConfig') is not None:
            self.node_config = m.get('NodeConfig')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraphNodes(TeaModel):
    def __init__(
        self,
        node: List[GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode] = None,
    ):
        self.node = node

    def validate(self):
        if self.node:
            for k in self.node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Node'] = []
        if self.node is not None:
            for k in self.node:
                result['Node'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node = []
        if m.get('Node') is not None:
            for k in m.get('Node'):
                temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode()
                self.node.append(temp_model.from_map(k))
        return self


class GetTaskFlowGraphResponseBodyTaskFlowGraph(TeaModel):
    def __init__(
        self,
        can_edit: bool = None,
        dag_name: str = None,
        edges: GetTaskFlowGraphResponseBodyTaskFlowGraphEdges = None,
        nodes: GetTaskFlowGraphResponseBodyTaskFlowGraphNodes = None,
        status: int = None,
    ):
        # Indicates whether the task flow is editable. Valid values:
        # 
        # - **true**: editable
        # - **false**: non-editable
        self.can_edit = can_edit
        # The name of the task flow.
        self.dag_name = dag_name
        # The list of task flow edges.
        self.edges = edges
        # The node list of the task flow.
        self.nodes = nodes
        # The status of the task flow. Valid values:
        # 
        # - **0**: invalid
        # - **1**: not scheduled
        # - **2**: to be scheduled
        self.status = status

    def validate(self):
        if self.edges:
            self.edges.validate()
        if self.nodes:
            self.nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_edit is not None:
            result['CanEdit'] = self.can_edit
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.edges is not None:
            result['Edges'] = self.edges.to_map()
        if self.nodes is not None:
            result['Nodes'] = self.nodes.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanEdit') is not None:
            self.can_edit = m.get('CanEdit')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('Edges') is not None:
            temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraphEdges()
            self.edges = temp_model.from_map(m['Edges'])
        if m.get('Nodes') is not None:
            temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraphNodes()
            self.nodes = temp_model.from_map(m['Nodes'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetTaskFlowGraphResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        task_flow_graph: GetTaskFlowGraphResponseBodyTaskFlowGraph = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The list of DAG variables of the task flow.
        self.task_flow_graph = task_flow_graph

    def validate(self):
        if self.task_flow_graph:
            self.task_flow_graph.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_flow_graph is not None:
            result['TaskFlowGraph'] = self.task_flow_graph.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskFlowGraph') is not None:
            temp_model = GetTaskFlowGraphResponseBodyTaskFlowGraph()
            self.task_flow_graph = temp_model.from_map(m['TaskFlowGraph'])
        return self


class GetTaskFlowGraphResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskFlowGraphResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskFlowGraphResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskFlowNotificationRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTaskFlowNotificationResponseBodyNotification(TeaModel):
    def __init__(
        self,
        dag_notification_fail: bool = None,
        dag_notification_sla: bool = None,
        dag_notification_success: bool = None,
    ):
        self.dag_notification_fail = dag_notification_fail
        self.dag_notification_sla = dag_notification_sla
        self.dag_notification_success = dag_notification_success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_notification_fail is not None:
            result['DagNotificationFail'] = self.dag_notification_fail
        if self.dag_notification_sla is not None:
            result['DagNotificationSla'] = self.dag_notification_sla
        if self.dag_notification_success is not None:
            result['DagNotificationSuccess'] = self.dag_notification_success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagNotificationFail') is not None:
            self.dag_notification_fail = m.get('DagNotificationFail')
        if m.get('DagNotificationSla') is not None:
            self.dag_notification_sla = m.get('DagNotificationSla')
        if m.get('DagNotificationSuccess') is not None:
            self.dag_notification_success = m.get('DagNotificationSuccess')
        return self


class GetTaskFlowNotificationResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        notification: GetTaskFlowNotificationResponseBodyNotification = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.notification = notification
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.notification:
            self.notification.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.notification is not None:
            result['Notification'] = self.notification.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Notification') is not None:
            temp_model = GetTaskFlowNotificationResponseBodyNotification()
            self.notification = temp_model.from_map(m['Notification'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTaskFlowNotificationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskFlowNotificationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskFlowNotificationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskInstanceRelationRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_instance_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
        self.dag_id = dag_id
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to obtain the execution record ID.
        self.dag_instance_id = dag_instance_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetTaskInstanceRelationResponseBodyNodeListNode(TeaModel):
    def __init__(
        self,
        business_time: str = None,
        end_time: str = None,
        execute_time: int = None,
        id: int = None,
        message: str = None,
        node_id: int = None,
        node_name: str = None,
        node_type: int = None,
        status: int = None,
    ):
        # The business time of the node.
        self.business_time = business_time
        # The time when the execution of the task flow was complete. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.end_time = end_time
        # The amount of time consumed for running the node. Unit: milliseconds.
        self.execute_time = execute_time
        # The ID of the execution record of the task flow.
        self.id = id
        # The description of the task.
        self.message = message
        # The ID of the node.
        self.node_id = node_id
        # The name of the node.
        self.node_name = node_name
        # The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
        self.node_type = node_type
        # The status of the node. Valid values:
        # 
        # *   **0**: The node is waiting to be scheduled.
        # *   **1**: The node is running.
        # *   **2**: The node is suspended.
        # *   **3**: The node failed to run.
        # *   **4**: The node is run.
        # *   **5**: The node is complete.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_time is not None:
            result['BusinessTime'] = self.business_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.execute_time is not None:
            result['ExecuteTime'] = self.execute_time
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessTime') is not None:
            self.business_time = m.get('BusinessTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecuteTime') is not None:
            self.execute_time = m.get('ExecuteTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetTaskInstanceRelationResponseBodyNodeList(TeaModel):
    def __init__(
        self,
        node: List[GetTaskInstanceRelationResponseBodyNodeListNode] = None,
    ):
        self.node = node

    def validate(self):
        if self.node:
            for k in self.node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Node'] = []
        if self.node is not None:
            for k in self.node:
                result['Node'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node = []
        if m.get('Node') is not None:
            for k in m.get('Node'):
                temp_model = GetTaskInstanceRelationResponseBodyNodeListNode()
                self.node.append(temp_model.from_map(k))
        return self


class GetTaskInstanceRelationResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        node_list: GetTaskInstanceRelationResponseBodyNodeList = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The information about the nodes in the execution record of the task flow.
        self.node_list = node_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        if self.node_list:
            self.node_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.node_list is not None:
            result['NodeList'] = self.node_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NodeList') is not None:
            temp_model = GetTaskInstanceRelationResponseBodyNodeList()
            self.node_list = temp_model.from_map(m['NodeList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTaskInstanceRelationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTaskInstanceRelationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTaskInstanceRelationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
        uid: str = None,
        user_id: str = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the ID of the tenant.
        self.tid = tid
        # The UID of the user. You can view your UID by moving the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console.
        self.uid = uid
        # The ID of the user. You can call the [ListUsers](~~141938~~) operation to query the ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetUserResponseBodyUserRoleIdList(TeaModel):
    def __init__(
        self,
        role_ids: List[int] = None,
    ):
        self.role_ids = role_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_ids is not None:
            result['RoleIds'] = self.role_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoleIds') is not None:
            self.role_ids = m.get('RoleIds')
        return self


class GetUserResponseBodyUserRoleNameList(TeaModel):
    def __init__(
        self,
        role_names: List[str] = None,
    ):
        self.role_names = role_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_names is not None:
            result['RoleNames'] = self.role_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoleNames') is not None:
            self.role_names = m.get('RoleNames')
        return self


class GetUserResponseBodyUser(TeaModel):
    def __init__(
        self,
        cur_execute_count: int = None,
        cur_result_count: int = None,
        ding_robot: str = None,
        email: str = None,
        last_login_time: str = None,
        max_execute_count: int = None,
        max_result_count: int = None,
        mobile: str = None,
        nick_name: str = None,
        notification_mode: str = None,
        parent_uid: int = None,
        role_id_list: GetUserResponseBodyUserRoleIdList = None,
        role_name_list: GetUserResponseBodyUserRoleNameList = None,
        signature_method: str = None,
        state: str = None,
        uid: str = None,
        user_id: str = None,
        webhook: str = None,
    ):
        # The number of queries that are performed on the current day.
        self.cur_execute_count = cur_execute_count
        # The number of rows that are queried on the current day.
        self.cur_result_count = cur_result_count
        # The DingTalk chatbot URL that is used to receive notifications.
        # 
        # > 
        # *   The system returns this parameter if the user has set a DingTalk chatbot URL in the console. To set a DingTalk chatbot URL in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # *   The system does not return this parameter if the user has not set a DingTalk chatbot URL.
        self.ding_robot = ding_robot
        # The email address that is used to receive notifications.
        # 
        # > 
        # *   The system returns this parameter if the user has set an email address in the console. To set an email address in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # *   The system does not return this parameter if the user has not set an email address.
        self.email = email
        # The last time when the user logged on to the console.
        self.last_login_time = last_login_time
        # The maximum number of queries that can be performed on the current day.
        self.max_execute_count = max_execute_count
        # The maximum number of rows that can be queried on the current day.
        self.max_result_count = max_result_count
        # The mobile phone number that is used to receive notifications.
        # 
        # > 
        # *   The system returns this parameter if the user has set a mobile phone number in the console. To set a mobile phone number in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # *   The system does not return this parameter if the user has not set a mobile phone number.
        self.mobile = mobile
        # The nickname of the user.
        self.nick_name = nick_name
        # The notification method. The system returns one or more values. Valid values:
        # 
        # *   **SMS**: text message.
        # *   **EMAIL**: email.
        # *   **DingTalk**: DingTalk.
        # *   **DINGROBOT**: DingTalk chatbot.
        # *   **WEBHOOK**: webhook.
        self.notification_mode = notification_mode
        # The UID of the Alibaba Cloud account of the user.
        # 
        # >  An Alibaba Cloud account can contain one or more RAM users.
        self.parent_uid = parent_uid
        # The ID of the role that is assigned to the user. Valid values:
        # 
        # *   **1**: a regular user role.
        # *   **2**: a database administrator (DBA) role.
        # *   **3**: a DMS administrator role.
        # *   **4**: a security administrator role.
        # *   **6**: a schema read-only user role.
        self.role_id_list = role_id_list
        # The name of the role that is assigned to the user. Valid values:
        # 
        # *   **USER**: a regular user.
        # *   **DBA** : a DBA.
        # *   **ADMIN**: a DMS administrator.
        # *   **SECURITY_ADMIN**: a security administrator.
        # *   **STRUCT_READ_ONLY**: a schema read-only user.
        self.role_name_list = role_name_list
        # The signature method that is used to secure connections when a webhook URL is used. Valid values:
        # 
        # *   **NONE**: no signature.
        # *   **HMAC_SHA1**: HMAC_SHA1.
        self.signature_method = signature_method
        # The status of the user. Valid values:
        # 
        # *   **NORMAL**: The user is normal.
        # *   **DISABLE**: The user is disabled.
        # *   **DELETE**: The user is deleted.
        self.state = state
        # The UID of the user.
        self.uid = uid
        # The ID of the user.
        self.user_id = user_id
        # The webhook URL that is used to receive notifications.
        # 
        # > 
        # *   If the user has set a webhook URL, DMS sends notifications to the specified URL.
        # *   The system does not return this parameter if the user has not set a webhook URL.
        self.webhook = webhook

    def validate(self):
        if self.role_id_list:
            self.role_id_list.validate()
        if self.role_name_list:
            self.role_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cur_execute_count is not None:
            result['CurExecuteCount'] = self.cur_execute_count
        if self.cur_result_count is not None:
            result['CurResultCount'] = self.cur_result_count
        if self.ding_robot is not None:
            result['DingRobot'] = self.ding_robot
        if self.email is not None:
            result['Email'] = self.email
        if self.last_login_time is not None:
            result['LastLoginTime'] = self.last_login_time
        if self.max_execute_count is not None:
            result['MaxExecuteCount'] = self.max_execute_count
        if self.max_result_count is not None:
            result['MaxResultCount'] = self.max_result_count
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.notification_mode is not None:
            result['NotificationMode'] = self.notification_mode
        if self.parent_uid is not None:
            result['ParentUid'] = self.parent_uid
        if self.role_id_list is not None:
            result['RoleIdList'] = self.role_id_list.to_map()
        if self.role_name_list is not None:
            result['RoleNameList'] = self.role_name_list.to_map()
        if self.signature_method is not None:
            result['SignatureMethod'] = self.signature_method
        if self.state is not None:
            result['State'] = self.state
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurExecuteCount') is not None:
            self.cur_execute_count = m.get('CurExecuteCount')
        if m.get('CurResultCount') is not None:
            self.cur_result_count = m.get('CurResultCount')
        if m.get('DingRobot') is not None:
            self.ding_robot = m.get('DingRobot')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('LastLoginTime') is not None:
            self.last_login_time = m.get('LastLoginTime')
        if m.get('MaxExecuteCount') is not None:
            self.max_execute_count = m.get('MaxExecuteCount')
        if m.get('MaxResultCount') is not None:
            self.max_result_count = m.get('MaxResultCount')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('NotificationMode') is not None:
            self.notification_mode = m.get('NotificationMode')
        if m.get('ParentUid') is not None:
            self.parent_uid = m.get('ParentUid')
        if m.get('RoleIdList') is not None:
            temp_model = GetUserResponseBodyUserRoleIdList()
            self.role_id_list = temp_model.from_map(m['RoleIdList'])
        if m.get('RoleNameList') is not None:
            temp_model = GetUserResponseBodyUserRoleNameList()
            self.role_name_list = temp_model.from_map(m['RoleNameList'])
        if m.get('SignatureMethod') is not None:
            self.signature_method = m.get('SignatureMethod')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class GetUserResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        user: GetUserResponseBodyUser = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The information about the user.
        self.user = user

    def validate(self):
        if self.user:
            self.user.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.user is not None:
            result['User'] = self.user.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('User') is not None:
            temp_model = GetUserResponseBodyUser()
            self.user = temp_model.from_map(m['User'])
        return self


class GetUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserActiveTenantRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetUserActiveTenantResponseBodyTenant(TeaModel):
    def __init__(
        self,
        status: str = None,
        tenant_name: str = None,
        tid: int = None,
    ):
        # The status of the tenant. Valid values:
        # 
        # *   **ACTIVE**: The tenant is used to access DMS.
        # *   **IN_ACTIVE**: The tenant is not used.
        self.status = status
        # The name of the tenant.
        self.tenant_name = tenant_name
        # The ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetUserActiveTenantResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tenant: GetUserActiveTenantResponseBodyTenant = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success
        # The details of the tenant.
        self.tenant = tenant

    def validate(self):
        if self.tenant:
            self.tenant.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tenant is not None:
            result['Tenant'] = self.tenant.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tenant') is not None:
            temp_model = GetUserActiveTenantResponseBodyTenant()
            self.tenant = temp_model.from_map(m['Tenant'])
        return self


class GetUserActiveTenantResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUserActiveTenantResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserActiveTenantResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserUploadFileJobRequest(TeaModel):
    def __init__(
        self,
        job_key: str = None,
        tid: int = None,
    ):
        # The key of the file upload task. You can call the [CreateUploadFileJob](~~206059~~) or [CreateUploadOSSFileJob](~~206060~~) operation to query the key.
        self.job_key = job_key
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_key is not None:
            result['JobKey'] = self.job_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobKey') is not None:
            self.job_key = m.get('JobKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam(TeaModel):
    def __init__(
        self,
        bucket_name: str = None,
        endpoint: str = None,
        object_name: str = None,
    ):
        # The name of the OSS bucket.
        self.bucket_name = bucket_name
        # The endpoint of the OSS bucket.
        self.endpoint = endpoint
        # The name of the OSS object.
        self.object_name = object_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['BucketName'] = self.bucket_name
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.object_name is not None:
            result['ObjectName'] = self.object_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BucketName') is not None:
            self.bucket_name = m.get('BucketName')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('ObjectName') is not None:
            self.object_name = m.get('ObjectName')
        return self


class GetUserUploadFileJobResponseBodyUploadFileJobDetail(TeaModel):
    def __init__(
        self,
        attachment_key: str = None,
        file_name: str = None,
        file_size: int = None,
        file_source: str = None,
        job_key: str = None,
        job_status: str = None,
        job_status_desc: str = None,
        upload_ossparam: GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam = None,
        upload_type: str = None,
        upload_url: str = None,
        uploaded_size: int = None,
    ):
        # The key of the file that is returned after the file is uploaded. You can use this key when you upload the file as an attachment in a ticket.
        self.attachment_key = attachment_key
        # The name of the file.
        self.file_name = file_name
        # The size of the file. Unit: byte.
        self.file_size = file_size
        # The purpose of the uploaded file. Valid values:
        # 
        # *   **datacorrect**: The file is uploaded to change data.
        # *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
        # *   **big-file**: The file is uploaded to import multiple data records at a time.
        # *   **sqlreview**: The file is uploaded for SQL review.
        self.file_source = file_source
        # The key of the file upload task.
        self.job_key = job_key
        # The status of the file upload task. Valid values:
        # 
        # *   **INIT**: The task was initialized.
        # *   **PENDING**: The task waited to be run.
        # *   **BE_SCHEDULED**: The task waited to be scheduled.
        # *   **FAIL**: The task failed.
        # *   **SUCCESS**: The task was run as expected.
        # *   **RUNNING**: The task was being run.
        self.job_status = job_status
        # The information about the status of the file upload task.
        self.job_status_desc = job_status_desc
        # The information about the Object Storage Service (OSS) bucket from which the file is uploaded.
        # 
        # >  This parameter is returned if the **UploadType** parameter is set to **OSS**.
        self.upload_ossparam = upload_ossparam
        # The method used to upload the file. Valid values:
        # 
        # *   **URL**\
        # *   **OSS**\
        self.upload_type = upload_type
        # The URL of the file.
        # 
        # >  This parameter is returned if the **UploadType** parameter is set to **URL**.
        self.upload_url = upload_url
        # The size of the uploaded file. Unit: byte.
        self.uploaded_size = uploaded_size

    def validate(self):
        if self.upload_ossparam:
            self.upload_ossparam.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attachment_key is not None:
            result['AttachmentKey'] = self.attachment_key
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_source is not None:
            result['FileSource'] = self.file_source
        if self.job_key is not None:
            result['JobKey'] = self.job_key
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.job_status_desc is not None:
            result['JobStatusDesc'] = self.job_status_desc
        if self.upload_ossparam is not None:
            result['UploadOSSParam'] = self.upload_ossparam.to_map()
        if self.upload_type is not None:
            result['UploadType'] = self.upload_type
        if self.upload_url is not None:
            result['UploadURL'] = self.upload_url
        if self.uploaded_size is not None:
            result['UploadedSize'] = self.uploaded_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AttachmentKey') is not None:
            self.attachment_key = m.get('AttachmentKey')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileSource') is not None:
            self.file_source = m.get('FileSource')
        if m.get('JobKey') is not None:
            self.job_key = m.get('JobKey')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('JobStatusDesc') is not None:
            self.job_status_desc = m.get('JobStatusDesc')
        if m.get('UploadOSSParam') is not None:
            temp_model = GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam()
            self.upload_ossparam = temp_model.from_map(m['UploadOSSParam'])
        if m.get('UploadType') is not None:
            self.upload_type = m.get('UploadType')
        if m.get('UploadURL') is not None:
            self.upload_url = m.get('UploadURL')
        if m.get('UploadedSize') is not None:
            self.uploaded_size = m.get('UploadedSize')
        return self


class GetUserUploadFileJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        upload_file_job_detail: GetUserUploadFileJobResponseBodyUploadFileJobDetail = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success
        # The details of the file upload task.
        self.upload_file_job_detail = upload_file_job_detail

    def validate(self):
        if self.upload_file_job_detail:
            self.upload_file_job_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.upload_file_job_detail is not None:
            result['UploadFileJobDetail'] = self.upload_file_job_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('UploadFileJobDetail') is not None:
            temp_model = GetUserUploadFileJobResponseBodyUploadFileJobDetail()
            self.upload_file_job_detail = temp_model.from_map(m['UploadFileJobDetail'])
        return self


class GetUserUploadFileJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUserUploadFileJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserUploadFileJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GrantUserPermissionRequest(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        ds_type: str = None,
        expire_date: str = None,
        instance_id: int = None,
        logic: bool = None,
        perm_types: str = None,
        table_id: str = None,
        table_name: str = None,
        tid: int = None,
        user_id: str = None,
    ):
        # The ID of the database. You can call the [ListDatabases](~~141873~~) operation to query the ID of a physical database and the [ListLogicDatabases](~~141874~~) operation to query the ID of a logical database.
        # 
        # >  The value of the DatabaseId parameter is that of the DbId parameter.
        self.db_id = db_id
        # The permissions on a specific type of object that you want to grant to the user. Valid values:
        # 
        # *   INSTANCE: permissions on instances
        # *   DATABASE: permissions on physical databases
        # *   LOGIC_DATABASE: permissions on logical databases
        # *   TABLE: permissions on physical tables
        # *   LOGIC_TABLE: permissions on logical tables
        self.ds_type = ds_type
        # The time when the permissions expire.
        self.expire_date = expire_date
        # The ID of the instance. You must specify this parameter if you grant permissions on an instance to the user. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to query the ID of the instance.
        self.instance_id = instance_id
        # Specifies whether the database is a logical database. You must specify this parameter if you grant permissions on a database to the user. Valid values:
        # 
        # *   true: The database is a logical database.
        # *   false: The database is a physical database.
        self.logic = logic
        # The permission type. Separate multiple permission types with commas (,). Valid values:
        # 
        # *   **QUERY**: the query permissions
        # *   **EXPORT**: the export permissions
        # *   **CORRECT**: the change permissions
        # *   **LOGIN**: the logon permissions
        # *   **PERF**: the query permissions on the performance details of the instance
        self.perm_types = perm_types
        # The ID of the table. You must specify this parameter if you grant permissions on a table to the user. You can call the [ListTables](~~141878~~) operation to query the table ID.
        self.table_id = table_id
        # The name of the table. You must specify this parameter if you grant permissions on a table to the user.
        self.table_name = table_name
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid
        # The ID of the user. You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the ID of the user.
        # 
        # >  The user ID is different from the ID of your Alibaba Cloud account.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.perm_types is not None:
            result['PermTypes'] = self.perm_types
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermTypes') is not None:
            self.perm_types = m.get('PermTypes')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GrantUserPermissionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GrantUserPermissionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GrantUserPermissionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GrantUserPermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InspectProxyAccessSecretRequest(TeaModel):
    def __init__(
        self,
        proxy_access_id: int = None,
        tid: int = None,
    ):
        # The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique. You can call the [ListProxyAccesses](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxyaccesses) operation to obtain this parameter.
        self.proxy_access_id = proxy_access_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class InspectProxyAccessSecretResponseBody(TeaModel):
    def __init__(
        self,
        access_secret: str = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The authorization password of the security protection agent.
        self.access_secret = access_secret
        # The error code returned to the query task.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_secret is not None:
            result['AccessSecret'] = self.access_secret
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessSecret') is not None:
            self.access_secret = m.get('AccessSecret')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InspectProxyAccessSecretResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InspectProxyAccessSecretResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InspectProxyAccessSecretResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClassificationTemplatesRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListClassificationTemplatesResponseBodyTemplateList(TeaModel):
    def __init__(
        self,
        name: str = None,
        remark: str = None,
        template_id: int = None,
        template_type: str = None,
    ):
        self.name = name
        self.remark = remark
        self.template_id = template_id
        self.template_type = template_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class ListClassificationTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        template_list: List[ListClassificationTemplatesResponseBodyTemplateList] = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.template_list = template_list

    def validate(self):
        if self.template_list:
            for k in self.template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TemplateList'] = []
        if self.template_list is not None:
            for k in self.template_list:
                result['TemplateList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.template_list = []
        if m.get('TemplateList') is not None:
            for k in m.get('TemplateList'):
                temp_model = ListClassificationTemplatesResponseBodyTemplateList()
                self.template_list.append(temp_model.from_map(k))
        return self


class ListClassificationTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListClassificationTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClassificationTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListColumnsRequest(TeaModel):
    def __init__(
        self,
        logic: bool = None,
        table_id: str = None,
        tid: int = None,
    ):
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic
        # The ID of the table. You can call the [ListTables](~~141878~~) operation to obtain the table ID.
        self.table_id = table_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListColumnsResponseBodyColumnListColumn(TeaModel):
    def __init__(
        self,
        auto_increment: bool = None,
        column_id: str = None,
        column_name: str = None,
        column_type: str = None,
        data_length: int = None,
        data_precision: int = None,
        data_scale: int = None,
        default_value: str = None,
        description: str = None,
        function_type: str = None,
        nullable: bool = None,
        security_level: str = None,
        sensitive: bool = None,
    ):
        # Indicates whether the field is an auto-increment field. Valid values:
        # 
        # *   true: The field is an auto-increment field.
        # *   false: The field is not an auto-increment field.
        self.auto_increment = auto_increment
        # The ID of the field.
        self.column_id = column_id
        # The name of the field.
        self.column_name = column_name
        # The data type of the field.
        self.column_type = column_type
        # The length of the field.
        self.data_length = data_length
        # The number of valid digits for the field.
        self.data_precision = data_precision
        # The number of decimal places for the field.
        self.data_scale = data_scale
        # The default value of the field.
        self.default_value = default_value
        # The description of the field.
        self.description = description
        # The type of the masking algorithm that is used for the field. Valid values:
        # 
        # *   null: No masking algorithm is used.
        # *   DEFAULT: A full masking algorithm is used.
        # *   FIX_POS: The fixed position is masked.
        # *   FIX_CHAR: The fixed characters are replaced.
        self.function_type = function_type
        # Indicates whether the field can be empty. Valid values:
        # 
        # *   **true**: The field can be empty.
        # *   **false**: The field cannot be empty.
        self.nullable = nullable
        # The security level of the field. Valid values:
        # 
        # *   INNER: The field is an internal field but not sensitive.
        # *   SENSITIVE: The field is a sensitive field.
        # *   CONFIDENTIAL: The field is a confidential field.
        # 
        # >  For more information, see [Adjust the sensitivity level of one or more fields](~~66091~~).
        self.security_level = security_level
        # Indicates whether the field is a sensitive field. Valid values:
        # 
        # *   **true**: The field is a sensitive field.
        # *   **false**: The field is not a sensitive field.
        self.sensitive = sensitive

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_increment is not None:
            result['AutoIncrement'] = self.auto_increment
        if self.column_id is not None:
            result['ColumnId'] = self.column_id
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.data_length is not None:
            result['DataLength'] = self.data_length
        if self.data_precision is not None:
            result['DataPrecision'] = self.data_precision
        if self.data_scale is not None:
            result['DataScale'] = self.data_scale
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.description is not None:
            result['Description'] = self.description
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.nullable is not None:
            result['Nullable'] = self.nullable
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.sensitive is not None:
            result['Sensitive'] = self.sensitive
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoIncrement') is not None:
            self.auto_increment = m.get('AutoIncrement')
        if m.get('ColumnId') is not None:
            self.column_id = m.get('ColumnId')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DataLength') is not None:
            self.data_length = m.get('DataLength')
        if m.get('DataPrecision') is not None:
            self.data_precision = m.get('DataPrecision')
        if m.get('DataScale') is not None:
            self.data_scale = m.get('DataScale')
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('Nullable') is not None:
            self.nullable = m.get('Nullable')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('Sensitive') is not None:
            self.sensitive = m.get('Sensitive')
        return self


class ListColumnsResponseBodyColumnList(TeaModel):
    def __init__(
        self,
        column: List[ListColumnsResponseBodyColumnListColumn] = None,
    ):
        self.column = column

    def validate(self):
        if self.column:
            for k in self.column:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Column'] = []
        if self.column is not None:
            for k in self.column:
                result['Column'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.column = []
        if m.get('Column') is not None:
            for k in m.get('Column'):
                temp_model = ListColumnsResponseBodyColumnListColumn()
                self.column.append(temp_model.from_map(k))
        return self


class ListColumnsResponseBody(TeaModel):
    def __init__(
        self,
        column_list: ListColumnsResponseBodyColumnList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The information about the columns returned.
        self.column_list = column_list
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        if self.column_list:
            self.column_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_list is not None:
            result['ColumnList'] = self.column_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnList') is not None:
            temp_model = ListColumnsResponseBodyColumnList()
            self.column_list = temp_model.from_map(m['ColumnList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListColumnsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListColumnsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListColumnsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDAGVersionsRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        page_index: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
        self.dag_id = dag_id
        # The number of the page to return.
        self.page_index = page_index
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDAGVersionsResponseBodyDagVersionListDagVersion(TeaModel):
    def __init__(
        self,
        dag_name: str = None,
        dag_owner_id: str = None,
        dag_owner_nick_name: str = None,
        last_version_id: int = None,
        version_comments: str = None,
        version_id: int = None,
    ):
        # The name of the task flow.
        self.dag_name = dag_name
        # The ID of the task flow owner.
        self.dag_owner_id = dag_owner_id
        # The name of the task flow owner.
        self.dag_owner_nick_name = dag_owner_nick_name
        # The ID of the previously published version.
        self.last_version_id = last_version_id
        # The description of the version.
        self.version_comments = version_comments
        # The ID of the version.
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.last_version_id is not None:
            result['LastVersionId'] = self.last_version_id
        if self.version_comments is not None:
            result['VersionComments'] = self.version_comments
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('LastVersionId') is not None:
            self.last_version_id = m.get('LastVersionId')
        if m.get('VersionComments') is not None:
            self.version_comments = m.get('VersionComments')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class ListDAGVersionsResponseBodyDagVersionList(TeaModel):
    def __init__(
        self,
        dag_version: List[ListDAGVersionsResponseBodyDagVersionListDagVersion] = None,
    ):
        self.dag_version = dag_version

    def validate(self):
        if self.dag_version:
            for k in self.dag_version:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DagVersion'] = []
        if self.dag_version is not None:
            for k in self.dag_version:
                result['DagVersion'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dag_version = []
        if m.get('DagVersion') is not None:
            for k in m.get('DagVersion'):
                temp_model = ListDAGVersionsResponseBodyDagVersionListDagVersion()
                self.dag_version.append(temp_model.from_map(k))
        return self


class ListDAGVersionsResponseBody(TeaModel):
    def __init__(
        self,
        dag_version_list: ListDAGVersionsResponseBodyDagVersionList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The information about the published versions.
        self.dag_version_list = dag_version_list
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.dag_version_list:
            self.dag_version_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_version_list is not None:
            result['DagVersionList'] = self.dag_version_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagVersionList') is not None:
            temp_model = ListDAGVersionsResponseBodyDagVersionList()
            self.dag_version_list = temp_model.from_map(m['DagVersionList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDAGVersionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDAGVersionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDAGVersionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDBTaskSQLJobRequest(TeaModel):
    def __init__(
        self,
        dbtask_group_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        self.dbtask_group_id = dbtask_group_id
        self.page_number = page_number
        self.page_size = page_size
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDBTaskSQLJobResponseBodyDBTaskSQLJobList(TeaModel):
    def __init__(
        self,
        comment: str = None,
        create_time: str = None,
        db_id: int = None,
        db_search_name: str = None,
        db_task_group_id: int = None,
        job_id: int = None,
        job_type: str = None,
        last_exec_time: str = None,
        logic: bool = None,
        status: str = None,
        transactional: bool = None,
    ):
        self.comment = comment
        self.create_time = create_time
        self.db_id = db_id
        self.db_search_name = db_search_name
        self.db_task_group_id = db_task_group_id
        self.job_id = job_id
        self.job_type = job_type
        self.last_exec_time = last_exec_time
        self.logic = logic
        self.status = status
        self.transactional = transactional

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_search_name is not None:
            result['DbSearchName'] = self.db_search_name
        if self.db_task_group_id is not None:
            result['DbTaskGroupId'] = self.db_task_group_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.last_exec_time is not None:
            result['LastExecTime'] = self.last_exec_time
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.status is not None:
            result['Status'] = self.status
        if self.transactional is not None:
            result['Transactional'] = self.transactional
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbSearchName') is not None:
            self.db_search_name = m.get('DbSearchName')
        if m.get('DbTaskGroupId') is not None:
            self.db_task_group_id = m.get('DbTaskGroupId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('LastExecTime') is not None:
            self.last_exec_time = m.get('LastExecTime')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Transactional') is not None:
            self.transactional = m.get('Transactional')
        return self


class ListDBTaskSQLJobResponseBody(TeaModel):
    def __init__(
        self,
        dbtask_sqljob_list: List[ListDBTaskSQLJobResponseBodyDBTaskSQLJobList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.dbtask_sqljob_list = dbtask_sqljob_list
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.dbtask_sqljob_list:
            for k in self.dbtask_sqljob_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DBTaskSQLJobList'] = []
        if self.dbtask_sqljob_list is not None:
            for k in self.dbtask_sqljob_list:
                result['DBTaskSQLJobList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dbtask_sqljob_list = []
        if m.get('DBTaskSQLJobList') is not None:
            for k in m.get('DBTaskSQLJobList'):
                temp_model = ListDBTaskSQLJobResponseBodyDBTaskSQLJobList()
                self.dbtask_sqljob_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDBTaskSQLJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDBTaskSQLJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDBTaskSQLJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDBTaskSQLJobDetailRequest(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The ID of the SQL task. You can call the [ListDBTaskSQLJob](~~207049~~) operation to query the SQL task ID.
        self.job_id = job_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList(TeaModel):
    def __init__(
        self,
        affect_rows: int = None,
        current_sql: str = None,
        db_id: int = None,
        end_time: str = None,
        execute_count: int = None,
        job_detail_id: int = None,
        job_id: int = None,
        log: str = None,
        logic: bool = None,
        skip: bool = None,
        sql_type: str = None,
        start_time: str = None,
        status: str = None,
        time_delay: int = None,
    ):
        # The number of rows affected by the SQL task.
        self.affect_rows = affect_rows
        # The SQL statement that was executed in the SQL task.
        self.current_sql = current_sql
        # The ID of the physical database.
        self.db_id = db_id
        # The point in time when the SQL task ended.
        self.end_time = end_time
        # The number of times that the SQL statement was executed.
        self.execute_count = execute_count
        # The ID of the details of the SQL task.
        self.job_detail_id = job_detail_id
        # The ID of the SQL task.
        self.job_id = job_id
        # The details of the operational log.
        self.log = log
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic
        # Indicates whether the SQL statement was skipped. Valid values:
        # 
        # *   **true**: The SQL statement was skipped.
        # *   **false**: The SQL statement was not skipped.
        self.skip = skip
        # The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
        self.sql_type = sql_type
        # The point in time when the SQL task started.
        self.start_time = start_time
        # The status of the SQL task. Valid values:
        # 
        # *   **INIT**: The SQL task was initialized.
        # *   **PENDING**: The SQL task waited to be run.
        # *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
        # *   **FAIL**: The SQL task failed.
        # *   **SUCCESS**: The SQL task was successful.
        # *   **PAUSE**: The SQL task was paused.
        # *   **DELETE**: The SQL task was deleted.
        # *   **RUNNING**: The SQL task was being run.
        self.status = status
        # The duration of the SQL task. Unit: milliseconds.
        self.time_delay = time_delay

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.current_sql is not None:
            result['CurrentSql'] = self.current_sql
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.execute_count is not None:
            result['ExecuteCount'] = self.execute_count
        if self.job_detail_id is not None:
            result['JobDetailId'] = self.job_detail_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.log is not None:
            result['Log'] = self.log
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.skip is not None:
            result['Skip'] = self.skip
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.time_delay is not None:
            result['TimeDelay'] = self.time_delay
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('CurrentSql') is not None:
            self.current_sql = m.get('CurrentSql')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecuteCount') is not None:
            self.execute_count = m.get('ExecuteCount')
        if m.get('JobDetailId') is not None:
            self.job_detail_id = m.get('JobDetailId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Log') is not None:
            self.log = m.get('Log')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Skip') is not None:
            self.skip = m.get('Skip')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TimeDelay') is not None:
            self.time_delay = m.get('TimeDelay')
        return self


class ListDBTaskSQLJobDetailResponseBody(TeaModel):
    def __init__(
        self,
        dbtask_sqljob_detail_list: List[ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The details of SQL tasks.
        self.dbtask_sqljob_detail_list = dbtask_sqljob_detail_list
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success
        # The total number of SQL tasks.
        self.total_count = total_count

    def validate(self):
        if self.dbtask_sqljob_detail_list:
            for k in self.dbtask_sqljob_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DBTaskSQLJobDetailList'] = []
        if self.dbtask_sqljob_detail_list is not None:
            for k in self.dbtask_sqljob_detail_list:
                result['DBTaskSQLJobDetailList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dbtask_sqljob_detail_list = []
        if m.get('DBTaskSQLJobDetailList') is not None:
            for k in m.get('DBTaskSQLJobDetailList'):
                temp_model = ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList()
                self.dbtask_sqljob_detail_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDBTaskSQLJobDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDBTaskSQLJobDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDBTaskSQLJobDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDDLPublishRecordsRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList(TeaModel):
    def __init__(
        self,
        dbtask_group_id: int = None,
        execute_count: int = None,
        scripts: str = None,
        status_desc: str = None,
        table_name: str = None,
        task_job_status: str = None,
    ):
        self.dbtask_group_id = dbtask_group_id
        self.execute_count = execute_count
        self.scripts = scripts
        self.status_desc = status_desc
        self.table_name = table_name
        self.task_job_status = task_job_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbtask_group_id is not None:
            result['DBTaskGroupId'] = self.dbtask_group_id
        if self.execute_count is not None:
            result['ExecuteCount'] = self.execute_count
        if self.scripts is not None:
            result['Scripts'] = self.scripts
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.task_job_status is not None:
            result['TaskJobStatus'] = self.task_job_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBTaskGroupId') is not None:
            self.dbtask_group_id = m.get('DBTaskGroupId')
        if m.get('ExecuteCount') is not None:
            self.execute_count = m.get('ExecuteCount')
        if m.get('Scripts') is not None:
            self.scripts = m.get('Scripts')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TaskJobStatus') is not None:
            self.task_job_status = m.get('TaskJobStatus')
        return self


class ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        logic: bool = None,
        plan_time: str = None,
        publish_job_list: List[ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList] = None,
        publish_strategy: str = None,
        status_desc: str = None,
        task_job_status: str = None,
    ):
        self.db_id = db_id
        self.logic = logic
        self.plan_time = plan_time
        self.publish_job_list = publish_job_list
        self.publish_strategy = publish_strategy
        self.status_desc = status_desc
        self.task_job_status = task_job_status

    def validate(self):
        if self.publish_job_list:
            for k in self.publish_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.plan_time is not None:
            result['PlanTime'] = self.plan_time
        result['PublishJobList'] = []
        if self.publish_job_list is not None:
            for k in self.publish_job_list:
                result['PublishJobList'].append(k.to_map() if k else None)
        if self.publish_strategy is not None:
            result['PublishStrategy'] = self.publish_strategy
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.task_job_status is not None:
            result['TaskJobStatus'] = self.task_job_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PlanTime') is not None:
            self.plan_time = m.get('PlanTime')
        self.publish_job_list = []
        if m.get('PublishJobList') is not None:
            for k in m.get('PublishJobList'):
                temp_model = ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList()
                self.publish_job_list.append(temp_model.from_map(k))
        if m.get('PublishStrategy') is not None:
            self.publish_strategy = m.get('PublishStrategy')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('TaskJobStatus') is not None:
            self.task_job_status = m.get('TaskJobStatus')
        return self


class ListDDLPublishRecordsResponseBodyDDLPublishRecordList(TeaModel):
    def __init__(
        self,
        audit_expire_time: str = None,
        audit_status: str = None,
        creator_id: int = None,
        finality: bool = None,
        finality_reason: str = None,
        publish_status: str = None,
        publish_task_info_list: List[ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList] = None,
        risk_level: str = None,
        status_desc: str = None,
        workflow_instance_id: int = None,
    ):
        self.audit_expire_time = audit_expire_time
        self.audit_status = audit_status
        self.creator_id = creator_id
        self.finality = finality
        self.finality_reason = finality_reason
        self.publish_status = publish_status
        self.publish_task_info_list = publish_task_info_list
        self.risk_level = risk_level
        self.status_desc = status_desc
        self.workflow_instance_id = workflow_instance_id

    def validate(self):
        if self.publish_task_info_list:
            for k in self.publish_task_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_expire_time is not None:
            result['AuditExpireTime'] = self.audit_expire_time
        if self.audit_status is not None:
            result['AuditStatus'] = self.audit_status
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.finality is not None:
            result['Finality'] = self.finality
        if self.finality_reason is not None:
            result['FinalityReason'] = self.finality_reason
        if self.publish_status is not None:
            result['PublishStatus'] = self.publish_status
        result['PublishTaskInfoList'] = []
        if self.publish_task_info_list is not None:
            for k in self.publish_task_info_list:
                result['PublishTaskInfoList'].append(k.to_map() if k else None)
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditExpireTime') is not None:
            self.audit_expire_time = m.get('AuditExpireTime')
        if m.get('AuditStatus') is not None:
            self.audit_status = m.get('AuditStatus')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Finality') is not None:
            self.finality = m.get('Finality')
        if m.get('FinalityReason') is not None:
            self.finality_reason = m.get('FinalityReason')
        if m.get('PublishStatus') is not None:
            self.publish_status = m.get('PublishStatus')
        self.publish_task_info_list = []
        if m.get('PublishTaskInfoList') is not None:
            for k in m.get('PublishTaskInfoList'):
                temp_model = ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList()
                self.publish_task_info_list.append(temp_model.from_map(k))
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class ListDDLPublishRecordsResponseBody(TeaModel):
    def __init__(
        self,
        ddlpublish_record_list: List[ListDDLPublishRecordsResponseBodyDDLPublishRecordList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.ddlpublish_record_list = ddlpublish_record_list
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.ddlpublish_record_list:
            for k in self.ddlpublish_record_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DDLPublishRecordList'] = []
        if self.ddlpublish_record_list is not None:
            for k in self.ddlpublish_record_list:
                result['DDLPublishRecordList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ddlpublish_record_list = []
        if m.get('DDLPublishRecordList') is not None:
            for k in m.get('DDLPublishRecordList'):
                temp_model = ListDDLPublishRecordsResponseBodyDDLPublishRecordList()
                self.ddlpublish_record_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDDLPublishRecordsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDDLPublishRecordsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDDLPublishRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataCorrectPreCheckDBRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The ID of the ticket for the data change.
        self.order_id = order_id
        # The number of the page to return.
        # 
        # Valid values: an integer that is greater than 0.
        # 
        # Default value: 1.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDataCorrectPreCheckDBResponseBodyPreCheckDBList(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        search_name: str = None,
        sql_num: int = None,
    ):
        # The ID of the database.
        self.db_id = db_id
        # The name of the database.
        self.search_name = search_name
        # The number of SQL statements.
        self.sql_num = sql_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sql_num is not None:
            result['SqlNum'] = self.sql_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('SqlNum') is not None:
            self.sql_num = m.get('SqlNum')
        return self


class ListDataCorrectPreCheckDBResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pre_check_dblist: List[ListDataCorrectPreCheckDBResponseBodyPreCheckDBList] = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The information about the databases that are involved in the precheck.
        self.pre_check_dblist = pre_check_dblist
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success

    def validate(self):
        if self.pre_check_dblist:
            for k in self.pre_check_dblist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['PreCheckDBList'] = []
        if self.pre_check_dblist is not None:
            for k in self.pre_check_dblist:
                result['PreCheckDBList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.pre_check_dblist = []
        if m.get('PreCheckDBList') is not None:
            for k in m.get('PreCheckDBList'):
                temp_model = ListDataCorrectPreCheckDBResponseBodyPreCheckDBList()
                self.pre_check_dblist.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataCorrectPreCheckDBResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataCorrectPreCheckDBResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataCorrectPreCheckDBResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataCorrectPreCheckSQLRequest(TeaModel):
    def __init__(
        self,
        db_id: int = None,
        order_id: int = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To query the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
        # *   To query the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
        self.db_id = db_id
        # The ID of the data change ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the data change ticket.
        self.order_id = order_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList(TeaModel):
    def __init__(
        self,
        affect_rows: int = None,
        check_sql: str = None,
        db_id: int = None,
        sqlreview_query_key: str = None,
        sql_review_status: str = None,
        sql_type: str = None,
        table_names: str = None,
    ):
        # The estimated number of affected rows.
        self.affect_rows = affect_rows
        # The SQL statement.
        self.check_sql = check_sql
        # The ID of the database.
        self.db_id = db_id
        # The key that is used to query the details of optimization suggestions. You can call the [GetSQLReviewOptimizeDetail](~~265977~~) operation to query the details of optimization suggestions based on the key.
        self.sqlreview_query_key = sqlreview_query_key
        # The review status of the SQL statement. Valid values:
        # 
        # *   **WAITING**: The SQL statement is pending for review.
        # *   **RUNNING**: The SQL statement is being reviewed.
        # *   **IGNORE**: The SQL statement review is skipped.
        # *   **PASS**: The SQL statement passed the review.
        # *   **BLOCK**: The SQL statement failed the review.
        self.sql_review_status = sql_review_status
        # The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
        self.sql_type = sql_type
        # The name of the table whose data is changed.
        self.table_names = table_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.check_sql is not None:
            result['CheckSQL'] = self.check_sql
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.sqlreview_query_key is not None:
            result['SQLReviewQueryKey'] = self.sqlreview_query_key
        if self.sql_review_status is not None:
            result['SqlReviewStatus'] = self.sql_review_status
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.table_names is not None:
            result['TableNames'] = self.table_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('CheckSQL') is not None:
            self.check_sql = m.get('CheckSQL')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('SQLReviewQueryKey') is not None:
            self.sqlreview_query_key = m.get('SQLReviewQueryKey')
        if m.get('SqlReviewStatus') is not None:
            self.sql_review_status = m.get('SqlReviewStatus')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('TableNames') is not None:
            self.table_names = m.get('TableNames')
        return self


class ListDataCorrectPreCheckSQLResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pre_check_sqllist: List[ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList] = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The precheck information about SQL statements.
        self.pre_check_sqllist = pre_check_sqllist
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        if self.pre_check_sqllist:
            for k in self.pre_check_sqllist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['PreCheckSQLList'] = []
        if self.pre_check_sqllist is not None:
            for k in self.pre_check_sqllist:
                result['PreCheckSQLList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.pre_check_sqllist = []
        if m.get('PreCheckSQLList') is not None:
            for k in m.get('PreCheckSQLList'):
                temp_model = ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList()
                self.pre_check_sqllist.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDataCorrectPreCheckSQLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataCorrectPreCheckSQLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataCorrectPreCheckSQLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDatabaseUserPermssionsRequest(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        logic: bool = None,
        page_number: int = None,
        page_size: int = None,
        perm_type: str = None,
        tid: int = None,
        user_name: str = None,
    ):
        self.db_id = db_id
        self.logic = logic
        self.page_number = page_number
        self.page_size = page_size
        self.perm_type = perm_type
        self.tid = tid
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail(TeaModel):
    def __init__(
        self,
        create_date: str = None,
        expire_date: str = None,
        extra_data: str = None,
        origin_from: str = None,
        perm_type: str = None,
        user_access_id: str = None,
    ):
        self.create_date = create_date
        self.expire_date = expire_date
        self.extra_data = extra_data
        self.origin_from = origin_from
        self.perm_type = perm_type
        self.user_access_id = user_access_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_date is not None:
            result['CreateDate'] = self.create_date
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.extra_data is not None:
            result['ExtraData'] = self.extra_data
        if self.origin_from is not None:
            result['OriginFrom'] = self.origin_from
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.user_access_id is not None:
            result['UserAccessId'] = self.user_access_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateDate') is not None:
            self.create_date = m.get('CreateDate')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('ExtraData') is not None:
            self.extra_data = m.get('ExtraData')
        if m.get('OriginFrom') is not None:
            self.origin_from = m.get('OriginFrom')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('UserAccessId') is not None:
            self.user_access_id = m.get('UserAccessId')
        return self


class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails(TeaModel):
    def __init__(
        self,
        perm_detail: List[ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail] = None,
    ):
        self.perm_detail = perm_detail

    def validate(self):
        if self.perm_detail:
            for k in self.perm_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PermDetail'] = []
        if self.perm_detail is not None:
            for k in self.perm_detail:
                result['PermDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.perm_detail = []
        if m.get('PermDetail') is not None:
            for k in m.get('PermDetail'):
                temp_model = ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail()
                self.perm_detail.append(temp_model.from_map(k))
        return self


class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission(TeaModel):
    def __init__(
        self,
        alias: str = None,
        column_name: str = None,
        db_id: str = None,
        db_type: str = None,
        ds_type: str = None,
        env_type: str = None,
        instance_id: str = None,
        logic: bool = None,
        perm_details: ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails = None,
        schema_name: str = None,
        search_name: str = None,
        table_id: str = None,
        table_name: str = None,
        user_id: str = None,
        user_nick_name: str = None,
    ):
        self.alias = alias
        self.column_name = column_name
        self.db_id = db_id
        self.db_type = db_type
        self.ds_type = ds_type
        self.env_type = env_type
        self.instance_id = instance_id
        self.logic = logic
        self.perm_details = perm_details
        self.schema_name = schema_name
        self.search_name = search_name
        self.table_id = table_id
        self.table_name = table_name
        self.user_id = user_id
        self.user_nick_name = user_nick_name

    def validate(self):
        if self.perm_details:
            self.perm_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.perm_details is not None:
            result['PermDetails'] = self.perm_details.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick_name is not None:
            result['UserNickName'] = self.user_nick_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermDetails') is not None:
            temp_model = ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails()
            self.perm_details = temp_model.from_map(m['PermDetails'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNickName') is not None:
            self.user_nick_name = m.get('UserNickName')
        return self


class ListDatabaseUserPermssionsResponseBodyUserPermissions(TeaModel):
    def __init__(
        self,
        user_permission: List[ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission] = None,
    ):
        self.user_permission = user_permission

    def validate(self):
        if self.user_permission:
            for k in self.user_permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserPermission'] = []
        if self.user_permission is not None:
            for k in self.user_permission:
                result['UserPermission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user_permission = []
        if m.get('UserPermission') is not None:
            for k in m.get('UserPermission'):
                temp_model = ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission()
                self.user_permission.append(temp_model.from_map(k))
        return self


class ListDatabaseUserPermssionsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
        user_permissions: ListDatabaseUserPermssionsResponseBodyUserPermissions = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.total_count = total_count
        self.user_permissions = user_permissions

    def validate(self):
        if self.user_permissions:
            self.user_permissions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_permissions is not None:
            result['UserPermissions'] = self.user_permissions.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserPermissions') is not None:
            temp_model = ListDatabaseUserPermssionsResponseBodyUserPermissions()
            self.user_permissions = temp_model.from_map(m['UserPermissions'])
        return self


class ListDatabaseUserPermssionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDatabaseUserPermssionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDatabaseUserPermssionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDatabasesRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        self.instance_id = instance_id
        self.page_number = page_number
        self.page_size = page_size
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListDatabasesResponseBodyDatabaseListDatabase(TeaModel):
    def __init__(
        self,
        catalog_name: str = None,
        database_id: str = None,
        db_type: str = None,
        dba_id: str = None,
        dba_name: str = None,
        encoding: str = None,
        env_type: str = None,
        host: str = None,
        instance_id: str = None,
        owner_id_list: ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList = None,
        owner_name_list: ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList = None,
        port: int = None,
        schema_name: str = None,
        search_name: str = None,
        sid: str = None,
        state: str = None,
    ):
        self.catalog_name = catalog_name
        self.database_id = database_id
        self.db_type = db_type
        self.dba_id = dba_id
        self.dba_name = dba_name
        self.encoding = encoding
        self.env_type = env_type
        self.host = host
        self.instance_id = instance_id
        self.owner_id_list = owner_id_list
        self.owner_name_list = owner_name_list
        self.port = port
        self.schema_name = schema_name
        self.search_name = search_name
        self.sid = sid
        self.state = state

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.catalog_name is not None:
            result['CatalogName'] = self.catalog_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_name is not None:
            result['DbaName'] = self.dba_name
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CatalogName') is not None:
            self.catalog_name = m.get('CatalogName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaName') is not None:
            self.dba_name = m.get('DbaName')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerIdList') is not None:
            temp_model = ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListDatabasesResponseBodyDatabaseList(TeaModel):
    def __init__(
        self,
        database: List[ListDatabasesResponseBodyDatabaseListDatabase] = None,
    ):
        self.database = database

    def validate(self):
        if self.database:
            for k in self.database:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Database'] = []
        if self.database is not None:
            for k in self.database:
                result['Database'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.database = []
        if m.get('Database') is not None:
            for k in m.get('Database'):
                temp_model = ListDatabasesResponseBodyDatabaseListDatabase()
                self.database.append(temp_model.from_map(k))
        return self


class ListDatabasesResponseBody(TeaModel):
    def __init__(
        self,
        database_list: ListDatabasesResponseBodyDatabaseList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.database_list = database_list
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.database_list:
            self.database_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_list is not None:
            result['DatabaseList'] = self.database_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseList') is not None:
            temp_model = ListDatabasesResponseBodyDatabaseList()
            self.database_list = temp_model.from_map(m['DatabaseList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDatabasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDatabasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDatabasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDefaultSLARulesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDefaultSLARulesResponseBodySLARuleListSLARule(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        id: int = None,
        interval_minutes: int = None,
        node_id: int = None,
        rule_type: int = None,
    ):
        # The ID of the task flow.
        self.dag_id = dag_id
        # The ID of the SLA rule.
        self.id = id
        # The timeout period. Unit: minutes.
        self.interval_minutes = interval_minutes
        # The ID of the task node.
        self.node_id = node_id
        # The type of the rule. Valid values:
        # 
        # *   **0**: an SLA rule for a task flow
        # *   **1**: an SLA rule for a task node
        self.rule_type = rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.interval_minutes is not None:
            result['IntervalMinutes'] = self.interval_minutes
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IntervalMinutes') is not None:
            self.interval_minutes = m.get('IntervalMinutes')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        return self


class ListDefaultSLARulesResponseBodySLARuleList(TeaModel):
    def __init__(
        self,
        slarule: List[ListDefaultSLARulesResponseBodySLARuleListSLARule] = None,
    ):
        self.slarule = slarule

    def validate(self):
        if self.slarule:
            for k in self.slarule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SLARule'] = []
        if self.slarule is not None:
            for k in self.slarule:
                result['SLARule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.slarule = []
        if m.get('SLARule') is not None:
            for k in m.get('SLARule'):
                temp_model = ListDefaultSLARulesResponseBodySLARuleListSLARule()
                self.slarule.append(temp_model.from_map(k))
        return self


class ListDefaultSLARulesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        slarule_list: ListDefaultSLARulesResponseBodySLARuleList = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # The list of SLA rules.
        self.slarule_list = slarule_list
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.slarule_list:
            self.slarule_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.slarule_list is not None:
            result['SLARuleList'] = self.slarule_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SLARuleList') is not None:
            temp_model = ListDefaultSLARulesResponseBodySLARuleList()
            self.slarule_list = temp_model.from_map(m['SLARuleList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDefaultSLARulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDefaultSLARulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDefaultSLARulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDesensitizationRuleRequest(TeaModel):
    def __init__(
        self,
        func_type: str = None,
        page_number: int = None,
        page_size: int = None,
        rule_id: int = None,
        rule_name: str = None,
        rule_type: str = None,
        tid: int = None,
    ):
        # The type of the masking algorithm.
        self.func_type = func_type
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page. The maximum value is 100.
        self.page_size = page_size
        # The ID of the masking rule.
        self.rule_id = rule_id
        # The name of the masking rule.
        self.rule_name = rule_name
        # The algorithm used for masking.
        self.rule_type = rule_type
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.func_type is not None:
            result['FuncType'] = self.func_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FuncType') is not None:
            self.func_type = m.get('FuncType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListDesensitizationRuleResponseBodyDesensitizationRuleList(TeaModel):
    def __init__(
        self,
        func_params: str = None,
        func_sample: str = None,
        function_type: str = None,
        last_modifier_id: str = None,
        last_modifier_name: str = None,
        reference_count: int = None,
        rule_desc: str = None,
        rule_id: int = None,
        rule_name: str = None,
        rule_type: str = None,
    ):
        # The parameter.
        self.func_params = func_params
        # The example.
        self.func_sample = func_sample
        # The algorithm type.
        self.function_type = function_type
        # The ID of the user who last modified the masking rule.
        self.last_modifier_id = last_modifier_id
        # The name of the user who last modified the masking rule.
        self.last_modifier_name = last_modifier_name
        # The number of times that the masking was used.
        self.reference_count = reference_count
        # The description of the rule.
        self.rule_desc = rule_desc
        # The ID of the masking rule.
        self.rule_id = rule_id
        # The name of the masking rule.
        self.rule_name = rule_name
        # The algorithm used for masking.
        self.rule_type = rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.func_params is not None:
            result['FuncParams'] = self.func_params
        if self.func_sample is not None:
            result['FuncSample'] = self.func_sample
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.last_modifier_id is not None:
            result['LastModifierId'] = self.last_modifier_id
        if self.last_modifier_name is not None:
            result['LastModifierName'] = self.last_modifier_name
        if self.reference_count is not None:
            result['ReferenceCount'] = self.reference_count
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FuncParams') is not None:
            self.func_params = m.get('FuncParams')
        if m.get('FuncSample') is not None:
            self.func_sample = m.get('FuncSample')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('LastModifierId') is not None:
            self.last_modifier_id = m.get('LastModifierId')
        if m.get('LastModifierName') is not None:
            self.last_modifier_name = m.get('LastModifierName')
        if m.get('ReferenceCount') is not None:
            self.reference_count = m.get('ReferenceCount')
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        return self


class ListDesensitizationRuleResponseBody(TeaModel):
    def __init__(
        self,
        desensitization_rule_list: List[ListDesensitizationRuleResponseBodyDesensitizationRuleList] = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The list of masking rules.
        self.desensitization_rule_list = desensitization_rule_list
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success
        # The total number of entries returned. By default, this parameter is not returned.
        self.total_count = total_count

    def validate(self):
        if self.desensitization_rule_list:
            for k in self.desensitization_rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DesensitizationRuleList'] = []
        if self.desensitization_rule_list is not None:
            for k in self.desensitization_rule_list:
                result['DesensitizationRuleList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.desensitization_rule_list = []
        if m.get('DesensitizationRuleList') is not None:
            for k in m.get('DesensitizationRuleList'):
                temp_model = ListDesensitizationRuleResponseBodyDesensitizationRuleList()
                self.desensitization_rule_list.append(temp_model.from_map(k))
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDesensitizationRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDesensitizationRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDesensitizationRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEffectiveOrdersRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListEffectiveOrdersResponseBodyOrderSummaryOrderList(TeaModel):
    def __init__(
        self,
        buyer_id: str = None,
        end_time: str = None,
        ins_num: str = None,
        instance_id: str = None,
        order_id: str = None,
        start_time: str = None,
    ):
        self.buyer_id = buyer_id
        self.end_time = end_time
        self.ins_num = ins_num
        self.instance_id = instance_id
        self.order_id = order_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.buyer_id is not None:
            result['BuyerId'] = self.buyer_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.ins_num is not None:
            result['InsNum'] = self.ins_num
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BuyerId') is not None:
            self.buyer_id = m.get('BuyerId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InsNum') is not None:
            self.ins_num = m.get('InsNum')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListEffectiveOrdersResponseBodyOrderSummary(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
        commodity_type: str = None,
        order_list: List[ListEffectiveOrdersResponseBodyOrderSummaryOrderList] = None,
        total_quota: int = None,
        version_type: str = None,
    ):
        self.commodity_code = commodity_code
        self.commodity_type = commodity_type
        self.order_list = order_list
        self.total_quota = total_quota
        self.version_type = version_type

    def validate(self):
        if self.order_list:
            for k in self.order_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.commodity_type is not None:
            result['CommodityType'] = self.commodity_type
        result['OrderList'] = []
        if self.order_list is not None:
            for k in self.order_list:
                result['OrderList'].append(k.to_map() if k else None)
        if self.total_quota is not None:
            result['TotalQuota'] = self.total_quota
        if self.version_type is not None:
            result['VersionType'] = self.version_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('CommodityType') is not None:
            self.commodity_type = m.get('CommodityType')
        self.order_list = []
        if m.get('OrderList') is not None:
            for k in m.get('OrderList'):
                temp_model = ListEffectiveOrdersResponseBodyOrderSummaryOrderList()
                self.order_list.append(temp_model.from_map(k))
        if m.get('TotalQuota') is not None:
            self.total_quota = m.get('TotalQuota')
        if m.get('VersionType') is not None:
            self.version_type = m.get('VersionType')
        return self


class ListEffectiveOrdersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        order_summary: List[ListEffectiveOrdersResponseBodyOrderSummary] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.order_summary = order_summary
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.order_summary:
            for k in self.order_summary:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['OrderSummary'] = []
        if self.order_summary is not None:
            for k in self.order_summary:
                result['OrderSummary'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.order_summary = []
        if m.get('OrderSummary') is not None:
            for k in m.get('OrderSummary'):
                temp_model = ListEffectiveOrdersResponseBodyOrderSummary()
                self.order_summary.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEffectiveOrdersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEffectiveOrdersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEffectiveOrdersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIndexesRequest(TeaModel):
    def __init__(
        self,
        logic: bool = None,
        table_id: str = None,
        tid: int = None,
    ):
        self.logic = logic
        self.table_id = table_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListIndexesResponseBodyIndexListIndex(TeaModel):
    def __init__(
        self,
        index_comment: str = None,
        index_id: str = None,
        index_name: str = None,
        index_type: str = None,
        table_id: str = None,
    ):
        self.index_comment = index_comment
        self.index_id = index_id
        self.index_name = index_name
        self.index_type = index_type
        self.table_id = table_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_comment is not None:
            result['IndexComment'] = self.index_comment
        if self.index_id is not None:
            result['IndexId'] = self.index_id
        if self.index_name is not None:
            result['IndexName'] = self.index_name
        if self.index_type is not None:
            result['IndexType'] = self.index_type
        if self.table_id is not None:
            result['TableId'] = self.table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IndexComment') is not None:
            self.index_comment = m.get('IndexComment')
        if m.get('IndexId') is not None:
            self.index_id = m.get('IndexId')
        if m.get('IndexName') is not None:
            self.index_name = m.get('IndexName')
        if m.get('IndexType') is not None:
            self.index_type = m.get('IndexType')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        return self


class ListIndexesResponseBodyIndexList(TeaModel):
    def __init__(
        self,
        index: List[ListIndexesResponseBodyIndexListIndex] = None,
    ):
        self.index = index

    def validate(self):
        if self.index:
            for k in self.index:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Index'] = []
        if self.index is not None:
            for k in self.index:
                result['Index'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.index = []
        if m.get('Index') is not None:
            for k in m.get('Index'):
                temp_model = ListIndexesResponseBodyIndexListIndex()
                self.index.append(temp_model.from_map(k))
        return self


class ListIndexesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        index_list: ListIndexesResponseBodyIndexList = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.index_list = index_list
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.index_list:
            self.index_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.index_list is not None:
            result['IndexList'] = self.index_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('IndexList') is not None:
            temp_model = ListIndexesResponseBodyIndexList()
            self.index_list = temp_model.from_map(m['IndexList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListIndexesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIndexesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIndexesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstanceLoginAuditLogRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        op_user_name: str = None,
        page_number: int = None,
        page_size: int = None,
        search_name: str = None,
        start_time: str = None,
        tid: int = None,
    ):
        # The end of the time range to query.
        # 
        # >  The end time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format. We recommend that you use the StartTime and EndTime parameters to specify a time range that does not exceed one day. This way, the returned entries can be displayed by page to increase query efficiency.
        self.end_time = end_time
        # The alias of the user.
        self.op_user_name = op_user_name
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: 100.
        self.page_size = page_size
        # The name of the database or instance whose logon records you want to query.
        # 
        # >  If SQL statements are executed at the instance level, you can set this parameter to an instance name. If SQL statements are executed at the database level, you can set this parameter to a database name.
        self.search_name = search_name
        # The beginning of the time range to query.
        # 
        # >  The start time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format.
        self.start_time = start_time
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.op_user_name is not None:
            result['OpUserName'] = self.op_user_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OpUserName') is not None:
            self.op_user_name = m.get('OpUserName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog(TeaModel):
    def __init__(
        self,
        db_user: str = None,
        instance_id: int = None,
        instance_name: str = None,
        op_time: str = None,
        request_ip: str = None,
        user_id: int = None,
        user_name: str = None,
    ):
        # The database account that is used to log on to the instance.
        self.db_user = db_user
        # The ID of the instance.
        self.instance_id = instance_id
        # The name of the instance.
        self.instance_name = instance_name
        # The time when the user performed an operation on the instance.
        self.op_time = op_time
        # The source IP address of the request.
        self.request_ip = request_ip
        # The ID of the user.
        self.user_id = user_id
        # The alias of the user.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_user is not None:
            result['DbUser'] = self.db_user
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        if self.request_ip is not None:
            result['RequestIp'] = self.request_ip
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbUser') is not None:
            self.db_user = m.get('DbUser')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        if m.get('RequestIp') is not None:
            self.request_ip = m.get('RequestIp')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList(TeaModel):
    def __init__(
        self,
        instance_login_audit_log: List[ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog] = None,
    ):
        self.instance_login_audit_log = instance_login_audit_log

    def validate(self):
        if self.instance_login_audit_log:
            for k in self.instance_login_audit_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceLoginAuditLog'] = []
        if self.instance_login_audit_log is not None:
            for k in self.instance_login_audit_log:
                result['InstanceLoginAuditLog'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance_login_audit_log = []
        if m.get('InstanceLoginAuditLog') is not None:
            for k in m.get('InstanceLoginAuditLog'):
                temp_model = ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog()
                self.instance_login_audit_log.append(temp_model.from_map(k))
        return self


class ListInstanceLoginAuditLogResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        instance_login_audit_log_list: ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The logon records of the instance.
        self.instance_login_audit_log_list = instance_login_audit_log_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.instance_login_audit_log_list:
            self.instance_login_audit_log_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_login_audit_log_list is not None:
            result['InstanceLoginAuditLogList'] = self.instance_login_audit_log_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceLoginAuditLogList') is not None:
            temp_model = ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList()
            self.instance_login_audit_log_list = temp_model.from_map(m['InstanceLoginAuditLogList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInstanceLoginAuditLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInstanceLoginAuditLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstanceLoginAuditLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstanceUserPermissionsRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
        user_name: str = None,
    ):
        # The ID of the instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to query the ID of the instance.
        self.instance_id = instance_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid
        # The nickname of the user. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to query the nickname of the user.
        # 
        # >  The value of the NickName parameter is that of the UserName parameter.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail(TeaModel):
    def __init__(
        self,
        create_date: str = None,
        expire_date: str = None,
        extra_data: str = None,
        origin_from: str = None,
        perm_type: str = None,
        user_access_id: str = None,
    ):
        # The time when the permissions were granted.
        self.create_date = create_date
        # The time when the permissions expire.
        self.expire_date = expire_date
        # This parameter is reserved.
        self.extra_data = extra_data
        # The user who grants the permissions.
        self.origin_from = origin_from
        # The type of the permissions. Valid values:
        # 
        # *   LOGIN: the logon permissions
        # *   PERF: the query permissions on the instance
        self.perm_type = perm_type
        # The ID of the authorization record.
        self.user_access_id = user_access_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_date is not None:
            result['CreateDate'] = self.create_date
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.extra_data is not None:
            result['ExtraData'] = self.extra_data
        if self.origin_from is not None:
            result['OriginFrom'] = self.origin_from
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.user_access_id is not None:
            result['UserAccessId'] = self.user_access_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateDate') is not None:
            self.create_date = m.get('CreateDate')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('ExtraData') is not None:
            self.extra_data = m.get('ExtraData')
        if m.get('OriginFrom') is not None:
            self.origin_from = m.get('OriginFrom')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('UserAccessId') is not None:
            self.user_access_id = m.get('UserAccessId')
        return self


class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails(TeaModel):
    def __init__(
        self,
        perm_detail: List[ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail] = None,
    ):
        self.perm_detail = perm_detail

    def validate(self):
        if self.perm_detail:
            for k in self.perm_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PermDetail'] = []
        if self.perm_detail is not None:
            for k in self.perm_detail:
                result['PermDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.perm_detail = []
        if m.get('PermDetail') is not None:
            for k in m.get('PermDetail'):
                temp_model = ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail()
                self.perm_detail.append(temp_model.from_map(k))
        return self


class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        perm_details: ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails = None,
        user_id: str = None,
        user_nick_name: str = None,
    ):
        # The ID of the instance.
        self.instance_id = instance_id
        # The details of permissions.
        self.perm_details = perm_details
        # The ID of the user.
        self.user_id = user_id
        # The nickname of the user.
        self.user_nick_name = user_nick_name

    def validate(self):
        if self.perm_details:
            self.perm_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.perm_details is not None:
            result['PermDetails'] = self.perm_details.to_map()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick_name is not None:
            result['UserNickName'] = self.user_nick_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PermDetails') is not None:
            temp_model = ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails()
            self.perm_details = temp_model.from_map(m['PermDetails'])
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNickName') is not None:
            self.user_nick_name = m.get('UserNickName')
        return self


class ListInstanceUserPermissionsResponseBodyUserPermissions(TeaModel):
    def __init__(
        self,
        user_permission: List[ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission] = None,
    ):
        self.user_permission = user_permission

    def validate(self):
        if self.user_permission:
            for k in self.user_permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserPermission'] = []
        if self.user_permission is not None:
            for k in self.user_permission:
                result['UserPermission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user_permission = []
        if m.get('UserPermission') is not None:
            for k in m.get('UserPermission'):
                temp_model = ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission()
                self.user_permission.append(temp_model.from_map(k))
        return self


class ListInstanceUserPermissionsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
        user_permissions: ListInstanceUserPermissionsResponseBodyUserPermissions = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success
        # The total number of returned entries.
        self.total_count = total_count
        # The permissions of the user on the instance.
        self.user_permissions = user_permissions

    def validate(self):
        if self.user_permissions:
            self.user_permissions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_permissions is not None:
            result['UserPermissions'] = self.user_permissions.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserPermissions') is not None:
            temp_model = ListInstanceUserPermissionsResponseBodyUserPermissions()
            self.user_permissions = temp_model.from_map(m['UserPermissions'])
        return self


class ListInstanceUserPermissionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInstanceUserPermissionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstanceUserPermissionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstancesRequest(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        env_type: str = None,
        instance_source: str = None,
        instance_state: str = None,
        net_type: str = None,
        page_number: int = None,
        page_size: int = None,
        search_key: str = None,
        tid: int = None,
    ):
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type
        # The type of the environment to which the database instance belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: staging environment
        # *   **test**: test environment
        # *   **sit**: system integration testing (SIT) environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: STAG environment
        self.env_type = env_type
        # The source of the database instance. Valid values:
        # 
        # *   **PUBLIC_OWN**: a self-managed database instance that is deployed on the Internet
        # *   **RDS**: an ApsaraDB RDS instance
        # *   **ECS_OWN**: a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
        # *   **VPC_IDC**: a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
        self.instance_source = instance_source
        # The status of the database instance. Valid values:
        # 
        # *   **NORMAL**: normal
        # *   **DISABLE**: disabled
        self.instance_state = instance_state
        # The network type of the database instance. Valid values:
        # 
        # *   **CLASSIC**: classic network
        # *   **VPC**: VPC
        self.net_type = net_type
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page. The number cannot exceed 100.
        self.page_size = page_size
        # The keyword that is used to search for database instances.
        self.search_key = search_key
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_state is not None:
            result['InstanceState'] = self.instance_state
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceState') is not None:
            self.instance_state = m.get('InstanceState')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListInstancesResponseBodyInstanceListInstanceOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListInstancesResponseBodyInstanceListInstanceOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListInstancesResponseBodyInstanceListInstanceStandardGroup(TeaModel):
    def __init__(
        self,
        group_mode: str = None,
        group_name: str = None,
    ):
        # The type of the control mode. Valid values:
        # 
        # *   **COMMON**: Security Collaboration
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        self.group_mode = group_mode
        # The name of the security rule set corresponding to the control mode.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class ListInstancesResponseBodyInstanceListInstance(TeaModel):
    def __init__(
        self,
        data_link_name: str = None,
        database_password: str = None,
        database_user: str = None,
        dba_id: str = None,
        dba_nick_name: str = None,
        ddl_online: int = None,
        ecs_instance_id: str = None,
        ecs_region: str = None,
        env_type: str = None,
        export_timeout: int = None,
        host: str = None,
        instance_alias: str = None,
        instance_id: str = None,
        instance_source: str = None,
        instance_type: str = None,
        owner_id_list: ListInstancesResponseBodyInstanceListInstanceOwnerIdList = None,
        owner_name_list: ListInstancesResponseBodyInstanceListInstanceOwnerNameList = None,
        port: int = None,
        query_timeout: int = None,
        safe_rule_id: str = None,
        sell_sitd: bool = None,
        sid: str = None,
        standard_group: ListInstancesResponseBodyInstanceListInstanceStandardGroup = None,
        state: str = None,
        use_dsql: int = None,
        vpc_id: str = None,
    ):
        # The name of the database link for the database instance.
        self.data_link_name = data_link_name
        # The password that is used to log on to the database.
        self.database_password = database_password
        # The account that is used to log on to the database.
        self.database_user = database_user
        # The ID of the database administrator (DBA) for the database instance.
        self.dba_id = dba_id
        # The nickname of the DBA for the database instance.
        self.dba_nick_name = dba_nick_name
        # Indicates whether the lock-free schema change feature is enabled for the database instance.
        self.ddl_online = ddl_online
        # The ID of the ECS instance on which the database instance is deployed.
        self.ecs_instance_id = ecs_instance_id
        # The ID of the region in which the database instance resides.
        self.ecs_region = ecs_region
        # The type of the environment to which the database instance belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: staging environment
        # *   **test**: test environment
        # *   **sit**: SIT environment
        # *   **uat**: UAT environment
        # *   **pet**: stress testing environment
        # *   **stag**: STAG environment
        self.env_type = env_type
        # The timeout period for exporting data from the database instance.
        self.export_timeout = export_timeout
        # The host address that is used to connect to the database instance.
        self.host = host
        # The alias of the database instance.
        self.instance_alias = instance_alias
        # The ID of the database instance.
        self.instance_id = instance_id
        # The source of the database instance.
        self.instance_source = instance_source
        # The type of the database instance.
        self.instance_type = instance_type
        # The ID of the owner for the database instance.
        self.owner_id_list = owner_id_list
        # The nickname of the owner for the database instance.
        self.owner_name_list = owner_name_list
        # The port number that is used to connect to the database instance.
        self.port = port
        # The timeout period for querying data in the database instance.
        self.query_timeout = query_timeout
        # The ID of the security rule set for the database instance.
        self.safe_rule_id = safe_rule_id
        self.sell_sitd = sell_sitd
        # The system ID (SID) of the database instance.
        self.sid = sid
        # The control mode of the database instance.
        self.standard_group = standard_group
        # The status of the database instance.
        self.state = state
        # Indicates whether the cross-database query feature is enabled for the database instance. Valid values:
        # 
        # *   **0**: disabled
        # *   **1**: enabled
        self.use_dsql = use_dsql
        # The ID of the VPC to which the database instance belongs.
        self.vpc_id = vpc_id

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()
        if self.standard_group:
            self.standard_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.dba_nick_name is not None:
            result['DbaNickName'] = self.dba_nick_name
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule_id is not None:
            result['SafeRuleId'] = self.safe_rule_id
        if self.sell_sitd is not None:
            result['SellSitd'] = self.sell_sitd
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.standard_group is not None:
            result['StandardGroup'] = self.standard_group.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DbaNickName') is not None:
            self.dba_nick_name = m.get('DbaNickName')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerIdList') is not None:
            temp_model = ListInstancesResponseBodyInstanceListInstanceOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListInstancesResponseBodyInstanceListInstanceOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRuleId') is not None:
            self.safe_rule_id = m.get('SafeRuleId')
        if m.get('SellSitd') is not None:
            self.sell_sitd = m.get('SellSitd')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('StandardGroup') is not None:
            temp_model = ListInstancesResponseBodyInstanceListInstanceStandardGroup()
            self.standard_group = temp_model.from_map(m['StandardGroup'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListInstancesResponseBodyInstanceList(TeaModel):
    def __init__(
        self,
        instance: List[ListInstancesResponseBodyInstanceListInstance] = None,
    ):
        self.instance = instance

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = ListInstancesResponseBodyInstanceListInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class ListInstancesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        instance_list: ListInstancesResponseBodyInstanceList = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The information about the database instances that are returned.
        self.instance_list = instance_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success
        # The total number of database instances that are returned.
        self.total_count = total_count

    def validate(self):
        if self.instance_list:
            self.instance_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_list is not None:
            result['InstanceList'] = self.instance_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceList') is not None:
            temp_model = ListInstancesResponseBodyInstanceList()
            self.instance_list = temp_model.from_map(m['InstanceList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLhTaskFlowAndScenarioRequest(TeaModel):
    def __init__(
        self,
        space_id: int = None,
        tid: int = None,
        user_id: int = None,
    ):
        # The ID of the workspace. You can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
        self.space_id = space_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid
        # The ID of the user. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag(TeaModel):
    def __init__(
        self,
        can_edit: bool = None,
        creator_id: str = None,
        creator_nick_name: str = None,
        dag_name: str = None,
        dag_owner_id: str = None,
        dag_owner_nick_name: str = None,
        data_flow_id: int = None,
        demo_id: str = None,
        deploy_id: int = None,
        id: int = None,
        is_deleted: bool = None,
        latest_instance_status: int = None,
        latest_instance_time: int = None,
        scenario_id: int = None,
        space_id: int = None,
        status: int = None,
    ):
        # Indicates whether the task flow can be modified. Valid values:
        # 
        # *   **true**: The task flow can be modified.
        # *   **false**: The task flow cannot be modified.
        self.can_edit = can_edit
        # The ID of the user who creates the task flow.
        self.creator_id = creator_id
        # The name of the user who creates the workspace.
        self.creator_nick_name = creator_nick_name
        # The name of the task flow.
        self.dag_name = dag_name
        # The user ID of the task flow owner.
        self.dag_owner_id = dag_owner_id
        # The name of the task flow owner.
        self.dag_owner_nick_name = dag_owner_nick_name
        # The extended field. No meaning is specified for this field.
        self.data_flow_id = data_flow_id
        # The extended field. No meaning is specified for this field.
        self.demo_id = demo_id
        # The ID of the latest deployment record.
        self.deploy_id = deploy_id
        # The ID of the task flow.
        self.id = id
        # Indicates whether the task flow is deleted. Valid values:
        # 
        # *   **true**: deleted
        # *   **false**: not deleted
        self.is_deleted = is_deleted
        # The status of the latest execution. Valid values:
        # 
        # *   **0**: invalid
        # *   **1**: scheduling disabled
        # *   **2**: waiting to be scheduled
        self.latest_instance_status = latest_instance_status
        # The time when the latest execution record was generated.
        self.latest_instance_time = latest_instance_time
        # The ID of the business scenario.
        self.scenario_id = scenario_id
        # The ID of the workspace.
        self.space_id = space_id
        # The status of the task flow. Valid values:
        # 
        # *   **0**: invalid
        # *   **1**: scheduling disabled
        # *   **2**: waiting to be scheduled
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_edit is not None:
            result['CanEdit'] = self.can_edit
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick_name is not None:
            result['CreatorNickName'] = self.creator_nick_name
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.data_flow_id is not None:
            result['DataFlowId'] = self.data_flow_id
        if self.demo_id is not None:
            result['DemoId'] = self.demo_id
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.id is not None:
            result['Id'] = self.id
        if self.is_deleted is not None:
            result['IsDeleted'] = self.is_deleted
        if self.latest_instance_status is not None:
            result['LatestInstanceStatus'] = self.latest_instance_status
        if self.latest_instance_time is not None:
            result['LatestInstanceTime'] = self.latest_instance_time
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanEdit') is not None:
            self.can_edit = m.get('CanEdit')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNickName') is not None:
            self.creator_nick_name = m.get('CreatorNickName')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('DataFlowId') is not None:
            self.data_flow_id = m.get('DataFlowId')
        if m.get('DemoId') is not None:
            self.demo_id = m.get('DemoId')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsDeleted') is not None:
            self.is_deleted = m.get('IsDeleted')
        if m.get('LatestInstanceStatus') is not None:
            self.latest_instance_status = m.get('LatestInstanceStatus')
        if m.get('LatestInstanceTime') is not None:
            self.latest_instance_time = m.get('LatestInstanceTime')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListLhTaskFlowAndScenarioResponseBodyRawDAGList(TeaModel):
    def __init__(
        self,
        dag: List[ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag] = None,
    ):
        self.dag = dag

    def validate(self):
        if self.dag:
            for k in self.dag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Dag'] = []
        if self.dag is not None:
            for k in self.dag:
                result['Dag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dag = []
        if m.get('Dag') is not None:
            for k in m.get('Dag'):
                temp_model = ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag()
                self.dag.append(temp_model.from_map(k))
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag(TeaModel):
    def __init__(
        self,
        can_edit: bool = None,
        creator_id: str = None,
        creator_nick_name: str = None,
        dag_name: str = None,
        dag_owner_id: str = None,
        dag_owner_nick_name: str = None,
        data_flow_id: int = None,
        demo_id: str = None,
        deploy_id: int = None,
        id: int = None,
        is_deleted: bool = None,
        latest_instance_status: int = None,
        latest_instance_time: int = None,
        scenario_id: int = None,
        space_id: int = None,
        status: int = None,
    ):
        # Indicates whether the task flow can be modified. Valid values:
        # 
        # - **true**: The task flow can be modified.
        # - **false**: The task flow cannot be modified.
        self.can_edit = can_edit
        # The ID of the user who creates the task flow.
        self.creator_id = creator_id
        # The name of the user who creates the workspace.
        self.creator_nick_name = creator_nick_name
        # The name of the task flow.
        self.dag_name = dag_name
        # The user ID of the task flow owner.
        self.dag_owner_id = dag_owner_id
        # The name of the task flow owner.
        self.dag_owner_nick_name = dag_owner_nick_name
        # The extended field. No meaning is specified for this field.
        self.data_flow_id = data_flow_id
        # The extended field. No meaning is specified for this field.
        self.demo_id = demo_id
        # The ID of the latest deployment record.
        self.deploy_id = deploy_id
        # The ID of the task flow.
        self.id = id
        # Indicates whether the task flow is deleted. Valid values:
        # 
        # - **true**: deleted
        # - **false**: not deleted
        self.is_deleted = is_deleted
        # The status of the latest execution. Valid values:
        # 
        # - 0: invalid
        # - 1: scheduling disabled
        # - 2: waiting to be scheduled
        self.latest_instance_status = latest_instance_status
        # The time when the latest execution record was generated.
        self.latest_instance_time = latest_instance_time
        # The ID of the business scenario.
        self.scenario_id = scenario_id
        # The ID of the workspace.
        self.space_id = space_id
        # The status of the task flow. Valid values:
        # 
        # - **0**: invalid
        # - **1**: scheduling disabled
        # - **2**: waiting to be scheduled
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_edit is not None:
            result['CanEdit'] = self.can_edit
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick_name is not None:
            result['CreatorNickName'] = self.creator_nick_name
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_id is not None:
            result['DagOwnerId'] = self.dag_owner_id
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.data_flow_id is not None:
            result['DataFlowId'] = self.data_flow_id
        if self.demo_id is not None:
            result['DemoId'] = self.demo_id
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.id is not None:
            result['Id'] = self.id
        if self.is_deleted is not None:
            result['IsDeleted'] = self.is_deleted
        if self.latest_instance_status is not None:
            result['LatestInstanceStatus'] = self.latest_instance_status
        if self.latest_instance_time is not None:
            result['LatestInstanceTime'] = self.latest_instance_time
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.space_id is not None:
            result['SpaceId'] = self.space_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanEdit') is not None:
            self.can_edit = m.get('CanEdit')
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNickName') is not None:
            self.creator_nick_name = m.get('CreatorNickName')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerId') is not None:
            self.dag_owner_id = m.get('DagOwnerId')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('DataFlowId') is not None:
            self.data_flow_id = m.get('DataFlowId')
        if m.get('DemoId') is not None:
            self.demo_id = m.get('DemoId')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsDeleted') is not None:
            self.is_deleted = m.get('IsDeleted')
        if m.get('LatestInstanceStatus') is not None:
            self.latest_instance_status = m.get('LatestInstanceStatus')
        if m.get('LatestInstanceTime') is not None:
            self.latest_instance_time = m.get('LatestInstanceTime')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('SpaceId') is not None:
            self.space_id = m.get('SpaceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList(TeaModel):
    def __init__(
        self,
        dag: List[ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag] = None,
    ):
        self.dag = dag

    def validate(self):
        if self.dag:
            for k in self.dag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Dag'] = []
        if self.dag is not None:
            for k in self.dag:
                result['Dag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dag = []
        if m.get('Dag') is not None:
            for k in m.get('Dag'):
                temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag()
                self.dag.append(temp_model.from_map(k))
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario(TeaModel):
    def __init__(
        self,
        creator_id: str = None,
        description: str = None,
        scenario_name: str = None,
    ):
        # The ID of the user who creates the business scenario.
        self.creator_id = creator_id
        # The description of the business scenario.
        self.description = description
        # The name of the business scenario.
        self.scenario_name = scenario_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.scenario_name is not None:
            result['ScenarioName'] = self.scenario_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ScenarioName') is not None:
            self.scenario_name = m.get('ScenarioName')
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG(TeaModel):
    def __init__(
        self,
        dag_list: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList = None,
        scenario: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario = None,
    ):
        # The list of task flows.
        self.dag_list = dag_list
        # The information about the business scenario.
        self.scenario = scenario

    def validate(self):
        if self.dag_list:
            self.dag_list.validate()
        if self.scenario:
            self.scenario.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_list is not None:
            result['DagList'] = self.dag_list.to_map()
        if self.scenario is not None:
            result['Scenario'] = self.scenario.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagList') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList()
            self.dag_list = temp_model.from_map(m['DagList'])
        if m.get('Scenario') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario()
            self.scenario = temp_model.from_map(m['Scenario'])
        return self


class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList(TeaModel):
    def __init__(
        self,
        scenario_dag: List[ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG] = None,
    ):
        self.scenario_dag = scenario_dag

    def validate(self):
        if self.scenario_dag:
            for k in self.scenario_dag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ScenarioDAG'] = []
        if self.scenario_dag is not None:
            for k in self.scenario_dag:
                result['ScenarioDAG'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.scenario_dag = []
        if m.get('ScenarioDAG') is not None:
            for k in m.get('ScenarioDAG'):
                temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG()
                self.scenario_dag.append(temp_model.from_map(k))
        return self


class ListLhTaskFlowAndScenarioResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        raw_daglist: ListLhTaskFlowAndScenarioResponseBodyRawDAGList = None,
        request_id: str = None,
        scenario_daglist: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The task flows in the default business scenario.
        self.raw_daglist = raw_daglist
        # The ID of the request.
        self.request_id = request_id
        # The task flows in other business scenarios.
        self.scenario_daglist = scenario_daglist
        # Indicates whether the request is successful. Valid values:
        # 
        # - **true**: The request is successful.
        # - **false**: The request fails.
        self.success = success

    def validate(self):
        if self.raw_daglist:
            self.raw_daglist.validate()
        if self.scenario_daglist:
            self.scenario_daglist.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.raw_daglist is not None:
            result['RawDAGList'] = self.raw_daglist.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scenario_daglist is not None:
            result['ScenarioDAGList'] = self.scenario_daglist.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RawDAGList') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBodyRawDAGList()
            self.raw_daglist = temp_model.from_map(m['RawDAGList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScenarioDAGList') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList()
            self.scenario_daglist = temp_model.from_map(m['ScenarioDAGList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListLhTaskFlowAndScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLhTaskFlowAndScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLhTaskFlowAndScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLogicDatabasesRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        tid: int = None,
    ):
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds(TeaModel):
    def __init__(
        self,
        database_ids: List[int] = None,
    ):
        self.database_ids = database_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseIds') is not None:
            self.database_ids = m.get('DatabaseIds')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_id: str = None,
        database_ids: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        owner_id_list: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList = None,
        owner_name_list: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList = None,
        schema_name: str = None,
        search_name: str = None,
    ):
        # The alias of the logical database.
        self.alias = alias
        # The ID of the logical database.
        self.database_id = database_id
        self.database_ids = database_ids
        # The type of the logical database. For more information about the valid values of this parameter, see [DbType parameter](https://www.alibabacloud.com/help/en/data-management-service/latest/dbtype-parameter).
        self.db_type = db_type
        # The type of the environment to which the logical database belongs. Valid values:
        # 
        # - **product**: production environment
        # - **dev**: development environment
        # - **pre**: staging environment
        # - **test**: test environment
        # - **sit**: system integration testing (SIT) environment
        # - **uat**: user acceptance testing (UAT) environment
        # - **pet**: stress testing environment
        # - **stag**: STAG environment
        self.env_type = env_type
        # Indicates whether the database is a logical database. The return value is true.
        self.logic = logic
        # The IDs of the owners of the logical database.
        self.owner_id_list = owner_id_list
        # The names of the owners of the logical database.
        self.owner_name_list = owner_name_list
        # The name of the logical database.
        self.schema_name = schema_name
        # The name that is used to search for the logical database.
        self.search_name = search_name

    def validate(self):
        if self.database_ids:
            self.database_ids.validate()
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.database_ids is not None:
            result['DatabaseIds'] = self.database_ids.to_map()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatabaseIds') is not None:
            temp_model = ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds()
            self.database_ids = temp_model.from_map(m['DatabaseIds'])
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class ListLogicDatabasesResponseBodyLogicDatabaseList(TeaModel):
    def __init__(
        self,
        logic_database: List[ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase] = None,
    ):
        self.logic_database = logic_database

    def validate(self):
        if self.logic_database:
            for k in self.logic_database:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogicDatabase'] = []
        if self.logic_database is not None:
            for k in self.logic_database:
                result['LogicDatabase'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.logic_database = []
        if m.get('LogicDatabase') is not None:
            for k in m.get('LogicDatabase'):
                temp_model = ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase()
                self.logic_database.append(temp_model.from_map(k))
        return self


class ListLogicDatabasesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        logic_database_list: ListLogicDatabasesResponseBodyLogicDatabaseList = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The details of logical databases.
        self.logic_database_list = logic_database_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - **true**: The request is successful.
        # - **false**: The request fails.
        self.success = success
        # The total number of logical databases.
        self.total_count = total_count

    def validate(self):
        if self.logic_database_list:
            self.logic_database_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_database_list is not None:
            result['LogicDatabaseList'] = self.logic_database_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicDatabaseList') is not None:
            temp_model = ListLogicDatabasesResponseBodyLogicDatabaseList()
            self.logic_database_list = temp_model.from_map(m['LogicDatabaseList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLogicDatabasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLogicDatabasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLogicDatabasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLogicTableRouteConfigRequest(TeaModel):
    def __init__(
        self,
        table_id: int = None,
        tid: int = None,
    ):
        # The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
        self.table_id = table_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig(TeaModel):
    def __init__(
        self,
        route_expr: str = None,
        route_key: str = None,
        table_id: int = None,
    ):
        # The routing algorithm expression.
        self.route_expr = route_expr
        # The unique key of the routing algorithm.
        self.route_key = route_key
        # The ID of the logical table.
        self.table_id = table_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_expr is not None:
            result['RouteExpr'] = self.route_expr
        if self.route_key is not None:
            result['RouteKey'] = self.route_key
        if self.table_id is not None:
            result['TableId'] = self.table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RouteExpr') is not None:
            self.route_expr = m.get('RouteExpr')
        if m.get('RouteKey') is not None:
            self.route_key = m.get('RouteKey')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        return self


class ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList(TeaModel):
    def __init__(
        self,
        logic_table_route_config: List[ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig] = None,
    ):
        self.logic_table_route_config = logic_table_route_config

    def validate(self):
        if self.logic_table_route_config:
            for k in self.logic_table_route_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogicTableRouteConfig'] = []
        if self.logic_table_route_config is not None:
            for k in self.logic_table_route_config:
                result['LogicTableRouteConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.logic_table_route_config = []
        if m.get('LogicTableRouteConfig') is not None:
            for k in m.get('LogicTableRouteConfig'):
                temp_model = ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig()
                self.logic_table_route_config.append(temp_model.from_map(k))
        return self


class ListLogicTableRouteConfigResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        logic_table_route_config_list: ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The routing algorithms.
        self.logic_table_route_config_list = logic_table_route_config_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        if self.logic_table_route_config_list:
            self.logic_table_route_config_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_table_route_config_list is not None:
            result['LogicTableRouteConfigList'] = self.logic_table_route_config_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicTableRouteConfigList') is not None:
            temp_model = ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList()
            self.logic_table_route_config_list = temp_model.from_map(m['LogicTableRouteConfigList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListLogicTableRouteConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLogicTableRouteConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLogicTableRouteConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLogicTablesRequest(TeaModel):
    def __init__(
        self,
        database_id: str = None,
        page_number: int = None,
        page_size: int = None,
        return_guid: bool = None,
        search_name: str = None,
        tid: int = None,
    ):
        self.database_id = database_id
        self.page_number = page_number
        self.page_size = page_size
        self.return_guid = return_guid
        self.search_name = search_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.return_guid is not None:
            result['ReturnGuid'] = self.return_guid
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ReturnGuid') is not None:
            self.return_guid = m.get('ReturnGuid')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListLogicTablesResponseBodyLogicTableListLogicTable(TeaModel):
    def __init__(
        self,
        database_id: str = None,
        logic: bool = None,
        owner_id_list: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList = None,
        owner_name_list: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList = None,
        schema_name: str = None,
        table_count: str = None,
        table_expr: str = None,
        table_guid: str = None,
        table_id: str = None,
        table_name: str = None,
    ):
        self.database_id = database_id
        self.logic = logic
        self.owner_id_list = owner_id_list
        self.owner_name_list = owner_name_list
        self.schema_name = schema_name
        self.table_count = table_count
        self.table_expr = table_expr
        self.table_guid = table_guid
        self.table_id = table_id
        self.table_name = table_name

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_count is not None:
            result['TableCount'] = self.table_count
        if self.table_expr is not None:
            result['TableExpr'] = self.table_expr
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableCount') is not None:
            self.table_count = m.get('TableCount')
        if m.get('TableExpr') is not None:
            self.table_expr = m.get('TableExpr')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListLogicTablesResponseBodyLogicTableList(TeaModel):
    def __init__(
        self,
        logic_table: List[ListLogicTablesResponseBodyLogicTableListLogicTable] = None,
    ):
        self.logic_table = logic_table

    def validate(self):
        if self.logic_table:
            for k in self.logic_table:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogicTable'] = []
        if self.logic_table is not None:
            for k in self.logic_table:
                result['LogicTable'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.logic_table = []
        if m.get('LogicTable') is not None:
            for k in m.get('LogicTable'):
                temp_model = ListLogicTablesResponseBodyLogicTableListLogicTable()
                self.logic_table.append(temp_model.from_map(k))
        return self


class ListLogicTablesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        logic_table_list: ListLogicTablesResponseBodyLogicTableList = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.logic_table_list = logic_table_list
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.logic_table_list:
            self.logic_table_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.logic_table_list is not None:
            result['LogicTableList'] = self.logic_table_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LogicTableList') is not None:
            temp_model = ListLogicTablesResponseBodyLogicTableList()
            self.logic_table_list = temp_model.from_map(m['LogicTableList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLogicTablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListLogicTablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLogicTablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOrdersRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        order_result_type: str = None,
        order_status: str = None,
        page_number: int = None,
        page_size: int = None,
        plugin_type: str = None,
        search_content: str = None,
        search_date_type: str = None,
        start_time: str = None,
        tid: int = None,
    ):
        # The end of the time range to query.
        self.end_time = end_time
        # The scope of the tickets that you want to query. Valid values:
        # 
        # *   **AS_ADMIN**: all tickets.
        # *   **AS_COMMITTER**: the tickets that are submitted by the current user.
        # *   **AS_HANDLER**: the tickets to be processed by the current user.
        # *   **AS_OWNER**: the tickets that are processed by the current user.
        # *   **AS_Related**: the tickets that are related to the current user.
        self.order_result_type = order_result_type
        # The status of the tickets that you want to query. Valid values:
        # 
        # *   **ALL**: queries the tickets of all statuses.
        # *   **FINISHED**: queries the tickets that are completed.
        # *   **RUNNING**: queries the tickets that are being processed.
        self.order_status = order_status
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The type of the tickets that you want to query. For more information, see [PluginType parameter](~~429109~~).
        self.plugin_type = plugin_type
        # The keyword that is used to query tickets.
        self.search_content = search_content
        # The time condition based on which you want to query tickets. Valid values:
        # 
        # *   **CREATE_TIME**: the time when a ticket was created.
        # *   **MODIFY_TIME**: the time when a ticket was last modified.
        self.search_date_type = search_date_type
        # The beginning of the time range to query.
        self.start_time = start_time
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.order_result_type is not None:
            result['OrderResultType'] = self.order_result_type
        if self.order_status is not None:
            result['OrderStatus'] = self.order_status
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.search_content is not None:
            result['SearchContent'] = self.search_content
        if self.search_date_type is not None:
            result['SearchDateType'] = self.search_date_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OrderResultType') is not None:
            self.order_result_type = m.get('OrderResultType')
        if m.get('OrderStatus') is not None:
            self.order_status = m.get('OrderStatus')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('SearchContent') is not None:
            self.search_content = m.get('SearchContent')
        if m.get('SearchDateType') is not None:
            self.search_date_type = m.get('SearchDateType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListOrdersResponseBodyOrdersOrder(TeaModel):
    def __init__(
        self,
        comment: str = None,
        committer: str = None,
        committer_id: int = None,
        create_time: str = None,
        last_modify_time: str = None,
        order_id: int = None,
        plugin_type: str = None,
        status_code: str = None,
        status_desc: str = None,
    ):
        # The remarks of the ticket.
        self.comment = comment
        # The user who submitted the ticket.
        self.committer = committer
        # The ID of the user who submitted the ticket.
        self.committer_id = committer_id
        # The time when the ticket was created.
        self.create_time = create_time
        # The time when the ticket was last modified.
        self.last_modify_time = last_modify_time
        # The ID of the ticket.
        self.order_id = order_id
        # The type of the ticket.
        self.plugin_type = plugin_type
        # The status code of the ticket. Valid values:
        # 
        # *   **fail**: The ticket fails to be executed.
        # *   **toaudit**: The ticket is waiting for approval.
        # *   **cancel**: The ticket is cancelled.
        # *   **processing**: The ticket is being executed.
        # *   **approved**: The ticket is approved.
        # *   **reject**: The ticket is rejected.
        # *   **success**: The ticket is executed.
        # *   **closed**: The ticket is closed.
        self.status_code = status_code
        # The status description of the ticket.
        self.status_desc = status_desc

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.committer is not None:
            result['Committer'] = self.committer
        if self.committer_id is not None:
            result['CommitterId'] = self.committer_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modify_time is not None:
            result['LastModifyTime'] = self.last_modify_time
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.plugin_type is not None:
            result['PluginType'] = self.plugin_type
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('Committer') is not None:
            self.committer = m.get('Committer')
        if m.get('CommitterId') is not None:
            self.committer_id = m.get('CommitterId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModifyTime') is not None:
            self.last_modify_time = m.get('LastModifyTime')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PluginType') is not None:
            self.plugin_type = m.get('PluginType')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        return self


class ListOrdersResponseBodyOrders(TeaModel):
    def __init__(
        self,
        order: List[ListOrdersResponseBodyOrdersOrder] = None,
    ):
        self.order = order

    def validate(self):
        if self.order:
            for k in self.order:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Order'] = []
        if self.order is not None:
            for k in self.order:
                result['Order'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.order = []
        if m.get('Order') is not None:
            for k in m.get('Order'):
                temp_model = ListOrdersResponseBodyOrdersOrder()
                self.order.append(temp_model.from_map(k))
        return self


class ListOrdersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        orders: ListOrdersResponseBodyOrders = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The details about the tickets.
        self.orders = orders
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success
        # The total number of entries that are returned.
        self.total_count = total_count

    def validate(self):
        if self.orders:
            self.orders.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.orders is not None:
            result['Orders'] = self.orders.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Orders') is not None:
            temp_model = ListOrdersResponseBodyOrders()
            self.orders = temp_model.from_map(m['Orders'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListOrdersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOrdersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOrdersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProxiesRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListProxiesResponseBodyProxyList(TeaModel):
    def __init__(
        self,
        creator_id: int = None,
        creator_name: str = None,
        https_port: int = None,
        instance_id: int = None,
        private_enable: bool = None,
        private_host: str = None,
        protocol_port: int = None,
        protocol_type: str = None,
        proxy_id: int = None,
        public_enable: bool = None,
        public_host: str = None,
    ):
        # The ID of the user who enabled the secure access proxy feature.
        self.creator_id = creator_id
        # The nickname of the user who enabled the secure access proxy feature.
        self.creator_name = creator_name
        # The port that was used by HTTPS clients to connect to the database instance.
        self.https_port = https_port
        # The ID of the database instance.
        self.instance_id = instance_id
        # Indicates whether the internal endpoint is enabled. Default value: **true**.
        self.private_enable = private_enable
        # The internal endpoint.
        self.private_host = private_host
        self.protocol_port = protocol_port
        self.protocol_type = protocol_type
        # The ID of the secure access proxy.
        self.proxy_id = proxy_id
        # Indicates whether the public endpoint is enabled. Valid values:
        # 
        # - **true**: The public endpoint is enabled.
        # - **false**: The public endpoint is disabled.
        self.public_enable = public_enable
        # The public endpoint. A public endpoint is returned no matter whether the public endpoint is enabled or disabled.  
        # 
        # > - If the value of the PublicEnable parameter is **true**, a valid public endpoint that can be resolved by using Alibaba Cloud DNS (DNS) is returned.
        # - If the value of the PublicEnable parameter is **false**, an invalid public endpoint that cannot be resolved by using DNS is returned.
        self.public_host = public_host

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_name is not None:
            result['CreatorName'] = self.creator_name
        if self.https_port is not None:
            result['HttpsPort'] = self.https_port
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.private_enable is not None:
            result['PrivateEnable'] = self.private_enable
        if self.private_host is not None:
            result['PrivateHost'] = self.private_host
        if self.protocol_port is not None:
            result['ProtocolPort'] = self.protocol_port
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.public_enable is not None:
            result['PublicEnable'] = self.public_enable
        if self.public_host is not None:
            result['PublicHost'] = self.public_host
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorName') is not None:
            self.creator_name = m.get('CreatorName')
        if m.get('HttpsPort') is not None:
            self.https_port = m.get('HttpsPort')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PrivateEnable') is not None:
            self.private_enable = m.get('PrivateEnable')
        if m.get('PrivateHost') is not None:
            self.private_host = m.get('PrivateHost')
        if m.get('ProtocolPort') is not None:
            self.protocol_port = m.get('ProtocolPort')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('PublicEnable') is not None:
            self.public_enable = m.get('PublicEnable')
        if m.get('PublicHost') is not None:
            self.public_host = m.get('PublicHost')
        return self


class ListProxiesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        proxy_list: List[ListProxiesResponseBodyProxyList] = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # An array that consists of secure access proxies.
        self.proxy_list = proxy_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        if self.proxy_list:
            for k in self.proxy_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['ProxyList'] = []
        if self.proxy_list is not None:
            for k in self.proxy_list:
                result['ProxyList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.proxy_list = []
        if m.get('ProxyList') is not None:
            for k in m.get('ProxyList'):
                temp_model = ListProxiesResponseBodyProxyList()
                self.proxy_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListProxiesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProxiesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProxiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProxyAccessesRequest(TeaModel):
    def __init__(
        self,
        proxy_id: int = None,
        tid: int = None,
    ):
        # The ID of the secure access proxy. 
        # 
        # >  You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) operation to query the ID of the secure access proxy.
        self.proxy_id = proxy_id
        # The ID of the tenant. 
        # 
        # >  You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListProxyAccessesResponseBodyProxyAccessList(TeaModel):
    def __init__(
        self,
        access_id: str = None,
        gmt_create: str = None,
        indep_account: str = None,
        instance_id: int = None,
        origin_info: str = None,
        proxy_access_id: int = None,
        proxy_id: int = None,
        user_id: int = None,
        user_name: str = None,
        user_uid: str = None,
    ):
        # The username of the database account that is authorized to access the database instance by using the secure access proxy feature.
        self.access_id = access_id
        # The time when the user is authorized to access the database instance by using the secure access proxy feature.
        self.gmt_create = gmt_create
        # The username of the independent database account.
        self.indep_account = indep_account
        # The ID of the database instance.
        self.instance_id = instance_id
        # The method that is used to authorize the user to access the database instance by using the secure access proxy feature. Valid values: 
        # 
        # - **Authorization by the Alibaba Cloud Account ()**: The information in the parentheses () indicates the user ID (UID) of the Alibaba Cloud account.
        # - **Authorization by submitting the ticket ()**:The information in the parentheses () indicates the number of the ticket that the user submits to apply for permissions.
        self.origin_info = origin_info
        # The ID that DMS generates after the user is authorized to access the database instance by using the secure access proxy feature. The ID is unique in DMS.
        self.proxy_access_id = proxy_access_id
        # The ID of the secure access proxy.
        self.proxy_id = proxy_id
        # The ID of the user.
        self.user_id = user_id
        # The nickname of the user.
        self.user_name = user_name
        # The UID of the Alibaba Cloud account.
        self.user_uid = user_uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_id is not None:
            result['AccessId'] = self.access_id
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.indep_account is not None:
            result['IndepAccount'] = self.indep_account
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.origin_info is not None:
            result['OriginInfo'] = self.origin_info
        if self.proxy_access_id is not None:
            result['ProxyAccessId'] = self.proxy_access_id
        if self.proxy_id is not None:
            result['ProxyId'] = self.proxy_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.user_uid is not None:
            result['UserUid'] = self.user_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessId') is not None:
            self.access_id = m.get('AccessId')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('IndepAccount') is not None:
            self.indep_account = m.get('IndepAccount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OriginInfo') is not None:
            self.origin_info = m.get('OriginInfo')
        if m.get('ProxyAccessId') is not None:
            self.proxy_access_id = m.get('ProxyAccessId')
        if m.get('ProxyId') is not None:
            self.proxy_id = m.get('ProxyId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('UserUid') is not None:
            self.user_uid = m.get('UserUid')
        return self


class ListProxyAccessesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        proxy_access_list: List[ListProxyAccessesResponseBodyProxyAccessList] = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The information about the users that are authorized to access the database instance by using the secure access proxy feature.
        self.proxy_access_list = proxy_access_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        if self.proxy_access_list:
            for k in self.proxy_access_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['ProxyAccessList'] = []
        if self.proxy_access_list is not None:
            for k in self.proxy_access_list:
                result['ProxyAccessList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.proxy_access_list = []
        if m.get('ProxyAccessList') is not None:
            for k in m.get('ProxyAccessList'):
                temp_model = ListProxyAccessesResponseBodyProxyAccessList()
                self.proxy_access_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListProxyAccessesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProxyAccessesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProxyAccessesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProxySQLExecAuditLogRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        exec_state: str = None,
        op_user_name: str = None,
        page_number: int = None,
        page_size: int = None,
        sqltype: str = None,
        search_name: str = None,
        start_time: int = None,
        tid: int = None,
    ):
        # The end of the time range to query. The value of this parameter must be a timestamp that follows the UNIX time format.
        self.end_time = end_time
        # The execution status of the SQL statement. Valid values:
        # 
        # *   **FAIL**: The execution of the SQL statement fails.
        # *   **CANCEL**: The execution of the SQL statement is canceled.
        # *   **SUCCESS**: The SQL statement is executed.
        self.exec_state = exec_state
        # The alias of the user.
        self.op_user_name = op_user_name
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum values: 100.
        self.page_size = page_size
        # The type of SQL statement. Valid values:
        # 
        # *   **SELECT**\
        # *   **INSERT**\
        # *   **DELETE**\
        # *   **CREATE_TABLE**\
        # 
        # >  You can choose Operation Audit > Secure Access Proxy in the top navigation bar of the DMS console to view more types of SQL statements.
        self.sqltype = sqltype
        # The name of the database instance.
        self.search_name = search_name
        # The beginning of the time range to query. The value of this parameter must be a timestamp that follows the UNIX time format.
        self.start_time = start_time
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.exec_state is not None:
            result['ExecState'] = self.exec_state
        if self.op_user_name is not None:
            result['OpUserName'] = self.op_user_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sqltype is not None:
            result['SQLType'] = self.sqltype
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecState') is not None:
            self.exec_state = m.get('ExecState')
        if m.get('OpUserName') is not None:
            self.op_user_name = m.get('OpUserName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SQLType') is not None:
            self.sqltype = m.get('SQLType')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog(TeaModel):
    def __init__(
        self,
        affect_rows: int = None,
        elapsed_time: int = None,
        exec_state: str = None,
        instance_id: int = None,
        instance_name: str = None,
        op_time: str = None,
        remark: str = None,
        sql: str = None,
        sqltype: str = None,
        schema_name: str = None,
        user_id: int = None,
        user_name: str = None,
    ):
        # Indicates the total number of rows returned after the SQL statement was executed. If an SELECT SQL statement is executed, the return value of this parameter indicates the total number of the queried data rows.
        self.affect_rows = affect_rows
        # The amount of time that is consumed to execute the SQL statement. Unit: milliseconds.
        self.elapsed_time = elapsed_time
        # The execution status of the SQL statement. Valid values:
        # 
        # *   **FAIL**: The execution of the SQL statement fails.
        # *   **CANCEL**: The execution of the SQL statement is canceled.
        # *   **SUCCESS**: The SQL statement is executed.
        self.exec_state = exec_state
        # The ID of the database instance.
        self.instance_id = instance_id
        # The name of the database instance.
        self.instance_name = instance_name
        # The time at which the user executes the SQL statement on the database instance. The value of this parameter must be a timestamp that follows the UNIX time format.
        self.op_time = op_time
        # The description.
        self.remark = remark
        # The SQL statement that was executed.
        self.sql = sql
        # The type of the SQL statement. Valid values:
        # 
        # *   **SELECT**\
        # *   **INSERT**\
        # *   **DELETE**\
        # *   **CREATE_TABLE**\
        # 
        # >  You can choose Operation Audit > Secure Access Proxy in the top navigation bar of the DMS console to view more types of SQL statements.
        self.sqltype = sqltype
        # The name of the database.
        self.schema_name = schema_name
        # The ID of the user.
        self.user_id = user_id
        # The nickname of the user.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.exec_state is not None:
            result['ExecState'] = self.exec_state
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sql is not None:
            result['SQL'] = self.sql
        if self.sqltype is not None:
            result['SQLType'] = self.sqltype
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('ExecState') is not None:
            self.exec_state = m.get('ExecState')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SQL') is not None:
            self.sql = m.get('SQL')
        if m.get('SQLType') is not None:
            self.sqltype = m.get('SQLType')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList(TeaModel):
    def __init__(
        self,
        proxy_sqlexec_audit_log: List[ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog] = None,
    ):
        self.proxy_sqlexec_audit_log = proxy_sqlexec_audit_log

    def validate(self):
        if self.proxy_sqlexec_audit_log:
            for k in self.proxy_sqlexec_audit_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ProxySQLExecAuditLog'] = []
        if self.proxy_sqlexec_audit_log is not None:
            for k in self.proxy_sqlexec_audit_log:
                result['ProxySQLExecAuditLog'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.proxy_sqlexec_audit_log = []
        if m.get('ProxySQLExecAuditLog') is not None:
            for k in m.get('ProxySQLExecAuditLog'):
                temp_model = ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog()
                self.proxy_sqlexec_audit_log.append(temp_model.from_map(k))
        return self


class ListProxySQLExecAuditLogResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        proxy_sqlexec_audit_log_list: ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The audit information about the database instance that is provided by the secure access proxy feature.
        self.proxy_sqlexec_audit_log_list = proxy_sqlexec_audit_log_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.proxy_sqlexec_audit_log_list:
            self.proxy_sqlexec_audit_log_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.proxy_sqlexec_audit_log_list is not None:
            result['ProxySQLExecAuditLogList'] = self.proxy_sqlexec_audit_log_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProxySQLExecAuditLogList') is not None:
            temp_model = ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList()
            self.proxy_sqlexec_audit_log_list = temp_model.from_map(m['ProxySQLExecAuditLogList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListProxySQLExecAuditLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProxySQLExecAuditLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProxySQLExecAuditLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSLARulesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSLARulesResponseBodySLARuleListSLARule(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        id: int = None,
        interval_minutes: int = None,
        node_id: int = None,
        rule_type: int = None,
    ):
        self.dag_id = dag_id
        self.id = id
        self.interval_minutes = interval_minutes
        self.node_id = node_id
        self.rule_type = rule_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.interval_minutes is not None:
            result['IntervalMinutes'] = self.interval_minutes
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IntervalMinutes') is not None:
            self.interval_minutes = m.get('IntervalMinutes')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        return self


class ListSLARulesResponseBodySLARuleList(TeaModel):
    def __init__(
        self,
        slarule: List[ListSLARulesResponseBodySLARuleListSLARule] = None,
    ):
        self.slarule = slarule

    def validate(self):
        if self.slarule:
            for k in self.slarule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SLARule'] = []
        if self.slarule is not None:
            for k in self.slarule:
                result['SLARule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.slarule = []
        if m.get('SLARule') is not None:
            for k in m.get('SLARule'):
                temp_model = ListSLARulesResponseBodySLARuleListSLARule()
                self.slarule.append(temp_model.from_map(k))
        return self


class ListSLARulesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        slarule_list: ListSLARulesResponseBodySLARuleList = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.slarule_list = slarule_list
        self.success = success

    def validate(self):
        if self.slarule_list:
            self.slarule_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.slarule_list is not None:
            result['SLARuleList'] = self.slarule_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SLARuleList') is not None:
            temp_model = ListSLARulesResponseBodySLARuleList()
            self.slarule_list = temp_model.from_map(m['SLARuleList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListSLARulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSLARulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSLARulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSQLExecAuditLogRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        exec_state: str = None,
        op_user_name: str = None,
        page_number: int = None,
        page_size: int = None,
        search_name: str = None,
        sql_type: str = None,
        start_time: str = None,
        tid: int = None,
    ):
        # The end of the time range to query.
        # 
        # >  The end time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format. We recommend that you use the StartTime and EndTime parameters to specify a time range that does not exceed one day. The returned entries can be displayed by page to improve query efficiency.
        self.end_time = end_time
        # The execution status of the SQL statement. Valid values:
        # 
        # *   **FAIL**: The SQL statement fails to be executed.
        # *   **NOEXE**: The SQL statement has not been executed.
        # *   **RUNNING**: The SQL statement is being executed.
        # *   **CANCEL**: The execution of the SQL statement is canceled.
        # *   **SUCCESS**: The SQL statement is executed.
        self.exec_state = exec_state
        # The nickname of the user who wrote the SQL statement.
        self.op_user_name = op_user_name
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page. The value cannot exceed 100.
        self.page_size = page_size
        # The name of the database or instance based on which you want to query SQL statements.
        # 
        # >  If the SQL statements to be queried are at the instance level, you can set this parameter to an instance name. If the SQL statements to be queried are at the database level, you can set this parameter to a database name.
        self.search_name = search_name
        # The type of the SQL statement. Valid values:
        # 
        # *   **SELECT**: the SQL statement that is used to query data.
        # *   **INSERT**: the SQL statement that is used to insert data.
        # *   **DELETE**: the SQL statement that is used to delete data.
        # *   **CREATE_TABLE**: the SQL statement that is used to create tables.
        # 
        # >  To view more types of SQL statements, log on to the DMS console and click Security and Specifications. In the left-side navigation pane, click **Operation Audit**. Then, you can view all supported types of SQL statements from the **SQL type** drop-down list.
        self.sql_type = sql_type
        # The beginning of the time range to query.
        # 
        # >  The start time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format.
        self.start_time = start_time
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.exec_state is not None:
            result['ExecState'] = self.exec_state
        if self.op_user_name is not None:
            result['OpUserName'] = self.op_user_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sql_type is not None:
            result['SqlType'] = self.sql_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExecState') is not None:
            self.exec_state = m.get('ExecState')
        if m.get('OpUserName') is not None:
            self.op_user_name = m.get('OpUserName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('SqlType') is not None:
            self.sql_type = m.get('SqlType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog(TeaModel):
    def __init__(
        self,
        affect_rows: int = None,
        db_id: int = None,
        elapsed_time: int = None,
        exec_state: str = None,
        instance_id: int = None,
        instance_name: str = None,
        logic: bool = None,
        op_time: str = None,
        remark: str = None,
        sql: str = None,
        sqltype: str = None,
        schema_name: str = None,
        user_id: int = None,
        user_name: str = None,
    ):
        # The number of rows affected by the SQL statement. For example, if you execute an SQL statement to query data, the number of retrieved rows is returned.
        self.affect_rows = affect_rows
        # The ID of the database.
        self.db_id = db_id
        # The amount of time consumed by the execution of the SQL statement. Unit: milliseconds.
        self.elapsed_time = elapsed_time
        # The execution status of the SQL statement. Valid values:
        # 
        # *   **FAIL**: The SQL statement fails to be executed.
        # *   **NOEXE**: The SQL statement has not been executed.
        # *   **RUNNING**: The SQL statement is being executed.
        # *   **CANCEL**: The execution of the SQL statement is canceled.
        # *   **SUCCESS**: The SQL statement is executed.
        self.exec_state = exec_state
        # The ID of the instance.
        self.instance_id = instance_id
        # The name of the database.
        # 
        # >  If the SQL statement takes effect on an instance, the name of the instance is returned.
        self.instance_name = instance_name
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic
        # The time when the operation specified by the SQL statement was performed on the instance or database.
        self.op_time = op_time
        # The comment on the SQL statement.
        self.remark = remark
        # The SQL statement that was written.
        self.sql = sql
        # The type of the SQL statement. Valid values:
        # 
        # *   **SELECT**: the SQL statement that is used to query data.
        # *   **INSERT**: the SQL statement that is used to insert data.
        # *   **DELETE**: the SQL statement that is used to delete data.
        # *   **CREATE_TABLE**: the SQL statement that is used to create tables.
        # 
        # >  To view more types of SQL statements, log on to the DMS console and click Security and Specifications. In the left-side navigation pane, click **Operation Audit**. Then, you can view all supported types of SQL statements from the **SQL type** drop-down list.
        self.sqltype = sqltype
        # The name of the database.
        self.schema_name = schema_name
        # The ID of the user who wrote the SQL statement.
        self.user_id = user_id
        # The nickname of the user who wrote the SQL statement.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affect_rows is not None:
            result['AffectRows'] = self.affect_rows
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.elapsed_time is not None:
            result['ElapsedTime'] = self.elapsed_time
        if self.exec_state is not None:
            result['ExecState'] = self.exec_state
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        if self.remark is not None:
            result['Remark'] = self.remark
        if self.sql is not None:
            result['SQL'] = self.sql
        if self.sqltype is not None:
            result['SQLType'] = self.sqltype
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AffectRows') is not None:
            self.affect_rows = m.get('AffectRows')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('ElapsedTime') is not None:
            self.elapsed_time = m.get('ElapsedTime')
        if m.get('ExecState') is not None:
            self.exec_state = m.get('ExecState')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        if m.get('SQL') is not None:
            self.sql = m.get('SQL')
        if m.get('SQLType') is not None:
            self.sqltype = m.get('SQLType')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListSQLExecAuditLogResponseBodySQLExecAuditLogList(TeaModel):
    def __init__(
        self,
        sqlexec_audit_log: List[ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog] = None,
    ):
        self.sqlexec_audit_log = sqlexec_audit_log

    def validate(self):
        if self.sqlexec_audit_log:
            for k in self.sqlexec_audit_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SQLExecAuditLog'] = []
        if self.sqlexec_audit_log is not None:
            for k in self.sqlexec_audit_log:
                result['SQLExecAuditLog'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.sqlexec_audit_log = []
        if m.get('SQLExecAuditLog') is not None:
            for k in m.get('SQLExecAuditLog'):
                temp_model = ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog()
                self.sqlexec_audit_log.append(temp_model.from_map(k))
        return self


class ListSQLExecAuditLogResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sqlexec_audit_log_list: ListSQLExecAuditLogResponseBodySQLExecAuditLogList = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The entries returned.
        self.sqlexec_audit_log_list = sqlexec_audit_log_list
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.sqlexec_audit_log_list:
            self.sqlexec_audit_log_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sqlexec_audit_log_list is not None:
            result['SQLExecAuditLogList'] = self.sqlexec_audit_log_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SQLExecAuditLogList') is not None:
            temp_model = ListSQLExecAuditLogResponseBodySQLExecAuditLogList()
            self.sqlexec_audit_log_list = temp_model.from_map(m['SQLExecAuditLogList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSQLExecAuditLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSQLExecAuditLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSQLExecAuditLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSQLReviewOriginSQLRequestOrderActionDetailPage(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
    ):
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListSQLReviewOriginSQLRequestOrderActionDetail(TeaModel):
    def __init__(
        self,
        check_status_result: str = None,
        file_id: int = None,
        page: ListSQLReviewOriginSQLRequestOrderActionDetailPage = None,
        sqlreview_result: str = None,
    ):
        # The review status of the SQL statement. Valid values:
        # 
        # *   **new**: The SQL statement is pending for analysis.
        # *   **unknown**: The SQL statement failed to be parsed.
        # *   **check_not_pass**: The SQL statement failed the review.
        # *   **check_pass**: The SQL statement passed the review.
        # *   **force_pass**: The SQL statement passed the review by manual effort.
        # *   **force_not_pass**: The SQL statement failed the review by manual effort.
        self.check_status_result = check_status_result
        # The ID of the file.
        self.file_id = file_id
        # The paging settings.
        self.page = page
        # The optimization suggestion for the SQL statement. Valid values:
        # 
        # *   **MUST_IMPROVE**: The SQL statement must be improved.
        # *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
        # *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
        # *   **USE_DMS_TOOLKIT**: We recommend that you change schemas without locking tables.
        # *   **USE_DMS_DML_UNLOCK**: We recommend that you change data without locking tables.
        # *   **TABLE_INDEX_SUGGEST**: We recommend that you use SQL statements that use indexes.
        self.sqlreview_result = sqlreview_result

    def validate(self):
        if self.page:
            self.page.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_status_result is not None:
            result['CheckStatusResult'] = self.check_status_result
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.page is not None:
            result['Page'] = self.page.to_map()
        if self.sqlreview_result is not None:
            result['SQLReviewResult'] = self.sqlreview_result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckStatusResult') is not None:
            self.check_status_result = m.get('CheckStatusResult')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('Page') is not None:
            temp_model = ListSQLReviewOriginSQLRequestOrderActionDetailPage()
            self.page = temp_model.from_map(m['Page'])
        if m.get('SQLReviewResult') is not None:
            self.sqlreview_result = m.get('SQLReviewResult')
        return self


class ListSQLReviewOriginSQLRequest(TeaModel):
    def __init__(
        self,
        order_action_detail: ListSQLReviewOriginSQLRequestOrderActionDetail = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The parameters that are used to filter SQL statements involved in the ticket.
        self.order_action_detail = order_action_detail
        # The ID of the ticket for the SQL review. You can call the [CreateSQLReviewOrder](~~257777~~) operation to query the ID of the ticket.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        if self.order_action_detail:
            self.order_action_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_action_detail is not None:
            result['OrderActionDetail'] = self.order_action_detail.to_map()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderActionDetail') is not None:
            temp_model = ListSQLReviewOriginSQLRequestOrderActionDetail()
            self.order_action_detail = temp_model.from_map(m['OrderActionDetail'])
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSQLReviewOriginSQLShrinkRequest(TeaModel):
    def __init__(
        self,
        order_action_detail_shrink: str = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The parameters that are used to filter SQL statements involved in the ticket.
        self.order_action_detail_shrink = order_action_detail_shrink
        # The ID of the ticket for the SQL review. You can call the [CreateSQLReviewOrder](~~257777~~) operation to query the ID of the ticket.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to query the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_action_detail_shrink is not None:
            result['OrderActionDetail'] = self.order_action_detail_shrink
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderActionDetail') is not None:
            self.order_action_detail_shrink = m.get('OrderActionDetail')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSQLReviewOriginSQLResponseBodyOriginSQLList(TeaModel):
    def __init__(
        self,
        check_status: str = None,
        checked_time: str = None,
        file_id: int = None,
        file_name: str = None,
        review_summary: str = None,
        sqlcontent: str = None,
        sqlid: int = None,
        sqlname: str = None,
        sqlreview_query_key: str = None,
        sql_hash: str = None,
        status_desc: str = None,
    ):
        # The review status of the SQL statement. Valid values:
        # 
        # *   **new**: The SQL statement is pending for analysis.
        # *   **unknown**: The SQL statement failed to be parsed.
        # *   **check_not_pass**: The SQL statement failed the review.
        # *   **check_pass**: The SQL statement passed the review.
        # *   **force_pass**: The SQL statement passed the review by manual effort.
        # *   **force_not_pass**: The SQL statement failed the review by manual effort.
        self.check_status = check_status
        # The time when the SQL statement is reviewed.
        self.checked_time = checked_time
        # The ID of the file.
        self.file_id = file_id
        # The name of the file.
        self.file_name = file_name
        # The statistics of optimization suggestions for SQL statements. The value is a JSON string. The following optimization suggestions are involved:
        # 
        # *   **MUST_IMPROVE**: The SQL statement must be improved.
        # *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
        # *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
        # *   **USEDMSTOOLKIT**: We recommend that you change schemas without locking tables.
        # *   **USEDMSDML_UNLOCK**: We recommend that you change data without locking tables.
        # *   **TABLEINDEXSUGGEST**: We recommend that you use SQL statements that use indexes.
        self.review_summary = review_summary
        # The SQL statement.
        self.sqlcontent = sqlcontent
        # The ID of the SQL statement.
        self.sqlid = sqlid
        self.sqlname = sqlname
        # The key that is used to query the details of optimization suggestions. You can call the [GetSQLReviewOptimizeDetail](https://icms.alibaba-inc.com/content/dms/doc?l=1\&m=61777\&n=2712723\&spm) operation to query the details of optimization suggestions based on the key.
        self.sqlreview_query_key = sqlreview_query_key
        # The MD5 hash value of the SQL statement.
        self.sql_hash = sql_hash
        # The description of the review status.
        self.status_desc = status_desc

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_status is not None:
            result['CheckStatus'] = self.check_status
        if self.checked_time is not None:
            result['CheckedTime'] = self.checked_time
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.review_summary is not None:
            result['ReviewSummary'] = self.review_summary
        if self.sqlcontent is not None:
            result['SQLContent'] = self.sqlcontent
        if self.sqlid is not None:
            result['SQLId'] = self.sqlid
        if self.sqlname is not None:
            result['SQLName'] = self.sqlname
        if self.sqlreview_query_key is not None:
            result['SQLReviewQueryKey'] = self.sqlreview_query_key
        if self.sql_hash is not None:
            result['SqlHash'] = self.sql_hash
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckStatus') is not None:
            self.check_status = m.get('CheckStatus')
        if m.get('CheckedTime') is not None:
            self.checked_time = m.get('CheckedTime')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('ReviewSummary') is not None:
            self.review_summary = m.get('ReviewSummary')
        if m.get('SQLContent') is not None:
            self.sqlcontent = m.get('SQLContent')
        if m.get('SQLId') is not None:
            self.sqlid = m.get('SQLId')
        if m.get('SQLName') is not None:
            self.sqlname = m.get('SQLName')
        if m.get('SQLReviewQueryKey') is not None:
            self.sqlreview_query_key = m.get('SQLReviewQueryKey')
        if m.get('SqlHash') is not None:
            self.sql_hash = m.get('SqlHash')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        return self


class ListSQLReviewOriginSQLResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        origin_sqllist: List[ListSQLReviewOriginSQLResponseBodyOriginSQLList] = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The information about the parsed SQL statements.
        self.origin_sqllist = origin_sqllist
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        self.success = success
        # The total number of the SQL statements.
        self.total_count = total_count

    def validate(self):
        if self.origin_sqllist:
            for k in self.origin_sqllist:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['OriginSQLList'] = []
        if self.origin_sqllist is not None:
            for k in self.origin_sqllist:
                result['OriginSQLList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.origin_sqllist = []
        if m.get('OriginSQLList') is not None:
            for k in m.get('OriginSQLList'):
                temp_model = ListSQLReviewOriginSQLResponseBodyOriginSQLList()
                self.origin_sqllist.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSQLReviewOriginSQLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSQLReviewOriginSQLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSQLReviewOriginSQLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListScenariosRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListScenariosResponseBodyScenarioList(TeaModel):
    def __init__(
        self,
        creator_id: str = None,
        description: str = None,
        id: int = None,
        scenario_name: str = None,
    ):
        self.creator_id = creator_id
        self.description = description
        self.id = id
        self.scenario_name = scenario_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.scenario_name is not None:
            result['ScenarioName'] = self.scenario_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ScenarioName') is not None:
            self.scenario_name = m.get('ScenarioName')
        return self


class ListScenariosResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        scenario_list: List[ListScenariosResponseBodyScenarioList] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.scenario_list = scenario_list
        self.success = success

    def validate(self):
        if self.scenario_list:
            for k in self.scenario_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['ScenarioList'] = []
        if self.scenario_list is not None:
            for k in self.scenario_list:
                result['ScenarioList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.scenario_list = []
        if m.get('ScenarioList') is not None:
            for k in m.get('ScenarioList'):
                temp_model = ListScenariosResponseBodyScenarioList()
                self.scenario_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListScenariosResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListScenariosResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListScenariosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSensitiveColumnsRequest(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        db_id: int = None,
        logic: bool = None,
        page_number: int = None,
        page_size: int = None,
        schema_name: str = None,
        security_level: str = None,
        table_name: str = None,
        tid: int = None,
    ):
        # The name of the field. You can call the [ListColumns](~~141870~~) operation to query the name of the field.
        self.column_name = column_name
        # The ID of the database. You can call the [SearchDatabase](~~141876~~) operation to query the ID of the database.
        # 
        # >  You can also call the [ListDatabases](~~141873~~) operation to query the ID of the physical database and the [ListLogicDatabases](~~141874~~) operation to query the ID of a logical database.
        self.db_id = db_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   true: The database is a logical database.
        # *   false: The database is a physical database.
        self.logic = logic
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The name of the database. You can call the [SearchDatabase](~~141876~~) operation to query the name of the database.
        # 
        # >  You can also call the [ListDatabases](~~141873~~) operation to query the name of a physical database and the [ListLogicDatabases](~~141874~~) operation to query the name of a logical database.
        self.schema_name = schema_name
        # The sensitivity level of the field. Valid values:
        # 
        # *   SENSITIVE: medium sensitivity level
        # *   CONFIDENTIAL: high sensitivity level
        self.security_level = security_level
        # The name of the table. You can call the [ListTables](~~141878~~) operation to query the ID of the table.
        self.table_name = table_name
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn(TeaModel):
    def __init__(
        self,
        column_count: int = None,
        column_name: str = None,
        function_type: str = None,
        schema_name: str = None,
        security_level: str = None,
        table_name: str = None,
    ):
        # The number of sensitive fields.
        self.column_count = column_count
        # The name of the field.
        self.column_name = column_name
        # The type of the de-identification algorithm. Valid values:
        # 
        # *   DEFAULT: All characters are masked. This is the default value.
        # *   FIX_POS: The characters at specific positions are masked.
        # *   FIX_CHAR: Specific characters are masked.
        self.function_type = function_type
        # The name of the database.
        self.schema_name = schema_name
        # The sensitivity level of the field. Valid values:
        # 
        # *   SENSITIVE
        # *   CONFIDENTIAL
        self.security_level = security_level
        # The name of the table.
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_count is not None:
            result['ColumnCount'] = self.column_count
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.function_type is not None:
            result['FunctionType'] = self.function_type
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnCount') is not None:
            self.column_count = m.get('ColumnCount')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('FunctionType') is not None:
            self.function_type = m.get('FunctionType')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListSensitiveColumnsResponseBodySensitiveColumnList(TeaModel):
    def __init__(
        self,
        sensitive_column: List[ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn] = None,
    ):
        self.sensitive_column = sensitive_column

    def validate(self):
        if self.sensitive_column:
            for k in self.sensitive_column:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SensitiveColumn'] = []
        if self.sensitive_column is not None:
            for k in self.sensitive_column:
                result['SensitiveColumn'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.sensitive_column = []
        if m.get('SensitiveColumn') is not None:
            for k in m.get('SensitiveColumn'):
                temp_model = ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn()
                self.sensitive_column.append(temp_model.from_map(k))
        return self


class ListSensitiveColumnsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sensitive_column_list: ListSensitiveColumnsResponseBodySensitiveColumnList = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The sensitive fields.
        self.sensitive_column_list = sensitive_column_list
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success
        # The total number of returned entries.
        self.total_count = total_count

    def validate(self):
        if self.sensitive_column_list:
            self.sensitive_column_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sensitive_column_list is not None:
            result['SensitiveColumnList'] = self.sensitive_column_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SensitiveColumnList') is not None:
            temp_model = ListSensitiveColumnsResponseBodySensitiveColumnList()
            self.sensitive_column_list = temp_model.from_map(m['SensitiveColumnList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSensitiveColumnsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSensitiveColumnsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSensitiveColumnsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSensitiveColumnsDetailRequest(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        db_id: int = None,
        logic: bool = None,
        schema_name: str = None,
        table_name: str = None,
        tid: int = None,
    ):
        # The name of the field. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the field.
        # 
        # >  You can also call the [ListColumns](~~141870~~) operation to obtain the name of the field.
        self.column_name = column_name
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To obtain the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
        # *   To obtain the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
        self.db_id = db_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        self.logic = logic
        # The name of the database. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the database.
        # 
        # > 
        # *   You can also call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the name of a physical database.
        # *   You can also call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation to obtain the name of a logical database.
        self.schema_name = schema_name
        # The name of the table. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the table.
        # 
        # >  You can also call the [ListTables](~~141878~~) operation to obtain the name of the table.
        self.table_name = table_name
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail(TeaModel):
    def __init__(
        self,
        column_description: str = None,
        column_name: str = None,
        column_type: str = None,
        db_id: int = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        schema_name: str = None,
        search_name: str = None,
        table_name: str = None,
    ):
        # The description of the field.
        self.column_description = column_description
        # The name of the field.
        self.column_name = column_name
        # The data type of the field.
        self.column_type = column_type
        # The ID of the database.
        self.db_id = db_id
        # The type of the database.
        self.db_type = db_type
        # The type of the environment to which the database belongs.
        self.env_type = env_type
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        self.logic = logic
        # The name of the database.
        self.schema_name = schema_name
        # The name that is used to search for the database.
        self.search_name = search_name
        # The name of the table.
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_description is not None:
            result['ColumnDescription'] = self.column_description
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_type is not None:
            result['ColumnType'] = self.column_type
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnDescription') is not None:
            self.column_description = m.get('ColumnDescription')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnType') is not None:
            self.column_type = m.get('ColumnType')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList(TeaModel):
    def __init__(
        self,
        sensitive_columns_detail: List[ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail] = None,
    ):
        self.sensitive_columns_detail = sensitive_columns_detail

    def validate(self):
        if self.sensitive_columns_detail:
            for k in self.sensitive_columns_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SensitiveColumnsDetail'] = []
        if self.sensitive_columns_detail is not None:
            for k in self.sensitive_columns_detail:
                result['SensitiveColumnsDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.sensitive_columns_detail = []
        if m.get('SensitiveColumnsDetail') is not None:
            for k in m.get('SensitiveColumnsDetail'):
                temp_model = ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail()
                self.sensitive_columns_detail.append(temp_model.from_map(k))
        return self


class ListSensitiveColumnsDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sensitive_columns_detail_list: ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The details of the sensitive field.
        self.sensitive_columns_detail_list = sensitive_columns_detail_list
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success

    def validate(self):
        if self.sensitive_columns_detail_list:
            self.sensitive_columns_detail_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sensitive_columns_detail_list is not None:
            result['SensitiveColumnsDetailList'] = self.sensitive_columns_detail_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SensitiveColumnsDetailList') is not None:
            temp_model = ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList()
            self.sensitive_columns_detail_list = temp_model.from_map(m['SensitiveColumnsDetailList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListSensitiveColumnsDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSensitiveColumnsDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSensitiveColumnsDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSensitiveDataAuditLogRequest(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        db_name: str = None,
        end_time: str = None,
        module_name: str = None,
        op_user_name: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time: str = None,
        table_name: str = None,
        tid: int = None,
    ):
        self.column_name = column_name
        self.db_name = db_name
        self.end_time = end_time
        self.module_name = module_name
        self.op_user_name = op_user_name
        self.page_number = page_number
        self.page_size = page_size
        self.start_time = start_time
        self.table_name = table_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.op_user_name is not None:
            result['OpUserName'] = self.op_user_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('OpUserName') is not None:
            self.op_user_name = m.get('OpUserName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        column_permission_type: str = None,
        desensitization_rule: str = None,
        security_level: str = None,
        table_name: str = None,
    ):
        self.column_name = column_name
        self.column_permission_type = column_permission_type
        self.desensitization_rule = desensitization_rule
        self.security_level = security_level
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.column_permission_type is not None:
            result['ColumnPermissionType'] = self.column_permission_type
        if self.desensitization_rule is not None:
            result['DesensitizationRule'] = self.desensitization_rule
        if self.security_level is not None:
            result['SecurityLevel'] = self.security_level
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('ColumnPermissionType') is not None:
            self.column_permission_type = m.get('ColumnPermissionType')
        if m.get('DesensitizationRule') is not None:
            self.desensitization_rule = m.get('DesensitizationRule')
        if m.get('SecurityLevel') is not None:
            self.security_level = m.get('SecurityLevel')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList(TeaModel):
    def __init__(
        self,
        db_display_name: str = None,
        instance_id: int = None,
        module_name: str = None,
        op_time: str = None,
        sensitive_data_log: List[ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog] = None,
        target_name: str = None,
        user_id: int = None,
        user_name: str = None,
    ):
        self.db_display_name = db_display_name
        self.instance_id = instance_id
        self.module_name = module_name
        self.op_time = op_time
        self.sensitive_data_log = sensitive_data_log
        self.target_name = target_name
        self.user_id = user_id
        self.user_name = user_name

    def validate(self):
        if self.sensitive_data_log:
            for k in self.sensitive_data_log:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_display_name is not None:
            result['DbDisplayName'] = self.db_display_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.op_time is not None:
            result['OpTime'] = self.op_time
        result['SensitiveDataLog'] = []
        if self.sensitive_data_log is not None:
            for k in self.sensitive_data_log:
                result['SensitiveDataLog'].append(k.to_map() if k else None)
        if self.target_name is not None:
            result['TargetName'] = self.target_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbDisplayName') is not None:
            self.db_display_name = m.get('DbDisplayName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('OpTime') is not None:
            self.op_time = m.get('OpTime')
        self.sensitive_data_log = []
        if m.get('SensitiveDataLog') is not None:
            for k in m.get('SensitiveDataLog'):
                temp_model = ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog()
                self.sensitive_data_log.append(temp_model.from_map(k))
        if m.get('TargetName') is not None:
            self.target_name = m.get('TargetName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ListSensitiveDataAuditLogResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sensitive_data_audit_log_list: List[ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList] = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.sensitive_data_audit_log_list = sensitive_data_audit_log_list
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.sensitive_data_audit_log_list:
            for k in self.sensitive_data_audit_log_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SensitiveDataAuditLogList'] = []
        if self.sensitive_data_audit_log_list is not None:
            for k in self.sensitive_data_audit_log_list:
                result['SensitiveDataAuditLogList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sensitive_data_audit_log_list = []
        if m.get('SensitiveDataAuditLogList') is not None:
            for k in m.get('SensitiveDataAuditLogList'):
                temp_model = ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList()
                self.sensitive_data_audit_log_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSensitiveDataAuditLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSensitiveDataAuditLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSensitiveDataAuditLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListStandardGroupsRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListStandardGroupsResponseBodyStandardGroupList(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        description: str = None,
        group_id: int = None,
        group_mode: str = None,
        group_name: str = None,
        last_mender_id: int = None,
    ):
        # The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type
        # The description of the security rule set.
        self.description = description
        self.group_id = group_id
        # The control mode. Valid values:
        # 
        # *   **NONE_CONTROL**: Flexible Management
        # *   **STABLE**: Stable Change
        # *   **COMMON**: Security Collaboration
        self.group_mode = group_mode
        # The name of the security rule set.
        self.group_name = group_name
        # The ID of the user who queries the security sets.
        self.last_mender_id = last_mender_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_mode is not None:
            result['GroupMode'] = self.group_mode
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.last_mender_id is not None:
            result['LastMenderId'] = self.last_mender_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupMode') is not None:
            self.group_mode = m.get('GroupMode')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('LastMenderId') is not None:
            self.last_mender_id = m.get('LastMenderId')
        return self


class ListStandardGroupsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        standard_group_list: List[ListStandardGroupsResponseBodyStandardGroupList] = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The security rule sets returned.
        self.standard_group_list = standard_group_list
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.standard_group_list:
            for k in self.standard_group_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StandardGroupList'] = []
        if self.standard_group_list is not None:
            for k in self.standard_group_list:
                result['StandardGroupList'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.standard_group_list = []
        if m.get('StandardGroupList') is not None:
            for k in m.get('StandardGroupList'):
                temp_model = ListStandardGroupsResponseBodyStandardGroupList()
                self.standard_group_list.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListStandardGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListStandardGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListStandardGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTablesRequest(TeaModel):
    def __init__(
        self,
        database_id: str = None,
        page_number: int = None,
        page_size: int = None,
        return_guid: bool = None,
        search_name: str = None,
        tid: int = None,
    ):
        # The ID of the physical database. You can call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the ID of the physical database.
        self.database_id = database_id
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # Specifies whether to return the GUID of a table. Valid values:
        # 
        # *   **true**: returns the GUID of a table.
        # *   **false**: does not return the GUID of a table.
        self.return_guid = return_guid
        # The name used to search for tables. Fuzzy search is supported.
        self.search_name = search_name
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.return_guid is not None:
            result['ReturnGuid'] = self.return_guid
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ReturnGuid') is not None:
            self.return_guid = m.get('ReturnGuid')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTablesResponseBodyTableListTableOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class ListTablesResponseBodyTableListTableOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class ListTablesResponseBodyTableListTable(TeaModel):
    def __init__(
        self,
        database_id: str = None,
        description: str = None,
        encoding: str = None,
        engine: str = None,
        num_rows: int = None,
        owner_id_list: ListTablesResponseBodyTableListTableOwnerIdList = None,
        owner_name_list: ListTablesResponseBodyTableListTableOwnerNameList = None,
        store_capacity: int = None,
        table_guid: str = None,
        table_id: str = None,
        table_name: str = None,
        table_schema_name: str = None,
        table_type: str = None,
    ):
        # The ID of the physical database.
        self.database_id = database_id
        # The description of the table.
        self.description = description
        # The encoding format of the table.
        self.encoding = encoding
        # The engine of the table.
        self.engine = engine
        # The number of rows in the table. This is a statistical value and does not indicate the actual number of rows.
        self.num_rows = num_rows
        # The IDs of the owners of the table.
        self.owner_id_list = owner_id_list
        # The nicknames of the owners of the table.
        self.owner_name_list = owner_name_list
        # The storage space that is occupied by the table. This is a statistical value and does not indicate the accurate storage space. Unit: MB.
        self.store_capacity = store_capacity
        # The GUID of the table in DMS.
        self.table_guid = table_guid
        # The ID of the table.
        self.table_id = table_id
        # The name of the table.
        self.table_name = table_name
        # The database in which the table resides.
        self.table_schema_name = table_schema_name
        # The type of the table. Default value: NORMAL.
        self.table_type = table_type

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.description is not None:
            result['Description'] = self.description
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.engine is not None:
            result['Engine'] = self.engine
        if self.num_rows is not None:
            result['NumRows'] = self.num_rows
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.store_capacity is not None:
            result['StoreCapacity'] = self.store_capacity
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_schema_name is not None:
            result['TableSchemaName'] = self.table_schema_name
        if self.table_type is not None:
            result['TableType'] = self.table_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('Engine') is not None:
            self.engine = m.get('Engine')
        if m.get('NumRows') is not None:
            self.num_rows = m.get('NumRows')
        if m.get('OwnerIdList') is not None:
            temp_model = ListTablesResponseBodyTableListTableOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = ListTablesResponseBodyTableListTableOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('StoreCapacity') is not None:
            self.store_capacity = m.get('StoreCapacity')
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableSchemaName') is not None:
            self.table_schema_name = m.get('TableSchemaName')
        if m.get('TableType') is not None:
            self.table_type = m.get('TableType')
        return self


class ListTablesResponseBodyTableList(TeaModel):
    def __init__(
        self,
        table: List[ListTablesResponseBodyTableListTable] = None,
    ):
        self.table = table

    def validate(self):
        if self.table:
            for k in self.table:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Table'] = []
        if self.table is not None:
            for k in self.table:
                result['Table'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.table = []
        if m.get('Table') is not None:
            for k in m.get('Table'):
                temp_model = ListTablesResponseBodyTableListTable()
                self.table.append(temp_model.from_map(k))
        return self


class ListTablesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        table_list: ListTablesResponseBodyTableList = None,
        total_count: int = None,
    ):
        # The error code that is returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success
        # The details of the tables.
        self.table_list = table_list
        # The total number of tables that meet the query conditions.
        self.total_count = total_count

    def validate(self):
        if self.table_list:
            self.table_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.table_list is not None:
            result['TableList'] = self.table_list.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TableList') is not None:
            temp_model = ListTablesResponseBodyTableList()
            self.table_list = temp_model.from_map(m['TableList'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowResponseBodyTaskFlowListTaskFlow(TeaModel):
    def __init__(
        self,
        creator_id: str = None,
        creator_nick_name: str = None,
        dag_owner_nick_name: str = None,
        deploy_id: int = None,
        id: int = None,
        latest_instance_status: int = None,
        latest_instance_time: str = None,
        status: int = None,
    ):
        # The ID of the user who creates the task flow.
        self.creator_id = creator_id
        # The name of the user who creates the task flow.
        self.creator_nick_name = creator_nick_name
        # The name of the task flow owner.
        self.dag_owner_nick_name = dag_owner_nick_name
        # The ID of the latest deployment record.
        self.deploy_id = deploy_id
        # The ID of the task flow.
        self.id = id
        # The status of the latest execution. Valid values:
        # 
        # *   **0**: invalid.
        # *   **1**: scheduling disabled.
        # *   **2**: waiting to be scheduled.
        self.latest_instance_status = latest_instance_status
        # The time when the latest execution record was generated.
        self.latest_instance_time = latest_instance_time
        # The status of the task flow. Valid values:
        # 
        # *   **0**: The task flow is invalid.
        # *   **1**: Scheduling is disabled for the task flow.
        # *   **2**: The task flow is waiting to be scheduled.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick_name is not None:
            result['CreatorNickName'] = self.creator_nick_name
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.id is not None:
            result['Id'] = self.id
        if self.latest_instance_status is not None:
            result['LatestInstanceStatus'] = self.latest_instance_status
        if self.latest_instance_time is not None:
            result['LatestInstanceTime'] = self.latest_instance_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNickName') is not None:
            self.creator_nick_name = m.get('CreatorNickName')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LatestInstanceStatus') is not None:
            self.latest_instance_status = m.get('LatestInstanceStatus')
        if m.get('LatestInstanceTime') is not None:
            self.latest_instance_time = m.get('LatestInstanceTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListTaskFlowResponseBodyTaskFlowList(TeaModel):
    def __init__(
        self,
        task_flow: List[ListTaskFlowResponseBodyTaskFlowListTaskFlow] = None,
    ):
        self.task_flow = task_flow

    def validate(self):
        if self.task_flow:
            for k in self.task_flow:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskFlow'] = []
        if self.task_flow is not None:
            for k in self.task_flow:
                result['TaskFlow'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_flow = []
        if m.get('TaskFlow') is not None:
            for k in m.get('TaskFlow'):
                temp_model = ListTaskFlowResponseBodyTaskFlowListTaskFlow()
                self.task_flow.append(temp_model.from_map(k))
        return self


class ListTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        task_flow_list: ListTaskFlowResponseBodyTaskFlowList = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The information about the task flows returned.
        self.task_flow_list = task_flow_list

    def validate(self):
        if self.task_flow_list:
            self.task_flow_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_flow_list is not None:
            result['TaskFlowList'] = self.task_flow_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskFlowList') is not None:
            temp_model = ListTaskFlowResponseBodyTaskFlowList()
            self.task_flow_list = temp_model.from_map(m['TaskFlowList'])
        return self


class ListTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowConstantsRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowConstantsResponseBodyDagConstantsDagConstant(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListTaskFlowConstantsResponseBodyDagConstants(TeaModel):
    def __init__(
        self,
        dag_constant: List[ListTaskFlowConstantsResponseBodyDagConstantsDagConstant] = None,
    ):
        self.dag_constant = dag_constant

    def validate(self):
        if self.dag_constant:
            for k in self.dag_constant:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DagConstant'] = []
        if self.dag_constant is not None:
            for k in self.dag_constant:
                result['DagConstant'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dag_constant = []
        if m.get('DagConstant') is not None:
            for k in m.get('DagConstant'):
                temp_model = ListTaskFlowConstantsResponseBodyDagConstantsDagConstant()
                self.dag_constant.append(temp_model.from_map(k))
        return self


class ListTaskFlowConstantsResponseBody(TeaModel):
    def __init__(
        self,
        dag_constants: ListTaskFlowConstantsResponseBodyDagConstants = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.dag_constants = dag_constants
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.dag_constants:
            self.dag_constants.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_constants is not None:
            result['DagConstants'] = self.dag_constants.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagConstants') is not None:
            temp_model = ListTaskFlowConstantsResponseBodyDagConstants()
            self.dag_constants = temp_model.from_map(m['DagConstants'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListTaskFlowConstantsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowConstantsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowConstantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowCooperatorsRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator(TeaModel):
    def __init__(
        self,
        email: str = None,
        login_name: str = None,
        nick_name: str = None,
        user_id: str = None,
    ):
        # The email address of the user.
        self.email = email
        # The username.
        self.login_name = login_name
        # The alias of the user.
        self.nick_name = nick_name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.email is not None:
            result['Email'] = self.email
        if self.login_name is not None:
            result['LoginName'] = self.login_name
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('LoginName') is not None:
            self.login_name = m.get('LoginName')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListTaskFlowCooperatorsResponseBodyCooperatorList(TeaModel):
    def __init__(
        self,
        cooperator: List[ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator] = None,
    ):
        self.cooperator = cooperator

    def validate(self):
        if self.cooperator:
            for k in self.cooperator:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Cooperator'] = []
        if self.cooperator is not None:
            for k in self.cooperator:
                result['Cooperator'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cooperator = []
        if m.get('Cooperator') is not None:
            for k in m.get('Cooperator'):
                temp_model = ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator()
                self.cooperator.append(temp_model.from_map(k))
        return self


class ListTaskFlowCooperatorsResponseBody(TeaModel):
    def __init__(
        self,
        cooperator_list: ListTaskFlowCooperatorsResponseBodyCooperatorList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The users that are involved in the task flow.
        self.cooperator_list = cooperator_list
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.cooperator_list:
            self.cooperator_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cooperator_list is not None:
            result['CooperatorList'] = self.cooperator_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CooperatorList') is not None:
            temp_model = ListTaskFlowCooperatorsResponseBodyCooperatorList()
            self.cooperator_list = temp_model.from_map(m['CooperatorList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListTaskFlowCooperatorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowCooperatorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowCooperatorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowEdgesByConditionRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        id: int = None,
        node_end: int = None,
        node_from: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The ID of the task flow edge.
        self.id = id
        # The ID of the end node on the edge.
        self.node_end = node_end
        # The ID of the start node on the edge.
        self.node_from = node_from
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowEdgesByConditionResponseBodyEdgesEdge(TeaModel):
    def __init__(
        self,
        id: int = None,
        node_end: int = None,
        node_from: int = None,
    ):
        # The ID of the task flow edge.
        self.id = id
        # The ID of the end node on the edge.
        self.node_end = node_end
        # The ID of the start node on the edge.
        self.node_from = node_from

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class ListTaskFlowEdgesByConditionResponseBodyEdges(TeaModel):
    def __init__(
        self,
        edge: List[ListTaskFlowEdgesByConditionResponseBodyEdgesEdge] = None,
    ):
        self.edge = edge

    def validate(self):
        if self.edge:
            for k in self.edge:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Edge'] = []
        if self.edge is not None:
            for k in self.edge:
                result['Edge'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.edge = []
        if m.get('Edge') is not None:
            for k in m.get('Edge'):
                temp_model = ListTaskFlowEdgesByConditionResponseBodyEdgesEdge()
                self.edge.append(temp_model.from_map(k))
        return self


class ListTaskFlowEdgesByConditionResponseBody(TeaModel):
    def __init__(
        self,
        edges: ListTaskFlowEdgesByConditionResponseBodyEdges = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The list of task flow edges.
        self.edges = edges
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.edges:
            self.edges.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edges is not None:
            result['Edges'] = self.edges.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Edges') is not None:
            temp_model = ListTaskFlowEdgesByConditionResponseBodyEdges()
            self.edges = temp_model.from_map(m['Edges'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListTaskFlowEdgesByConditionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowEdgesByConditionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowEdgesByConditionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowInstanceRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        page_index: int = None,
        page_size: int = None,
        start_time_begin: str = None,
        start_time_end: str = None,
        tid: int = None,
        trigger_type: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
        self.dag_id = dag_id
        # The number of the page to return.
        self.page_index = page_index
        # The number of entries to return on each page.
        self.page_size = page_size
        # The beginning of the time range to query the execution records of the task flow. Specify the time in the yyyy-MM-DD format.
        self.start_time_begin = start_time_begin
        # The end of the time range to query the execution records of the task flow. Specify the time in the yyyy-MM-DD format.
        self.start_time_end = start_time_end
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid
        # The mode in which the task flow is triggered. Valid values:
        # 
        # *   **0**: The task flow is automatically triggered based on periodic scheduling.
        # *   **1**: The task flow is manually triggered.
        self.trigger_type = trigger_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time_begin is not None:
            result['StartTimeBegin'] = self.start_time_begin
        if self.start_time_end is not None:
            result['StartTimeEnd'] = self.start_time_end
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTimeBegin') is not None:
            self.start_time_begin = m.get('StartTimeBegin')
        if m.get('StartTimeEnd') is not None:
            self.start_time_end = m.get('StartTimeEnd')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance(TeaModel):
    def __init__(
        self,
        business_time: str = None,
        dag_id: str = None,
        dag_name: str = None,
        dag_version: str = None,
        end_time: str = None,
        history_dag_id: int = None,
        id: int = None,
        message: str = None,
        owner_name: str = None,
        status: int = None,
        trigger_type: int = None,
    ):
        # The business time of the task flow. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.business_time = business_time
        # The ID of the task flow.
        self.dag_id = dag_id
        # The name of the task flow.
        self.dag_name = dag_name
        self.dag_version = dag_version
        # The time when the execution of the task flow was complete. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
        self.end_time = end_time
        # The ID of the previously published version of the task flow.
        self.history_dag_id = history_dag_id
        # The ID of the execution record.
        self.id = id
        # The description of the task.
        self.message = message
        # The name of the task flow owner.
        self.owner_name = owner_name
        # The status of the task flow. Valid values:
        # 
        # *   **0**: The task flow is waiting to be scheduled.
        # *   **1**: The task flow is being executed.
        # *   **2**: The task flow is paused.
        # *   **3**: The task flow failed.
        # *   **4**: The task flow is executed.
        # *   **5**: The task flow is complete.
        self.status = status
        # The mode in which the task flow is triggered. Valid values:
        # 
        # *   **0**: The task flow is automatically triggered based on periodic scheduling.
        # *   **1**: The task flow is manually triggered.
        self.trigger_type = trigger_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_time is not None:
            result['BusinessTime'] = self.business_time
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_version is not None:
            result['DagVersion'] = self.dag_version
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.history_dag_id is not None:
            result['HistoryDagId'] = self.history_dag_id
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.owner_name is not None:
            result['OwnerName'] = self.owner_name
        if self.status is not None:
            result['Status'] = self.status
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BusinessTime') is not None:
            self.business_time = m.get('BusinessTime')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagVersion') is not None:
            self.dag_version = m.get('DagVersion')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('HistoryDagId') is not None:
            self.history_dag_id = m.get('HistoryDagId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('OwnerName') is not None:
            self.owner_name = m.get('OwnerName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class ListTaskFlowInstanceResponseBodyDAGInstanceList(TeaModel):
    def __init__(
        self,
        daginstance: List[ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance] = None,
    ):
        self.daginstance = daginstance

    def validate(self):
        if self.daginstance:
            for k in self.daginstance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DAGInstance'] = []
        if self.daginstance is not None:
            for k in self.daginstance:
                result['DAGInstance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.daginstance = []
        if m.get('DAGInstance') is not None:
            for k in m.get('DAGInstance'):
                temp_model = ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance()
                self.daginstance.append(temp_model.from_map(k))
        return self


class ListTaskFlowInstanceResponseBody(TeaModel):
    def __init__(
        self,
        daginstance_list: ListTaskFlowInstanceResponseBodyDAGInstanceList = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The information about the execution records returned.
        self.daginstance_list = daginstance_list
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success
        # The total number of execution records returned.
        self.total_count = total_count

    def validate(self):
        if self.daginstance_list:
            self.daginstance_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.daginstance_list is not None:
            result['DAGInstanceList'] = self.daginstance_list.to_map()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DAGInstanceList') is not None:
            temp_model = ListTaskFlowInstanceResponseBodyDAGInstanceList()
            self.daginstance_list = temp_model.from_map(m['DAGInstanceList'])
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTaskFlowInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowTimeVariablesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable(TeaModel):
    def __init__(
        self,
        name: str = None,
        pattern: str = None,
    ):
        self.name = name
        self.pattern = pattern

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.pattern is not None:
            result['Pattern'] = self.pattern
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pattern') is not None:
            self.pattern = m.get('Pattern')
        return self


class ListTaskFlowTimeVariablesResponseBodyTimeVariables(TeaModel):
    def __init__(
        self,
        time_variable: List[ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable] = None,
    ):
        self.time_variable = time_variable

    def validate(self):
        if self.time_variable:
            for k in self.time_variable:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TimeVariable'] = []
        if self.time_variable is not None:
            for k in self.time_variable:
                result['TimeVariable'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.time_variable = []
        if m.get('TimeVariable') is not None:
            for k in m.get('TimeVariable'):
                temp_model = ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable()
                self.time_variable.append(temp_model.from_map(k))
        return self


class ListTaskFlowTimeVariablesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        time_variables: ListTaskFlowTimeVariablesResponseBodyTimeVariables = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.time_variables = time_variables

    def validate(self):
        if self.time_variables:
            self.time_variables.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TimeVariables') is not None:
            temp_model = ListTaskFlowTimeVariablesResponseBodyTimeVariables()
            self.time_variables = temp_model.from_map(m['TimeVariables'])
        return self


class ListTaskFlowTimeVariablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowTimeVariablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowTimeVariablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskFlowsByPageRequest(TeaModel):
    def __init__(
        self,
        page_index: int = None,
        page_size: int = None,
        search_key: str = None,
        tid: int = None,
    ):
        self.page_index = page_index
        self.page_size = page_size
        self.search_key = search_key
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow(TeaModel):
    def __init__(
        self,
        creator_id: str = None,
        creator_nick_name: str = None,
        dag_name: str = None,
        dag_owner_nick_name: str = None,
        deploy_id: int = None,
        description: str = None,
        id: int = None,
        latest_instance_status: int = None,
        latest_instance_time: str = None,
        status: int = None,
    ):
        self.creator_id = creator_id
        self.creator_nick_name = creator_nick_name
        self.dag_name = dag_name
        self.dag_owner_nick_name = dag_owner_nick_name
        self.deploy_id = deploy_id
        self.description = description
        self.id = id
        self.latest_instance_status = latest_instance_status
        self.latest_instance_time = latest_instance_time
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['CreatorId'] = self.creator_id
        if self.creator_nick_name is not None:
            result['CreatorNickName'] = self.creator_nick_name
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.dag_owner_nick_name is not None:
            result['DagOwnerNickName'] = self.dag_owner_nick_name
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.latest_instance_status is not None:
            result['LatestInstanceStatus'] = self.latest_instance_status
        if self.latest_instance_time is not None:
            result['LatestInstanceTime'] = self.latest_instance_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatorId') is not None:
            self.creator_id = m.get('CreatorId')
        if m.get('CreatorNickName') is not None:
            self.creator_nick_name = m.get('CreatorNickName')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('DagOwnerNickName') is not None:
            self.dag_owner_nick_name = m.get('DagOwnerNickName')
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LatestInstanceStatus') is not None:
            self.latest_instance_status = m.get('LatestInstanceStatus')
        if m.get('LatestInstanceTime') is not None:
            self.latest_instance_time = m.get('LatestInstanceTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListTaskFlowsByPageResponseBodyTaskFlowList(TeaModel):
    def __init__(
        self,
        task_flow: List[ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow] = None,
    ):
        self.task_flow = task_flow

    def validate(self):
        if self.task_flow:
            for k in self.task_flow:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskFlow'] = []
        if self.task_flow is not None:
            for k in self.task_flow:
                result['TaskFlow'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_flow = []
        if m.get('TaskFlow') is not None:
            for k in m.get('TaskFlow'):
                temp_model = ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow()
                self.task_flow.append(temp_model.from_map(k))
        return self


class ListTaskFlowsByPageResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        task_flow_list: ListTaskFlowsByPageResponseBodyTaskFlowList = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.task_flow_list = task_flow_list
        self.total_count = total_count

    def validate(self):
        if self.task_flow_list:
            self.task_flow_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_flow_list is not None:
            result['TaskFlowList'] = self.task_flow_list.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskFlowList') is not None:
            temp_model = ListTaskFlowsByPageResponseBodyTaskFlowList()
            self.task_flow_list = temp_model.from_map(m['TaskFlowList'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTaskFlowsByPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskFlowsByPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskFlowsByPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTasksInTaskFlowRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListTasksInTaskFlowResponseBodyTasksTask(TeaModel):
    def __init__(
        self,
        graph_param: str = None,
        node_config: str = None,
        node_content: str = None,
        node_id: str = None,
        node_name: str = None,
        node_output: str = None,
        node_type: str = None,
        time_variables: str = None,
    ):
        # The position of the node on the Directed Acyclic Graph (DAG).
        self.graph_param = graph_param
        # The advanced configuration for the node.
        self.node_config = node_config
        # The configuration for the node.
        self.node_content = node_content
        # The ID of the node.
        self.node_id = node_id
        # The name of the node.
        self.node_name = node_name
        # The output variables for the task.
        self.node_output = node_output
        # The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
        self.node_type = node_type
        # The time variables configured for the node.
        self.time_variables = time_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.graph_param is not None:
            result['GraphParam'] = self.graph_param
        if self.node_config is not None:
            result['NodeConfig'] = self.node_config
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_output is not None:
            result['NodeOutput'] = self.node_output
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GraphParam') is not None:
            self.graph_param = m.get('GraphParam')
        if m.get('NodeConfig') is not None:
            self.node_config = m.get('NodeConfig')
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeOutput') is not None:
            self.node_output = m.get('NodeOutput')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class ListTasksInTaskFlowResponseBodyTasks(TeaModel):
    def __init__(
        self,
        task: List[ListTasksInTaskFlowResponseBodyTasksTask] = None,
    ):
        self.task = task

    def validate(self):
        if self.task:
            for k in self.task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Task'] = []
        if self.task is not None:
            for k in self.task:
                result['Task'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task = []
        if m.get('Task') is not None:
            for k in m.get('Task'):
                temp_model = ListTasksInTaskFlowResponseBodyTasksTask()
                self.task.append(temp_model.from_map(k))
        return self


class ListTasksInTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tasks: ListTasksInTaskFlowResponseBodyTasks = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success
        # The tasks in the task flow.
        self.tasks = tasks

    def validate(self):
        if self.tasks:
            self.tasks.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tasks is not None:
            result['Tasks'] = self.tasks.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tasks') is not None:
            temp_model = ListTasksInTaskFlowResponseBodyTasks()
            self.tasks = temp_model.from_map(m['Tasks'])
        return self


class ListTasksInTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTasksInTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTasksInTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserPermissionsRequest(TeaModel):
    def __init__(
        self,
        database_name: str = None,
        db_type: str = None,
        env_type: str = None,
        logic: bool = None,
        page_number: int = None,
        page_size: int = None,
        perm_type: str = None,
        search_key: str = None,
        tid: int = None,
        user_id: str = None,
    ):
        # The name of the database.
        self.database_name = database_name
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type
        # The type of the environment to which the database belongs. Valid values:
        # 
        # *   product: production environment
        # *   dev: development environment
        # *   pre: staging environment
        # *   test: test environment
        # *   sit: SIT environment
        # *   uat: user acceptance testing (UAT) environment
        # *   pet: stress testing environment
        # *   stag: STAG environment
        self.env_type = env_type
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   true: The database is a logical database.
        # *   false: The database is a physical database.
        self.logic = logic
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The permissions on a specific type of resources that you want to query. Valid values:
        # 
        # *   DATABASE: permissions on databases
        # *   TABLE: permissions on tables
        # *   COLUMN: permissions on fields
        # *   INSTANCE: permissions on instances
        self.perm_type = perm_type
        # The keyword used in the query. For example, if you want to query permissions on an instance, you can specify the endpoint of the instance, such as rm-bp144d5ky4l4r****.
        self.search_key = search_key
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid
        # The ID of the user. You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the ID of the user.
        # 
        # >  The user ID is different from the ID of your Alibaba Cloud account.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.database_name is not None:
            result['DatabaseName'] = self.database_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatabaseName') is not None:
            self.database_name = m.get('DatabaseName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail(TeaModel):
    def __init__(
        self,
        create_date: str = None,
        expire_date: str = None,
        extra_data: str = None,
        origin_from: str = None,
        perm_type: str = None,
        user_access_id: str = None,
    ):
        # The time when the permissions were granted.
        self.create_date = create_date
        # The time when the permissions expire.
        self.expire_date = expire_date
        # This parameter is reserved.
        self.extra_data = extra_data
        # The user who grants the permissions.
        self.origin_from = origin_from
        # The type of the permissions. Valid values:
        # 
        # *   QUERY: the query permissions
        # *   EXPORT: the export permissions
        # *   CORRECT: the change permissions
        self.perm_type = perm_type
        # The ID of the authorization record.
        self.user_access_id = user_access_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_date is not None:
            result['CreateDate'] = self.create_date
        if self.expire_date is not None:
            result['ExpireDate'] = self.expire_date
        if self.extra_data is not None:
            result['ExtraData'] = self.extra_data
        if self.origin_from is not None:
            result['OriginFrom'] = self.origin_from
        if self.perm_type is not None:
            result['PermType'] = self.perm_type
        if self.user_access_id is not None:
            result['UserAccessId'] = self.user_access_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateDate') is not None:
            self.create_date = m.get('CreateDate')
        if m.get('ExpireDate') is not None:
            self.expire_date = m.get('ExpireDate')
        if m.get('ExtraData') is not None:
            self.extra_data = m.get('ExtraData')
        if m.get('OriginFrom') is not None:
            self.origin_from = m.get('OriginFrom')
        if m.get('PermType') is not None:
            self.perm_type = m.get('PermType')
        if m.get('UserAccessId') is not None:
            self.user_access_id = m.get('UserAccessId')
        return self


class ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails(TeaModel):
    def __init__(
        self,
        perm_detail: List[ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail] = None,
    ):
        self.perm_detail = perm_detail

    def validate(self):
        if self.perm_detail:
            for k in self.perm_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PermDetail'] = []
        if self.perm_detail is not None:
            for k in self.perm_detail:
                result['PermDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.perm_detail = []
        if m.get('PermDetail') is not None:
            for k in m.get('PermDetail'):
                temp_model = ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail()
                self.perm_detail.append(temp_model.from_map(k))
        return self


class ListUserPermissionsResponseBodyUserPermissionsUserPermission(TeaModel):
    def __init__(
        self,
        alias: str = None,
        column_name: str = None,
        db_id: str = None,
        db_type: str = None,
        ds_type: str = None,
        env_type: str = None,
        host: str = None,
        instance_id: str = None,
        logic: bool = None,
        perm_details: ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails = None,
        port: int = None,
        schema_name: str = None,
        search_name: str = None,
        table_id: str = None,
        table_name: str = None,
        user_id: str = None,
        user_nick_name: str = None,
    ):
        # The alias of the instance.
        self.alias = alias
        # The name of the field.
        self.column_name = column_name
        # The ID of the database.
        self.db_id = db_id
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://www.alibabacloud.com/help/en/data-management-service/latest/dbtype-parameter).
        self.db_type = db_type
        # The permissions on a specific type of objects that are granted to the user. Valid values: 
        # 
        # - DATABASE: permissions on physical databases
        # - LOGIC_DATABASE: permissions on logical databases
        # - TABLE: permissions on physical tables
        # - LOGIC_TABLE: permissions on logical tables
        self.ds_type = ds_type
        # The type of the environment to which the database belongs. Valid values:
        # 
        # - product: production environment
        # - dev: development environment
        # - pre: staging environment
        # - test: test environment
        # - sit: SIT environment
        # - uat: UAT environment
        # - pet: stress testing environment
        # - stag: STAG environment
        self.env_type = env_type
        # The endpoint that is used to connect the database.
        self.host = host
        # The ID of the instance.
        self.instance_id = instance_id
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   true: The database is a logical database.
        # *   false: The database is a physical database.
        self.logic = logic
        # The details of permissions.
        self.perm_details = perm_details
        # The port that is used to connect to the instance.
        self.port = port
        # The name of the database.
        self.schema_name = schema_name
        # The name that is used to search for the database.
        self.search_name = search_name
        # The ID of the table.
        self.table_id = table_id
        # The name of the table.
        self.table_name = table_name
        # The ID of the user.
        self.user_id = user_id
        # The nickname of the user.
        self.user_nick_name = user_nick_name

    def validate(self):
        if self.perm_details:
            self.perm_details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.perm_details is not None:
            result['PermDetails'] = self.perm_details.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_nick_name is not None:
            result['UserNickName'] = self.user_nick_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermDetails') is not None:
            temp_model = ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails()
            self.perm_details = temp_model.from_map(m['PermDetails'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserNickName') is not None:
            self.user_nick_name = m.get('UserNickName')
        return self


class ListUserPermissionsResponseBodyUserPermissions(TeaModel):
    def __init__(
        self,
        user_permission: List[ListUserPermissionsResponseBodyUserPermissionsUserPermission] = None,
    ):
        self.user_permission = user_permission

    def validate(self):
        if self.user_permission:
            for k in self.user_permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserPermission'] = []
        if self.user_permission is not None:
            for k in self.user_permission:
                result['UserPermission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user_permission = []
        if m.get('UserPermission') is not None:
            for k in m.get('UserPermission'):
                temp_model = ListUserPermissionsResponseBodyUserPermissionsUserPermission()
                self.user_permission.append(temp_model.from_map(k))
        return self


class ListUserPermissionsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
        user_permissions: ListUserPermissionsResponseBodyUserPermissions = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # - true: The request is successful.
        # - false: The request fails.
        self.success = success
        # The total number of entries that meet the query conditions.
        self.total_count = total_count
        # The details of the permissions that the user has.
        self.user_permissions = user_permissions

    def validate(self):
        if self.user_permissions:
            self.user_permissions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_permissions is not None:
            result['UserPermissions'] = self.user_permissions.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserPermissions') is not None:
            temp_model = ListUserPermissionsResponseBodyUserPermissions()
            self.user_permissions = temp_model.from_map(m['UserPermissions'])
        return self


class ListUserPermissionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUserPermissionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserPermissionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserTenantsRequest(TeaModel):
    def __init__(
        self,
        tid: int = None,
    ):
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListUserTenantsResponseBodyTenantList(TeaModel):
    def __init__(
        self,
        status: str = None,
        tenant_name: str = None,
        tid: int = None,
    ):
        # The status of the tenant. Valid values:
        # 
        # *   **ACTIVE**: The tenant is used to access DMS.
        # *   **IN_ACTIVE**: The tenant is not used.
        self.status = status
        # The name of the tenant.
        self.tenant_name = tenant_name
        # The ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.tenant_name is not None:
            result['TenantName'] = self.tenant_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TenantName') is not None:
            self.tenant_name = m.get('TenantName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListUserTenantsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        tenant_list: List[ListUserTenantsResponseBodyTenantList] = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success
        # The details of the tenants that were returned.
        self.tenant_list = tenant_list

    def validate(self):
        if self.tenant_list:
            for k in self.tenant_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TenantList'] = []
        if self.tenant_list is not None:
            for k in self.tenant_list:
                result['TenantList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.tenant_list = []
        if m.get('TenantList') is not None:
            for k in m.get('TenantList'):
                temp_model = ListUserTenantsResponseBodyTenantList()
                self.tenant_list.append(temp_model.from_map(k))
        return self


class ListUserTenantsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUserTenantsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserTenantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUsersRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        role: str = None,
        search_key: str = None,
        tid: int = None,
        user_state: str = None,
    ):
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        # 
        # >  Valid values: 10, 20, 50, and 100. Default value: 10.
        self.page_size = page_size
        # The role that is assigned to the user. Valid values:
        # 
        # *   **USER**: a regular user role.
        # *   **DBA**: a database administrator (DBA) role.
        # *   **ADMIN**: a Data Management (DMS) administrator role.
        # *   **SECURITY_ADMIN**: a security administrator role.
        # *   **STRUCT_READ_ONLY**: a schema read-only user role.
        # 
        # >  To check your role, move the pointer over the profile picture in the upper-right corner of the DMS console.
        self.role = role
        # The search keyword. Fuzzy match is supported.
        self.search_key = search_key
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the ID of the tenant.
        self.tid = tid
        # The status of the user. Valid values:
        # 
        # *   **NORMAL**: The user is normal.
        # *   **DISABLE**: The user is disabled.
        # *   **DELETE**: The user is deleted.
        self.user_state = user_state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.role is not None:
            result['Role'] = self.role
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_state is not None:
            result['UserState'] = self.user_state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserState') is not None:
            self.user_state = m.get('UserState')
        return self


class ListUsersResponseBodyUserListUserRoleIdList(TeaModel):
    def __init__(
        self,
        role_ids: List[int] = None,
    ):
        self.role_ids = role_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_ids is not None:
            result['RoleIds'] = self.role_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoleIds') is not None:
            self.role_ids = m.get('RoleIds')
        return self


class ListUsersResponseBodyUserListUserRoleNameList(TeaModel):
    def __init__(
        self,
        role_names: List[str] = None,
    ):
        self.role_names = role_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_names is not None:
            result['RoleNames'] = self.role_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RoleNames') is not None:
            self.role_names = m.get('RoleNames')
        return self


class ListUsersResponseBodyUserListUser(TeaModel):
    def __init__(
        self,
        cur_execute_count: int = None,
        cur_result_count: int = None,
        ding_robot: str = None,
        email: str = None,
        last_login_time: str = None,
        max_execute_count: int = None,
        max_result_count: int = None,
        mobile: str = None,
        nick_name: str = None,
        notification_mode: str = None,
        parent_uid: str = None,
        role_id_list: ListUsersResponseBodyUserListUserRoleIdList = None,
        role_name_list: ListUsersResponseBodyUserListUserRoleNameList = None,
        signature_method: str = None,
        state: str = None,
        uid: str = None,
        user_id: str = None,
        webhook: str = None,
    ):
        # The number of queries that are performed on the current day.
        self.cur_execute_count = cur_execute_count
        # The number of rows that are queried on the current day.
        self.cur_result_count = cur_result_count
        # The DingTalk chatbot URL that is used to receive notifications.
        # 
        # > 
        # *   The system returns this parameter if the user has set a DingTalk chatbot URL in the console. To set a DingTalk chatbot URL in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # *   The system does not return this parameter if the user has not set a DingTalk chatbot URL.
        self.ding_robot = ding_robot
        # The email address that is used to receive notifications.
        # 
        # > 
        # *   The system returns this parameter if the user has set an email address in the console. To set an email address in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # *   The system does not return this parameter if the user has not set an email address.
        self.email = email
        # The last time when the user logged on to the console.
        self.last_login_time = last_login_time
        # The maximum number of queries that can be performed on the current day.
        self.max_execute_count = max_execute_count
        # The maximum number of rows that can be queried on the current day.
        self.max_result_count = max_result_count
        # The mobile phone number that is used to receive notifications.
        # 
        # > 
        # *   The system returns this parameter if the user has set a mobile phone number in the console. To set a mobile phone number in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
        # *   The system does not return this parameter if the user has not set a mobile phone number.
        self.mobile = mobile
        # The nickname of the user.
        self.nick_name = nick_name
        # The notification method. The system returns one or more values. Valid values:
        # 
        # *   **SMS**: text message.
        # *   **EMAIL**: email.
        # *   **DingTalk**: DingTalk.
        # *   **DINGROBOT**: DingTalk chatbot.
        # *   **WEBHOOK**: webhook.
        self.notification_mode = notification_mode
        # The UID of the Alibaba Cloud account of the user.
        self.parent_uid = parent_uid
        # The ID of the role that is assigned to the user. Valid values:
        # 
        # *   **1**: a regular user role.
        # *   **2**: a DBA role.
        # *   **3**: a DMS administrator role.
        # *   **4**: a security administrator role.
        # *   **6**: a schema read-only user role.
        self.role_id_list = role_id_list
        # The name of the role that is assigned to the user. Valid values:
        # 
        # *   **USER**: a regular user.
        # *   **DBA**: a DBA.
        # *   **ADMIN**: a DMS administrator.
        # *   **SECURITY_ADMIN**: a security administrator.
        # *   **STRUCT_READ_ONLY**: a schema read-only user.
        self.role_name_list = role_name_list
        # The signature method that is used to secure connections when a webhook URL is used. Valid values:
        # 
        # *   **NONE**: no signature.
        # *   **HMAC_SHA1**: HMAC-SHA1.
        self.signature_method = signature_method
        # The status of the user. Valid values:
        # 
        # *   **NORMAL**: The user is normal.
        # *   **DISABLE**: The user is disabled.
        # *   **DELETE**: The user is deleted.
        self.state = state
        # The UID of the user.
        self.uid = uid
        # The ID of the user.
        self.user_id = user_id
        # The webhook URL that is used to receive notifications.
        # 
        # > 
        # *   If the user has set a webhook URL, DMS sends notifications to the specified URL.
        # *   The system does not return this parameter if the user has not set a webhook URL.
        self.webhook = webhook

    def validate(self):
        if self.role_id_list:
            self.role_id_list.validate()
        if self.role_name_list:
            self.role_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cur_execute_count is not None:
            result['CurExecuteCount'] = self.cur_execute_count
        if self.cur_result_count is not None:
            result['CurResultCount'] = self.cur_result_count
        if self.ding_robot is not None:
            result['DingRobot'] = self.ding_robot
        if self.email is not None:
            result['Email'] = self.email
        if self.last_login_time is not None:
            result['LastLoginTime'] = self.last_login_time
        if self.max_execute_count is not None:
            result['MaxExecuteCount'] = self.max_execute_count
        if self.max_result_count is not None:
            result['MaxResultCount'] = self.max_result_count
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.notification_mode is not None:
            result['NotificationMode'] = self.notification_mode
        if self.parent_uid is not None:
            result['ParentUid'] = self.parent_uid
        if self.role_id_list is not None:
            result['RoleIdList'] = self.role_id_list.to_map()
        if self.role_name_list is not None:
            result['RoleNameList'] = self.role_name_list.to_map()
        if self.signature_method is not None:
            result['SignatureMethod'] = self.signature_method
        if self.state is not None:
            result['State'] = self.state
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurExecuteCount') is not None:
            self.cur_execute_count = m.get('CurExecuteCount')
        if m.get('CurResultCount') is not None:
            self.cur_result_count = m.get('CurResultCount')
        if m.get('DingRobot') is not None:
            self.ding_robot = m.get('DingRobot')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('LastLoginTime') is not None:
            self.last_login_time = m.get('LastLoginTime')
        if m.get('MaxExecuteCount') is not None:
            self.max_execute_count = m.get('MaxExecuteCount')
        if m.get('MaxResultCount') is not None:
            self.max_result_count = m.get('MaxResultCount')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('NotificationMode') is not None:
            self.notification_mode = m.get('NotificationMode')
        if m.get('ParentUid') is not None:
            self.parent_uid = m.get('ParentUid')
        if m.get('RoleIdList') is not None:
            temp_model = ListUsersResponseBodyUserListUserRoleIdList()
            self.role_id_list = temp_model.from_map(m['RoleIdList'])
        if m.get('RoleNameList') is not None:
            temp_model = ListUsersResponseBodyUserListUserRoleNameList()
            self.role_name_list = temp_model.from_map(m['RoleNameList'])
        if m.get('SignatureMethod') is not None:
            self.signature_method = m.get('SignatureMethod')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class ListUsersResponseBodyUserList(TeaModel):
    def __init__(
        self,
        user: List[ListUsersResponseBodyUserListUser] = None,
    ):
        self.user = user

    def validate(self):
        if self.user:
            for k in self.user:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['User'] = []
        if self.user is not None:
            for k in self.user:
                result['User'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user = []
        if m.get('User') is not None:
            for k in m.get('User'):
                temp_model = ListUsersResponseBodyUserListUser()
                self.user.append(temp_model.from_map(k))
        return self


class ListUsersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
        user_list: ListUsersResponseBodyUserList = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success
        # The total number of entries returned.
        self.total_count = total_count
        # The details of users.
        self.user_list = user_list

    def validate(self):
        if self.user_list:
            self.user_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.user_list is not None:
            result['UserList'] = self.user_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('UserList') is not None:
            temp_model = ListUsersResponseBodyUserList()
            self.user_list = temp_model.from_map(m['UserList'])
        return self


class ListUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkFlowNodesRequest(TeaModel):
    def __init__(
        self,
        search_name: str = None,
        tid: int = None,
    ):
        self.search_name = search_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser(TeaModel):
    def __init__(
        self,
        nick_name: str = None,
        real_name: str = None,
        user_id: int = None,
    ):
        self.nick_name = nick_name
        self.real_name = real_name
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.real_name is not None:
            result['RealName'] = self.real_name
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('RealName') is not None:
            self.real_name = m.get('RealName')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers(TeaModel):
    def __init__(
        self,
        audit_user: List[ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser] = None,
    ):
        self.audit_user = audit_user

    def validate(self):
        if self.audit_user:
            for k in self.audit_user:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuditUser'] = []
        if self.audit_user is not None:
            for k in self.audit_user:
                result['AuditUser'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audit_user = []
        if m.get('AuditUser') is not None:
            for k in m.get('AuditUser'):
                temp_model = ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser()
                self.audit_user.append(temp_model.from_map(k))
        return self


class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode(TeaModel):
    def __init__(
        self,
        audit_users: ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers = None,
        comment: str = None,
        create_user_id: int = None,
        create_user_nick_name: str = None,
        node_id: int = None,
        node_name: str = None,
        node_type: str = None,
    ):
        self.audit_users = audit_users
        self.comment = comment
        self.create_user_id = create_user_id
        self.create_user_nick_name = create_user_nick_name
        self.node_id = node_id
        self.node_name = node_name
        self.node_type = node_type

    def validate(self):
        if self.audit_users:
            self.audit_users.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_users is not None:
            result['AuditUsers'] = self.audit_users.to_map()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.create_user_nick_name is not None:
            result['CreateUserNickName'] = self.create_user_nick_name
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditUsers') is not None:
            temp_model = ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers()
            self.audit_users = temp_model.from_map(m['AuditUsers'])
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('CreateUserNickName') is not None:
            self.create_user_nick_name = m.get('CreateUserNickName')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        return self


class ListWorkFlowNodesResponseBodyWorkflowNodes(TeaModel):
    def __init__(
        self,
        workflow_node: List[ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode] = None,
    ):
        self.workflow_node = workflow_node

    def validate(self):
        if self.workflow_node:
            for k in self.workflow_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkflowNode'] = []
        if self.workflow_node is not None:
            for k in self.workflow_node:
                result['WorkflowNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.workflow_node = []
        if m.get('WorkflowNode') is not None:
            for k in m.get('WorkflowNode'):
                temp_model = ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode()
                self.workflow_node.append(temp_model.from_map(k))
        return self


class ListWorkFlowNodesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        workflow_nodes: ListWorkFlowNodesResponseBodyWorkflowNodes = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.workflow_nodes = workflow_nodes

    def validate(self):
        if self.workflow_nodes:
            self.workflow_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.workflow_nodes is not None:
            result['WorkflowNodes'] = self.workflow_nodes.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('WorkflowNodes') is not None:
            temp_model = ListWorkFlowNodesResponseBodyWorkflowNodes()
            self.workflow_nodes = temp_model.from_map(m['WorkflowNodes'])
        return self


class ListWorkFlowNodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkFlowNodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkFlowNodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkFlowTemplatesRequest(TeaModel):
    def __init__(
        self,
        search_name: str = None,
        tid: int = None,
    ):
        self.search_name = search_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode(TeaModel):
    def __init__(
        self,
        comment: str = None,
        create_user_id: int = None,
        node_id: int = None,
        node_name: str = None,
        node_type: str = None,
        position: int = None,
        template_id: int = None,
    ):
        self.comment = comment
        self.create_user_id = create_user_id
        self.node_id = node_id
        self.node_name = node_name
        self.node_type = node_type
        self.position = position
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.position is not None:
            result['Position'] = self.position
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes(TeaModel):
    def __init__(
        self,
        workflow_node: List[ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode] = None,
    ):
        self.workflow_node = workflow_node

    def validate(self):
        if self.workflow_node:
            for k in self.workflow_node:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkflowNode'] = []
        if self.workflow_node is not None:
            for k in self.workflow_node:
                result['WorkflowNode'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.workflow_node = []
        if m.get('WorkflowNode') is not None:
            for k in m.get('WorkflowNode'):
                temp_model = ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode()
                self.workflow_node.append(temp_model.from_map(k))
        return self


class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate(TeaModel):
    def __init__(
        self,
        comment: str = None,
        create_user_id: int = None,
        enabled: str = None,
        is_system: int = None,
        template_id: int = None,
        template_name: str = None,
        workflow_nodes: ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes = None,
    ):
        self.comment = comment
        self.create_user_id = create_user_id
        self.enabled = enabled
        self.is_system = is_system
        self.template_id = template_id
        self.template_name = template_name
        self.workflow_nodes = workflow_nodes

    def validate(self):
        if self.workflow_nodes:
            self.workflow_nodes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.is_system is not None:
            result['IsSystem'] = self.is_system
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.workflow_nodes is not None:
            result['WorkflowNodes'] = self.workflow_nodes.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('IsSystem') is not None:
            self.is_system = m.get('IsSystem')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('WorkflowNodes') is not None:
            temp_model = ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes()
            self.workflow_nodes = temp_model.from_map(m['WorkflowNodes'])
        return self


class ListWorkFlowTemplatesResponseBodyWorkFlowTemplates(TeaModel):
    def __init__(
        self,
        work_flow_template: List[ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate] = None,
    ):
        self.work_flow_template = work_flow_template

    def validate(self):
        if self.work_flow_template:
            for k in self.work_flow_template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WorkFlowTemplate'] = []
        if self.work_flow_template is not None:
            for k in self.work_flow_template:
                result['WorkFlowTemplate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.work_flow_template = []
        if m.get('WorkFlowTemplate') is not None:
            for k in m.get('WorkFlowTemplate'):
                temp_model = ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate()
                self.work_flow_template.append(temp_model.from_map(k))
        return self


class ListWorkFlowTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        work_flow_templates: ListWorkFlowTemplatesResponseBodyWorkFlowTemplates = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.work_flow_templates = work_flow_templates

    def validate(self):
        if self.work_flow_templates:
            self.work_flow_templates.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.work_flow_templates is not None:
            result['WorkFlowTemplates'] = self.work_flow_templates.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('WorkFlowTemplates') is not None:
            temp_model = ListWorkFlowTemplatesResponseBodyWorkFlowTemplates()
            self.work_flow_templates = temp_model.from_map(m['WorkFlowTemplates'])
        return self


class ListWorkFlowTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkFlowTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkFlowTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MakeTaskFlowInstanceSuccessRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_instance_id: int = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.dag_instance_id = dag_instance_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class MakeTaskFlowInstanceSuccessResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MakeTaskFlowInstanceSuccessResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MakeTaskFlowInstanceSuccessResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MakeTaskFlowInstanceSuccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDataCorrectExecSQLRequest(TeaModel):
    def __init__(
        self,
        exec_sql: str = None,
        order_id: int = None,
        tid: int = None,
    ):
        # The new SQL script.
        self.exec_sql = exec_sql
        # The ID of the data change ticket.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exec_sql is not None:
            result['ExecSQL'] = self.exec_sql
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExecSQL') is not None:
            self.exec_sql = m.get('ExecSQL')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ModifyDataCorrectExecSQLResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyDataCorrectExecSQLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyDataCorrectExecSQLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDataCorrectExecSQLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDesensitizationStrategyRequest(TeaModel):
    def __init__(
        self,
        column_name: str = None,
        db_id: int = None,
        is_logic: bool = None,
        is_reset: bool = None,
        rule_id: int = None,
        schema_name: str = None,
        table_name: str = None,
        tid: int = None,
    ):
        # The name of the field. You can call the [ListSensitiveColumns](~~188103~~) operation to query the field name.
        # 
        # >  You can also call the [ListColumns](~~141870~~) operation to query the field name.
        self.column_name = column_name
        # The ID of the database. You can call the [ListDatabases](~~141873~~) operation to query the ID.
        self.db_id = db_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true:** The database is a physical database.
        # *   **false:** The database is a logical database.
        self.is_logic = is_logic
        # Specifies whether to reset the masking rule. Valid values:
        # 
        # *   **true**: resets the masking rule.
        # *   **false**: does not reset the masking rule. This is the default value.
        self.is_reset = is_reset
        # The ID of the masking rule.
        self.rule_id = rule_id
        # The name of the database. You can call the [ListSensitiveColumns](~~188103~~) operation to query the database name.
        # 
        # > 
        # *   If the database is a physical database, you can call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to query the database name.
        # *   If the database is a logical database, you can call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation to query the database name.
        self.schema_name = schema_name
        # The name of the table. You can call the [ListSensitiveColumns](~~188103~~) operation to query the table name.
        # 
        # >  You can also call the [ListTables](~~141878~~) operation to query the table name.
        self.table_name = table_name
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.column_name is not None:
            result['ColumnName'] = self.column_name
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.is_logic is not None:
            result['IsLogic'] = self.is_logic
        if self.is_reset is not None:
            result['IsReset'] = self.is_reset
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColumnName') is not None:
            self.column_name = m.get('ColumnName')
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('IsLogic') is not None:
            self.is_logic = m.get('IsLogic')
        if m.get('IsReset') is not None:
            self.is_reset = m.get('IsReset')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ModifyDesensitizationStrategyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: bool = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The returned result.
        self.result = result
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyDesensitizationStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyDesensitizationStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDesensitizationStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveTaskFlowToScenarioRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        scenario_id: int = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.scenario_id = scenario_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class MoveTaskFlowToScenarioResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MoveTaskFlowToScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MoveTaskFlowToScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveTaskFlowToScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OfflineTaskFlowRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
        self.dag_id = dag_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class OfflineTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class OfflineTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OfflineTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OfflineTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PauseDataCorrectSQLJobRequest(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        order_id: int = None,
        tid: int = None,
        type: str = None,
    ):
        # The ID of the SQL task. You can call the [GetDataCorrectTaskDetail](~~208481~~) and [ListDBTaskSQLJob](~~207049~~) operations to obtain the value of this parameter.
        # 
        # >  If the Type parameter is set to SINGLE, you must pass the value of the JobId parameter to confirm the ID of the SQL task that you want to rerun.
        self.job_id = job_id
        # The ID of the data change ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the data change ticket.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid
        # The type of the pause operation. Valid values:
        # 
        # *   ALL: pauses all SQL tasks.
        # *   SINGLE: pauses a single SQL task.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class PauseDataCorrectSQLJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PauseDataCorrectSQLJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PauseDataCorrectSQLJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PauseDataCorrectSQLJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublishAndDeployTaskFlowRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
        version_comments: str = None,
    ):
        self.dag_id = dag_id
        self.tid = tid
        self.version_comments = version_comments

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.version_comments is not None:
            result['VersionComments'] = self.version_comments
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('VersionComments') is not None:
            self.version_comments = m.get('VersionComments')
        return self


class PublishAndDeployTaskFlowResponseBody(TeaModel):
    def __init__(
        self,
        deploy_id: int = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.deploy_id = deploy_id
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PublishAndDeployTaskFlowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PublishAndDeployTaskFlowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublishAndDeployTaskFlowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReDeployLhDagVersionRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_version: int = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
        self.dag_id = dag_id
        # The ID of the task flow version. You can call the [ListDAGVersions](~~424682~~) operation to obtain the ID of the task flow version.
        self.dag_version = dag_version
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the ID of the tenant.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_version is not None:
            result['DagVersion'] = self.dag_version
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagVersion') is not None:
            self.dag_version = m.get('DagVersion')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ReDeployLhDagVersionResponseBody(TeaModel):
    def __init__(
        self,
        deploy_id: int = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the deployment record.
        self.deploy_id = deploy_id
        # The error code returned if the request fails.
        self.error_code = error_code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deploy_id is not None:
            result['DeployId'] = self.deploy_id
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeployId') is not None:
            self.deploy_id = m.get('DeployId')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReDeployLhDagVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReDeployLhDagVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReDeployLhDagVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReRunTaskFlowInstanceRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_instance_id: int = None,
        dag_version: str = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the execution record ID.
        self.dag_instance_id = dag_instance_id
        # The version number of the task flow. You can call the ListTaskFlowVersions operation to query the version number of the task flow.
        self.dag_version = dag_version
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.dag_version is not None:
            result['DagVersion'] = self.dag_version
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('DagVersion') is not None:
            self.dag_version = m.get('DagVersion')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ReRunTaskFlowInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReRunTaskFlowInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReRunTaskFlowInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReRunTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefundPayAsYouGoOrderRequest(TeaModel):
    def __init__(
        self,
        order_id: str = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class RefundPayAsYouGoOrderResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RefundPayAsYouGoOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RefundPayAsYouGoOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefundPayAsYouGoOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterInstanceRequest(TeaModel):
    def __init__(
        self,
        data_link_name: str = None,
        database_password: str = None,
        database_user: str = None,
        dba_uid: int = None,
        ddl_online: int = None,
        ecs_instance_id: str = None,
        ecs_region: str = None,
        enable_sell_sitd: str = None,
        env_type: str = None,
        export_timeout: int = None,
        host: str = None,
        instance_alias: str = None,
        instance_source: str = None,
        instance_type: str = None,
        network_type: str = None,
        port: int = None,
        query_timeout: int = None,
        safe_rule: str = None,
        sid: str = None,
        skip_test: bool = None,
        template_id: int = None,
        template_type: str = None,
        tid: int = None,
        use_dsql: int = None,
        vpc_id: str = None,
    ):
        # The name of the data link for cross-database query.
        # 
        # > 
        # *   This parameter is required if the UseDsql parameter is set to 1.
        # *   The name can contain only lowercase letters and underscores (\_).
        # *   The name must be unique within a tenant.
        self.data_link_name = data_link_name
        # The password that is used to log on to the database.
        self.database_password = database_password
        # The account that is used to log on to the database.
        self.database_user = database_user
        # The ID of the user who assumes the DBA role of the database instance. You can call the [ListUsers](~~141938~~) or [GetInstance](~~141567~~) operation to obtain the user ID.
        self.dba_uid = dba_uid
        # Specifies whether to enable the lock-free schema change feature for the database instance. Valid values:
        # 
        # *   0: The feature is disabled.
        # *   1: The native online DDL feature takes precedence.
        # *   2: The lock-free schema change feature of DMS takes precedence.
        # 
        # >  Supported database types: ApsaraDB RDS for MySQL, PolarDB for MySQL, ApsaraDB MyBase for MySQL, and MySQL databases from other sources.
        self.ddl_online = ddl_online
        # The ID of the ECS instance.
        # 
        # >  This parameter is required if the InstanceSource parameter is set to ECS_OWN.
        self.ecs_instance_id = ecs_instance_id
        # The ID of the region in which the database instance resides.
        # 
        # >  This parameter is required if the InstanceSource parameter is set to RDS, ECS_OWN, or VPC_IDC.
        self.ecs_region = ecs_region
        self.enable_sell_sitd = enable_sell_sitd
        # The type of the environment to which the database instance belongs. Valid values:
        # 
        # *   product: production environment
        # *   dev: development environment
        # *   pre: staging environment
        # *   test: test environment
        # *   sit: system integration testing (SIT) environment
        # *   uat: user acceptance testing (UAT) environment
        # *   pet: stress testing environment
        # *   stag: STAG environment
        self.env_type = env_type
        # The timeout period for exporting data from the database instance. Unit: seconds.
        self.export_timeout = export_timeout
        # The host address that is used to connect to the database instance.
        self.host = host
        # The alias of the database instance. Specify an alias that can help you identify the database instance in DMS.
        self.instance_alias = instance_alias
        # The source of the database instance. Valid values:
        # 
        # *   **PUBLIC_OWN**: a self-managed database instance that is deployed on the Internet
        # *   **RDS**: an ApsaraDB RDS instance
        # *   **ECS_OWN**: a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
        # *   **VPC_IDC**: a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
        self.instance_source = instance_source
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.instance_type = instance_type
        # The network type of the database instance. Valid values:
        # 
        # *   **CLASSIC**: classic network
        # *   **VPC**: VPC
        self.network_type = network_type
        # The port number that is used to connect to the database instance.
        self.port = port
        # The timeout period for querying data in the database instance. Unit: seconds.
        self.query_timeout = query_timeout
        # The name of the security rule set for the database. You can call the [ListStandardGroups](~~417891~~) or [GetInstance](~~141567~~) operation to obtain the name of the security rule set that you want to use.
        self.safe_rule = safe_rule
        # The system ID (SID) of the database.
        # 
        # >  This parameter is required if the InstanceType parameter is set to ORACLE.
        self.sid = sid
        # Specifies whether to skip connectivity test. Valid values:
        # 
        # *   **true**: The connectivity test is skipped.
        # *   **false**: The connectivity test is not skipped.
        self.skip_test = skip_test
        self.template_id = template_id
        self.template_type = template_type
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid
        # Specifies whether to enable the cross-database query feature for the database instance. Valid values:
        # 
        # *   0: The feature is disabled.
        # *   1: The feature is enabled.
        # 
        # >  Supported database types: MySQL, SQL Server, PostgreSQL, PolarDB for Oracle, and ApsaraDB for Redis.
        self.use_dsql = use_dsql
        # The ID of the VPC.
        # 
        # >  This parameter is required if the InstanceSource parameter is set to VPC_IDC.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_uid is not None:
            result['DbaUid'] = self.dba_uid
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.enable_sell_sitd is not None:
            result['EnableSellSitd'] = self.enable_sell_sitd
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule is not None:
            result['SafeRule'] = self.safe_rule
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.skip_test is not None:
            result['SkipTest'] = self.skip_test
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaUid') is not None:
            self.dba_uid = m.get('DbaUid')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnableSellSitd') is not None:
            self.enable_sell_sitd = m.get('EnableSellSitd')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRule') is not None:
            self.safe_rule = m.get('SafeRule')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('SkipTest') is not None:
            self.skip_test = m.get('SkipTest')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class RegisterInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RegisterInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RegisterInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterUserRequest(TeaModel):
    def __init__(
        self,
        mobile: str = None,
        role_names: str = None,
        tid: int = None,
        uid: str = None,
        user_nick: str = None,
    ):
        # The mobile number of the user.
        self.mobile = mobile
        # The role that you want to assign to the user. Valid values:
        # 
        # *   **USER**: a regular user role
        # *   **DBA**: a database administrator (DBA) role
        # *   **ADMIN**: a DMS administrator role
        # *   **SECURITY_ADMIN**: a security administrator role
        # 
        # >  If you do not specify this parameter, the regular user role is assigned to the user by default. You can assign one or more roles to the user. Separate multiple roles with commas (,).
        self.role_names = role_names
        # The ID of the tenant.
        # 
        # >  To query ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid
        # The UID of the Alibaba Cloud account of the user that you want to register.
        self.uid = uid
        # The nickname of the user.
        self.user_nick = user_nick

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.role_names is not None:
            result['RoleNames'] = self.role_names
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('RoleNames') is not None:
            self.role_names = m.get('RoleNames')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class RegisterUserResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # *   true: The request was successful.
        # *   false: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RegisterUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RegisterUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartDataCorrectSQLJobRequest(TeaModel):
    def __init__(
        self,
        job_id: int = None,
        order_id: int = None,
        tid: int = None,
        type: str = None,
    ):
        # The ID of the SQL task. You can call the [GetDataCorrectTaskDetail](~~208481~~) and [ListDBTaskSQLJob](~~207049~~) operations to obtain the value of this parameter.
        # 
        # If the Type parameter is set to SINGLE, you must pass the value of the JobId parameter to confirm the ID of the SQL task that you want to rerun.
        self.job_id = job_id
        # The ID of the data change ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the data change ticket.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid
        # The type of the rerun operation. Valid values:
        # 
        # *   **ALL**: reruns all SQL tasks.
        # *   **SINGLE**: reruns a single SQL task.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RestartDataCorrectSQLJobResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   **true**: The request is successful.
        # *   **false**: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RestartDataCorrectSQLJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartDataCorrectSQLJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartDataCorrectSQLJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResumeTaskFlowInstanceRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_instance_id: int = None,
        dag_version: str = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.dag_instance_id = dag_instance_id
        self.dag_version = dag_version
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.dag_version is not None:
            result['DagVersion'] = self.dag_version
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('DagVersion') is not None:
            self.dag_version = m.get('DagVersion')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class ResumeTaskFlowInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ResumeTaskFlowInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResumeTaskFlowInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResumeTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RetryDataCorrectPreCheckRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        # The ID of the data change ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the data change ticket.
        self.order_id = order_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class RetryDataCorrectPreCheckResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RetryDataCorrectPreCheckResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RetryDataCorrectPreCheckResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RetryDataCorrectPreCheckResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RevokeUserPermissionRequest(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        ds_type: str = None,
        instance_id: int = None,
        logic: bool = None,
        perm_types: str = None,
        table_id: str = None,
        table_name: str = None,
        tid: int = None,
        user_access_id: str = None,
        user_id: str = None,
    ):
        # The ID of the database. The database can be a physical database or a logical database.
        # 
        # *   To query the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
        # *   To query the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
        self.db_id = db_id
        # The object type on which the permission you want to revoke from the user. Valid values:
        # 
        # *   **INSTANCE**: database instances
        # *   **DATABASE**: physical databases
        # *   **LOGIC_DATABASE**: logical databases
        # *   **TABLE**: physical tables
        # *   **LOGIC_TABLE**: logical tables
        self.ds_type = ds_type
        # The ID of the database instance. You must specify this parameter when you revoke a permission from the database instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to query the database instance ID.
        self.instance_id = instance_id
        # Specifies whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is a physical database.
        # 
        # > 
        # *   If the database is a logical database, set this parameter to **true**.
        # *   If the database is a physical database, set this parameter to **false**.
        self.logic = logic
        # The type of the permission. Valid values:
        # 
        # *   **QUERY**: the data query permission
        # *   **EXPORT**: the data export permission
        # *   **CORRECT**: the data change permission
        self.perm_types = perm_types
        # The ID of the table. You must specify this parameter when you revoke a permission from the table. You can call the [ListTables](~~141878~~) operation to query the table ID.
        self.table_id = table_id
        # The name of the table. You can call the [ListTables](~~141878~~) operation to query the table name.
        self.table_name = table_name
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
        self.tid = tid
        # The ID of the permission. You can call the [ListUserPermission](~~146957~~) operation to query the permission ID.
        self.user_access_id = user_access_id
        # The ID of the user. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to query the user ID.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.ds_type is not None:
            result['DsType'] = self.ds_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.perm_types is not None:
            result['PermTypes'] = self.perm_types
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.user_access_id is not None:
            result['UserAccessId'] = self.user_access_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('DsType') is not None:
            self.ds_type = m.get('DsType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('PermTypes') is not None:
            self.perm_types = m.get('PermTypes')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UserAccessId') is not None:
            self.user_access_id = m.get('UserAccessId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RevokeUserPermissionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RevokeUserPermissionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RevokeUserPermissionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RevokeUserPermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchDatabaseRequest(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        env_type: str = None,
        page_number: int = None,
        page_size: int = None,
        search_key: str = None,
        search_range: str = None,
        search_target: str = None,
        tid: int = None,
    ):
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.db_type = db_type
        # The type of the environment to which the database belongs. For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The keyword that is used to search for databases.
        self.search_key = search_key
        # The query range based on permissions. Valid values:
        # 
        # *   **HAS_PERMSSION**: searches for databases on which the current user has permissions.
        # *   **OWNER**: searches for databases owned by the current user.
        # *   **MY_FOCUS**: searches for databases that the current user follows.
        # *   **UNKNOWN**: searches for all databases.
        self.search_range = search_range
        # The category of the database. Valid values:
        # 
        # *   **DB**: single database or logical database.
        # *   **SINGLE_DB**: single database.
        # *   **LOGIC_DB**: logical database.
        self.search_target = search_target
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.search_range is not None:
            result['SearchRange'] = self.search_range
        if self.search_target is not None:
            result['SearchTarget'] = self.search_target
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SearchRange') is not None:
            self.search_range = m.get('SearchRange')
        if m.get('SearchTarget') is not None:
            self.search_target = m.get('SearchTarget')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class SearchDatabaseResponseBodySearchDatabaseListSearchDatabase(TeaModel):
    def __init__(
        self,
        alias: str = None,
        database_id: str = None,
        datalink_name: str = None,
        db_type: str = None,
        dba_id: str = None,
        encoding: str = None,
        env_type: str = None,
        host: str = None,
        logic: bool = None,
        owner_id_list: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList = None,
        owner_name_list: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList = None,
        port: int = None,
        schema_name: str = None,
        search_name: str = None,
        sid: str = None,
    ):
        # The alias of the database.
        self.alias = alias
        # The ID of the database.
        self.database_id = database_id
        # The name of the data link for cross-database queries.
        self.datalink_name = datalink_name
        # The type of the database.
        self.db_type = db_type
        # The ID of the user who assumes the database administrator (DBA) role.
        self.dba_id = dba_id
        # The encoding method of the database.
        self.encoding = encoding
        # The type of the environment to which the database belongs. For more information, see [Change the environment type of an instance](~~163309~~).
        self.env_type = env_type
        # The endpoint of the instance in which the database resides.
        self.host = host
        # Indicates whether the database is a logical database. Valid values:
        # 
        # *   **true**: The database is a logical database.
        # *   **false**: The database is not a logical database.
        self.logic = logic
        # The IDs of the owners of the database.
        self.owner_id_list = owner_id_list
        # The nicknames of the database owners.
        self.owner_name_list = owner_name_list
        # The port number of the instance in which the database resides.
        self.port = port
        # The name of the database.
        self.schema_name = schema_name
        # The name that is used to search for the database.
        self.search_name = search_name
        # The system ID (Sid) of the instance in which the database resides.
        self.sid = sid

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.datalink_name is not None:
            result['DatalinkName'] = self.datalink_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.host is not None:
            result['Host'] = self.host
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.port is not None:
            result['Port'] = self.port
        if self.schema_name is not None:
            result['SchemaName'] = self.schema_name
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.sid is not None:
            result['Sid'] = self.sid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DatalinkName') is not None:
            self.datalink_name = m.get('DatalinkName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('SchemaName') is not None:
            self.schema_name = m.get('SchemaName')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        return self


class SearchDatabaseResponseBodySearchDatabaseList(TeaModel):
    def __init__(
        self,
        search_database: List[SearchDatabaseResponseBodySearchDatabaseListSearchDatabase] = None,
    ):
        self.search_database = search_database

    def validate(self):
        if self.search_database:
            for k in self.search_database:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchDatabase'] = []
        if self.search_database is not None:
            for k in self.search_database:
                result['SearchDatabase'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.search_database = []
        if m.get('SearchDatabase') is not None:
            for k in m.get('SearchDatabase'):
                temp_model = SearchDatabaseResponseBodySearchDatabaseListSearchDatabase()
                self.search_database.append(temp_model.from_map(k))
        return self


class SearchDatabaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        search_database_list: SearchDatabaseResponseBodySearchDatabaseList = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned.
        self.error_code = error_code
        # The error message returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The information about the databases.
        self.search_database_list = search_database_list
        # Indicates whether the request was successful. Valid values:
        # 
        # - **true**: The request was successful.
        # - **false**: The request failed.
        self.success = success
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.search_database_list:
            self.search_database_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.search_database_list is not None:
            result['SearchDatabaseList'] = self.search_database_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SearchDatabaseList') is not None:
            temp_model = SearchDatabaseResponseBodySearchDatabaseList()
            self.search_database_list = temp_model.from_map(m['SearchDatabaseList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchDatabaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchDatabaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchDatabaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchTableRequest(TeaModel):
    def __init__(
        self,
        db_type: str = None,
        env_type: str = None,
        page_number: int = None,
        page_size: int = None,
        return_guid: bool = None,
        search_key: str = None,
        search_range: str = None,
        search_target: str = None,
        tid: int = None,
    ):
        self.db_type = db_type
        self.env_type = env_type
        self.page_number = page_number
        self.page_size = page_size
        self.return_guid = return_guid
        self.search_key = search_key
        self.search_range = search_range
        self.search_target = search_target
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.return_guid is not None:
            result['ReturnGuid'] = self.return_guid
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.search_range is not None:
            result['SearchRange'] = self.search_range
        if self.search_target is not None:
            result['SearchTarget'] = self.search_target
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ReturnGuid') is not None:
            self.return_guid = m.get('ReturnGuid')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SearchRange') is not None:
            self.search_range = m.get('SearchRange')
        if m.get('SearchTarget') is not None:
            self.search_target = m.get('SearchTarget')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SearchTableResponseBodySearchTableListSearchTableOwnerIdList(TeaModel):
    def __init__(
        self,
        owner_ids: List[str] = None,
    ):
        self.owner_ids = owner_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        return self


class SearchTableResponseBodySearchTableListSearchTableOwnerNameList(TeaModel):
    def __init__(
        self,
        owner_names: List[str] = None,
    ):
        self.owner_names = owner_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_names is not None:
            result['OwnerNames'] = self.owner_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerNames') is not None:
            self.owner_names = m.get('OwnerNames')
        return self


class SearchTableResponseBodySearchTableListSearchTable(TeaModel):
    def __init__(
        self,
        dbsearch_name: str = None,
        database_id: str = None,
        db_name: str = None,
        db_type: str = None,
        description: str = None,
        encoding: str = None,
        engine: str = None,
        env_type: str = None,
        logic: bool = None,
        owner_id_list: SearchTableResponseBodySearchTableListSearchTableOwnerIdList = None,
        owner_name_list: SearchTableResponseBodySearchTableListSearchTableOwnerNameList = None,
        table_guid: str = None,
        table_id: str = None,
        table_name: str = None,
        table_schema_name: str = None,
    ):
        self.dbsearch_name = dbsearch_name
        self.database_id = database_id
        self.db_name = db_name
        self.db_type = db_type
        self.description = description
        self.encoding = encoding
        self.engine = engine
        self.env_type = env_type
        self.logic = logic
        self.owner_id_list = owner_id_list
        self.owner_name_list = owner_name_list
        self.table_guid = table_guid
        self.table_id = table_id
        self.table_name = table_name
        self.table_schema_name = table_schema_name

    def validate(self):
        if self.owner_id_list:
            self.owner_id_list.validate()
        if self.owner_name_list:
            self.owner_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dbsearch_name is not None:
            result['DBSearchName'] = self.dbsearch_name
        if self.database_id is not None:
            result['DatabaseId'] = self.database_id
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.db_type is not None:
            result['DbType'] = self.db_type
        if self.description is not None:
            result['Description'] = self.description
        if self.encoding is not None:
            result['Encoding'] = self.encoding
        if self.engine is not None:
            result['Engine'] = self.engine
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.owner_id_list is not None:
            result['OwnerIdList'] = self.owner_id_list.to_map()
        if self.owner_name_list is not None:
            result['OwnerNameList'] = self.owner_name_list.to_map()
        if self.table_guid is not None:
            result['TableGuid'] = self.table_guid
        if self.table_id is not None:
            result['TableId'] = self.table_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        if self.table_schema_name is not None:
            result['TableSchemaName'] = self.table_schema_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DBSearchName') is not None:
            self.dbsearch_name = m.get('DBSearchName')
        if m.get('DatabaseId') is not None:
            self.database_id = m.get('DatabaseId')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('DbType') is not None:
            self.db_type = m.get('DbType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Encoding') is not None:
            self.encoding = m.get('Encoding')
        if m.get('Engine') is not None:
            self.engine = m.get('Engine')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('OwnerIdList') is not None:
            temp_model = SearchTableResponseBodySearchTableListSearchTableOwnerIdList()
            self.owner_id_list = temp_model.from_map(m['OwnerIdList'])
        if m.get('OwnerNameList') is not None:
            temp_model = SearchTableResponseBodySearchTableListSearchTableOwnerNameList()
            self.owner_name_list = temp_model.from_map(m['OwnerNameList'])
        if m.get('TableGuid') is not None:
            self.table_guid = m.get('TableGuid')
        if m.get('TableId') is not None:
            self.table_id = m.get('TableId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        if m.get('TableSchemaName') is not None:
            self.table_schema_name = m.get('TableSchemaName')
        return self


class SearchTableResponseBodySearchTableList(TeaModel):
    def __init__(
        self,
        search_table: List[SearchTableResponseBodySearchTableListSearchTable] = None,
    ):
        self.search_table = search_table

    def validate(self):
        if self.search_table:
            for k in self.search_table:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchTable'] = []
        if self.search_table is not None:
            for k in self.search_table:
                result['SearchTable'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.search_table = []
        if m.get('SearchTable') is not None:
            for k in m.get('SearchTable'):
                temp_model = SearchTableResponseBodySearchTableListSearchTable()
                self.search_table.append(temp_model.from_map(k))
        return self


class SearchTableResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        search_table_list: SearchTableResponseBodySearchTableList = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.search_table_list = search_table_list
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.search_table_list:
            self.search_table_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.search_table_list is not None:
            result['SearchTableList'] = self.search_table_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SearchTableList') is not None:
            temp_model = SearchTableResponseBodySearchTableList()
            self.search_table_list = temp_model.from_map(m['SearchTableList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetOwnersRequest(TeaModel):
    def __init__(
        self,
        owner_ids: str = None,
        owner_type: str = None,
        resource_id: str = None,
        tid: int = None,
    ):
        # The ID of the user whom you want to specify as an owner. Separate multiple IDs with commas (,). You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the ID of the user.
        # 
        # >  The value of the OwnerIds parameter is that of the UserId parameter.
        self.owner_ids = owner_ids
        # The type of the owner. Valid values:
        # 
        # *   INSTANCE: an owner of an instance.
        # *   DATABASE: an owner of a physical database.
        # *   LOGIC_DATABASE: an owner of a logical database.
        # *   TABLE: an owner of a physical table.
        # *   LOGIC_TABLE: an owner of a logical table.
        self.owner_type = owner_type
        # The ID of the resource. The ID of the resource varies with the owner type. The owner types and resource IDs have the following mappings:
        # 
        # *   INSTANCE: the ID of an instance. You can call the [ListInstances](~~141936~~) operation to query the ID of the instance.
        # *   DATABASE: the ID of a physical database. You can call the [ListDatabases](~~141873~~) operation to query the ID of the physical database.
        # *   LOGIC_DATABASE: the ID of a logical database. You can call the [ListLogicDatabases](~~141874~~) operation to query the ID of the logical database.
        # *   TABLE: the ID of a physical table. You can call the [ListTables](~~141878~~) operation to query the ID of the physical table.
        # *   LOGIC_DATABASE: the ID of a logical table. You can call the [ListLogicTables](~~141875~~) operation to query the ID of the logical table.
        self.resource_id = resource_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ids is not None:
            result['OwnerIds'] = self.owner_ids
        if self.owner_type is not None:
            result['OwnerType'] = self.owner_type
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerIds') is not None:
            self.owner_ids = m.get('OwnerIds')
        if m.get('OwnerType') is not None:
            self.owner_type = m.get('OwnerType')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SetOwnersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code.
        self.error_code = error_code
        # The error message.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   true: The request is successful.
        # *   false: The request fails.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetOwnersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetOwnersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetOwnersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopTaskFlowInstanceRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_instance_id: int = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.dag_instance_id = dag_instance_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class StopTaskFlowInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StopTaskFlowInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopTaskFlowInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitOrderApprovalRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SubmitOrderApprovalResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitOrderApprovalResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitOrderApprovalResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitOrderApprovalResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitStructSyncOrderApprovalRequest(TeaModel):
    def __init__(
        self,
        order_id: int = None,
        tid: int = None,
    ):
        self.order_id = order_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SubmitStructSyncOrderApprovalResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        workflow_instance_id: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.workflow_instance_id = workflow_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.workflow_instance_id is not None:
            result['WorkflowInstanceId'] = self.workflow_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('WorkflowInstanceId') is not None:
            self.workflow_instance_id = m.get('WorkflowInstanceId')
        return self


class SubmitStructSyncOrderApprovalResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitStructSyncOrderApprovalResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitStructSyncOrderApprovalResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SuspendTaskFlowInstanceRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_instance_id: int = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.dag_instance_id = dag_instance_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_instance_id is not None:
            result['DagInstanceId'] = self.dag_instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagInstanceId') is not None:
            self.dag_instance_id = m.get('DagInstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SuspendTaskFlowInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SuspendTaskFlowInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SuspendTaskFlowInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SuspendTaskFlowInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SyncDatabaseMetaRequest(TeaModel):
    def __init__(
        self,
        db_id: str = None,
        logic: bool = None,
        tid: int = None,
    ):
        self.db_id = db_id
        self.logic = logic
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.db_id is not None:
            result['DbId'] = self.db_id
        if self.logic is not None:
            result['Logic'] = self.logic
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DbId') is not None:
            self.db_id = m.get('DbId')
        if m.get('Logic') is not None:
            self.logic = m.get('Logic')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SyncDatabaseMetaResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SyncDatabaseMetaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SyncDatabaseMetaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SyncDatabaseMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SyncInstanceMetaRequest(TeaModel):
    def __init__(
        self,
        ignore_table: bool = None,
        instance_id: str = None,
        tid: int = None,
    ):
        self.ignore_table = ignore_table
        self.instance_id = instance_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_table is not None:
            result['IgnoreTable'] = self.ignore_table
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IgnoreTable') is not None:
            self.ignore_table = m.get('IgnoreTable')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class SyncInstanceMetaResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SyncInstanceMetaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SyncInstanceMetaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SyncInstanceMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateInstanceRequest(TeaModel):
    def __init__(
        self,
        data_link_name: str = None,
        database_password: str = None,
        database_user: str = None,
        dba_id: str = None,
        ddl_online: int = None,
        ecs_instance_id: str = None,
        ecs_region: str = None,
        enable_sell_sitd: str = None,
        env_type: str = None,
        export_timeout: int = None,
        host: str = None,
        instance_alias: str = None,
        instance_id: str = None,
        instance_source: str = None,
        instance_type: str = None,
        port: int = None,
        query_timeout: int = None,
        safe_rule_id: str = None,
        sid: str = None,
        skip_test: bool = None,
        template_id: int = None,
        template_type: str = None,
        tid: int = None,
        use_dsql: int = None,
        vpc_id: str = None,
    ):
        # The name of the data link for cross-database query.
        # 
        # > 
        # *   This parameter is required if the UseDsql parameter is set to 1.
        # *   The name can contain only lowercase letters and underscores (\_).
        # *   The name must be unique within a tenant.
        self.data_link_name = data_link_name
        # The password that is used to log on to the database.
        self.database_password = database_password
        # The account that is used to log on to the database.
        self.database_user = database_user
        # The ID of the user who assumes the DBA role of the database instance. You can call the [ListUsers](~~141938~~) or [GetInstance](~~141567~~) operation to obtain the user ID.
        self.dba_id = dba_id
        # Specifies whether to enable the lock-free schema change feature for the database instance. Valid values:
        # 
        # *   0: The feature is disabled.
        # *   1: The native online DDL feature takes precedence.
        # *   2: The lock-free schema change feature of DMS takes precedence.
        self.ddl_online = ddl_online
        # The ID of the ECS instance.
        # 
        # >  This parameter is required if the InstanceSource parameter is set to ECS_OWN.
        self.ecs_instance_id = ecs_instance_id
        # The ID of the region in which the database instance resides.
        # 
        # >  This parameter is required if the InstanceSource parameter is set to RDS, ECS_OWN, or VPC_IDC.
        self.ecs_region = ecs_region
        self.enable_sell_sitd = enable_sell_sitd
        # The type of the environment to which the database instance belongs. Valid values:
        # 
        # *   **product**: production environment
        # *   **dev**: development environment
        # *   **pre**: staging environment
        # *   **test**: test environment
        # *   **sit**: system integration testing (SIT) environment
        # *   **uat**: user acceptance testing (UAT) environment
        # *   **pet**: stress testing environment
        # *   **stag**: STAG environment
        self.env_type = env_type
        # The timeout period for exporting data from the database instance.
        self.export_timeout = export_timeout
        # The host address that is used to connect to the database instance.
        self.host = host
        # The alias of the database instance. Specify an alias that can help you identify the database instance in DMS.
        self.instance_alias = instance_alias
        # The ID of the database instance. You can call the [GetInstance](~~141567~~) operation to obtain the instance ID.
        self.instance_id = instance_id
        # The source of the database instance. Valid values:
        # 
        # *   **PUBLIC_OWN**: a self-managed database instance that is deployed on the Internet
        # *   **RDS**: an ApsaraDB RDS instance
        # *   **ECS_OWN**: a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
        # *   **VPC_IDC**: a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
        self.instance_source = instance_source
        # The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
        self.instance_type = instance_type
        # The port number that is used to connect to the database instance.
        self.port = port
        # The timeout period for querying data in the database instance.
        self.query_timeout = query_timeout
        # The ID of the security rule set for the instance. You can call the [ListStandardGroups](~~417891~~) or [GetInstance](~~141567~~) operation to obtain the name of the security rule set that you want to use.
        self.safe_rule_id = safe_rule_id
        # The system ID (SID) of the database instance.
        # 
        # >  This parameter is required if the InstanceType parameter is set to ORACLE.
        self.sid = sid
        # Specifies whether to skip connectivity test. Valid values:
        # 
        # *   **true**: The connectivity test is skipped.
        # *   **false**: The connectivity test is not skipped.
        self.skip_test = skip_test
        self.template_id = template_id
        self.template_type = template_type
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
        self.tid = tid
        # Specifies whether to enable the cross-database query feature for the database instance. Valid values:
        # 
        # *   0: The feature is disabled.
        # *   1: The feature is enabled.
        # 
        # >  Supported database types: MySQL, SQL Server, PostgreSQL, PolarDB for Oracle, and ApsaraDB for Redis.
        self.use_dsql = use_dsql
        # The ID of the VPC.
        # 
        # >  This parameter is required if the InstanceSource parameter is set to VPC_IDC.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_link_name is not None:
            result['DataLinkName'] = self.data_link_name
        if self.database_password is not None:
            result['DatabasePassword'] = self.database_password
        if self.database_user is not None:
            result['DatabaseUser'] = self.database_user
        if self.dba_id is not None:
            result['DbaId'] = self.dba_id
        if self.ddl_online is not None:
            result['DdlOnline'] = self.ddl_online
        if self.ecs_instance_id is not None:
            result['EcsInstanceId'] = self.ecs_instance_id
        if self.ecs_region is not None:
            result['EcsRegion'] = self.ecs_region
        if self.enable_sell_sitd is not None:
            result['EnableSellSitd'] = self.enable_sell_sitd
        if self.env_type is not None:
            result['EnvType'] = self.env_type
        if self.export_timeout is not None:
            result['ExportTimeout'] = self.export_timeout
        if self.host is not None:
            result['Host'] = self.host
        if self.instance_alias is not None:
            result['InstanceAlias'] = self.instance_alias
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_source is not None:
            result['InstanceSource'] = self.instance_source
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.port is not None:
            result['Port'] = self.port
        if self.query_timeout is not None:
            result['QueryTimeout'] = self.query_timeout
        if self.safe_rule_id is not None:
            result['SafeRuleId'] = self.safe_rule_id
        if self.sid is not None:
            result['Sid'] = self.sid
        if self.skip_test is not None:
            result['SkipTest'] = self.skip_test
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.use_dsql is not None:
            result['UseDsql'] = self.use_dsql
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataLinkName') is not None:
            self.data_link_name = m.get('DataLinkName')
        if m.get('DatabasePassword') is not None:
            self.database_password = m.get('DatabasePassword')
        if m.get('DatabaseUser') is not None:
            self.database_user = m.get('DatabaseUser')
        if m.get('DbaId') is not None:
            self.dba_id = m.get('DbaId')
        if m.get('DdlOnline') is not None:
            self.ddl_online = m.get('DdlOnline')
        if m.get('EcsInstanceId') is not None:
            self.ecs_instance_id = m.get('EcsInstanceId')
        if m.get('EcsRegion') is not None:
            self.ecs_region = m.get('EcsRegion')
        if m.get('EnableSellSitd') is not None:
            self.enable_sell_sitd = m.get('EnableSellSitd')
        if m.get('EnvType') is not None:
            self.env_type = m.get('EnvType')
        if m.get('ExportTimeout') is not None:
            self.export_timeout = m.get('ExportTimeout')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('InstanceAlias') is not None:
            self.instance_alias = m.get('InstanceAlias')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceSource') is not None:
            self.instance_source = m.get('InstanceSource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('QueryTimeout') is not None:
            self.query_timeout = m.get('QueryTimeout')
        if m.get('SafeRuleId') is not None:
            self.safe_rule_id = m.get('SafeRuleId')
        if m.get('Sid') is not None:
            self.sid = m.get('Sid')
        if m.get('SkipTest') is not None:
            self.skip_test = m.get('SkipTest')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('UseDsql') is not None:
            self.use_dsql = m.get('UseDsql')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class UpdateInstanceResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code that is returned.
        self.error_code = error_code
        # The error message that is returned.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSLARulesRequestSlaRuleList(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        interval_minutes: int = None,
        node_id: int = None,
        type: int = None,
    ):
        self.dag_id = dag_id
        self.interval_minutes = interval_minutes
        self.node_id = node_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.interval_minutes is not None:
            result['IntervalMinutes'] = self.interval_minutes
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('IntervalMinutes') is not None:
            self.interval_minutes = m.get('IntervalMinutes')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateSLARulesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        sla_rule_list: List[UpdateSLARulesRequestSlaRuleList] = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.sla_rule_list = sla_rule_list
        self.tid = tid

    def validate(self):
        if self.sla_rule_list:
            for k in self.sla_rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        result['SlaRuleList'] = []
        if self.sla_rule_list is not None:
            for k in self.sla_rule_list:
                result['SlaRuleList'].append(k.to_map() if k else None)
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        self.sla_rule_list = []
        if m.get('SlaRuleList') is not None:
            for k in m.get('SlaRuleList'):
                temp_model = UpdateSLARulesRequestSlaRuleList()
                self.sla_rule_list.append(temp_model.from_map(k))
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateSLARulesShrinkRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        sla_rule_list_shrink: str = None,
        tid: int = None,
    ):
        self.dag_id = dag_id
        self.sla_rule_list_shrink = sla_rule_list_shrink
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.sla_rule_list_shrink is not None:
            result['SlaRuleList'] = self.sla_rule_list_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('SlaRuleList') is not None:
            self.sla_rule_list_shrink = m.get('SlaRuleList')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateSLARulesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateSLARulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSLARulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSLARulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateScenarioRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        scenario_id: str = None,
        scenario_name: str = None,
        tid: int = None,
    ):
        self.description = description
        self.scenario_id = scenario_id
        self.scenario_name = scenario_name
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        if self.scenario_name is not None:
            result['ScenarioName'] = self.scenario_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        if m.get('ScenarioName') is not None:
            self.scenario_name = m.get('ScenarioName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateScenarioResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskConfigRequest(TeaModel):
    def __init__(
        self,
        node_config: str = None,
        node_id: str = None,
        tid: int = None,
    ):
        self.node_config = node_config
        self.node_id = node_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_config is not None:
            result['NodeConfig'] = self.node_config
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeConfig') is not None:
            self.node_config = m.get('NodeConfig')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskConfigResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskContentRequest(TeaModel):
    def __init__(
        self,
        node_content: str = None,
        node_id: str = None,
        tid: int = None,
    ):
        # The node configurations after modification.
        self.node_content = node_content
        # The ID of the task node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
        self.node_id = node_id
        # The ID of the tenant.
        # 
        # > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the ["View information about the current tenant"](~~181330~~) section of the Manage DMS tenants topic.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_content is not None:
            result['NodeContent'] = self.node_content
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeContent') is not None:
            self.node_content = m.get('NodeContent')
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskContentResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowConstantsRequestDagConstants(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key name of a constant for the task flow.
        self.key = key
        # The key value of a constant for the task flow.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateTaskFlowConstantsRequest(TeaModel):
    def __init__(
        self,
        dag_constants: List[UpdateTaskFlowConstantsRequestDagConstants] = None,
        dag_id: int = None,
        tid: int = None,
    ):
        # The constants for the task flow.
        self.dag_constants = dag_constants
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        if self.dag_constants:
            for k in self.dag_constants:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DagConstants'] = []
        if self.dag_constants is not None:
            for k in self.dag_constants:
                result['DagConstants'].append(k.to_map() if k else None)
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dag_constants = []
        if m.get('DagConstants') is not None:
            for k in m.get('DagConstants'):
                temp_model = UpdateTaskFlowConstantsRequestDagConstants()
                self.dag_constants.append(temp_model.from_map(k))
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowConstantsShrinkRequest(TeaModel):
    def __init__(
        self,
        dag_constants_shrink: str = None,
        dag_id: int = None,
        tid: int = None,
    ):
        # The constants for the task flow.
        self.dag_constants_shrink = dag_constants_shrink
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_constants_shrink is not None:
            result['DagConstants'] = self.dag_constants_shrink
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagConstants') is not None:
            self.dag_constants_shrink = m.get('DagConstants')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowConstantsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowConstantsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowConstantsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowConstantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowCooperatorsRequest(TeaModel):
    def __init__(
        self,
        cooperator_ids: List[str] = None,
        dag_id: int = None,
        tid: int = None,
    ):
        self.cooperator_ids = cooperator_ids
        self.dag_id = dag_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cooperator_ids is not None:
            result['CooperatorIds'] = self.cooperator_ids
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CooperatorIds') is not None:
            self.cooperator_ids = m.get('CooperatorIds')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowCooperatorsShrinkRequest(TeaModel):
    def __init__(
        self,
        cooperator_ids_shrink: str = None,
        dag_id: int = None,
        tid: int = None,
    ):
        self.cooperator_ids_shrink = cooperator_ids_shrink
        self.dag_id = dag_id
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cooperator_ids_shrink is not None:
            result['CooperatorIds'] = self.cooperator_ids_shrink
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CooperatorIds') is not None:
            self.cooperator_ids_shrink = m.get('CooperatorIds')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowCooperatorsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowCooperatorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowCooperatorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowCooperatorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowEdgesRequestEdges(TeaModel):
    def __init__(
        self,
        id: int = None,
        node_end: int = None,
        node_from: int = None,
    ):
        # The ID of the task flow edge.
        self.id = id
        # The ID of the end node on the edge.
        self.node_end = node_end
        # The ID of the start node on the edge.
        self.node_from = node_from

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class UpdateTaskFlowEdgesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        edges: List[UpdateTaskFlowEdgesRequestEdges] = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The list of updated task flow edges.
        self.edges = edges
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        if self.edges:
            for k in self.edges:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        result['Edges'] = []
        if self.edges is not None:
            for k in self.edges:
                result['Edges'].append(k.to_map() if k else None)
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        self.edges = []
        if m.get('Edges') is not None:
            for k in m.get('Edges'):
                temp_model = UpdateTaskFlowEdgesRequestEdges()
                self.edges.append(temp_model.from_map(k))
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowEdgesShrinkRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        edges_shrink: str = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The list of updated task flow edges.
        self.edges_shrink = edges_shrink
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.edges_shrink is not None:
            result['Edges'] = self.edges_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Edges') is not None:
            self.edges_shrink = m.get('Edges')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowEdgesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowEdgesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowEdgesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowEdgesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowNameAndDescRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_name: str = None,
        description: str = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The new name that you want to specify for the task flow.
        self.dag_name = dag_name
        # The description that you want to specify for the task flow.
        self.description = description
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_name is not None:
            result['DagName'] = self.dag_name
        if self.description is not None:
            result['Description'] = self.description
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagName') is not None:
            self.dag_name = m.get('DagName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowNameAndDescResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowNameAndDescResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowNameAndDescResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowNameAndDescResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowNotificationRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        dag_notification_fail: bool = None,
        dag_notification_sla: bool = None,
        dag_notification_success: bool = None,
        tid: int = None,
    ):
        # The unique ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # Specifies whether to enable notifications for failed task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
        self.dag_notification_fail = dag_notification_fail
        # Specifies whether to enable SLA global notifications for task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
        self.dag_notification_sla = dag_notification_sla
        # Specifies whether to enable notifications for successful task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
        self.dag_notification_success = dag_notification_success
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.dag_notification_fail is not None:
            result['DagNotificationFail'] = self.dag_notification_fail
        if self.dag_notification_sla is not None:
            result['DagNotificationSla'] = self.dag_notification_sla
        if self.dag_notification_success is not None:
            result['DagNotificationSuccess'] = self.dag_notification_success
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('DagNotificationFail') is not None:
            self.dag_notification_fail = m.get('DagNotificationFail')
        if m.get('DagNotificationSla') is not None:
            self.dag_notification_sla = m.get('DagNotificationSla')
        if m.get('DagNotificationSuccess') is not None:
            self.dag_notification_success = m.get('DagNotificationSuccess')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowNotificationResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowNotificationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowNotificationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowNotificationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowOwnerRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        new_owner_id: str = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The user ID of the new owner. You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the user ID.
        self.new_owner_id = new_owner_id
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.new_owner_id is not None:
            result['NewOwnerId'] = self.new_owner_id
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('NewOwnerId') is not None:
            self.new_owner_id = m.get('NewOwnerId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowOwnerResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowOwnerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowOwnerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowOwnerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowRelationsRequestEdges(TeaModel):
    def __init__(
        self,
        id: int = None,
        node_end: int = None,
        node_from: int = None,
    ):
        # The ID of the task flow edge.
        self.id = id
        # The ID of the end node on the edge.
        self.node_end = node_end
        # The ID of the start node on the edge.
        self.node_from = node_from

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.node_end is not None:
            result['NodeEnd'] = self.node_end
        if self.node_from is not None:
            result['NodeFrom'] = self.node_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NodeEnd') is not None:
            self.node_end = m.get('NodeEnd')
        if m.get('NodeFrom') is not None:
            self.node_from = m.get('NodeFrom')
        return self


class UpdateTaskFlowRelationsRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        edges: List[UpdateTaskFlowRelationsRequestEdges] = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The list of task flow edges to be updated.
        self.edges = edges
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        if self.edges:
            for k in self.edges:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        result['Edges'] = []
        if self.edges is not None:
            for k in self.edges:
                result['Edges'].append(k.to_map() if k else None)
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        self.edges = []
        if m.get('Edges') is not None:
            for k in m.get('Edges'):
                temp_model = UpdateTaskFlowRelationsRequestEdges()
                self.edges.append(temp_model.from_map(k))
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowRelationsShrinkRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        edges_shrink: str = None,
        tid: int = None,
    ):
        # The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
        self.dag_id = dag_id
        # The list of task flow edges to be updated.
        self.edges_shrink = edges_shrink
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.edges_shrink is not None:
            result['Edges'] = self.edges_shrink
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Edges') is not None:
            self.edges_shrink = m.get('Edges')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskFlowRelationsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowRelationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowRelationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowRelationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowScheduleRequest(TeaModel):
    def __init__(
        self,
        cron_begin_date: str = None,
        cron_end_date: str = None,
        cron_str: str = None,
        cron_type: str = None,
        dag_id: int = None,
        schedule_param: str = None,
        schedule_switch: bool = None,
        tid: int = None,
        time_zone_id: str = None,
        trigger_type: str = None,
    ):
        self.cron_begin_date = cron_begin_date
        self.cron_end_date = cron_end_date
        self.cron_str = cron_str
        self.cron_type = cron_type
        self.dag_id = dag_id
        self.schedule_param = schedule_param
        self.schedule_switch = schedule_switch
        self.tid = tid
        self.time_zone_id = time_zone_id
        self.trigger_type = trigger_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron_begin_date is not None:
            result['CronBeginDate'] = self.cron_begin_date
        if self.cron_end_date is not None:
            result['CronEndDate'] = self.cron_end_date
        if self.cron_str is not None:
            result['CronStr'] = self.cron_str
        if self.cron_type is not None:
            result['CronType'] = self.cron_type
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.schedule_param is not None:
            result['ScheduleParam'] = self.schedule_param
        if self.schedule_switch is not None:
            result['ScheduleSwitch'] = self.schedule_switch
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.time_zone_id is not None:
            result['TimeZoneId'] = self.time_zone_id
        if self.trigger_type is not None:
            result['TriggerType'] = self.trigger_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CronBeginDate') is not None:
            self.cron_begin_date = m.get('CronBeginDate')
        if m.get('CronEndDate') is not None:
            self.cron_end_date = m.get('CronEndDate')
        if m.get('CronStr') is not None:
            self.cron_str = m.get('CronStr')
        if m.get('CronType') is not None:
            self.cron_type = m.get('CronType')
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('ScheduleParam') is not None:
            self.schedule_param = m.get('ScheduleParam')
        if m.get('ScheduleSwitch') is not None:
            self.schedule_switch = m.get('ScheduleSwitch')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TimeZoneId') is not None:
            self.time_zone_id = m.get('TimeZoneId')
        if m.get('TriggerType') is not None:
            self.trigger_type = m.get('TriggerType')
        return self


class UpdateTaskFlowScheduleResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskFlowTimeVariablesRequest(TeaModel):
    def __init__(
        self,
        dag_id: int = None,
        tid: int = None,
        time_variables: str = None,
    ):
        self.dag_id = dag_id
        self.tid = tid
        self.time_variables = time_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dag_id is not None:
            result['DagId'] = self.dag_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DagId') is not None:
            self.dag_id = m.get('DagId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class UpdateTaskFlowTimeVariablesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskFlowTimeVariablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskFlowTimeVariablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskFlowTimeVariablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskNameRequest(TeaModel):
    def __init__(
        self,
        node_id: str = None,
        node_name: str = None,
        tid: int = None,
    ):
        # The ID of the node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
        self.node_id = node_id
        # The name of the node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node name.
        self.node_name = node_name
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_name is not None:
            result['NodeName'] = self.node_name
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeName') is not None:
            self.node_name = m.get('NodeName')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskNameResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskOutputRequest(TeaModel):
    def __init__(
        self,
        node_id: str = None,
        node_output: str = None,
        tid: int = None,
    ):
        # The ID of the node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
        self.node_id = node_id
        # The output variables for the task.
        self.node_output = node_output
        # The ID of the tenant.
        # 
        # >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
        self.tid = tid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.node_output is not None:
            result['NodeOutput'] = self.node_output
        if self.tid is not None:
            result['Tid'] = self.tid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('NodeOutput') is not None:
            self.node_output = m.get('NodeOutput')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        return self


class UpdateTaskOutputResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request failed.
        self.error_code = error_code
        # The error message returned if the request failed.
        self.error_message = error_message
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskOutputResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskOutputResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskOutputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTaskTimeVariablesRequest(TeaModel):
    def __init__(
        self,
        node_id: str = None,
        tid: int = None,
        time_variables: str = None,
    ):
        self.node_id = node_id
        self.tid = tid
        self.time_variables = time_variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_id is not None:
            result['NodeId'] = self.node_id
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.time_variables is not None:
            result['TimeVariables'] = self.time_variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NodeId') is not None:
            self.node_id = m.get('NodeId')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('TimeVariables') is not None:
            self.time_variables = m.get('TimeVariables')
        return self


class UpdateTaskTimeVariablesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTaskTimeVariablesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTaskTimeVariablesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTaskTimeVariablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateUserRequest(TeaModel):
    def __init__(
        self,
        max_execute_count: int = None,
        max_result_count: int = None,
        mobile: str = None,
        role_names: str = None,
        tid: int = None,
        uid: int = None,
        user_nick: str = None,
    ):
        self.max_execute_count = max_execute_count
        self.max_result_count = max_result_count
        self.mobile = mobile
        self.role_names = role_names
        self.tid = tid
        self.uid = uid
        self.user_nick = user_nick

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_execute_count is not None:
            result['MaxExecuteCount'] = self.max_execute_count
        if self.max_result_count is not None:
            result['MaxResultCount'] = self.max_result_count
        if self.mobile is not None:
            result['Mobile'] = self.mobile
        if self.role_names is not None:
            result['RoleNames'] = self.role_names
        if self.tid is not None:
            result['Tid'] = self.tid
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.user_nick is not None:
            result['UserNick'] = self.user_nick
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxExecuteCount') is not None:
            self.max_execute_count = m.get('MaxExecuteCount')
        if m.get('MaxResultCount') is not None:
            self.max_result_count = m.get('MaxResultCount')
        if m.get('Mobile') is not None:
            self.mobile = m.get('Mobile')
        if m.get('RoleNames') is not None:
            self.role_names = m.get('RoleNames')
        if m.get('Tid') is not None:
            self.tid = m.get('Tid')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('UserNick') is not None:
            self.user_nick = m.get('UserNick')
        return self


class UpdateUserResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


