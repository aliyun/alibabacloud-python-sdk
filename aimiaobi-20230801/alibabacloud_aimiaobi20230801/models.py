# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict, Any


class WritingStyleTemplateDefineExample(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class WritingStyleTemplateFieldEnums(TeaModel):
    def __init__(
        self,
        cascading_fields: List[str] = None,
        key: str = None,
        name: str = None,
    ):
        self.cascading_fields = cascading_fields
        self.key = key
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cascading_fields is not None:
            result['CascadingFields'] = self.cascading_fields
        if self.key is not None:
            result['Key'] = self.key
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CascadingFields') is not None:
            self.cascading_fields = m.get('CascadingFields')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class WritingStyleTemplateFieldStyle(TeaModel):
    def __init__(
        self,
        description: str = None,
        format: str = None,
        placeholder: str = None,
        show_time: bool = None,
        suffix: str = None,
        type: str = None,
    ):
        self.description = description
        self.format = format
        self.placeholder = placeholder
        self.show_time = show_time
        self.suffix = suffix
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.format is not None:
            result['Format'] = self.format
        if self.placeholder is not None:
            result['Placeholder'] = self.placeholder
        if self.show_time is not None:
            result['ShowTime'] = self.show_time
        if self.suffix is not None:
            result['Suffix'] = self.suffix
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Placeholder') is not None:
            self.placeholder = m.get('Placeholder')
        if m.get('ShowTime') is not None:
            self.show_time = m.get('ShowTime')
        if m.get('Suffix') is not None:
            self.suffix = m.get('Suffix')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class WritingStyleTemplateField(TeaModel):
    def __init__(
        self,
        build_in: bool = None,
        cascading_fields: List['WritingStyleTemplateField'] = None,
        enums: List[WritingStyleTemplateFieldEnums] = None,
        initial_value: str = None,
        key: str = None,
        max: float = None,
        max_item: int = None,
        max_item_length: int = None,
        max_length: int = None,
        min: float = None,
        min_item_length: int = None,
        min_length: int = None,
        name: str = None,
        required: bool = None,
        style: WritingStyleTemplateFieldStyle = None,
    ):
        self.build_in = build_in
        self.cascading_fields = cascading_fields
        self.enums = enums
        self.initial_value = initial_value
        self.key = key
        self.max = max
        self.max_item = max_item
        self.max_item_length = max_item_length
        self.max_length = max_length
        self.min = min
        self.min_item_length = min_item_length
        self.min_length = min_length
        self.name = name
        self.required = required
        self.style = style

    def validate(self):
        if self.cascading_fields:
            for k in self.cascading_fields:
                if k:
                    k.validate()
        if self.enums:
            for k in self.enums:
                if k:
                    k.validate()
        if self.style:
            self.style.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.build_in is not None:
            result['BuildIn'] = self.build_in
        result['CascadingFields'] = []
        if self.cascading_fields is not None:
            for k in self.cascading_fields:
                result['CascadingFields'].append(k.to_map() if k else None)
        result['Enums'] = []
        if self.enums is not None:
            for k in self.enums:
                result['Enums'].append(k.to_map() if k else None)
        if self.initial_value is not None:
            result['InitialValue'] = self.initial_value
        if self.key is not None:
            result['Key'] = self.key
        if self.max is not None:
            result['Max'] = self.max
        if self.max_item is not None:
            result['MaxItem'] = self.max_item
        if self.max_item_length is not None:
            result['MaxItemLength'] = self.max_item_length
        if self.max_length is not None:
            result['MaxLength'] = self.max_length
        if self.min is not None:
            result['Min'] = self.min
        if self.min_item_length is not None:
            result['MinItemLength'] = self.min_item_length
        if self.min_length is not None:
            result['MinLength'] = self.min_length
        if self.name is not None:
            result['Name'] = self.name
        if self.required is not None:
            result['Required'] = self.required
        if self.style is not None:
            result['Style'] = self.style.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BuildIn') is not None:
            self.build_in = m.get('BuildIn')
        self.cascading_fields = []
        if m.get('CascadingFields') is not None:
            for k in m.get('CascadingFields'):
                temp_model = WritingStyleTemplateField()
                self.cascading_fields.append(temp_model.from_map(k))
        self.enums = []
        if m.get('Enums') is not None:
            for k in m.get('Enums'):
                temp_model = WritingStyleTemplateFieldEnums()
                self.enums.append(temp_model.from_map(k))
        if m.get('InitialValue') is not None:
            self.initial_value = m.get('InitialValue')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('MaxItem') is not None:
            self.max_item = m.get('MaxItem')
        if m.get('MaxItemLength') is not None:
            self.max_item_length = m.get('MaxItemLength')
        if m.get('MaxLength') is not None:
            self.max_length = m.get('MaxLength')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        if m.get('MinItemLength') is not None:
            self.min_item_length = m.get('MinItemLength')
        if m.get('MinLength') is not None:
            self.min_length = m.get('MinLength')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        if m.get('Style') is not None:
            temp_model = WritingStyleTemplateFieldStyle()
            self.style = temp_model.from_map(m['Style'])
        return self


class WritingStyleTemplateDefine(TeaModel):
    def __init__(
        self,
        example: List[WritingStyleTemplateDefineExample] = None,
        fields: List[WritingStyleTemplateField] = None,
    ):
        self.example = example
        self.fields = fields

    def validate(self):
        if self.example:
            for k in self.example:
                if k:
                    k.validate()
        if self.fields:
            for k in self.fields:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Example'] = []
        if self.example is not None:
            for k in self.example:
                result['Example'].append(k.to_map() if k else None)
        result['Fields'] = []
        if self.fields is not None:
            for k in self.fields:
                result['Fields'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.example = []
        if m.get('Example') is not None:
            for k in m.get('Example'):
                temp_model = WritingStyleTemplateDefineExample()
                self.example.append(temp_model.from_map(k))
        self.fields = []
        if m.get('Fields') is not None:
            for k in m.get('Fields'):
                temp_model = WritingStyleTemplateField()
                self.fields.append(temp_model.from_map(k))
        return self


class AddAuditTermsRequest(TeaModel):
    def __init__(
        self,
        exception_word: List[str] = None,
        keyword: str = None,
        suggest_word: str = None,
        terms_desc: str = None,
        workspace_id: str = None,
    ):
        self.exception_word = exception_word
        self.keyword = keyword
        self.suggest_word = suggest_word
        self.terms_desc = terms_desc
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exception_word is not None:
            result['ExceptionWord'] = self.exception_word
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.suggest_word is not None:
            result['SuggestWord'] = self.suggest_word
        if self.terms_desc is not None:
            result['TermsDesc'] = self.terms_desc
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExceptionWord') is not None:
            self.exception_word = m.get('ExceptionWord')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('SuggestWord') is not None:
            self.suggest_word = m.get('SuggestWord')
        if m.get('TermsDesc') is not None:
            self.terms_desc = m.get('TermsDesc')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AddAuditTermsShrinkRequest(TeaModel):
    def __init__(
        self,
        exception_word_shrink: str = None,
        keyword: str = None,
        suggest_word: str = None,
        terms_desc: str = None,
        workspace_id: str = None,
    ):
        self.exception_word_shrink = exception_word_shrink
        self.keyword = keyword
        self.suggest_word = suggest_word
        self.terms_desc = terms_desc
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exception_word_shrink is not None:
            result['ExceptionWord'] = self.exception_word_shrink
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.suggest_word is not None:
            result['SuggestWord'] = self.suggest_word
        if self.terms_desc is not None:
            result['TermsDesc'] = self.terms_desc
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExceptionWord') is not None:
            self.exception_word_shrink = m.get('ExceptionWord')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('SuggestWord') is not None:
            self.suggest_word = m.get('SuggestWord')
        if m.get('TermsDesc') is not None:
            self.terms_desc = m.get('TermsDesc')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AddAuditTermsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddAuditTermsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddAuditTermsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddAuditTermsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDatasetDocumentRequestDocumentMultimodalMedias(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        media_id: str = None,
        media_type: str = None,
    ):
        self.file_url = file_url
        self.media_id = media_id
        self.media_type = media_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class AddDatasetDocumentRequestDocument(TeaModel):
    def __init__(
        self,
        content: str = None,
        disable_handle_multimodal_media: bool = None,
        doc_id: str = None,
        doc_type: str = None,
        doc_uuid: str = None,
        extend_1: str = None,
        extend_2: str = None,
        extend_3: str = None,
        multimodal_index_name: str = None,
        multimodal_medias: List[AddDatasetDocumentRequestDocumentMultimodalMedias] = None,
        pub_time: str = None,
        source_from: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.content = content
        self.disable_handle_multimodal_media = disable_handle_multimodal_media
        self.doc_id = doc_id
        self.doc_type = doc_type
        self.doc_uuid = doc_uuid
        self.extend_1 = extend_1
        self.extend_2 = extend_2
        self.extend_3 = extend_3
        self.multimodal_index_name = multimodal_index_name
        self.multimodal_medias = multimodal_medias
        self.pub_time = pub_time
        self.source_from = source_from
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        if self.multimodal_medias:
            for k in self.multimodal_medias:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.disable_handle_multimodal_media is not None:
            result['DisableHandleMultimodalMedia'] = self.disable_handle_multimodal_media
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.extend_1 is not None:
            result['Extend1'] = self.extend_1
        if self.extend_2 is not None:
            result['Extend2'] = self.extend_2
        if self.extend_3 is not None:
            result['Extend3'] = self.extend_3
        if self.multimodal_index_name is not None:
            result['MultimodalIndexName'] = self.multimodal_index_name
        result['MultimodalMedias'] = []
        if self.multimodal_medias is not None:
            for k in self.multimodal_medias:
                result['MultimodalMedias'].append(k.to_map() if k else None)
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source_from is not None:
            result['SourceFrom'] = self.source_from
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DisableHandleMultimodalMedia') is not None:
            self.disable_handle_multimodal_media = m.get('DisableHandleMultimodalMedia')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('Extend1') is not None:
            self.extend_1 = m.get('Extend1')
        if m.get('Extend2') is not None:
            self.extend_2 = m.get('Extend2')
        if m.get('Extend3') is not None:
            self.extend_3 = m.get('Extend3')
        if m.get('MultimodalIndexName') is not None:
            self.multimodal_index_name = m.get('MultimodalIndexName')
        self.multimodal_medias = []
        if m.get('MultimodalMedias') is not None:
            for k in m.get('MultimodalMedias'):
                temp_model = AddDatasetDocumentRequestDocumentMultimodalMedias()
                self.multimodal_medias.append(temp_model.from_map(k))
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('SourceFrom') is not None:
            self.source_from = m.get('SourceFrom')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class AddDatasetDocumentRequest(TeaModel):
    def __init__(
        self,
        dataset_id: int = None,
        dataset_name: str = None,
        document: AddDatasetDocumentRequestDocument = None,
        workspace_id: str = None,
    ):
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        # This parameter is required.
        self.document = document
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.document:
            self.document.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.document is not None:
            result['Document'] = self.document.to_map()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('Document') is not None:
            temp_model = AddDatasetDocumentRequestDocument()
            self.document = temp_model.from_map(m['Document'])
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AddDatasetDocumentShrinkRequest(TeaModel):
    def __init__(
        self,
        dataset_id: int = None,
        dataset_name: str = None,
        document_shrink: str = None,
        workspace_id: str = None,
    ):
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        # This parameter is required.
        self.document_shrink = document_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.document_shrink is not None:
            result['Document'] = self.document_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('Document') is not None:
            self.document_shrink = m.get('Document')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AddDatasetDocumentResponseBodyData(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        error_code: str = None,
        error_message: str = None,
        status: int = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.error_code = error_code
        self.error_message = error_message
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class AddDatasetDocumentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: AddDatasetDocumentResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AddDatasetDocumentResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddDatasetDocumentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDatasetDocumentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDatasetDocumentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AsyncCreateClipsTaskRequestColorWords(TeaModel):
    def __init__(
        self,
        content: str = None,
        effect_color_style: str = None,
        font_size: int = None,
        timeline_in: int = None,
        timeline_out: int = None,
        x: float = None,
        y: float = None,
    ):
        self.content = content
        self.effect_color_style = effect_color_style
        self.font_size = font_size
        self.timeline_in = timeline_in
        self.timeline_out = timeline_out
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.effect_color_style is not None:
            result['EffectColorStyle'] = self.effect_color_style
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.timeline_in is not None:
            result['TimelineIn'] = self.timeline_in
        if self.timeline_out is not None:
            result['TimelineOut'] = self.timeline_out
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EffectColorStyle') is not None:
            self.effect_color_style = m.get('EffectColorStyle')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('TimelineIn') is not None:
            self.timeline_in = m.get('TimelineIn')
        if m.get('TimelineOut') is not None:
            self.timeline_out = m.get('TimelineOut')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class AsyncCreateClipsTaskRequest(TeaModel):
    def __init__(
        self,
        color_words: List[AsyncCreateClipsTaskRequestColorWords] = None,
        height: int = None,
        music_url: str = None,
        music_volume: int = None,
        subtitle_font_size: int = None,
        task_id: str = None,
        voice_style: str = None,
        voice_volume: int = None,
        width: int = None,
        workspace_id: str = None,
    ):
        self.color_words = color_words
        self.height = height
        self.music_url = music_url
        self.music_volume = music_volume
        self.subtitle_font_size = subtitle_font_size
        # This parameter is required.
        self.task_id = task_id
        self.voice_style = voice_style
        self.voice_volume = voice_volume
        self.width = width
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.color_words:
            for k in self.color_words:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ColorWords'] = []
        if self.color_words is not None:
            for k in self.color_words:
                result['ColorWords'].append(k.to_map() if k else None)
        if self.height is not None:
            result['Height'] = self.height
        if self.music_url is not None:
            result['MusicUrl'] = self.music_url
        if self.music_volume is not None:
            result['MusicVolume'] = self.music_volume
        if self.subtitle_font_size is not None:
            result['SubtitleFontSize'] = self.subtitle_font_size
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.voice_style is not None:
            result['VoiceStyle'] = self.voice_style
        if self.voice_volume is not None:
            result['VoiceVolume'] = self.voice_volume
        if self.width is not None:
            result['Width'] = self.width
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.color_words = []
        if m.get('ColorWords') is not None:
            for k in m.get('ColorWords'):
                temp_model = AsyncCreateClipsTaskRequestColorWords()
                self.color_words.append(temp_model.from_map(k))
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MusicUrl') is not None:
            self.music_url = m.get('MusicUrl')
        if m.get('MusicVolume') is not None:
            self.music_volume = m.get('MusicVolume')
        if m.get('SubtitleFontSize') is not None:
            self.subtitle_font_size = m.get('SubtitleFontSize')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('VoiceStyle') is not None:
            self.voice_style = m.get('VoiceStyle')
        if m.get('VoiceVolume') is not None:
            self.voice_volume = m.get('VoiceVolume')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AsyncCreateClipsTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        color_words_shrink: str = None,
        height: int = None,
        music_url: str = None,
        music_volume: int = None,
        subtitle_font_size: int = None,
        task_id: str = None,
        voice_style: str = None,
        voice_volume: int = None,
        width: int = None,
        workspace_id: str = None,
    ):
        self.color_words_shrink = color_words_shrink
        self.height = height
        self.music_url = music_url
        self.music_volume = music_volume
        self.subtitle_font_size = subtitle_font_size
        # This parameter is required.
        self.task_id = task_id
        self.voice_style = voice_style
        self.voice_volume = voice_volume
        self.width = width
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.color_words_shrink is not None:
            result['ColorWords'] = self.color_words_shrink
        if self.height is not None:
            result['Height'] = self.height
        if self.music_url is not None:
            result['MusicUrl'] = self.music_url
        if self.music_volume is not None:
            result['MusicVolume'] = self.music_volume
        if self.subtitle_font_size is not None:
            result['SubtitleFontSize'] = self.subtitle_font_size
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.voice_style is not None:
            result['VoiceStyle'] = self.voice_style
        if self.voice_volume is not None:
            result['VoiceVolume'] = self.voice_volume
        if self.width is not None:
            result['Width'] = self.width
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ColorWords') is not None:
            self.color_words_shrink = m.get('ColorWords')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MusicUrl') is not None:
            self.music_url = m.get('MusicUrl')
        if m.get('MusicVolume') is not None:
            self.music_volume = m.get('MusicVolume')
        if m.get('SubtitleFontSize') is not None:
            self.subtitle_font_size = m.get('SubtitleFontSize')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('VoiceStyle') is not None:
            self.voice_style = m.get('VoiceStyle')
        if m.get('VoiceVolume') is not None:
            self.voice_volume = m.get('VoiceVolume')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AsyncCreateClipsTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class AsyncCreateClipsTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: AsyncCreateClipsTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AsyncCreateClipsTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AsyncCreateClipsTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AsyncCreateClipsTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AsyncCreateClipsTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AsyncCreateClipsTimeLineRequest(TeaModel):
    def __init__(
        self,
        additional_content: str = None,
        custom_content: str = None,
        no_ref_video: bool = None,
        process_prompt: str = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.additional_content = additional_content
        self.custom_content = custom_content
        self.no_ref_video = no_ref_video
        self.process_prompt = process_prompt
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.additional_content is not None:
            result['AdditionalContent'] = self.additional_content
        if self.custom_content is not None:
            result['CustomContent'] = self.custom_content
        if self.no_ref_video is not None:
            result['NoRefVideo'] = self.no_ref_video
        if self.process_prompt is not None:
            result['ProcessPrompt'] = self.process_prompt
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdditionalContent') is not None:
            self.additional_content = m.get('AdditionalContent')
        if m.get('CustomContent') is not None:
            self.custom_content = m.get('CustomContent')
        if m.get('NoRefVideo') is not None:
            self.no_ref_video = m.get('NoRefVideo')
        if m.get('ProcessPrompt') is not None:
            self.process_prompt = m.get('ProcessPrompt')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AsyncCreateClipsTimeLineResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class AsyncCreateClipsTimeLineResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: AsyncCreateClipsTimeLineResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AsyncCreateClipsTimeLineResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AsyncCreateClipsTimeLineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AsyncCreateClipsTimeLineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AsyncCreateClipsTimeLineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AsyncEditTimelineRequestTimelinesClips(TeaModel):
    def __init__(
        self,
        clip_id: str = None,
        content_inner: str = None,
        in_: int = None,
        in_ex: float = None,
        out: int = None,
        out_ex: float = None,
        video_id: str = None,
        video_name: str = None,
    ):
        self.clip_id = clip_id
        self.content_inner = content_inner
        self.in_ = in_
        self.in_ex = in_ex
        self.out = out
        self.out_ex = out_ex
        self.video_id = video_id
        self.video_name = video_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clip_id is not None:
            result['ClipId'] = self.clip_id
        if self.content_inner is not None:
            result['ContentInner'] = self.content_inner
        if self.in_ is not None:
            result['In'] = self.in_
        if self.in_ex is not None:
            result['InEx'] = self.in_ex
        if self.out is not None:
            result['Out'] = self.out
        if self.out_ex is not None:
            result['OutEx'] = self.out_ex
        if self.video_id is not None:
            result['VideoId'] = self.video_id
        if self.video_name is not None:
            result['VideoName'] = self.video_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipId') is not None:
            self.clip_id = m.get('ClipId')
        if m.get('ContentInner') is not None:
            self.content_inner = m.get('ContentInner')
        if m.get('In') is not None:
            self.in_ = m.get('In')
        if m.get('InEx') is not None:
            self.in_ex = m.get('InEx')
        if m.get('Out') is not None:
            self.out = m.get('Out')
        if m.get('OutEx') is not None:
            self.out_ex = m.get('OutEx')
        if m.get('VideoId') is not None:
            self.video_id = m.get('VideoId')
        if m.get('VideoName') is not None:
            self.video_name = m.get('VideoName')
        return self


class AsyncEditTimelineRequestTimelines(TeaModel):
    def __init__(
        self,
        clips: List[AsyncEditTimelineRequestTimelinesClips] = None,
        timeline_id: str = None,
    ):
        # This parameter is required.
        self.clips = clips
        self.timeline_id = timeline_id

    def validate(self):
        if self.clips:
            for k in self.clips:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Clips'] = []
        if self.clips is not None:
            for k in self.clips:
                result['Clips'].append(k.to_map() if k else None)
        if self.timeline_id is not None:
            result['TimelineId'] = self.timeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clips = []
        if m.get('Clips') is not None:
            for k in m.get('Clips'):
                temp_model = AsyncEditTimelineRequestTimelinesClips()
                self.clips.append(temp_model.from_map(k))
        if m.get('TimelineId') is not None:
            self.timeline_id = m.get('TimelineId')
        return self


class AsyncEditTimelineRequest(TeaModel):
    def __init__(
        self,
        auto_clips: bool = None,
        task_id: str = None,
        timelines: List[AsyncEditTimelineRequestTimelines] = None,
        workspace_id: str = None,
    ):
        self.auto_clips = auto_clips
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.timelines = timelines
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.timelines:
            for k in self.timelines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_clips is not None:
            result['AutoClips'] = self.auto_clips
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        result['Timelines'] = []
        if self.timelines is not None:
            for k in self.timelines:
                result['Timelines'].append(k.to_map() if k else None)
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoClips') is not None:
            self.auto_clips = m.get('AutoClips')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        self.timelines = []
        if m.get('Timelines') is not None:
            for k in m.get('Timelines'):
                temp_model = AsyncEditTimelineRequestTimelines()
                self.timelines.append(temp_model.from_map(k))
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AsyncEditTimelineShrinkRequest(TeaModel):
    def __init__(
        self,
        auto_clips: bool = None,
        task_id: str = None,
        timelines_shrink: str = None,
        workspace_id: str = None,
    ):
        self.auto_clips = auto_clips
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.timelines_shrink = timelines_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_clips is not None:
            result['AutoClips'] = self.auto_clips
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.timelines_shrink is not None:
            result['Timelines'] = self.timelines_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoClips') is not None:
            self.auto_clips = m.get('AutoClips')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Timelines') is not None:
            self.timelines_shrink = m.get('Timelines')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AsyncEditTimelineResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        task_id: str = None,
    ):
        self.message = message
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class AsyncEditTimelineResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: AsyncEditTimelineResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AsyncEditTimelineResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AsyncEditTimelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AsyncEditTimelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AsyncEditTimelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AsyncUploadVideoRequestReferenceVideo(TeaModel):
    def __init__(
        self,
        video_extra_info: str = None,
        video_name: str = None,
        video_url: str = None,
    ):
        self.video_extra_info = video_extra_info
        self.video_name = video_name
        self.video_url = video_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.video_extra_info is not None:
            result['VideoExtraInfo'] = self.video_extra_info
        if self.video_name is not None:
            result['VideoName'] = self.video_name
        if self.video_url is not None:
            result['VideoUrl'] = self.video_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VideoExtraInfo') is not None:
            self.video_extra_info = m.get('VideoExtraInfo')
        if m.get('VideoName') is not None:
            self.video_name = m.get('VideoName')
        if m.get('VideoUrl') is not None:
            self.video_url = m.get('VideoUrl')
        return self


class AsyncUploadVideoRequestSourceVideos(TeaModel):
    def __init__(
        self,
        video_extra_info: str = None,
        video_name: str = None,
        video_url: str = None,
    ):
        self.video_extra_info = video_extra_info
        # This parameter is required.
        self.video_name = video_name
        # This parameter is required.
        self.video_url = video_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.video_extra_info is not None:
            result['VideoExtraInfo'] = self.video_extra_info
        if self.video_name is not None:
            result['VideoName'] = self.video_name
        if self.video_url is not None:
            result['VideoUrl'] = self.video_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VideoExtraInfo') is not None:
            self.video_extra_info = m.get('VideoExtraInfo')
        if m.get('VideoName') is not None:
            self.video_name = m.get('VideoName')
        if m.get('VideoUrl') is not None:
            self.video_url = m.get('VideoUrl')
        return self


class AsyncUploadVideoRequest(TeaModel):
    def __init__(
        self,
        anlysis_prompt: str = None,
        reference_video: AsyncUploadVideoRequestReferenceVideo = None,
        source_videos: List[AsyncUploadVideoRequestSourceVideos] = None,
        split_interval: int = None,
        workspace_id: str = None,
    ):
        self.anlysis_prompt = anlysis_prompt
        self.reference_video = reference_video
        # This parameter is required.
        self.source_videos = source_videos
        self.split_interval = split_interval
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.reference_video:
            self.reference_video.validate()
        if self.source_videos:
            for k in self.source_videos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.anlysis_prompt is not None:
            result['AnlysisPrompt'] = self.anlysis_prompt
        if self.reference_video is not None:
            result['ReferenceVideo'] = self.reference_video.to_map()
        result['SourceVideos'] = []
        if self.source_videos is not None:
            for k in self.source_videos:
                result['SourceVideos'].append(k.to_map() if k else None)
        if self.split_interval is not None:
            result['SplitInterval'] = self.split_interval
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnlysisPrompt') is not None:
            self.anlysis_prompt = m.get('AnlysisPrompt')
        if m.get('ReferenceVideo') is not None:
            temp_model = AsyncUploadVideoRequestReferenceVideo()
            self.reference_video = temp_model.from_map(m['ReferenceVideo'])
        self.source_videos = []
        if m.get('SourceVideos') is not None:
            for k in m.get('SourceVideos'):
                temp_model = AsyncUploadVideoRequestSourceVideos()
                self.source_videos.append(temp_model.from_map(k))
        if m.get('SplitInterval') is not None:
            self.split_interval = m.get('SplitInterval')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AsyncUploadVideoShrinkRequest(TeaModel):
    def __init__(
        self,
        anlysis_prompt: str = None,
        reference_video_shrink: str = None,
        source_videos_shrink: str = None,
        split_interval: int = None,
        workspace_id: str = None,
    ):
        self.anlysis_prompt = anlysis_prompt
        self.reference_video_shrink = reference_video_shrink
        # This parameter is required.
        self.source_videos_shrink = source_videos_shrink
        self.split_interval = split_interval
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.anlysis_prompt is not None:
            result['AnlysisPrompt'] = self.anlysis_prompt
        if self.reference_video_shrink is not None:
            result['ReferenceVideo'] = self.reference_video_shrink
        if self.source_videos_shrink is not None:
            result['SourceVideos'] = self.source_videos_shrink
        if self.split_interval is not None:
            result['SplitInterval'] = self.split_interval
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnlysisPrompt') is not None:
            self.anlysis_prompt = m.get('AnlysisPrompt')
        if m.get('ReferenceVideo') is not None:
            self.reference_video_shrink = m.get('ReferenceVideo')
        if m.get('SourceVideos') is not None:
            self.source_videos_shrink = m.get('SourceVideos')
        if m.get('SplitInterval') is not None:
            self.split_interval = m.get('SplitInterval')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class AsyncUploadVideoResponseBodyDataVideoInfos(TeaModel):
    def __init__(
        self,
        video_extra_info: str = None,
        video_id: str = None,
        video_name: str = None,
        video_url: str = None,
    ):
        self.video_extra_info = video_extra_info
        self.video_id = video_id
        self.video_name = video_name
        self.video_url = video_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.video_extra_info is not None:
            result['VideoExtraInfo'] = self.video_extra_info
        if self.video_id is not None:
            result['VideoId'] = self.video_id
        if self.video_name is not None:
            result['VideoName'] = self.video_name
        if self.video_url is not None:
            result['VideoUrl'] = self.video_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('VideoExtraInfo') is not None:
            self.video_extra_info = m.get('VideoExtraInfo')
        if m.get('VideoId') is not None:
            self.video_id = m.get('VideoId')
        if m.get('VideoName') is not None:
            self.video_name = m.get('VideoName')
        if m.get('VideoUrl') is not None:
            self.video_url = m.get('VideoUrl')
        return self


class AsyncUploadVideoResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        video_infos: List[AsyncUploadVideoResponseBodyDataVideoInfos] = None,
    ):
        self.task_id = task_id
        self.video_infos = video_infos

    def validate(self):
        if self.video_infos:
            for k in self.video_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        result['VideoInfos'] = []
        if self.video_infos is not None:
            for k in self.video_infos:
                result['VideoInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        self.video_infos = []
        if m.get('VideoInfos') is not None:
            for k in m.get('VideoInfos'):
                temp_model = AsyncUploadVideoResponseBodyDataVideoInfos()
                self.video_infos.append(temp_model.from_map(k))
        return self


class AsyncUploadVideoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: AsyncUploadVideoResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AsyncUploadVideoResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AsyncUploadVideoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AsyncUploadVideoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AsyncUploadVideoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelAsyncTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CancelAsyncTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CancelAsyncTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelAsyncTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelAsyncTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelAuditTaskRequest(TeaModel):
    def __init__(
        self,
        article_id: str = None,
        content_audit_task_id: str = None,
        workspace_id: str = None,
    ):
        self.article_id = article_id
        self.content_audit_task_id = content_audit_task_id
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article_id is not None:
            result['ArticleId'] = self.article_id
        if self.content_audit_task_id is not None:
            result['ContentAuditTaskId'] = self.content_audit_task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArticleId') is not None:
            self.article_id = m.get('ArticleId')
        if m.get('ContentAuditTaskId') is not None:
            self.content_audit_task_id = m.get('ContentAuditTaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CancelAuditTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CancelAuditTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelAuditTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelAuditTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ClearIntervenesRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        return self


class ClearIntervenesResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        fail_id_list: List[str] = None,
        task_id: str = None,
    ):
        self.code = code
        self.fail_id_list = fail_id_list
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.fail_id_list is not None:
            result['FailIdList'] = self.fail_id_list
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('FailIdList') is not None:
            self.fail_id_list = m.get('FailIdList')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ClearIntervenesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ClearIntervenesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ClearIntervenesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ClearIntervenesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ClearIntervenesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ClearIntervenesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ConfirmAndPostProcessAuditNoteRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ConfirmAndPostProcessAuditNoteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ConfirmAndPostProcessAuditNoteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ConfirmAndPostProcessAuditNoteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ConfirmAndPostProcessAuditNoteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        value_format: str = None,
        value_type: str = None,
    ):
        self.name = name
        self.value = value
        self.value_format = value_format
        self.value_type = value_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        if self.value_format is not None:
            result['ValueFormat'] = self.value_format
        if self.value_type is not None:
            result['ValueType'] = self.value_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('ValueFormat') is not None:
            self.value_format = m.get('ValueFormat')
        if m.get('ValueType') is not None:
            self.value_type = m.get('ValueType')
        return self


class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        value_format: str = None,
        value_type: str = None,
    ):
        self.name = name
        self.value = value
        self.value_format = value_format
        self.value_type = value_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        if self.value_format is not None:
            result['ValueFormat'] = self.value_format
        if self.value_type is not None:
            result['ValueType'] = self.value_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('ValueFormat') is not None:
            self.value_format = m.get('ValueFormat')
        if m.get('ValueType') is not None:
            self.value_type = m.get('ValueType')
        return self


class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig(TeaModel):
    def __init__(
        self,
        body: str = None,
        connect_timeout: int = None,
        headers: List[CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders] = None,
        method: str = None,
        params: List[CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams] = None,
        path_params_enable: bool = None,
        socket_timeout: int = None,
        url: str = None,
    ):
        self.body = body
        self.connect_timeout = connect_timeout
        self.headers = headers
        self.method = method
        self.params = params
        self.path_params_enable = path_params_enable
        self.socket_timeout = socket_timeout
        self.url = url

    def validate(self):
        if self.headers:
            for k in self.headers:
                if k:
                    k.validate()
        if self.params:
            for k in self.params:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['Body'] = self.body
        if self.connect_timeout is not None:
            result['ConnectTimeout'] = self.connect_timeout
        result['Headers'] = []
        if self.headers is not None:
            for k in self.headers:
                result['Headers'].append(k.to_map() if k else None)
        if self.method is not None:
            result['Method'] = self.method
        result['Params'] = []
        if self.params is not None:
            for k in self.params:
                result['Params'].append(k.to_map() if k else None)
        if self.path_params_enable is not None:
            result['PathParamsEnable'] = self.path_params_enable
        if self.socket_timeout is not None:
            result['SocketTimeout'] = self.socket_timeout
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Body') is not None:
            self.body = m.get('Body')
        if m.get('ConnectTimeout') is not None:
            self.connect_timeout = m.get('ConnectTimeout')
        self.headers = []
        if m.get('Headers') is not None:
            for k in m.get('Headers'):
                temp_model = CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders()
                self.headers.append(temp_model.from_map(k))
        if m.get('Method') is not None:
            self.method = m.get('Method')
        self.params = []
        if m.get('Params') is not None:
            for k in m.get('Params'):
                temp_model = CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams()
                self.params.append(temp_model.from_map(k))
        if m.get('PathParamsEnable') is not None:
            self.path_params_enable = m.get('PathParamsEnable')
        if m.get('SocketTimeout') is not None:
            self.socket_timeout = m.get('SocketTimeout')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes(TeaModel):
    def __init__(
        self,
        key: str = None,
        path: str = None,
        type: str = None,
    ):
        self.key = key
        self.path = path
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes(TeaModel):
    def __init__(
        self,
        jq_nodes: List[CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes] = None,
        key: str = None,
        path: str = None,
        type: str = None,
    ):
        self.jq_nodes = jq_nodes
        self.key = key
        self.path = path
        self.type = type

    def validate(self):
        if self.jq_nodes:
            for k in self.jq_nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JqNodes'] = []
        if self.jq_nodes is not None:
            for k in self.jq_nodes:
                result['JqNodes'].append(k.to_map() if k else None)
        if self.key is not None:
            result['Key'] = self.key
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jq_nodes = []
        if m.get('JqNodes') is not None:
            for k in m.get('JqNodes'):
                temp_model = CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes()
                self.jq_nodes.append(temp_model.from_map(k))
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes(TeaModel):
    def __init__(
        self,
        jq_nodes: List[CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes] = None,
        key: str = None,
        path: str = None,
        type: str = None,
    ):
        self.jq_nodes = jq_nodes
        self.key = key
        self.path = path
        self.type = type

    def validate(self):
        if self.jq_nodes:
            for k in self.jq_nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JqNodes'] = []
        if self.jq_nodes is not None:
            for k in self.jq_nodes:
                result['JqNodes'].append(k.to_map() if k else None)
        if self.key is not None:
            result['Key'] = self.key
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jq_nodes = []
        if m.get('JqNodes') is not None:
            for k in m.get('JqNodes'):
                temp_model = CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes()
                self.jq_nodes.append(temp_model.from_map(k))
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig(TeaModel):
    def __init__(
        self,
        jq_nodes: List[CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes] = None,
    ):
        self.jq_nodes = jq_nodes

    def validate(self):
        if self.jq_nodes:
            for k in self.jq_nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JqNodes'] = []
        if self.jq_nodes is not None:
            for k in self.jq_nodes:
                result['JqNodes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jq_nodes = []
        if m.get('JqNodes') is not None:
            for k in m.get('JqNodes'):
                temp_model = CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes()
                self.jq_nodes.append(temp_model.from_map(k))
        return self


class CreateDatasetRequestDatasetConfigSearchSourceConfigs(TeaModel):
    def __init__(
        self,
        demo_query: str = None,
        search_source_request_config: CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig = None,
        search_source_response_config: CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig = None,
        size: int = None,
    ):
        self.demo_query = demo_query
        self.search_source_request_config = search_source_request_config
        self.search_source_response_config = search_source_response_config
        self.size = size

    def validate(self):
        if self.search_source_request_config:
            self.search_source_request_config.validate()
        if self.search_source_response_config:
            self.search_source_response_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.demo_query is not None:
            result['DemoQuery'] = self.demo_query
        if self.search_source_request_config is not None:
            result['SearchSourceRequestConfig'] = self.search_source_request_config.to_map()
        if self.search_source_response_config is not None:
            result['SearchSourceResponseConfig'] = self.search_source_response_config.to_map()
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DemoQuery') is not None:
            self.demo_query = m.get('DemoQuery')
        if m.get('SearchSourceRequestConfig') is not None:
            temp_model = CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig()
            self.search_source_request_config = temp_model.from_map(m['SearchSourceRequestConfig'])
        if m.get('SearchSourceResponseConfig') is not None:
            temp_model = CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig()
            self.search_source_response_config = temp_model.from_map(m['SearchSourceResponseConfig'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class CreateDatasetRequestDatasetConfig(TeaModel):
    def __init__(
        self,
        search_source_configs: List[CreateDatasetRequestDatasetConfigSearchSourceConfigs] = None,
    ):
        self.search_source_configs = search_source_configs

    def validate(self):
        if self.search_source_configs:
            for k in self.search_source_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchSourceConfigs'] = []
        if self.search_source_configs is not None:
            for k in self.search_source_configs:
                result['SearchSourceConfigs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.search_source_configs = []
        if m.get('SearchSourceConfigs') is not None:
            for k in m.get('SearchSourceConfigs'):
                temp_model = CreateDatasetRequestDatasetConfigSearchSourceConfigs()
                self.search_source_configs.append(temp_model.from_map(k))
        return self


class CreateDatasetRequestDocumentHandleConfig(TeaModel):
    def __init__(
        self,
        disable_handle_multimodal_media: bool = None,
    ):
        self.disable_handle_multimodal_media = disable_handle_multimodal_media

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disable_handle_multimodal_media is not None:
            result['DisableHandleMultimodalMedia'] = self.disable_handle_multimodal_media
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisableHandleMultimodalMedia') is not None:
            self.disable_handle_multimodal_media = m.get('DisableHandleMultimodalMedia')
        return self


class CreateDatasetRequest(TeaModel):
    def __init__(
        self,
        dataset_config: CreateDatasetRequestDatasetConfig = None,
        dataset_description: str = None,
        dataset_name: str = None,
        dataset_type: str = None,
        document_handle_config: CreateDatasetRequestDocumentHandleConfig = None,
        invoke_type: str = None,
        search_dataset_enable: int = None,
        workspace_id: str = None,
    ):
        self.dataset_config = dataset_config
        self.dataset_description = dataset_description
        # This parameter is required.
        self.dataset_name = dataset_name
        self.dataset_type = dataset_type
        self.document_handle_config = document_handle_config
        self.invoke_type = invoke_type
        self.search_dataset_enable = search_dataset_enable
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.dataset_config:
            self.dataset_config.validate()
        if self.document_handle_config:
            self.document_handle_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_config is not None:
            result['DatasetConfig'] = self.dataset_config.to_map()
        if self.dataset_description is not None:
            result['DatasetDescription'] = self.dataset_description
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.dataset_type is not None:
            result['DatasetType'] = self.dataset_type
        if self.document_handle_config is not None:
            result['DocumentHandleConfig'] = self.document_handle_config.to_map()
        if self.invoke_type is not None:
            result['InvokeType'] = self.invoke_type
        if self.search_dataset_enable is not None:
            result['SearchDatasetEnable'] = self.search_dataset_enable
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetConfig') is not None:
            temp_model = CreateDatasetRequestDatasetConfig()
            self.dataset_config = temp_model.from_map(m['DatasetConfig'])
        if m.get('DatasetDescription') is not None:
            self.dataset_description = m.get('DatasetDescription')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('DatasetType') is not None:
            self.dataset_type = m.get('DatasetType')
        if m.get('DocumentHandleConfig') is not None:
            temp_model = CreateDatasetRequestDocumentHandleConfig()
            self.document_handle_config = temp_model.from_map(m['DocumentHandleConfig'])
        if m.get('InvokeType') is not None:
            self.invoke_type = m.get('InvokeType')
        if m.get('SearchDatasetEnable') is not None:
            self.search_dataset_enable = m.get('SearchDatasetEnable')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CreateDatasetShrinkRequest(TeaModel):
    def __init__(
        self,
        dataset_config_shrink: str = None,
        dataset_description: str = None,
        dataset_name: str = None,
        dataset_type: str = None,
        document_handle_config_shrink: str = None,
        invoke_type: str = None,
        search_dataset_enable: int = None,
        workspace_id: str = None,
    ):
        self.dataset_config_shrink = dataset_config_shrink
        self.dataset_description = dataset_description
        # This parameter is required.
        self.dataset_name = dataset_name
        self.dataset_type = dataset_type
        self.document_handle_config_shrink = document_handle_config_shrink
        self.invoke_type = invoke_type
        self.search_dataset_enable = search_dataset_enable
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_config_shrink is not None:
            result['DatasetConfig'] = self.dataset_config_shrink
        if self.dataset_description is not None:
            result['DatasetDescription'] = self.dataset_description
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.dataset_type is not None:
            result['DatasetType'] = self.dataset_type
        if self.document_handle_config_shrink is not None:
            result['DocumentHandleConfig'] = self.document_handle_config_shrink
        if self.invoke_type is not None:
            result['InvokeType'] = self.invoke_type
        if self.search_dataset_enable is not None:
            result['SearchDatasetEnable'] = self.search_dataset_enable
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetConfig') is not None:
            self.dataset_config_shrink = m.get('DatasetConfig')
        if m.get('DatasetDescription') is not None:
            self.dataset_description = m.get('DatasetDescription')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('DatasetType') is not None:
            self.dataset_type = m.get('DatasetType')
        if m.get('DocumentHandleConfig') is not None:
            self.document_handle_config_shrink = m.get('DocumentHandleConfig')
        if m.get('InvokeType') is not None:
            self.invoke_type = m.get('InvokeType')
        if m.get('SearchDatasetEnable') is not None:
            self.search_dataset_enable = m.get('SearchDatasetEnable')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class CreateDatasetResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_user: str = None,
        dataset_description: str = None,
        dataset_id: int = None,
        dataset_name: str = None,
        dataset_type: str = None,
        search_dataset_enable: int = None,
    ):
        self.create_time = create_time
        self.create_user = create_user
        self.dataset_description = dataset_description
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        self.dataset_type = dataset_type
        self.search_dataset_enable = search_dataset_enable

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.dataset_description is not None:
            result['DatasetDescription'] = self.dataset_description
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.dataset_type is not None:
            result['DatasetType'] = self.dataset_type
        if self.search_dataset_enable is not None:
            result['SearchDatasetEnable'] = self.search_dataset_enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DatasetDescription') is not None:
            self.dataset_description = m.get('DatasetDescription')
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('DatasetType') is not None:
            self.dataset_type = m.get('DatasetType')
        if m.get('SearchDatasetEnable') is not None:
            self.search_dataset_enable = m.get('SearchDatasetEnable')
        return self


class CreateDatasetResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateDatasetResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateDatasetResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDatasetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDatasetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDatasetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateGeneratedContentRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        content: str = None,
        content_domain: str = None,
        content_text: str = None,
        keywords: List[str] = None,
        prompt: str = None,
        task_id: str = None,
        title: str = None,
        uuid: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.content = content
        self.content_domain = content_domain
        self.content_text = content_text
        self.keywords = keywords
        self.prompt = prompt
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.title = title
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.content is not None:
            result['Content'] = self.content
        if self.content_domain is not None:
            result['ContentDomain'] = self.content_domain
        if self.content_text is not None:
            result['ContentText'] = self.content_text
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.title is not None:
            result['Title'] = self.title
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentDomain') is not None:
            self.content_domain = m.get('ContentDomain')
        if m.get('ContentText') is not None:
            self.content_text = m.get('ContentText')
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class CreateGeneratedContentShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        content: str = None,
        content_domain: str = None,
        content_text: str = None,
        keywords_shrink: str = None,
        prompt: str = None,
        task_id: str = None,
        title: str = None,
        uuid: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.content = content
        self.content_domain = content_domain
        self.content_text = content_text
        self.keywords_shrink = keywords_shrink
        self.prompt = prompt
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.title = title
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.content is not None:
            result['Content'] = self.content
        if self.content_domain is not None:
            result['ContentDomain'] = self.content_domain
        if self.content_text is not None:
            result['ContentText'] = self.content_text
        if self.keywords_shrink is not None:
            result['Keywords'] = self.keywords_shrink
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.title is not None:
            result['Title'] = self.title
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentDomain') is not None:
            self.content_domain = m.get('ContentDomain')
        if m.get('ContentText') is not None:
            self.content_text = m.get('ContentText')
        if m.get('Keywords') is not None:
            self.keywords_shrink = m.get('Keywords')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class CreateGeneratedContentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: int = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateGeneratedContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateGeneratedContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateGeneratedContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTokenRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        return self


class CreateTokenResponseBodyData(TeaModel):
    def __init__(
        self,
        expired_time: int = None,
        token: str = None,
    ):
        self.expired_time = expired_time
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class CreateTokenResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateTokenResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateTokenResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateTokenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTokenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTokenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAuditNoteRequest(TeaModel):
    def __init__(
        self,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteAuditNoteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteAuditNoteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAuditNoteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAuditNoteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAuditTermsRequest(TeaModel):
    def __init__(
        self,
        id_list: List[int] = None,
        workspace_id: str = None,
    ):
        self.id_list = id_list
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id_list is not None:
            result['IdList'] = self.id_list
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IdList') is not None:
            self.id_list = m.get('IdList')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteAuditTermsShrinkRequest(TeaModel):
    def __init__(
        self,
        id_list_shrink: str = None,
        workspace_id: str = None,
    ):
        self.id_list_shrink = id_list_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id_list_shrink is not None:
            result['IdList'] = self.id_list_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IdList') is not None:
            self.id_list_shrink = m.get('IdList')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteAuditTermsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteAuditTermsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAuditTermsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAuditTermsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomTextRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        commodity_code: str = None,
        id: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.commodity_code = commodity_code
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteCustomTextResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCustomTextResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustomTextResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomTextResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomTopicByTopicRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        topic: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class DeleteCustomTopicByTopicResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: int = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCustomTopicByTopicResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustomTopicByTopicResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomTopicByTopicResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomTopicViewPointByIdRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        custom_view_point_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.custom_view_point_id = custom_view_point_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.custom_view_point_id is not None:
            result['CustomViewPointId'] = self.custom_view_point_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CustomViewPointId') is not None:
            self.custom_view_point_id = m.get('CustomViewPointId')
        return self


class DeleteCustomTopicViewPointByIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: int = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCustomTopicViewPointByIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCustomTopicViewPointByIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomTopicViewPointByIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDatasetRequest(TeaModel):
    def __init__(
        self,
        dataset_id: int = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.dataset_id = dataset_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteDatasetResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDatasetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDatasetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDatasetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDatasetDocumentRequest(TeaModel):
    def __init__(
        self,
        dataset_id: int = None,
        dataset_name: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        workspace_id: str = None,
    ):
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteDatasetDocumentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[str] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDatasetDocumentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDatasetDocumentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDatasetDocumentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDocsRequest(TeaModel):
    def __init__(
        self,
        doc_ids: List[str] = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.doc_ids = doc_ids
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_ids is not None:
            result['DocIds'] = self.doc_ids
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocIds') is not None:
            self.doc_ids = m.get('DocIds')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteDocsShrinkRequest(TeaModel):
    def __init__(
        self,
        doc_ids_shrink: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.doc_ids_shrink = doc_ids_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_ids_shrink is not None:
            result['DocIds'] = self.doc_ids_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocIds') is not None:
            self.doc_ids_shrink = m.get('DocIds')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteDocsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDocsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDocsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDocsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteFactAuditUrlRequest(TeaModel):
    def __init__(
        self,
        url: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DeleteFactAuditUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteFactAuditUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteFactAuditUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteFactAuditUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGeneratedContentRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        id: int = None,
        region_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.id = id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.id is not None:
            result['Id'] = self.id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteGeneratedContentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteGeneratedContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteGeneratedContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteGeneratedContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInterveneRuleRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        rule_id: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DeleteInterveneRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        fail_id_list: List[str] = None,
        task_id: str = None,
    ):
        self.code = code
        self.fail_id_list = fail_id_list
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.fail_id_list is not None:
            result['FailIdList'] = self.fail_id_list
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('FailIdList') is not None:
            self.fail_id_list = m.get('FailIdList')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DeleteInterveneRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteInterveneRuleResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteInterveneRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteInterveneRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteInterveneRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInterveneRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMaterialByIdRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        id: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteMaterialByIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMaterialByIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMaterialByIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMaterialByIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteStyleLearningResultRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        id: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteStyleLearningResultResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteStyleLearningResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteStyleLearningResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteStyleLearningResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DocumentExtractionRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        urls: List[str] = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.urls = urls

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.urls is not None:
            result['Urls'] = self.urls
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Urls') is not None:
            self.urls = m.get('Urls')
        return self


class DocumentExtractionShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        urls_shrink: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.urls_shrink = urls_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.urls_shrink is not None:
            result['Urls'] = self.urls_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Urls') is not None:
            self.urls_shrink = m.get('Urls')
        return self


class DocumentExtractionResponseBodyData(TeaModel):
    def __init__(
        self,
        author: str = None,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        tag: str = None,
        title: str = None,
        url: str = None,
    ):
        self.author = author
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.tag = tag
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class DocumentExtractionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[DocumentExtractionResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DocumentExtractionResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DocumentExtractionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DocumentExtractionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DocumentExtractionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DownloadAuditNoteRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class DownloadAuditNoteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DownloadAuditNoteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DownloadAuditNoteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DownloadAuditNoteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EditAuditTermsRequest(TeaModel):
    def __init__(
        self,
        exception_word: List[str] = None,
        id: str = None,
        keyword: str = None,
        suggest_word: str = None,
        terms_desc: str = None,
        workspace_id: str = None,
    ):
        self.exception_word = exception_word
        self.id = id
        self.keyword = keyword
        self.suggest_word = suggest_word
        self.terms_desc = terms_desc
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exception_word is not None:
            result['ExceptionWord'] = self.exception_word
        if self.id is not None:
            result['Id'] = self.id
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.suggest_word is not None:
            result['SuggestWord'] = self.suggest_word
        if self.terms_desc is not None:
            result['TermsDesc'] = self.terms_desc
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExceptionWord') is not None:
            self.exception_word = m.get('ExceptionWord')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('SuggestWord') is not None:
            self.suggest_word = m.get('SuggestWord')
        if m.get('TermsDesc') is not None:
            self.terms_desc = m.get('TermsDesc')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class EditAuditTermsShrinkRequest(TeaModel):
    def __init__(
        self,
        exception_word_shrink: str = None,
        id: str = None,
        keyword: str = None,
        suggest_word: str = None,
        terms_desc: str = None,
        workspace_id: str = None,
    ):
        self.exception_word_shrink = exception_word_shrink
        self.id = id
        self.keyword = keyword
        self.suggest_word = suggest_word
        self.terms_desc = terms_desc
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exception_word_shrink is not None:
            result['ExceptionWord'] = self.exception_word_shrink
        if self.id is not None:
            result['Id'] = self.id
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.suggest_word is not None:
            result['SuggestWord'] = self.suggest_word
        if self.terms_desc is not None:
            result['TermsDesc'] = self.terms_desc
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExceptionWord') is not None:
            self.exception_word_shrink = m.get('ExceptionWord')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('SuggestWord') is not None:
            self.suggest_word = m.get('SuggestWord')
        if m.get('TermsDesc') is not None:
            self.terms_desc = m.get('TermsDesc')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class EditAuditTermsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EditAuditTermsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EditAuditTermsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EditAuditTermsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportAnalysisTagDetailByTaskIdRequest(TeaModel):
    def __init__(
        self,
        categories: List[str] = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.categories = categories
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.categories is not None:
            result['Categories'] = self.categories
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Categories') is not None:
            self.categories = m.get('Categories')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ExportAnalysisTagDetailByTaskIdShrinkRequest(TeaModel):
    def __init__(
        self,
        categories_shrink: str = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.categories_shrink = categories_shrink
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.categories_shrink is not None:
            result['Categories'] = self.categories_shrink
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Categories') is not None:
            self.categories_shrink = m.get('Categories')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ExportAnalysisTagDetailByTaskIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExportAnalysisTagDetailByTaskIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportAnalysisTagDetailByTaskIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportAnalysisTagDetailByTaskIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportAuditContentResultRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.task_id = task_id
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ExportAuditContentResultResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExportAuditContentResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportAuditContentResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportAuditContentResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportCustomSourceAnalysisTaskRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ExportCustomSourceAnalysisTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExportCustomSourceAnalysisTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportCustomSourceAnalysisTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportCustomSourceAnalysisTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportGeneratedContentRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        id: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class ExportGeneratedContentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExportGeneratedContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportGeneratedContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportGeneratedContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportHotTopicPlanningProposalsRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        custom_view_point_ids: List[str] = None,
        export_type: str = None,
        titles: List[str] = None,
        topic: str = None,
        topic_source: str = None,
        view_point_type: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.custom_view_point_ids = custom_view_point_ids
        self.export_type = export_type
        self.titles = titles
        # This parameter is required.
        self.topic = topic
        # This parameter is required.
        self.topic_source = topic_source
        self.view_point_type = view_point_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.custom_view_point_ids is not None:
            result['CustomViewPointIds'] = self.custom_view_point_ids
        if self.export_type is not None:
            result['ExportType'] = self.export_type
        if self.titles is not None:
            result['Titles'] = self.titles
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        if self.view_point_type is not None:
            result['ViewPointType'] = self.view_point_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CustomViewPointIds') is not None:
            self.custom_view_point_ids = m.get('CustomViewPointIds')
        if m.get('ExportType') is not None:
            self.export_type = m.get('ExportType')
        if m.get('Titles') is not None:
            self.titles = m.get('Titles')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        if m.get('ViewPointType') is not None:
            self.view_point_type = m.get('ViewPointType')
        return self


class ExportHotTopicPlanningProposalsShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        custom_view_point_ids_shrink: str = None,
        export_type: str = None,
        titles_shrink: str = None,
        topic: str = None,
        topic_source: str = None,
        view_point_type: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.custom_view_point_ids_shrink = custom_view_point_ids_shrink
        self.export_type = export_type
        self.titles_shrink = titles_shrink
        # This parameter is required.
        self.topic = topic
        # This parameter is required.
        self.topic_source = topic_source
        self.view_point_type = view_point_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.custom_view_point_ids_shrink is not None:
            result['CustomViewPointIds'] = self.custom_view_point_ids_shrink
        if self.export_type is not None:
            result['ExportType'] = self.export_type
        if self.titles_shrink is not None:
            result['Titles'] = self.titles_shrink
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        if self.view_point_type is not None:
            result['ViewPointType'] = self.view_point_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CustomViewPointIds') is not None:
            self.custom_view_point_ids_shrink = m.get('CustomViewPointIds')
        if m.get('ExportType') is not None:
            self.export_type = m.get('ExportType')
        if m.get('Titles') is not None:
            self.titles_shrink = m.get('Titles')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        if m.get('ViewPointType') is not None:
            self.view_point_type = m.get('ViewPointType')
        return self


class ExportHotTopicPlanningProposalsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExportHotTopicPlanningProposalsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportHotTopicPlanningProposalsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportHotTopicPlanningProposalsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportIntervenesRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        return self


class ExportIntervenesResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        file_url: str = None,
    ):
        self.code = code
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class ExportIntervenesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ExportIntervenesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ExportIntervenesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ExportIntervenesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportIntervenesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportIntervenesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class FeedbackDialogueRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        customer_response: str = None,
        good_text: str = None,
        modified_response: str = None,
        rating: str = None,
        rating_tags: List[str] = None,
        session_id: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.customer_response = customer_response
        self.good_text = good_text
        self.modified_response = modified_response
        self.rating = rating
        self.rating_tags = rating_tags
        # This parameter is required.
        self.session_id = session_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.customer_response is not None:
            result['CustomerResponse'] = self.customer_response
        if self.good_text is not None:
            result['GoodText'] = self.good_text
        if self.modified_response is not None:
            result['ModifiedResponse'] = self.modified_response
        if self.rating is not None:
            result['Rating'] = self.rating
        if self.rating_tags is not None:
            result['RatingTags'] = self.rating_tags
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CustomerResponse') is not None:
            self.customer_response = m.get('CustomerResponse')
        if m.get('GoodText') is not None:
            self.good_text = m.get('GoodText')
        if m.get('ModifiedResponse') is not None:
            self.modified_response = m.get('ModifiedResponse')
        if m.get('Rating') is not None:
            self.rating = m.get('Rating')
        if m.get('RatingTags') is not None:
            self.rating_tags = m.get('RatingTags')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class FeedbackDialogueShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        customer_response: str = None,
        good_text: str = None,
        modified_response: str = None,
        rating: str = None,
        rating_tags_shrink: str = None,
        session_id: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.customer_response = customer_response
        self.good_text = good_text
        self.modified_response = modified_response
        self.rating = rating
        self.rating_tags_shrink = rating_tags_shrink
        # This parameter is required.
        self.session_id = session_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.customer_response is not None:
            result['CustomerResponse'] = self.customer_response
        if self.good_text is not None:
            result['GoodText'] = self.good_text
        if self.modified_response is not None:
            result['ModifiedResponse'] = self.modified_response
        if self.rating is not None:
            result['Rating'] = self.rating
        if self.rating_tags_shrink is not None:
            result['RatingTags'] = self.rating_tags_shrink
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CustomerResponse') is not None:
            self.customer_response = m.get('CustomerResponse')
        if m.get('GoodText') is not None:
            self.good_text = m.get('GoodText')
        if m.get('ModifiedResponse') is not None:
            self.modified_response = m.get('ModifiedResponse')
        if m.get('Rating') is not None:
            self.rating = m.get('Rating')
        if m.get('RatingTags') is not None:
            self.rating_tags_shrink = m.get('RatingTags')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class FeedbackDialogueResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class FeedbackDialogueResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: FeedbackDialogueResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = FeedbackDialogueResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class FetchExportTermsTaskRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class FetchExportTermsTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        status: str = None,
    ):
        self.file_url = file_url
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class FetchExportTermsTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: FetchExportTermsTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = FetchExportTermsTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class FetchExportTermsTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: FetchExportTermsTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = FetchExportTermsTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class FetchExportWordTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class FetchExportWordTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        task_stats: str = None,
    ):
        self.file_url = file_url
        self.task_stats = task_stats

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.task_stats is not None:
            result['TaskStats'] = self.task_stats
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('TaskStats') is not None:
            self.task_stats = m.get('TaskStats')
        return self


class FetchExportWordTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: FetchExportWordTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = FetchExportWordTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class FetchExportWordTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: FetchExportWordTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = FetchExportWordTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class FetchImageTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        article_task_id: str = None,
        task_id_list: List[str] = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.article_task_id = article_task_id
        # This parameter is required.
        self.task_id_list = task_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.article_task_id is not None:
            result['ArticleTaskId'] = self.article_task_id
        if self.task_id_list is not None:
            result['TaskIdList'] = self.task_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('ArticleTaskId') is not None:
            self.article_task_id = m.get('ArticleTaskId')
        if m.get('TaskIdList') is not None:
            self.task_id_list = m.get('TaskIdList')
        return self


class FetchImageTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        article_task_id: str = None,
        task_id_list_shrink: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.article_task_id = article_task_id
        # This parameter is required.
        self.task_id_list_shrink = task_id_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.article_task_id is not None:
            result['ArticleTaskId'] = self.article_task_id
        if self.task_id_list_shrink is not None:
            result['TaskIdList'] = self.task_id_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('ArticleTaskId') is not None:
            self.article_task_id = m.get('ArticleTaskId')
        if m.get('TaskIdList') is not None:
            self.task_id_list_shrink = m.get('TaskIdList')
        return self


class FetchImageTaskResponseBodyDataTaskInfoListImageList(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        url: str = None,
    ):
        self.code = code
        self.message = message
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class FetchImageTaskResponseBodyDataTaskInfoList(TeaModel):
    def __init__(
        self,
        id: int = None,
        image_list: List[FetchImageTaskResponseBodyDataTaskInfoListImageList] = None,
        task_id: str = None,
        task_status: str = None,
    ):
        self.id = id
        self.image_list = image_list
        self.task_id = task_id
        self.task_status = task_status

    def validate(self):
        if self.image_list:
            for k in self.image_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        result['ImageList'] = []
        if self.image_list is not None:
            for k in self.image_list:
                result['ImageList'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        self.image_list = []
        if m.get('ImageList') is not None:
            for k in m.get('ImageList'):
                temp_model = FetchImageTaskResponseBodyDataTaskInfoListImageList()
                self.image_list.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class FetchImageTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_info_list: List[FetchImageTaskResponseBodyDataTaskInfoList] = None,
    ):
        self.task_info_list = task_info_list

    def validate(self):
        if self.task_info_list:
            for k in self.task_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskInfoList'] = []
        if self.task_info_list is not None:
            for k in self.task_info_list:
                result['TaskInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_info_list = []
        if m.get('TaskInfoList') is not None:
            for k in m.get('TaskInfoList'):
                temp_model = FetchImageTaskResponseBodyDataTaskInfoList()
                self.task_info_list.append(temp_model.from_map(k))
        return self


class FetchImageTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: FetchImageTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = FetchImageTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class FetchImageTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: FetchImageTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = FetchImageTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class FetchImportTermsTaskRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class FetchImportTermsTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        status: str = None,
    ):
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class FetchImportTermsTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: FetchImportTermsTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = FetchImportTermsTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class FetchImportTermsTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: FetchImportTermsTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = FetchImportTermsTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateExportWordTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        generated_content_id: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.generated_content_id = generated_content_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.generated_content_id is not None:
            result['GeneratedContentId'] = self.generated_content_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('GeneratedContentId') is not None:
            self.generated_content_id = m.get('GeneratedContentId')
        return self


class GenerateExportWordTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GenerateExportWordTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GenerateExportWordTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GenerateExportWordTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GenerateExportWordTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateExportWordTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateExportWordTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateFileUrlByKeyRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        file_key: str = None,
        file_name: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.file_key = file_key
        self.file_name = file_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        if self.file_name is not None:
            result['FileName'] = self.file_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        return self


class GenerateFileUrlByKeyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GenerateFileUrlByKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateFileUrlByKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateFileUrlByKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateImageTaskRequestParagraphList(TeaModel):
    def __init__(
        self,
        content: str = None,
        id: int = None,
        task_id: str = None,
        task_status: str = None,
    ):
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.id = id
        self.task_id = task_id
        self.task_status = task_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.id is not None:
            result['Id'] = self.id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class GenerateImageTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        article_task_id: str = None,
        paragraph_list: List[GenerateImageTaskRequestParagraphList] = None,
        size: str = None,
        style: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.article_task_id = article_task_id
        # This parameter is required.
        self.paragraph_list = paragraph_list
        # This parameter is required.
        self.size = size
        # This parameter is required.
        self.style = style

    def validate(self):
        if self.paragraph_list:
            for k in self.paragraph_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.article_task_id is not None:
            result['ArticleTaskId'] = self.article_task_id
        result['ParagraphList'] = []
        if self.paragraph_list is not None:
            for k in self.paragraph_list:
                result['ParagraphList'].append(k.to_map() if k else None)
        if self.size is not None:
            result['Size'] = self.size
        if self.style is not None:
            result['Style'] = self.style
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('ArticleTaskId') is not None:
            self.article_task_id = m.get('ArticleTaskId')
        self.paragraph_list = []
        if m.get('ParagraphList') is not None:
            for k in m.get('ParagraphList'):
                temp_model = GenerateImageTaskRequestParagraphList()
                self.paragraph_list.append(temp_model.from_map(k))
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Style') is not None:
            self.style = m.get('Style')
        return self


class GenerateImageTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        article_task_id: str = None,
        paragraph_list_shrink: str = None,
        size: str = None,
        style: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.article_task_id = article_task_id
        # This parameter is required.
        self.paragraph_list_shrink = paragraph_list_shrink
        # This parameter is required.
        self.size = size
        # This parameter is required.
        self.style = style

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.article_task_id is not None:
            result['ArticleTaskId'] = self.article_task_id
        if self.paragraph_list_shrink is not None:
            result['ParagraphList'] = self.paragraph_list_shrink
        if self.size is not None:
            result['Size'] = self.size
        if self.style is not None:
            result['Style'] = self.style
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('ArticleTaskId') is not None:
            self.article_task_id = m.get('ArticleTaskId')
        if m.get('ParagraphList') is not None:
            self.paragraph_list_shrink = m.get('ParagraphList')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Style') is not None:
            self.style = m.get('Style')
        return self


class GenerateImageTaskResponseBodyDataTaskList(TeaModel):
    def __init__(
        self,
        content: str = None,
        id: int = None,
        task_id: str = None,
        task_status: str = None,
    ):
        self.content = content
        self.id = id
        self.task_id = task_id
        self.task_status = task_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.id is not None:
            result['Id'] = self.id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class GenerateImageTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_list: List[GenerateImageTaskResponseBodyDataTaskList] = None,
    ):
        self.task_list = task_list

    def validate(self):
        if self.task_list:
            for k in self.task_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TaskList'] = []
        if self.task_list is not None:
            for k in self.task_list:
                result['TaskList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.task_list = []
        if m.get('TaskList') is not None:
            for k in m.get('TaskList'):
                temp_model = GenerateImageTaskResponseBodyDataTaskList()
                self.task_list.append(temp_model.from_map(k))
        return self


class GenerateImageTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GenerateImageTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GenerateImageTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GenerateImageTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateImageTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateImageTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateUploadConfigRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        file_name: str = None,
        parent_dir: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.file_name = file_name
        # This parameter is required.
        self.parent_dir = parent_dir

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.parent_dir is not None:
            result['ParentDir'] = self.parent_dir
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('ParentDir') is not None:
            self.parent_dir = m.get('ParentDir')
        return self


class GenerateUploadConfigResponseBodyData(TeaModel):
    def __init__(
        self,
        file_key: str = None,
        form_datas: Dict[str, Any] = None,
        post_url: str = None,
    ):
        self.file_key = file_key
        self.form_datas = form_datas
        self.post_url = post_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        if self.form_datas is not None:
            result['FormDatas'] = self.form_datas
        if self.post_url is not None:
            result['PostUrl'] = self.post_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        if m.get('FormDatas') is not None:
            self.form_datas = m.get('FormDatas')
        if m.get('PostUrl') is not None:
            self.post_url = m.get('PostUrl')
        return self


class GenerateUploadConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GenerateUploadConfigResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GenerateUploadConfigResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GenerateUploadConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateUploadConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateUploadConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateViewPointRequestReferenceData(TeaModel):
    def __init__(
        self,
        mini_doc: List[str] = None,
    ):
        self.mini_doc = mini_doc

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mini_doc is not None:
            result['MiniDoc'] = self.mini_doc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MiniDoc') is not None:
            self.mini_doc = m.get('MiniDoc')
        return self


class GenerateViewPointRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        reference_data: GenerateViewPointRequestReferenceData = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.reference_data = reference_data

    def validate(self):
        if self.reference_data:
            self.reference_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.reference_data is not None:
            result['ReferenceData'] = self.reference_data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('ReferenceData') is not None:
            temp_model = GenerateViewPointRequestReferenceData()
            self.reference_data = temp_model.from_map(m['ReferenceData'])
        return self


class GenerateViewPointShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        reference_data_shrink: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.reference_data_shrink = reference_data_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.reference_data_shrink is not None:
            result['ReferenceData'] = self.reference_data_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('ReferenceData') is not None:
            self.reference_data_shrink = m.get('ReferenceData')
        return self


class GenerateViewPointResponseBodyData(TeaModel):
    def __init__(
        self,
        point: str = None,
    ):
        self.point = point

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.point is not None:
            result['Point'] = self.point
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Point') is not None:
            self.point = m.get('Point')
        return self


class GenerateViewPointResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GenerateViewPointResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GenerateViewPointResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GenerateViewPointResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateViewPointResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateViewPointResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAuditNotePostProcessingStatusRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetAuditNotePostProcessingStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        completion_time: str = None,
        create_time: str = None,
        error_message: str = None,
        note_id: str = None,
        processed_lines: int = None,
        status: str = None,
        total_lines: int = None,
    ):
        self.completion_time = completion_time
        self.create_time = create_time
        self.error_message = error_message
        self.note_id = note_id
        self.processed_lines = processed_lines
        self.status = status
        self.total_lines = total_lines

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.completion_time is not None:
            result['CompletionTime'] = self.completion_time
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.note_id is not None:
            result['NoteId'] = self.note_id
        if self.processed_lines is not None:
            result['ProcessedLines'] = self.processed_lines
        if self.status is not None:
            result['Status'] = self.status
        if self.total_lines is not None:
            result['TotalLines'] = self.total_lines
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CompletionTime') is not None:
            self.completion_time = m.get('CompletionTime')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NoteId') is not None:
            self.note_id = m.get('NoteId')
        if m.get('ProcessedLines') is not None:
            self.processed_lines = m.get('ProcessedLines')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TotalLines') is not None:
            self.total_lines = m.get('TotalLines')
        return self


class GetAuditNotePostProcessingStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetAuditNotePostProcessingStatusResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # This parameter is required.
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        # This parameter is required.
        self.message = message
        # Id of the request
        # 
        # This parameter is required.
        self.request_id = request_id
        # This parameter is required.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetAuditNotePostProcessingStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAuditNotePostProcessingStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAuditNotePostProcessingStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAuditNotePostProcessingStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAuditNoteProcessingStatusRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetAuditNoteProcessingStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        file_key: str = None,
        file_size: int = None,
        note_name: str = None,
        status: str = None,
        task_id: str = None,
        update_time: int = None,
    ):
        self.file_key = file_key
        self.file_size = file_size
        self.note_name = note_name
        self.status = status
        self.task_id = task_id
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.note_name is not None:
            result['NoteName'] = self.note_name
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('NoteName') is not None:
            self.note_name = m.get('NoteName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class GetAuditNoteProcessingStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetAuditNoteProcessingStatusResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetAuditNoteProcessingStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAuditNoteProcessingStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAuditNoteProcessingStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAuditNoteProcessingStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAutoClipsTaskInfoRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetAutoClipsTaskInfoResponseBodyDataColorWords(TeaModel):
    def __init__(
        self,
        content: str = None,
        effect_color_style: str = None,
        font_size: int = None,
        timeline_in: int = None,
        timeline_out: int = None,
        x: float = None,
        y: float = None,
    ):
        self.content = content
        self.effect_color_style = effect_color_style
        self.font_size = font_size
        self.timeline_in = timeline_in
        self.timeline_out = timeline_out
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.effect_color_style is not None:
            result['EffectColorStyle'] = self.effect_color_style
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.timeline_in is not None:
            result['TimelineIn'] = self.timeline_in
        if self.timeline_out is not None:
            result['TimelineOut'] = self.timeline_out
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EffectColorStyle') is not None:
            self.effect_color_style = m.get('EffectColorStyle')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('TimelineIn') is not None:
            self.timeline_in = m.get('TimelineIn')
        if m.get('TimelineOut') is not None:
            self.timeline_out = m.get('TimelineOut')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class GetAutoClipsTaskInfoResponseBodyDataTimelinesClips(TeaModel):
    def __init__(
        self,
        clip_id: str = None,
        content_inner: str = None,
        in_: int = None,
        in_ex: float = None,
        out: int = None,
        out_ex: float = None,
        video_id: str = None,
        video_name: str = None,
    ):
        self.clip_id = clip_id
        self.content_inner = content_inner
        self.in_ = in_
        self.in_ex = in_ex
        self.out = out
        self.out_ex = out_ex
        self.video_id = video_id
        self.video_name = video_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clip_id is not None:
            result['ClipId'] = self.clip_id
        if self.content_inner is not None:
            result['ContentInner'] = self.content_inner
        if self.in_ is not None:
            result['In'] = self.in_
        if self.in_ex is not None:
            result['InEx'] = self.in_ex
        if self.out is not None:
            result['Out'] = self.out
        if self.out_ex is not None:
            result['OutEx'] = self.out_ex
        if self.video_id is not None:
            result['VideoId'] = self.video_id
        if self.video_name is not None:
            result['VideoName'] = self.video_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClipId') is not None:
            self.clip_id = m.get('ClipId')
        if m.get('ContentInner') is not None:
            self.content_inner = m.get('ContentInner')
        if m.get('In') is not None:
            self.in_ = m.get('In')
        if m.get('InEx') is not None:
            self.in_ex = m.get('InEx')
        if m.get('Out') is not None:
            self.out = m.get('Out')
        if m.get('OutEx') is not None:
            self.out_ex = m.get('OutEx')
        if m.get('VideoId') is not None:
            self.video_id = m.get('VideoId')
        if m.get('VideoName') is not None:
            self.video_name = m.get('VideoName')
        return self


class GetAutoClipsTaskInfoResponseBodyDataTimelines(TeaModel):
    def __init__(
        self,
        clips: List[GetAutoClipsTaskInfoResponseBodyDataTimelinesClips] = None,
        content: str = None,
        timeline_id: str = None,
    ):
        self.clips = clips
        self.content = content
        self.timeline_id = timeline_id

    def validate(self):
        if self.clips:
            for k in self.clips:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Clips'] = []
        if self.clips is not None:
            for k in self.clips:
                result['Clips'].append(k.to_map() if k else None)
        if self.content is not None:
            result['Content'] = self.content
        if self.timeline_id is not None:
            result['TimelineId'] = self.timeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clips = []
        if m.get('Clips') is not None:
            for k in m.get('Clips'):
                temp_model = GetAutoClipsTaskInfoResponseBodyDataTimelinesClips()
                self.clips.append(temp_model.from_map(k))
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('TimelineId') is not None:
            self.timeline_id = m.get('TimelineId')
        return self


class GetAutoClipsTaskInfoResponseBodyData(TeaModel):
    def __init__(
        self,
        color_words: List[GetAutoClipsTaskInfoResponseBodyDataColorWords] = None,
        content: str = None,
        error_message: str = None,
        media_cloud_timeline: str = None,
        music_style: str = None,
        music_url: str = None,
        music_volume: int = None,
        output_video_url: str = None,
        status: int = None,
        step: str = None,
        subtitle_font_size: int = None,
        task_id: str = None,
        timelines: List[GetAutoClipsTaskInfoResponseBodyDataTimelines] = None,
        voice_style: str = None,
        voice_volume: int = None,
    ):
        self.color_words = color_words
        self.content = content
        self.error_message = error_message
        self.media_cloud_timeline = media_cloud_timeline
        self.music_style = music_style
        self.music_url = music_url
        self.music_volume = music_volume
        self.output_video_url = output_video_url
        self.status = status
        self.step = step
        self.subtitle_font_size = subtitle_font_size
        self.task_id = task_id
        self.timelines = timelines
        self.voice_style = voice_style
        self.voice_volume = voice_volume

    def validate(self):
        if self.color_words:
            for k in self.color_words:
                if k:
                    k.validate()
        if self.timelines:
            for k in self.timelines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ColorWords'] = []
        if self.color_words is not None:
            for k in self.color_words:
                result['ColorWords'].append(k.to_map() if k else None)
        if self.content is not None:
            result['Content'] = self.content
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.media_cloud_timeline is not None:
            result['MediaCloudTimeline'] = self.media_cloud_timeline
        if self.music_style is not None:
            result['MusicStyle'] = self.music_style
        if self.music_url is not None:
            result['MusicUrl'] = self.music_url
        if self.music_volume is not None:
            result['MusicVolume'] = self.music_volume
        if self.output_video_url is not None:
            result['OutputVideoUrl'] = self.output_video_url
        if self.status is not None:
            result['Status'] = self.status
        if self.step is not None:
            result['Step'] = self.step
        if self.subtitle_font_size is not None:
            result['SubtitleFontSize'] = self.subtitle_font_size
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        result['Timelines'] = []
        if self.timelines is not None:
            for k in self.timelines:
                result['Timelines'].append(k.to_map() if k else None)
        if self.voice_style is not None:
            result['VoiceStyle'] = self.voice_style
        if self.voice_volume is not None:
            result['VoiceVolume'] = self.voice_volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.color_words = []
        if m.get('ColorWords') is not None:
            for k in m.get('ColorWords'):
                temp_model = GetAutoClipsTaskInfoResponseBodyDataColorWords()
                self.color_words.append(temp_model.from_map(k))
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MediaCloudTimeline') is not None:
            self.media_cloud_timeline = m.get('MediaCloudTimeline')
        if m.get('MusicStyle') is not None:
            self.music_style = m.get('MusicStyle')
        if m.get('MusicUrl') is not None:
            self.music_url = m.get('MusicUrl')
        if m.get('MusicVolume') is not None:
            self.music_volume = m.get('MusicVolume')
        if m.get('OutputVideoUrl') is not None:
            self.output_video_url = m.get('OutputVideoUrl')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        if m.get('SubtitleFontSize') is not None:
            self.subtitle_font_size = m.get('SubtitleFontSize')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        self.timelines = []
        if m.get('Timelines') is not None:
            for k in m.get('Timelines'):
                temp_model = GetAutoClipsTaskInfoResponseBodyDataTimelines()
                self.timelines.append(temp_model.from_map(k))
        if m.get('VoiceStyle') is not None:
            self.voice_style = m.get('VoiceStyle')
        if m.get('VoiceVolume') is not None:
            self.voice_volume = m.get('VoiceVolume')
        return self


class GetAutoClipsTaskInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetAutoClipsTaskInfoResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetAutoClipsTaskInfoResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAutoClipsTaskInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAutoClipsTaskInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAutoClipsTaskInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAvailableAuditNotesRequest(TeaModel):
    def __init__(
        self,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetAvailableAuditNotesResponseBodyData(TeaModel):
    def __init__(
        self,
        file_size: int = None,
        id: str = None,
        note_id: str = None,
        note_name: str = None,
        update_time: str = None,
    ):
        self.file_size = file_size
        self.id = id
        self.note_id = note_id
        self.note_name = note_name
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.id is not None:
            result['Id'] = self.id
        if self.note_id is not None:
            result['NoteId'] = self.note_id
        if self.note_name is not None:
            result['NoteName'] = self.note_name
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('NoteId') is not None:
            self.note_id = m.get('NoteId')
        if m.get('NoteName') is not None:
            self.note_name = m.get('NoteName')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class GetAvailableAuditNotesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetAvailableAuditNotesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetAvailableAuditNotesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAvailableAuditNotesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAvailableAuditNotesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAvailableAuditNotesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCategoriesByTaskIdRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetCategoriesByTaskIdResponseBodyDataChildren(TeaModel):
    def __init__(
        self,
        category: str = None,
    ):
        self.category = category

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        return self


class GetCategoriesByTaskIdResponseBodyData(TeaModel):
    def __init__(
        self,
        category: str = None,
        children: List[GetCategoriesByTaskIdResponseBodyDataChildren] = None,
        count: int = None,
    ):
        self.category = category
        self.children = children
        self.count = count

    def validate(self):
        if self.children:
            for k in self.children:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        result['Children'] = []
        if self.children is not None:
            for k in self.children:
                result['Children'].append(k.to_map() if k else None)
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        self.children = []
        if m.get('Children') is not None:
            for k in m.get('Children'):
                temp_model = GetCategoriesByTaskIdResponseBodyDataChildren()
                self.children.append(temp_model.from_map(k))
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class GetCategoriesByTaskIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GetCategoriesByTaskIdResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetCategoriesByTaskIdResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetCategoriesByTaskIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCategoriesByTaskIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCategoriesByTaskIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCustomHotTopicBroadcastJobRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetCustomHotTopicBroadcastJobResponseBodyData(TeaModel):
    def __init__(
        self,
        error_message: str = None,
        hot_topic_version: str = None,
        status: str = None,
    ):
        self.error_message = error_message
        self.hot_topic_version = hot_topic_version
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.hot_topic_version is not None:
            result['HotTopicVersion'] = self.hot_topic_version
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('HotTopicVersion') is not None:
            self.hot_topic_version = m.get('HotTopicVersion')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetCustomHotTopicBroadcastJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetCustomHotTopicBroadcastJobResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetCustomHotTopicBroadcastJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetCustomHotTopicBroadcastJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCustomHotTopicBroadcastJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCustomHotTopicBroadcastJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCustomSourceTopicAnalysisTaskRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetCustomSourceTopicAnalysisTaskResponseBodyDataClusterResultsClusterNews(TeaModel):
    def __init__(
        self,
        title: str = None,
        url: str = None,
    ):
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetCustomSourceTopicAnalysisTaskResponseBodyDataClusterResults(TeaModel):
    def __init__(
        self,
        cluster_news: List[GetCustomSourceTopicAnalysisTaskResponseBodyDataClusterResultsClusterNews] = None,
        topic: str = None,
    ):
        self.cluster_news = cluster_news
        self.topic = topic

    def validate(self):
        if self.cluster_news:
            for k in self.cluster_news:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ClusterNews'] = []
        if self.cluster_news is not None:
            for k in self.cluster_news:
                result['ClusterNews'].append(k.to_map() if k else None)
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cluster_news = []
        if m.get('ClusterNews') is not None:
            for k in m.get('ClusterNews'):
                temp_model = GetCustomSourceTopicAnalysisTaskResponseBodyDataClusterResultsClusterNews()
                self.cluster_news.append(temp_model.from_map(k))
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class GetCustomSourceTopicAnalysisTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        cluster_count: int = None,
        cluster_results: List[GetCustomSourceTopicAnalysisTaskResponseBodyDataClusterResults] = None,
        error_message: str = None,
        max_clustered_topic_news_size: int = None,
        parsed_news_size: int = None,
        status: str = None,
        rt: int = None,
        usages: Dict[str, int] = None,
    ):
        self.cluster_count = cluster_count
        self.cluster_results = cluster_results
        self.error_message = error_message
        self.max_clustered_topic_news_size = max_clustered_topic_news_size
        self.parsed_news_size = parsed_news_size
        self.status = status
        self.rt = rt
        self.usages = usages

    def validate(self):
        if self.cluster_results:
            for k in self.cluster_results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_count is not None:
            result['ClusterCount'] = self.cluster_count
        result['ClusterResults'] = []
        if self.cluster_results is not None:
            for k in self.cluster_results:
                result['ClusterResults'].append(k.to_map() if k else None)
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.max_clustered_topic_news_size is not None:
            result['MaxClusteredTopicNewsSize'] = self.max_clustered_topic_news_size
        if self.parsed_news_size is not None:
            result['ParsedNewsSize'] = self.parsed_news_size
        if self.status is not None:
            result['Status'] = self.status
        if self.rt is not None:
            result['rt'] = self.rt
        if self.usages is not None:
            result['usages'] = self.usages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterCount') is not None:
            self.cluster_count = m.get('ClusterCount')
        self.cluster_results = []
        if m.get('ClusterResults') is not None:
            for k in m.get('ClusterResults'):
                temp_model = GetCustomSourceTopicAnalysisTaskResponseBodyDataClusterResults()
                self.cluster_results.append(temp_model.from_map(k))
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MaxClusteredTopicNewsSize') is not None:
            self.max_clustered_topic_news_size = m.get('MaxClusteredTopicNewsSize')
        if m.get('ParsedNewsSize') is not None:
            self.parsed_news_size = m.get('ParsedNewsSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('rt') is not None:
            self.rt = m.get('rt')
        if m.get('usages') is not None:
            self.usages = m.get('usages')
        return self


class GetCustomSourceTopicAnalysisTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetCustomSourceTopicAnalysisTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetCustomSourceTopicAnalysisTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetCustomSourceTopicAnalysisTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCustomSourceTopicAnalysisTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCustomSourceTopicAnalysisTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCustomTextRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        commodity_code: str = None,
        id: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.commodity_code = commodity_code
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetCustomTextResponseBodyData(TeaModel):
    def __init__(
        self,
        content: str = None,
        create_time: str = None,
        create_user: str = None,
        id: int = None,
        title: str = None,
        update_time: str = None,
        update_user: str = None,
    ):
        self.content = content
        self.create_time = create_time
        self.create_user = create_user
        self.id = id
        self.title = title
        self.update_time = update_time
        self.update_user = update_user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.id is not None:
            result['Id'] = self.id
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_user is not None:
            result['UpdateUser'] = self.update_user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateUser') is not None:
            self.update_user = m.get('UpdateUser')
        return self


class GetCustomTextResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetCustomTextResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetCustomTextResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetCustomTextResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCustomTextResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCustomTextResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCustomTopicSelectionPerspectiveAnalysisTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPointsOutlines(TeaModel):
    def __init__(
        self,
        outline: str = None,
        summary: str = None,
    ):
        self.outline = outline
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.outline is not None:
            result['Outline'] = self.outline
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPoints(TeaModel):
    def __init__(
        self,
        outlines: List[GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPointsOutlines] = None,
        point: str = None,
        summary: str = None,
    ):
        self.outlines = outlines
        self.point = point
        self.summary = summary

    def validate(self):
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.point is not None:
            result['Point'] = self.point
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPointsOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Point') is not None:
            self.point = m.get('Point')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudes(TeaModel):
    def __init__(
        self,
        attitude: str = None,
        attitude_type: str = None,
        ratio: str = None,
        view_points: List[GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPoints] = None,
    ):
        self.attitude = attitude
        self.attitude_type = attitude_type
        self.ratio = ratio
        self.view_points = view_points

    def validate(self):
        if self.view_points:
            for k in self.view_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.attitude_type is not None:
            result['AttitudeType'] = self.attitude_type
        if self.ratio is not None:
            result['Ratio'] = self.ratio
        result['ViewPoints'] = []
        if self.view_points is not None:
            for k in self.view_points:
                result['ViewPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('AttitudeType') is not None:
            self.attitude_type = m.get('AttitudeType')
        if m.get('Ratio') is not None:
            self.ratio = m.get('Ratio')
        self.view_points = []
        if m.get('ViewPoints') is not None:
            for k in m.get('ViewPoints'):
                temp_model = GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPoints()
                self.view_points.append(temp_model.from_map(k))
        return self


class GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResult(TeaModel):
    def __init__(
        self,
        attitudes: List[GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudes] = None,
        topic: str = None,
    ):
        self.attitudes = attitudes
        self.topic = topic

    def validate(self):
        if self.attitudes:
            for k in self.attitudes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attitudes'] = []
        if self.attitudes is not None:
            for k in self.attitudes:
                result['Attitudes'].append(k.to_map() if k else None)
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attitudes = []
        if m.get('Attitudes') is not None:
            for k in m.get('Attitudes'):
                temp_model = GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudes()
                self.attitudes.append(temp_model.from_map(k))
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        custom_view_points_result: GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResult = None,
        error_message: str = None,
        status: str = None,
    ):
        self.custom_view_points_result = custom_view_points_result
        self.error_message = error_message
        self.status = status

    def validate(self):
        if self.custom_view_points_result:
            self.custom_view_points_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_view_points_result is not None:
            result['CustomViewPointsResult'] = self.custom_view_points_result.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomViewPointsResult') is not None:
            temp_model = GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResult()
            self.custom_view_points_result = temp_model.from_map(m['CustomViewPointsResult'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetCustomTopicSelectionPerspectiveAnalysisTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataSourceOrderConfigRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        generate_technology: str = None,
        product_code: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.generate_technology = generate_technology
        # This parameter is required.
        self.product_code = product_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.generate_technology is not None:
            result['GenerateTechnology'] = self.generate_technology
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('GenerateTechnology') is not None:
            self.generate_technology = m.get('GenerateTechnology')
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        return self


class GetDataSourceOrderConfigResponseBodyDataUserConfigDataSourceList(TeaModel):
    def __init__(
        self,
        code: str = None,
        enable: bool = None,
        name: str = None,
        number: int = None,
        type: str = None,
    ):
        self.code = code
        self.enable = enable
        self.name = name
        self.number = number
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.name is not None:
            result['Name'] = self.name
        if self.number is not None:
            result['Number'] = self.number
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataSourceOrderConfigResponseBodyData(TeaModel):
    def __init__(
        self,
        total_doc_size: int = None,
        user_config_data_source_list: List[GetDataSourceOrderConfigResponseBodyDataUserConfigDataSourceList] = None,
    ):
        self.total_doc_size = total_doc_size
        self.user_config_data_source_list = user_config_data_source_list

    def validate(self):
        if self.user_config_data_source_list:
            for k in self.user_config_data_source_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_doc_size is not None:
            result['TotalDocSize'] = self.total_doc_size
        result['UserConfigDataSourceList'] = []
        if self.user_config_data_source_list is not None:
            for k in self.user_config_data_source_list:
                result['UserConfigDataSourceList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TotalDocSize') is not None:
            self.total_doc_size = m.get('TotalDocSize')
        self.user_config_data_source_list = []
        if m.get('UserConfigDataSourceList') is not None:
            for k in m.get('UserConfigDataSourceList'):
                temp_model = GetDataSourceOrderConfigResponseBodyDataUserConfigDataSourceList()
                self.user_config_data_source_list.append(temp_model.from_map(k))
        return self


class GetDataSourceOrderConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetDataSourceOrderConfigResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetDataSourceOrderConfigResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataSourceOrderConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataSourceOrderConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataSourceOrderConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDatasetRequest(TeaModel):
    def __init__(
        self,
        dataset_id: int = None,
        dataset_name: str = None,
        workspace_id: str = None,
    ):
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        value_format: str = None,
        value_type: str = None,
    ):
        self.name = name
        self.value = value
        self.value_format = value_format
        self.value_type = value_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        if self.value_format is not None:
            result['ValueFormat'] = self.value_format
        if self.value_type is not None:
            result['ValueType'] = self.value_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('ValueFormat') is not None:
            self.value_format = m.get('ValueFormat')
        if m.get('ValueType') is not None:
            self.value_type = m.get('ValueType')
        return self


class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        value_format: str = None,
        value_type: str = None,
    ):
        self.name = name
        self.value = value
        self.value_format = value_format
        self.value_type = value_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        if self.value_format is not None:
            result['ValueFormat'] = self.value_format
        if self.value_type is not None:
            result['ValueType'] = self.value_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('ValueFormat') is not None:
            self.value_format = m.get('ValueFormat')
        if m.get('ValueType') is not None:
            self.value_type = m.get('ValueType')
        return self


class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfig(TeaModel):
    def __init__(
        self,
        body: str = None,
        connect_timeout: int = None,
        headers: List[GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders] = None,
        method: str = None,
        params: List[GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams] = None,
        path_params_enable: bool = None,
        socket_timeout: int = None,
        url: str = None,
    ):
        self.body = body
        self.connect_timeout = connect_timeout
        self.headers = headers
        self.method = method
        self.params = params
        self.path_params_enable = path_params_enable
        self.socket_timeout = socket_timeout
        self.url = url

    def validate(self):
        if self.headers:
            for k in self.headers:
                if k:
                    k.validate()
        if self.params:
            for k in self.params:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['Body'] = self.body
        if self.connect_timeout is not None:
            result['ConnectTimeout'] = self.connect_timeout
        result['Headers'] = []
        if self.headers is not None:
            for k in self.headers:
                result['Headers'].append(k.to_map() if k else None)
        if self.method is not None:
            result['Method'] = self.method
        result['Params'] = []
        if self.params is not None:
            for k in self.params:
                result['Params'].append(k.to_map() if k else None)
        if self.path_params_enable is not None:
            result['PathParamsEnable'] = self.path_params_enable
        if self.socket_timeout is not None:
            result['SocketTimeout'] = self.socket_timeout
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Body') is not None:
            self.body = m.get('Body')
        if m.get('ConnectTimeout') is not None:
            self.connect_timeout = m.get('ConnectTimeout')
        self.headers = []
        if m.get('Headers') is not None:
            for k in m.get('Headers'):
                temp_model = GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders()
                self.headers.append(temp_model.from_map(k))
        if m.get('Method') is not None:
            self.method = m.get('Method')
        self.params = []
        if m.get('Params') is not None:
            for k in m.get('Params'):
                temp_model = GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams()
                self.params.append(temp_model.from_map(k))
        if m.get('PathParamsEnable') is not None:
            self.path_params_enable = m.get('PathParamsEnable')
        if m.get('SocketTimeout') is not None:
            self.socket_timeout = m.get('SocketTimeout')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes(TeaModel):
    def __init__(
        self,
        key: str = None,
        path: str = None,
        type: str = None,
    ):
        self.key = key
        self.path = path
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes(TeaModel):
    def __init__(
        self,
        jq_nodes: List[GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes] = None,
        key: str = None,
        path: str = None,
        type: str = None,
    ):
        self.jq_nodes = jq_nodes
        self.key = key
        self.path = path
        self.type = type

    def validate(self):
        if self.jq_nodes:
            for k in self.jq_nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JqNodes'] = []
        if self.jq_nodes is not None:
            for k in self.jq_nodes:
                result['JqNodes'].append(k.to_map() if k else None)
        if self.key is not None:
            result['Key'] = self.key
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jq_nodes = []
        if m.get('JqNodes') is not None:
            for k in m.get('JqNodes'):
                temp_model = GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes()
                self.jq_nodes.append(temp_model.from_map(k))
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes(TeaModel):
    def __init__(
        self,
        jq_nodes: List[GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes] = None,
        key: str = None,
        path: str = None,
        type: str = None,
    ):
        self.jq_nodes = jq_nodes
        self.key = key
        self.path = path
        self.type = type

    def validate(self):
        if self.jq_nodes:
            for k in self.jq_nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JqNodes'] = []
        if self.jq_nodes is not None:
            for k in self.jq_nodes:
                result['JqNodes'].append(k.to_map() if k else None)
        if self.key is not None:
            result['Key'] = self.key
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jq_nodes = []
        if m.get('JqNodes') is not None:
            for k in m.get('JqNodes'):
                temp_model = GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes()
                self.jq_nodes.append(temp_model.from_map(k))
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfig(TeaModel):
    def __init__(
        self,
        jq_nodes: List[GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes] = None,
    ):
        self.jq_nodes = jq_nodes

    def validate(self):
        if self.jq_nodes:
            for k in self.jq_nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JqNodes'] = []
        if self.jq_nodes is not None:
            for k in self.jq_nodes:
                result['JqNodes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jq_nodes = []
        if m.get('JqNodes') is not None:
            for k in m.get('JqNodes'):
                temp_model = GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes()
                self.jq_nodes.append(temp_model.from_map(k))
        return self


class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigs(TeaModel):
    def __init__(
        self,
        demo_query: str = None,
        search_source_request_config: GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfig = None,
        search_source_response_config: GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfig = None,
        size: int = None,
    ):
        self.demo_query = demo_query
        self.search_source_request_config = search_source_request_config
        self.search_source_response_config = search_source_response_config
        self.size = size

    def validate(self):
        if self.search_source_request_config:
            self.search_source_request_config.validate()
        if self.search_source_response_config:
            self.search_source_response_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.demo_query is not None:
            result['DemoQuery'] = self.demo_query
        if self.search_source_request_config is not None:
            result['SearchSourceRequestConfig'] = self.search_source_request_config.to_map()
        if self.search_source_response_config is not None:
            result['SearchSourceResponseConfig'] = self.search_source_response_config.to_map()
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DemoQuery') is not None:
            self.demo_query = m.get('DemoQuery')
        if m.get('SearchSourceRequestConfig') is not None:
            temp_model = GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfig()
            self.search_source_request_config = temp_model.from_map(m['SearchSourceRequestConfig'])
        if m.get('SearchSourceResponseConfig') is not None:
            temp_model = GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfig()
            self.search_source_response_config = temp_model.from_map(m['SearchSourceResponseConfig'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class GetDatasetResponseBodyDataDatasetConfig(TeaModel):
    def __init__(
        self,
        search_source_configs: List[GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigs] = None,
    ):
        self.search_source_configs = search_source_configs

    def validate(self):
        if self.search_source_configs:
            for k in self.search_source_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchSourceConfigs'] = []
        if self.search_source_configs is not None:
            for k in self.search_source_configs:
                result['SearchSourceConfigs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.search_source_configs = []
        if m.get('SearchSourceConfigs') is not None:
            for k in m.get('SearchSourceConfigs'):
                temp_model = GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigs()
                self.search_source_configs.append(temp_model.from_map(k))
        return self


class GetDatasetResponseBodyDataDocumentHandleConfig(TeaModel):
    def __init__(
        self,
        disable_handle_multimodal_media: bool = None,
    ):
        self.disable_handle_multimodal_media = disable_handle_multimodal_media

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disable_handle_multimodal_media is not None:
            result['DisableHandleMultimodalMedia'] = self.disable_handle_multimodal_media
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DisableHandleMultimodalMedia') is not None:
            self.disable_handle_multimodal_media = m.get('DisableHandleMultimodalMedia')
        return self


class GetDatasetResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_user: str = None,
        dataset_config: GetDatasetResponseBodyDataDatasetConfig = None,
        dataset_description: str = None,
        dataset_id: int = None,
        dataset_name: str = None,
        dataset_type: str = None,
        document_handle_config: GetDatasetResponseBodyDataDocumentHandleConfig = None,
        search_dataset_enable: int = None,
    ):
        self.create_time = create_time
        self.create_user = create_user
        self.dataset_config = dataset_config
        self.dataset_description = dataset_description
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        self.dataset_type = dataset_type
        self.document_handle_config = document_handle_config
        self.search_dataset_enable = search_dataset_enable

    def validate(self):
        if self.dataset_config:
            self.dataset_config.validate()
        if self.document_handle_config:
            self.document_handle_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.dataset_config is not None:
            result['DatasetConfig'] = self.dataset_config.to_map()
        if self.dataset_description is not None:
            result['DatasetDescription'] = self.dataset_description
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.dataset_type is not None:
            result['DatasetType'] = self.dataset_type
        if self.document_handle_config is not None:
            result['DocumentHandleConfig'] = self.document_handle_config.to_map()
        if self.search_dataset_enable is not None:
            result['SearchDatasetEnable'] = self.search_dataset_enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DatasetConfig') is not None:
            temp_model = GetDatasetResponseBodyDataDatasetConfig()
            self.dataset_config = temp_model.from_map(m['DatasetConfig'])
        if m.get('DatasetDescription') is not None:
            self.dataset_description = m.get('DatasetDescription')
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('DatasetType') is not None:
            self.dataset_type = m.get('DatasetType')
        if m.get('DocumentHandleConfig') is not None:
            temp_model = GetDatasetResponseBodyDataDocumentHandleConfig()
            self.document_handle_config = temp_model.from_map(m['DocumentHandleConfig'])
        if m.get('SearchDatasetEnable') is not None:
            self.search_dataset_enable = m.get('SearchDatasetEnable')
        return self


class GetDatasetResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetDatasetResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetDatasetResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDatasetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDatasetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDatasetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDatasetDocumentRequest(TeaModel):
    def __init__(
        self,
        dataset_id: int = None,
        dataset_name: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        workspace_id: str = None,
    ):
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetDatasetDocumentResponseBodyData(TeaModel):
    def __init__(
        self,
        content: str = None,
        disable_handle_multimodal_media: bool = None,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        source_from: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.content = content
        self.disable_handle_multimodal_media = disable_handle_multimodal_media
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.source_from = source_from
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.disable_handle_multimodal_media is not None:
            result['DisableHandleMultimodalMedia'] = self.disable_handle_multimodal_media
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source_from is not None:
            result['SourceFrom'] = self.source_from
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DisableHandleMultimodalMedia') is not None:
            self.disable_handle_multimodal_media = m.get('DisableHandleMultimodalMedia')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('SourceFrom') is not None:
            self.source_from = m.get('SourceFrom')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetDatasetDocumentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetDatasetDocumentResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetDatasetDocumentResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDatasetDocumentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDatasetDocumentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDatasetDocumentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDocClusterTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetDocClusterTaskResponseBodyDataTopics(TeaModel):
    def __init__(
        self,
        doc_ids: List[str] = None,
        summary: str = None,
        title: str = None,
    ):
        self.doc_ids = doc_ids
        self.summary = summary
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_ids is not None:
            result['DocIds'] = self.doc_ids
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocIds') is not None:
            self.doc_ids = m.get('DocIds')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetDocClusterTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        error_message: str = None,
        status: str = None,
        topics: List[GetDocClusterTaskResponseBodyDataTopics] = None,
    ):
        self.error_message = error_message
        self.status = status
        self.topics = topics

    def validate(self):
        if self.topics:
            for k in self.topics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.status is not None:
            result['Status'] = self.status
        result['Topics'] = []
        if self.topics is not None:
            for k in self.topics:
                result['Topics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.topics = []
        if m.get('Topics') is not None:
            for k in m.get('Topics'):
                temp_model = GetDocClusterTaskResponseBodyDataTopics()
                self.topics.append(temp_model.from_map(k))
        return self


class GetDocClusterTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetDocClusterTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetDocClusterTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDocClusterTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDocClusterTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDocClusterTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDocInfoRequest(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        doc_id: str = None,
        workspace_id: str = None,
    ):
        self.category_id = category_id
        # This parameter is required.
        self.doc_id = doc_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetDocInfoResponseBodyData(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        doc_name: str = None,
        doc_type: str = None,
        file_url: str = None,
        status: int = None,
        status_message: str = None,
        video_contents: List[str] = None,
    ):
        self.category_id = category_id
        self.doc_name = doc_name
        self.doc_type = doc_type
        self.file_url = file_url
        self.status = status
        self.status_message = status_message
        self.video_contents = video_contents

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.doc_name is not None:
            result['DocName'] = self.doc_name
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.status is not None:
            result['Status'] = self.status
        if self.status_message is not None:
            result['StatusMessage'] = self.status_message
        if self.video_contents is not None:
            result['VideoContents'] = self.video_contents
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('DocName') is not None:
            self.doc_name = m.get('DocName')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusMessage') is not None:
            self.status_message = m.get('StatusMessage')
        if m.get('VideoContents') is not None:
            self.video_contents = m.get('VideoContents')
        return self


class GetDocInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetDocInfoResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetDocInfoResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDocInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDocInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDocInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEnterpriseVocAnalysisTaskRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatisticsTagValueCountStatistic(TeaModel):
    def __init__(
        self,
        tag_name: str = None,
        tag_task_type: str = None,
        value_count: int = None,
    ):
        self.tag_name = tag_name
        self.tag_task_type = tag_task_type
        self.value_count = value_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.tag_task_type is not None:
            result['TagTaskType'] = self.tag_task_type
        if self.value_count is not None:
            result['ValueCount'] = self.value_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('TagTaskType') is not None:
            self.tag_task_type = m.get('TagTaskType')
        if m.get('ValueCount') is not None:
            self.value_count = m.get('ValueCount')
        return self


class GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatistics(TeaModel):
    def __init__(
        self,
        tag_value_count_statistic: List[GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatisticsTagValueCountStatistic] = None,
    ):
        self.tag_value_count_statistic = tag_value_count_statistic

    def validate(self):
        if self.tag_value_count_statistic:
            for k in self.tag_value_count_statistic:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TagValueCountStatistic'] = []
        if self.tag_value_count_statistic is not None:
            for k in self.tag_value_count_statistic:
                result['TagValueCountStatistic'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tag_value_count_statistic = []
        if m.get('TagValueCountStatistic') is not None:
            for k in m.get('TagValueCountStatistic'):
                temp_model = GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatisticsTagValueCountStatistic()
                self.tag_value_count_statistic.append(temp_model.from_map(k))
        return self


class GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatisticsTagValueCountStatistic(TeaModel):
    def __init__(
        self,
        tag_name: str = None,
        tag_task_type: str = None,
        value_count: int = None,
    ):
        self.tag_name = tag_name
        self.tag_task_type = tag_task_type
        self.value_count = value_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.tag_task_type is not None:
            result['TagTaskType'] = self.tag_task_type
        if self.value_count is not None:
            result['ValueCount'] = self.value_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('TagTaskType') is not None:
            self.tag_task_type = m.get('TagTaskType')
        if m.get('ValueCount') is not None:
            self.value_count = m.get('ValueCount')
        return self


class GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatistics(TeaModel):
    def __init__(
        self,
        tag_value_count_statistic: List[GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatisticsTagValueCountStatistic] = None,
    ):
        self.tag_value_count_statistic = tag_value_count_statistic

    def validate(self):
        if self.tag_value_count_statistic:
            for k in self.tag_value_count_statistic:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TagValueCountStatistic'] = []
        if self.tag_value_count_statistic is not None:
            for k in self.tag_value_count_statistic:
                result['TagValueCountStatistic'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tag_value_count_statistic = []
        if m.get('TagValueCountStatistic') is not None:
            for k in m.get('TagValueCountStatistic'):
                temp_model = GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatisticsTagValueCountStatistic()
                self.tag_value_count_statistic.append(temp_model.from_map(k))
        return self


class GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverview(TeaModel):
    def __init__(
        self,
        count: int = None,
        filter_dimension_statistics: GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatistics = None,
        tag_dimension_statistics: GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatistics = None,
    ):
        self.count = count
        self.filter_dimension_statistics = filter_dimension_statistics
        self.tag_dimension_statistics = tag_dimension_statistics

    def validate(self):
        if self.filter_dimension_statistics:
            self.filter_dimension_statistics.validate()
        if self.tag_dimension_statistics:
            self.tag_dimension_statistics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.filter_dimension_statistics is not None:
            result['FilterDimensionStatistics'] = self.filter_dimension_statistics.to_map()
        if self.tag_dimension_statistics is not None:
            result['TagDimensionStatistics'] = self.tag_dimension_statistics.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('FilterDimensionStatistics') is not None:
            temp_model = GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatistics()
            self.filter_dimension_statistics = temp_model.from_map(m['FilterDimensionStatistics'])
        if m.get('TagDimensionStatistics') is not None:
            temp_model = GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatistics()
            self.tag_dimension_statistics = temp_model.from_map(m['TagDimensionStatistics'])
        return self


class GetEnterpriseVocAnalysisTaskResponseBodyDataUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        return self


class GetEnterpriseVocAnalysisTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        error_message: str = None,
        statistics_overview: GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverview = None,
        status: str = None,
        usage: GetEnterpriseVocAnalysisTaskResponseBodyDataUsage = None,
    ):
        self.error_message = error_message
        self.statistics_overview = statistics_overview
        self.status = status
        self.usage = usage

    def validate(self):
        if self.statistics_overview:
            self.statistics_overview.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.statistics_overview is not None:
            result['StatisticsOverview'] = self.statistics_overview.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('StatisticsOverview') is not None:
            temp_model = GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverview()
            self.statistics_overview = temp_model.from_map(m['StatisticsOverview'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Usage') is not None:
            temp_model = GetEnterpriseVocAnalysisTaskResponseBodyDataUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class GetEnterpriseVocAnalysisTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetEnterpriseVocAnalysisTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetEnterpriseVocAnalysisTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetEnterpriseVocAnalysisTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEnterpriseVocAnalysisTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEnterpriseVocAnalysisTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFactAuditUrlRequest(TeaModel):
    def __init__(
        self,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetFactAuditUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[str] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        # This parameter is required.
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetFactAuditUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFactAuditUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFactAuditUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileContentLengthRequest(TeaModel):
    def __init__(
        self,
        doc_name: str = None,
        file_url: str = None,
        workspace_id: str = None,
    ):
        self.doc_name = doc_name
        self.file_url = file_url
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_name is not None:
            result['DocName'] = self.doc_name
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocName') is not None:
            self.doc_name = m.get('DocName')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetFileContentLengthResponseBodyData(TeaModel):
    def __init__(
        self,
        word_num: int = None,
    ):
        self.word_num = word_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.word_num is not None:
            result['WordNum'] = self.word_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WordNum') is not None:
            self.word_num = m.get('WordNum')
        return self


class GetFileContentLengthResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetFileContentLengthResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetFileContentLengthResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetFileContentLengthResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFileContentLengthResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFileContentLengthResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetGeneratedContentRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        id: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetGeneratedContentResponseBodyData(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_domain: str = None,
        content_text: str = None,
        create_time: str = None,
        create_user: str = None,
        device_id: str = None,
        id: int = None,
        ignore_content_audit_words: str = None,
        keyword_list: List[str] = None,
        keywords: str = None,
        prompt: str = None,
        task_id: str = None,
        title: str = None,
        update_time: str = None,
        update_user: str = None,
        uuid: str = None,
    ):
        self.content = content
        self.content_domain = content_domain
        self.content_text = content_text
        self.create_time = create_time
        self.create_user = create_user
        self.device_id = device_id
        self.id = id
        self.ignore_content_audit_words = ignore_content_audit_words
        self.keyword_list = keyword_list
        self.keywords = keywords
        self.prompt = prompt
        self.task_id = task_id
        self.title = title
        self.update_time = update_time
        self.update_user = update_user
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.content_domain is not None:
            result['ContentDomain'] = self.content_domain
        if self.content_text is not None:
            result['ContentText'] = self.content_text
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.id is not None:
            result['Id'] = self.id
        if self.ignore_content_audit_words is not None:
            result['IgnoreContentAuditWords'] = self.ignore_content_audit_words
        if self.keyword_list is not None:
            result['KeywordList'] = self.keyword_list
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_user is not None:
            result['UpdateUser'] = self.update_user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentDomain') is not None:
            self.content_domain = m.get('ContentDomain')
        if m.get('ContentText') is not None:
            self.content_text = m.get('ContentText')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IgnoreContentAuditWords') is not None:
            self.ignore_content_audit_words = m.get('IgnoreContentAuditWords')
        if m.get('KeywordList') is not None:
            self.keyword_list = m.get('KeywordList')
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateUser') is not None:
            self.update_user = m.get('UpdateUser')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class GetGeneratedContentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetGeneratedContentResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetGeneratedContentResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetGeneratedContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetGeneratedContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetGeneratedContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetHotTopicBroadcastRequestStepForCustomSummaryStyleConfig(TeaModel):
    def __init__(
        self,
        summary_image_count: int = None,
        summary_model: str = None,
        summary_prompt: str = None,
    ):
        self.summary_image_count = summary_image_count
        self.summary_model = summary_model
        self.summary_prompt = summary_prompt

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.summary_image_count is not None:
            result['SummaryImageCount'] = self.summary_image_count
        if self.summary_model is not None:
            result['SummaryModel'] = self.summary_model
        if self.summary_prompt is not None:
            result['SummaryPrompt'] = self.summary_prompt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SummaryImageCount') is not None:
            self.summary_image_count = m.get('SummaryImageCount')
        if m.get('SummaryModel') is not None:
            self.summary_model = m.get('SummaryModel')
        if m.get('SummaryPrompt') is not None:
            self.summary_prompt = m.get('SummaryPrompt')
        return self


class GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfigCustomHotValueWeights(TeaModel):
    def __init__(
        self,
        dimension: str = None,
        weight: int = None,
    ):
        self.dimension = dimension
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dimension is not None:
            result['Dimension'] = self.dimension
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dimension') is not None:
            self.dimension = m.get('Dimension')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfig(TeaModel):
    def __init__(
        self,
        categories: List[str] = None,
        custom_hot_value_weights: List[GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfigCustomHotValueWeights] = None,
        topic_count: int = None,
    ):
        self.categories = categories
        self.custom_hot_value_weights = custom_hot_value_weights
        self.topic_count = topic_count

    def validate(self):
        if self.custom_hot_value_weights:
            for k in self.custom_hot_value_weights:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.categories is not None:
            result['Categories'] = self.categories
        result['CustomHotValueWeights'] = []
        if self.custom_hot_value_weights is not None:
            for k in self.custom_hot_value_weights:
                result['CustomHotValueWeights'].append(k.to_map() if k else None)
        if self.topic_count is not None:
            result['TopicCount'] = self.topic_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Categories') is not None:
            self.categories = m.get('Categories')
        self.custom_hot_value_weights = []
        if m.get('CustomHotValueWeights') is not None:
            for k in m.get('CustomHotValueWeights'):
                temp_model = GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfigCustomHotValueWeights()
                self.custom_hot_value_weights.append(temp_model.from_map(k))
        if m.get('TopicCount') is not None:
            self.topic_count = m.get('TopicCount')
        return self


class GetHotTopicBroadcastRequest(TeaModel):
    def __init__(
        self,
        calc_total_token: bool = None,
        category: str = None,
        current: int = None,
        hot_topic_version: str = None,
        location_query: str = None,
        locations: List[str] = None,
        query: str = None,
        size: int = None,
        step_for_custom_summary_style_config: GetHotTopicBroadcastRequestStepForCustomSummaryStyleConfig = None,
        step_for_news_broadcast_content_config: GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfig = None,
        topics: List[str] = None,
        workspace_id: str = None,
    ):
        self.calc_total_token = calc_total_token
        self.category = category
        self.current = current
        self.hot_topic_version = hot_topic_version
        self.location_query = location_query
        self.locations = locations
        self.query = query
        self.size = size
        self.step_for_custom_summary_style_config = step_for_custom_summary_style_config
        self.step_for_news_broadcast_content_config = step_for_news_broadcast_content_config
        self.topics = topics
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.step_for_custom_summary_style_config:
            self.step_for_custom_summary_style_config.validate()
        if self.step_for_news_broadcast_content_config:
            self.step_for_news_broadcast_content_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calc_total_token is not None:
            result['CalcTotalToken'] = self.calc_total_token
        if self.category is not None:
            result['Category'] = self.category
        if self.current is not None:
            result['Current'] = self.current
        if self.hot_topic_version is not None:
            result['HotTopicVersion'] = self.hot_topic_version
        if self.location_query is not None:
            result['LocationQuery'] = self.location_query
        if self.locations is not None:
            result['Locations'] = self.locations
        if self.query is not None:
            result['Query'] = self.query
        if self.size is not None:
            result['Size'] = self.size
        if self.step_for_custom_summary_style_config is not None:
            result['StepForCustomSummaryStyleConfig'] = self.step_for_custom_summary_style_config.to_map()
        if self.step_for_news_broadcast_content_config is not None:
            result['StepForNewsBroadcastContentConfig'] = self.step_for_news_broadcast_content_config.to_map()
        if self.topics is not None:
            result['Topics'] = self.topics
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalcTotalToken') is not None:
            self.calc_total_token = m.get('CalcTotalToken')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('HotTopicVersion') is not None:
            self.hot_topic_version = m.get('HotTopicVersion')
        if m.get('LocationQuery') is not None:
            self.location_query = m.get('LocationQuery')
        if m.get('Locations') is not None:
            self.locations = m.get('Locations')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StepForCustomSummaryStyleConfig') is not None:
            temp_model = GetHotTopicBroadcastRequestStepForCustomSummaryStyleConfig()
            self.step_for_custom_summary_style_config = temp_model.from_map(m['StepForCustomSummaryStyleConfig'])
        if m.get('StepForNewsBroadcastContentConfig') is not None:
            temp_model = GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfig()
            self.step_for_news_broadcast_content_config = temp_model.from_map(m['StepForNewsBroadcastContentConfig'])
        if m.get('Topics') is not None:
            self.topics = m.get('Topics')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetHotTopicBroadcastShrinkRequest(TeaModel):
    def __init__(
        self,
        calc_total_token: bool = None,
        category: str = None,
        current: int = None,
        hot_topic_version: str = None,
        location_query: str = None,
        locations_shrink: str = None,
        query: str = None,
        size: int = None,
        step_for_custom_summary_style_config_shrink: str = None,
        step_for_news_broadcast_content_config_shrink: str = None,
        topics_shrink: str = None,
        workspace_id: str = None,
    ):
        self.calc_total_token = calc_total_token
        self.category = category
        self.current = current
        self.hot_topic_version = hot_topic_version
        self.location_query = location_query
        self.locations_shrink = locations_shrink
        self.query = query
        self.size = size
        self.step_for_custom_summary_style_config_shrink = step_for_custom_summary_style_config_shrink
        self.step_for_news_broadcast_content_config_shrink = step_for_news_broadcast_content_config_shrink
        self.topics_shrink = topics_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.calc_total_token is not None:
            result['CalcTotalToken'] = self.calc_total_token
        if self.category is not None:
            result['Category'] = self.category
        if self.current is not None:
            result['Current'] = self.current
        if self.hot_topic_version is not None:
            result['HotTopicVersion'] = self.hot_topic_version
        if self.location_query is not None:
            result['LocationQuery'] = self.location_query
        if self.locations_shrink is not None:
            result['Locations'] = self.locations_shrink
        if self.query is not None:
            result['Query'] = self.query
        if self.size is not None:
            result['Size'] = self.size
        if self.step_for_custom_summary_style_config_shrink is not None:
            result['StepForCustomSummaryStyleConfig'] = self.step_for_custom_summary_style_config_shrink
        if self.step_for_news_broadcast_content_config_shrink is not None:
            result['StepForNewsBroadcastContentConfig'] = self.step_for_news_broadcast_content_config_shrink
        if self.topics_shrink is not None:
            result['Topics'] = self.topics_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CalcTotalToken') is not None:
            self.calc_total_token = m.get('CalcTotalToken')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('HotTopicVersion') is not None:
            self.hot_topic_version = m.get('HotTopicVersion')
        if m.get('LocationQuery') is not None:
            self.location_query = m.get('LocationQuery')
        if m.get('Locations') is not None:
            self.locations_shrink = m.get('Locations')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StepForCustomSummaryStyleConfig') is not None:
            self.step_for_custom_summary_style_config_shrink = m.get('StepForCustomSummaryStyleConfig')
        if m.get('StepForNewsBroadcastContentConfig') is not None:
            self.step_for_news_broadcast_content_config_shrink = m.get('StepForNewsBroadcastContentConfig')
        if m.get('Topics') is not None:
            self.topics_shrink = m.get('Topics')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetHotTopicBroadcastResponseBodyDataDataImages(TeaModel):
    def __init__(
        self,
        url: str = None,
    ):
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetHotTopicBroadcastResponseBodyDataDataNewsComments(TeaModel):
    def __init__(
        self,
        text: str = None,
        username: str = None,
    ):
        self.text = text
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class GetHotTopicBroadcastResponseBodyDataDataNews(TeaModel):
    def __init__(
        self,
        analysis_category: str = None,
        analysis_topic: str = None,
        author: str = None,
        category: List[str] = None,
        comments: List[GetHotTopicBroadcastResponseBodyDataDataNewsComments] = None,
        content: str = None,
        create_time: str = None,
        domain: str = None,
        dt: str = None,
        hot_topic: str = None,
        img_list: List[str] = None,
        logo: str = None,
        pub_time: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
        uuid: str = None,
        website: str = None,
    ):
        self.analysis_category = analysis_category
        self.analysis_topic = analysis_topic
        self.author = author
        self.category = category
        self.comments = comments
        self.content = content
        self.create_time = create_time
        self.domain = domain
        self.dt = dt
        self.hot_topic = hot_topic
        self.img_list = img_list
        # logo
        self.logo = logo
        self.pub_time = pub_time
        self.summary = summary
        self.title = title
        self.url = url
        self.uuid = uuid
        self.website = website

    def validate(self):
        if self.comments:
            for k in self.comments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_category is not None:
            result['AnalysisCategory'] = self.analysis_category
        if self.analysis_topic is not None:
            result['AnalysisTopic'] = self.analysis_topic
        if self.author is not None:
            result['Author'] = self.author
        if self.category is not None:
            result['Category'] = self.category
        result['Comments'] = []
        if self.comments is not None:
            for k in self.comments:
                result['Comments'].append(k.to_map() if k else None)
        if self.content is not None:
            result['Content'] = self.content
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.dt is not None:
            result['Dt'] = self.dt
        if self.hot_topic is not None:
            result['HotTopic'] = self.hot_topic
        if self.img_list is not None:
            result['ImgList'] = self.img_list
        if self.logo is not None:
            result['Logo'] = self.logo
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.website is not None:
            result['Website'] = self.website
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisCategory') is not None:
            self.analysis_category = m.get('AnalysisCategory')
        if m.get('AnalysisTopic') is not None:
            self.analysis_topic = m.get('AnalysisTopic')
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        self.comments = []
        if m.get('Comments') is not None:
            for k in m.get('Comments'):
                temp_model = GetHotTopicBroadcastResponseBodyDataDataNewsComments()
                self.comments.append(temp_model.from_map(k))
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Dt') is not None:
            self.dt = m.get('Dt')
        if m.get('HotTopic') is not None:
            self.hot_topic = m.get('HotTopic')
        if m.get('ImgList') is not None:
            self.img_list = m.get('ImgList')
        if m.get('Logo') is not None:
            self.logo = m.get('Logo')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('Website') is not None:
            self.website = m.get('Website')
        return self


class GetHotTopicBroadcastResponseBodyDataDataSummarySummaries(TeaModel):
    def __init__(
        self,
        summary: str = None,
        title: str = None,
    ):
        self.summary = summary
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetHotTopicBroadcastResponseBodyDataDataSummary(TeaModel):
    def __init__(
        self,
        input_token: int = None,
        output_token: int = None,
        summaries: List[GetHotTopicBroadcastResponseBodyDataDataSummarySummaries] = None,
    ):
        self.input_token = input_token
        self.output_token = output_token
        self.summaries = summaries

    def validate(self):
        if self.summaries:
            for k in self.summaries:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_token is not None:
            result['InputToken'] = self.input_token
        if self.output_token is not None:
            result['OutputToken'] = self.output_token
        result['Summaries'] = []
        if self.summaries is not None:
            for k in self.summaries:
                result['Summaries'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputToken') is not None:
            self.input_token = m.get('InputToken')
        if m.get('OutputToken') is not None:
            self.output_token = m.get('OutputToken')
        self.summaries = []
        if m.get('Summaries') is not None:
            for k in m.get('Summaries'):
                temp_model = GetHotTopicBroadcastResponseBodyDataDataSummarySummaries()
                self.summaries.append(temp_model.from_map(k))
        return self


class GetHotTopicBroadcastResponseBodyDataData(TeaModel):
    def __init__(
        self,
        category: str = None,
        create_time: str = None,
        custom_hot_value: float = None,
        custom_text_summary: str = None,
        hot_topic: str = None,
        hot_topic_version: str = None,
        hot_value: float = None,
        id: str = None,
        images: List[GetHotTopicBroadcastResponseBodyDataDataImages] = None,
        input_token: int = None,
        locations: List[str] = None,
        news: List[GetHotTopicBroadcastResponseBodyDataDataNews] = None,
        output_token: int = None,
        pub_time: str = None,
        summary: GetHotTopicBroadcastResponseBodyDataDataSummary = None,
        text_summary: str = None,
        url: str = None,
    ):
        self.category = category
        self.create_time = create_time
        self.custom_hot_value = custom_hot_value
        self.custom_text_summary = custom_text_summary
        self.hot_topic = hot_topic
        self.hot_topic_version = hot_topic_version
        self.hot_value = hot_value
        self.id = id
        self.images = images
        self.input_token = input_token
        self.locations = locations
        self.news = news
        self.output_token = output_token
        self.pub_time = pub_time
        self.summary = summary
        self.text_summary = text_summary
        self.url = url

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.news:
            for k in self.news:
                if k:
                    k.validate()
        if self.summary:
            self.summary.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.custom_hot_value is not None:
            result['CustomHotValue'] = self.custom_hot_value
        if self.custom_text_summary is not None:
            result['CustomTextSummary'] = self.custom_text_summary
        if self.hot_topic is not None:
            result['HotTopic'] = self.hot_topic
        if self.hot_topic_version is not None:
            result['HotTopicVersion'] = self.hot_topic_version
        if self.hot_value is not None:
            result['HotValue'] = self.hot_value
        if self.id is not None:
            result['Id'] = self.id
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.input_token is not None:
            result['InputToken'] = self.input_token
        if self.locations is not None:
            result['Locations'] = self.locations
        result['News'] = []
        if self.news is not None:
            for k in self.news:
                result['News'].append(k.to_map() if k else None)
        if self.output_token is not None:
            result['OutputToken'] = self.output_token
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.summary is not None:
            result['Summary'] = self.summary.to_map()
        if self.text_summary is not None:
            result['TextSummary'] = self.text_summary
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CustomHotValue') is not None:
            self.custom_hot_value = m.get('CustomHotValue')
        if m.get('CustomTextSummary') is not None:
            self.custom_text_summary = m.get('CustomTextSummary')
        if m.get('HotTopic') is not None:
            self.hot_topic = m.get('HotTopic')
        if m.get('HotTopicVersion') is not None:
            self.hot_topic_version = m.get('HotTopicVersion')
        if m.get('HotValue') is not None:
            self.hot_value = m.get('HotValue')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = GetHotTopicBroadcastResponseBodyDataDataImages()
                self.images.append(temp_model.from_map(k))
        if m.get('InputToken') is not None:
            self.input_token = m.get('InputToken')
        if m.get('Locations') is not None:
            self.locations = m.get('Locations')
        self.news = []
        if m.get('News') is not None:
            for k in m.get('News'):
                temp_model = GetHotTopicBroadcastResponseBodyDataDataNews()
                self.news.append(temp_model.from_map(k))
        if m.get('OutputToken') is not None:
            self.output_token = m.get('OutputToken')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Summary') is not None:
            temp_model = GetHotTopicBroadcastResponseBodyDataDataSummary()
            self.summary = temp_model.from_map(m['Summary'])
        if m.get('TextSummary') is not None:
            self.text_summary = m.get('TextSummary')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetHotTopicBroadcastResponseBodyDataTotalTokenInfo(TeaModel):
    def __init__(
        self,
        hot_topic_count: int = None,
        input_tokens: int = None,
        output_tokens: int = None,
        word_count: int = None,
    ):
        self.hot_topic_count = hot_topic_count
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.word_count = word_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hot_topic_count is not None:
            result['HotTopicCount'] = self.hot_topic_count
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.word_count is not None:
            result['WordCount'] = self.word_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HotTopicCount') is not None:
            self.hot_topic_count = m.get('HotTopicCount')
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('WordCount') is not None:
            self.word_count = m.get('WordCount')
        return self


class GetHotTopicBroadcastResponseBodyData(TeaModel):
    def __init__(
        self,
        data: List[GetHotTopicBroadcastResponseBodyDataData] = None,
        total_count: int = None,
        total_token_info: GetHotTopicBroadcastResponseBodyDataTotalTokenInfo = None,
    ):
        self.data = data
        self.total_count = total_count
        self.total_token_info = total_token_info

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.total_token_info:
            self.total_token_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.total_token_info is not None:
            result['TotalTokenInfo'] = self.total_token_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetHotTopicBroadcastResponseBodyDataData()
                self.data.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('TotalTokenInfo') is not None:
            temp_model = GetHotTopicBroadcastResponseBodyDataTotalTokenInfo()
            self.total_token_info = temp_model.from_map(m['TotalTokenInfo'])
        return self


class GetHotTopicBroadcastResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetHotTopicBroadcastResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetHotTopicBroadcastResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetHotTopicBroadcastResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetHotTopicBroadcastResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetHotTopicBroadcastResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInterveneGlobalReplyRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        return self


class GetInterveneGlobalReplyResponseBodyDataReplyMessagList(TeaModel):
    def __init__(
        self,
        message: str = None,
        reply_type: str = None,
    ):
        self.message = message
        self.reply_type = reply_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.reply_type is not None:
            result['ReplyType'] = self.reply_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ReplyType') is not None:
            self.reply_type = m.get('ReplyType')
        return self


class GetInterveneGlobalReplyResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        reply_messag_list: List[GetInterveneGlobalReplyResponseBodyDataReplyMessagList] = None,
    ):
        self.code = code
        self.reply_messag_list = reply_messag_list

    def validate(self):
        if self.reply_messag_list:
            for k in self.reply_messag_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['ReplyMessagList'] = []
        if self.reply_messag_list is not None:
            for k in self.reply_messag_list:
                result['ReplyMessagList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.reply_messag_list = []
        if m.get('ReplyMessagList') is not None:
            for k in m.get('ReplyMessagList'):
                temp_model = GetInterveneGlobalReplyResponseBodyDataReplyMessagList()
                self.reply_messag_list.append(temp_model.from_map(k))
        return self


class GetInterveneGlobalReplyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetInterveneGlobalReplyResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetInterveneGlobalReplyResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetInterveneGlobalReplyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInterveneGlobalReplyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInterveneGlobalReplyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInterveneImportTaskInfoRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetInterveneImportTaskInfoResponseBodyDataStatus(TeaModel):
    def __init__(
        self,
        msg: str = None,
        percentage: int = None,
        status: int = None,
        task_id: str = None,
        task_name: str = None,
    ):
        self.msg = msg
        self.percentage = percentage
        self.status = status
        self.task_id = task_id
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class GetInterveneImportTaskInfoResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        status: GetInterveneImportTaskInfoResponseBodyDataStatus = None,
    ):
        self.code = code
        self.status = status

    def validate(self):
        if self.status:
            self.status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.status is not None:
            result['Status'] = self.status.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Status') is not None:
            temp_model = GetInterveneImportTaskInfoResponseBodyDataStatus()
            self.status = temp_model.from_map(m['Status'])
        return self


class GetInterveneImportTaskInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetInterveneImportTaskInfoResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetInterveneImportTaskInfoResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetInterveneImportTaskInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInterveneImportTaskInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInterveneImportTaskInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInterveneRuleDetailRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        rule_id: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailAnswerConfig(TeaModel):
    def __init__(
        self,
        answer_type: int = None,
        message: str = None,
        namespace: str = None,
    ):
        self.answer_type = answer_type
        self.message = message
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_type is not None:
            result['AnswerType'] = self.answer_type
        if self.message is not None:
            result['Message'] = self.message
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerType') is not None:
            self.answer_type = m.get('AnswerType')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailEffectConfig(TeaModel):
    def __init__(
        self,
        effect_type: int = None,
        end_time: str = None,
        start_time: str = None,
    ):
        self.effect_type = effect_type
        self.end_time = end_time
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effect_type is not None:
            result['EffectType'] = self.effect_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EffectType') is not None:
            self.effect_type = m.get('EffectType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetInterveneRuleDetailResponseBodyDataInterveneRuleDetail(TeaModel):
    def __init__(
        self,
        answer_config: List[GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailAnswerConfig] = None,
        effect_config: GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailEffectConfig = None,
        intervene_type: int = None,
        namespace_list: List[str] = None,
        rule_id: int = None,
        rule_name: str = None,
    ):
        self.answer_config = answer_config
        self.effect_config = effect_config
        self.intervene_type = intervene_type
        self.namespace_list = namespace_list
        self.rule_id = rule_id
        self.rule_name = rule_name

    def validate(self):
        if self.answer_config:
            for k in self.answer_config:
                if k:
                    k.validate()
        if self.effect_config:
            self.effect_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AnswerConfig'] = []
        if self.answer_config is not None:
            for k in self.answer_config:
                result['AnswerConfig'].append(k.to_map() if k else None)
        if self.effect_config is not None:
            result['EffectConfig'] = self.effect_config.to_map()
        if self.intervene_type is not None:
            result['InterveneType'] = self.intervene_type
        if self.namespace_list is not None:
            result['NamespaceList'] = self.namespace_list
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.answer_config = []
        if m.get('AnswerConfig') is not None:
            for k in m.get('AnswerConfig'):
                temp_model = GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailAnswerConfig()
                self.answer_config.append(temp_model.from_map(k))
        if m.get('EffectConfig') is not None:
            temp_model = GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailEffectConfig()
            self.effect_config = temp_model.from_map(m['EffectConfig'])
        if m.get('InterveneType') is not None:
            self.intervene_type = m.get('InterveneType')
        if m.get('NamespaceList') is not None:
            self.namespace_list = m.get('NamespaceList')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class GetInterveneRuleDetailResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        intervene_rule_detail: GetInterveneRuleDetailResponseBodyDataInterveneRuleDetail = None,
    ):
        self.code = code
        self.intervene_rule_detail = intervene_rule_detail

    def validate(self):
        if self.intervene_rule_detail:
            self.intervene_rule_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.intervene_rule_detail is not None:
            result['InterveneRuleDetail'] = self.intervene_rule_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('InterveneRuleDetail') is not None:
            temp_model = GetInterveneRuleDetailResponseBodyDataInterveneRuleDetail()
            self.intervene_rule_detail = temp_model.from_map(m['InterveneRuleDetail'])
        return self


class GetInterveneRuleDetailResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetInterveneRuleDetailResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetInterveneRuleDetailResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetInterveneRuleDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInterveneRuleDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInterveneRuleDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInterveneTemplateFileUrlRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        return self


class GetInterveneTemplateFileUrlResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        file_url: str = None,
    ):
        self.code = code
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class GetInterveneTemplateFileUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetInterveneTemplateFileUrlResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetInterveneTemplateFileUrlResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetInterveneTemplateFileUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetInterveneTemplateFileUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInterveneTemplateFileUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMaterialByIdRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        id: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetMaterialByIdResponseBodyData(TeaModel):
    def __init__(
        self,
        author: str = None,
        create_time: str = None,
        create_user: str = None,
        doc_keywords: List[str] = None,
        doc_type: str = None,
        external_url: str = None,
        html_content: str = None,
        id: int = None,
        pub_time: str = None,
        public_url: str = None,
        share_attr: int = None,
        src_from: str = None,
        summary: str = None,
        text_content: str = None,
        thumbnail_in_base_64: str = None,
        title: str = None,
        update_time: str = None,
        update_user: str = None,
        url: str = None,
    ):
        self.author = author
        self.create_time = create_time
        self.create_user = create_user
        self.doc_keywords = doc_keywords
        self.doc_type = doc_type
        self.external_url = external_url
        self.html_content = html_content
        self.id = id
        self.pub_time = pub_time
        self.public_url = public_url
        self.share_attr = share_attr
        self.src_from = src_from
        self.summary = summary
        self.text_content = text_content
        self.thumbnail_in_base_64 = thumbnail_in_base_64
        self.title = title
        self.update_time = update_time
        self.update_user = update_user
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.doc_keywords is not None:
            result['DocKeywords'] = self.doc_keywords
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.external_url is not None:
            result['ExternalUrl'] = self.external_url
        if self.html_content is not None:
            result['HtmlContent'] = self.html_content
        if self.id is not None:
            result['Id'] = self.id
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.public_url is not None:
            result['PublicUrl'] = self.public_url
        if self.share_attr is not None:
            result['ShareAttr'] = self.share_attr
        if self.src_from is not None:
            result['SrcFrom'] = self.src_from
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.text_content is not None:
            result['TextContent'] = self.text_content
        if self.thumbnail_in_base_64 is not None:
            result['ThumbnailInBase64'] = self.thumbnail_in_base_64
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_user is not None:
            result['UpdateUser'] = self.update_user
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DocKeywords') is not None:
            self.doc_keywords = m.get('DocKeywords')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('ExternalUrl') is not None:
            self.external_url = m.get('ExternalUrl')
        if m.get('HtmlContent') is not None:
            self.html_content = m.get('HtmlContent')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('PublicUrl') is not None:
            self.public_url = m.get('PublicUrl')
        if m.get('ShareAttr') is not None:
            self.share_attr = m.get('ShareAttr')
        if m.get('SrcFrom') is not None:
            self.src_from = m.get('SrcFrom')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TextContent') is not None:
            self.text_content = m.get('TextContent')
        if m.get('ThumbnailInBase64') is not None:
            self.thumbnail_in_base_64 = m.get('ThumbnailInBase64')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateUser') is not None:
            self.update_user = m.get('UpdateUser')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetMaterialByIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetMaterialByIdResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetMaterialByIdResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetMaterialByIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMaterialByIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMaterialByIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPropertiesRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        return self


class GetPropertiesResponseBodyDataConsoleConfig(TeaModel):
    def __init__(
        self,
        tip_content: str = None,
        title: str = None,
    ):
        self.tip_content = tip_content
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tip_content is not None:
            result['TipContent'] = self.tip_content
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TipContent') is not None:
            self.tip_content = m.get('TipContent')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetPropertiesResponseBodyDataIntelligentSearchConfigCopilotPreciseSearchSources(TeaModel):
    def __init__(
        self,
        code: str = None,
        dataset_name: str = None,
        name: str = None,
    ):
        self.code = code
        self.dataset_name = dataset_name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamplesArticles(TeaModel):
    def __init__(
        self,
        select: bool = None,
        stared: bool = None,
        title: str = None,
        url: str = None,
    ):
        self.select = select
        self.stared = stared
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.select is not None:
            result['Select'] = self.select
        if self.stared is not None:
            result['Stared'] = self.stared
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Select') is not None:
            self.select = m.get('Select')
        if m.get('Stared') is not None:
            self.stared = m.get('Stared')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamples(TeaModel):
    def __init__(
        self,
        articles: List[GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamplesArticles] = None,
        prompt: str = None,
        text: str = None,
    ):
        self.articles = articles
        self.prompt = prompt
        self.text = text

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamplesArticles()
                self.articles.append(temp_model.from_map(k))
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSources(TeaModel):
    def __init__(
        self,
        code: str = None,
        dataset_name: str = None,
        name: str = None,
    ):
        self.code = code
        self.dataset_name = dataset_name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetPropertiesResponseBodyDataIntelligentSearchConfig(TeaModel):
    def __init__(
        self,
        copilot_precise_search_sources: List[GetPropertiesResponseBodyDataIntelligentSearchConfigCopilotPreciseSearchSources] = None,
        product_description: str = None,
        search_samples: List[GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamples] = None,
        search_sources: List[GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSources] = None,
    ):
        self.copilot_precise_search_sources = copilot_precise_search_sources
        self.product_description = product_description
        self.search_samples = search_samples
        self.search_sources = search_sources

    def validate(self):
        if self.copilot_precise_search_sources:
            for k in self.copilot_precise_search_sources:
                if k:
                    k.validate()
        if self.search_samples:
            for k in self.search_samples:
                if k:
                    k.validate()
        if self.search_sources:
            for k in self.search_sources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CopilotPreciseSearchSources'] = []
        if self.copilot_precise_search_sources is not None:
            for k in self.copilot_precise_search_sources:
                result['CopilotPreciseSearchSources'].append(k.to_map() if k else None)
        if self.product_description is not None:
            result['ProductDescription'] = self.product_description
        result['SearchSamples'] = []
        if self.search_samples is not None:
            for k in self.search_samples:
                result['SearchSamples'].append(k.to_map() if k else None)
        result['SearchSources'] = []
        if self.search_sources is not None:
            for k in self.search_sources:
                result['SearchSources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.copilot_precise_search_sources = []
        if m.get('CopilotPreciseSearchSources') is not None:
            for k in m.get('CopilotPreciseSearchSources'):
                temp_model = GetPropertiesResponseBodyDataIntelligentSearchConfigCopilotPreciseSearchSources()
                self.copilot_precise_search_sources.append(temp_model.from_map(k))
        if m.get('ProductDescription') is not None:
            self.product_description = m.get('ProductDescription')
        self.search_samples = []
        if m.get('SearchSamples') is not None:
            for k in m.get('SearchSamples'):
                temp_model = GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamples()
                self.search_samples.append(temp_model.from_map(k))
        self.search_sources = []
        if m.get('SearchSources') is not None:
            for k in m.get('SearchSources'):
                temp_model = GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSources()
                self.search_sources.append(temp_model.from_map(k))
        return self


class GetPropertiesResponseBodyDataMiaosouConfigModelInfos(TeaModel):
    def __init__(
        self,
        model_id: str = None,
        model_name: str = None,
    ):
        self.model_id = model_id
        self.model_name = model_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        return self


class GetPropertiesResponseBodyDataMiaosouConfig(TeaModel):
    def __init__(
        self,
        max_doc_size: int = None,
        model_infos: List[GetPropertiesResponseBodyDataMiaosouConfigModelInfos] = None,
        use_doc_size: int = None,
    ):
        self.max_doc_size = max_doc_size
        self.model_infos = model_infos
        self.use_doc_size = use_doc_size

    def validate(self):
        if self.model_infos:
            for k in self.model_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_doc_size is not None:
            result['MaxDocSize'] = self.max_doc_size
        result['ModelInfos'] = []
        if self.model_infos is not None:
            for k in self.model_infos:
                result['ModelInfos'].append(k.to_map() if k else None)
        if self.use_doc_size is not None:
            result['UseDocSize'] = self.use_doc_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxDocSize') is not None:
            self.max_doc_size = m.get('MaxDocSize')
        self.model_infos = []
        if m.get('ModelInfos') is not None:
            for k in m.get('ModelInfos'):
                temp_model = GetPropertiesResponseBodyDataMiaosouConfigModelInfos()
                self.model_infos.append(temp_model.from_map(k))
        if m.get('UseDocSize') is not None:
            self.use_doc_size = m.get('UseDocSize')
        return self


class GetPropertiesResponseBodyDataSearchSourceList(TeaModel):
    def __init__(
        self,
        code: str = None,
        dataset_name: str = None,
        name: str = None,
    ):
        self.code = code
        self.dataset_name = dataset_name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetPropertiesResponseBodyDataSearchSources(TeaModel):
    def __init__(
        self,
        label: str = None,
        value: str = None,
    ):
        self.label = label
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetPropertiesResponseBodyDataUserInfo(TeaModel):
    def __init__(
        self,
        agent_id: str = None,
        tenant_id: str = None,
        user_id: str = None,
        username: str = None,
    ):
        self.agent_id = agent_id
        self.tenant_id = tenant_id
        self.user_id = user_id
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_id is not None:
            result['AgentId'] = self.agent_id
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentId') is not None:
            self.agent_id = m.get('AgentId')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class GetPropertiesResponseBodyDataWanxiangImageSizeConfig(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        self.name = name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetPropertiesResponseBodyDataWanxiangImageStyleConfig(TeaModel):
    def __init__(
        self,
        name: str = None,
        pic: str = None,
        value: str = None,
    ):
        self.name = name
        self.pic = pic
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.pic is not None:
            result['Pic'] = self.pic
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pic') is not None:
            self.pic = m.get('Pic')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetPropertiesResponseBodyData(TeaModel):
    def __init__(
        self,
        chat_config: Dict[str, Any] = None,
        console_config: GetPropertiesResponseBodyDataConsoleConfig = None,
        general_config_map: Dict[str, Any] = None,
        intelligent_search_config: GetPropertiesResponseBodyDataIntelligentSearchConfig = None,
        miaosou_config: GetPropertiesResponseBodyDataMiaosouConfig = None,
        search_source_list: List[GetPropertiesResponseBodyDataSearchSourceList] = None,
        search_sources: List[GetPropertiesResponseBodyDataSearchSources] = None,
        slr_authorized: bool = None,
        user_info: GetPropertiesResponseBodyDataUserInfo = None,
        wanxiang_image_size_config: List[GetPropertiesResponseBodyDataWanxiangImageSizeConfig] = None,
        wanxiang_image_style_config: List[GetPropertiesResponseBodyDataWanxiangImageStyleConfig] = None,
    ):
        self.chat_config = chat_config
        self.console_config = console_config
        self.general_config_map = general_config_map
        self.intelligent_search_config = intelligent_search_config
        self.miaosou_config = miaosou_config
        self.search_source_list = search_source_list
        self.search_sources = search_sources
        self.slr_authorized = slr_authorized
        self.user_info = user_info
        self.wanxiang_image_size_config = wanxiang_image_size_config
        self.wanxiang_image_style_config = wanxiang_image_style_config

    def validate(self):
        if self.console_config:
            self.console_config.validate()
        if self.intelligent_search_config:
            self.intelligent_search_config.validate()
        if self.miaosou_config:
            self.miaosou_config.validate()
        if self.search_source_list:
            for k in self.search_source_list:
                if k:
                    k.validate()
        if self.search_sources:
            for k in self.search_sources:
                if k:
                    k.validate()
        if self.user_info:
            self.user_info.validate()
        if self.wanxiang_image_size_config:
            for k in self.wanxiang_image_size_config:
                if k:
                    k.validate()
        if self.wanxiang_image_style_config:
            for k in self.wanxiang_image_style_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chat_config is not None:
            result['ChatConfig'] = self.chat_config
        if self.console_config is not None:
            result['ConsoleConfig'] = self.console_config.to_map()
        if self.general_config_map is not None:
            result['GeneralConfigMap'] = self.general_config_map
        if self.intelligent_search_config is not None:
            result['IntelligentSearchConfig'] = self.intelligent_search_config.to_map()
        if self.miaosou_config is not None:
            result['MiaosouConfig'] = self.miaosou_config.to_map()
        result['SearchSourceList'] = []
        if self.search_source_list is not None:
            for k in self.search_source_list:
                result['SearchSourceList'].append(k.to_map() if k else None)
        result['SearchSources'] = []
        if self.search_sources is not None:
            for k in self.search_sources:
                result['SearchSources'].append(k.to_map() if k else None)
        if self.slr_authorized is not None:
            result['SlrAuthorized'] = self.slr_authorized
        if self.user_info is not None:
            result['UserInfo'] = self.user_info.to_map()
        result['WanxiangImageSizeConfig'] = []
        if self.wanxiang_image_size_config is not None:
            for k in self.wanxiang_image_size_config:
                result['WanxiangImageSizeConfig'].append(k.to_map() if k else None)
        result['WanxiangImageStyleConfig'] = []
        if self.wanxiang_image_style_config is not None:
            for k in self.wanxiang_image_style_config:
                result['WanxiangImageStyleConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChatConfig') is not None:
            self.chat_config = m.get('ChatConfig')
        if m.get('ConsoleConfig') is not None:
            temp_model = GetPropertiesResponseBodyDataConsoleConfig()
            self.console_config = temp_model.from_map(m['ConsoleConfig'])
        if m.get('GeneralConfigMap') is not None:
            self.general_config_map = m.get('GeneralConfigMap')
        if m.get('IntelligentSearchConfig') is not None:
            temp_model = GetPropertiesResponseBodyDataIntelligentSearchConfig()
            self.intelligent_search_config = temp_model.from_map(m['IntelligentSearchConfig'])
        if m.get('MiaosouConfig') is not None:
            temp_model = GetPropertiesResponseBodyDataMiaosouConfig()
            self.miaosou_config = temp_model.from_map(m['MiaosouConfig'])
        self.search_source_list = []
        if m.get('SearchSourceList') is not None:
            for k in m.get('SearchSourceList'):
                temp_model = GetPropertiesResponseBodyDataSearchSourceList()
                self.search_source_list.append(temp_model.from_map(k))
        self.search_sources = []
        if m.get('SearchSources') is not None:
            for k in m.get('SearchSources'):
                temp_model = GetPropertiesResponseBodyDataSearchSources()
                self.search_sources.append(temp_model.from_map(k))
        if m.get('SlrAuthorized') is not None:
            self.slr_authorized = m.get('SlrAuthorized')
        if m.get('UserInfo') is not None:
            temp_model = GetPropertiesResponseBodyDataUserInfo()
            self.user_info = temp_model.from_map(m['UserInfo'])
        self.wanxiang_image_size_config = []
        if m.get('WanxiangImageSizeConfig') is not None:
            for k in m.get('WanxiangImageSizeConfig'):
                temp_model = GetPropertiesResponseBodyDataWanxiangImageSizeConfig()
                self.wanxiang_image_size_config.append(temp_model.from_map(k))
        self.wanxiang_image_style_config = []
        if m.get('WanxiangImageStyleConfig') is not None:
            for k in m.get('WanxiangImageStyleConfig'):
                temp_model = GetPropertiesResponseBodyDataWanxiangImageStyleConfig()
                self.wanxiang_image_style_config.append(temp_model.from_map(k))
        return self


class GetPropertiesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetPropertiesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetPropertiesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetPropertiesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPropertiesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPropertiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSmartAuditResultRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.task_id = task_id
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetSmartAuditResultResponseBodyDataErrorItemDetails(TeaModel):
    def __init__(
        self,
        check_id: str = None,
        context: str = None,
        context_offset: int = None,
        error_level: int = None,
        error_word: str = None,
        major_code: str = None,
        major_code_desc: str = None,
        offset: int = None,
        reason: str = None,
        right_word: str = None,
        sub_class_code: str = None,
        sub_class_desc: str = None,
        url: str = None,
    ):
        self.check_id = check_id
        self.context = context
        self.context_offset = context_offset
        self.error_level = error_level
        self.error_word = error_word
        self.major_code = major_code
        self.major_code_desc = major_code_desc
        self.offset = offset
        self.reason = reason
        self.right_word = right_word
        self.sub_class_code = sub_class_code
        self.sub_class_desc = sub_class_desc
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_id is not None:
            result['CheckId'] = self.check_id
        if self.context is not None:
            result['Context'] = self.context
        if self.context_offset is not None:
            result['ContextOffset'] = self.context_offset
        if self.error_level is not None:
            result['ErrorLevel'] = self.error_level
        if self.error_word is not None:
            result['ErrorWord'] = self.error_word
        if self.major_code is not None:
            result['MajorCode'] = self.major_code
        if self.major_code_desc is not None:
            result['MajorCodeDesc'] = self.major_code_desc
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.right_word is not None:
            result['RightWord'] = self.right_word
        if self.sub_class_code is not None:
            result['SubClassCode'] = self.sub_class_code
        if self.sub_class_desc is not None:
            result['SubClassDesc'] = self.sub_class_desc
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckId') is not None:
            self.check_id = m.get('CheckId')
        if m.get('Context') is not None:
            self.context = m.get('Context')
        if m.get('ContextOffset') is not None:
            self.context_offset = m.get('ContextOffset')
        if m.get('ErrorLevel') is not None:
            self.error_level = m.get('ErrorLevel')
        if m.get('ErrorWord') is not None:
            self.error_word = m.get('ErrorWord')
        if m.get('MajorCode') is not None:
            self.major_code = m.get('MajorCode')
        if m.get('MajorCodeDesc') is not None:
            self.major_code_desc = m.get('MajorCodeDesc')
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('RightWord') is not None:
            self.right_word = m.get('RightWord')
        if m.get('SubClassCode') is not None:
            self.sub_class_code = m.get('SubClassCode')
        if m.get('SubClassDesc') is not None:
            self.sub_class_desc = m.get('SubClassDesc')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetSmartAuditResultResponseBodyData(TeaModel):
    def __init__(
        self,
        error_item_details: List[GetSmartAuditResultResponseBodyDataErrorItemDetails] = None,
        error_message: str = None,
        status: str = None,
    ):
        self.error_item_details = error_item_details
        self.error_message = error_message
        self.status = status

    def validate(self):
        if self.error_item_details:
            for k in self.error_item_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ErrorItemDetails'] = []
        if self.error_item_details is not None:
            for k in self.error_item_details:
                result['ErrorItemDetails'].append(k.to_map() if k else None)
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.error_item_details = []
        if m.get('ErrorItemDetails') is not None:
            for k in m.get('ErrorItemDetails'):
                temp_model = GetSmartAuditResultResponseBodyDataErrorItemDetails()
                self.error_item_details.append(temp_model.from_map(k))
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetSmartAuditResultResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetSmartAuditResultResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetSmartAuditResultResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSmartAuditResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSmartAuditResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSmartAuditResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSmartClipTaskRequest(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class GetSmartClipTaskResponseBodyDataSubJobsFileAttr(TeaModel):
    def __init__(
        self,
        duration: float = None,
        file_length: str = None,
        file_name: str = None,
        height: int = None,
        tmp_url: str = None,
        width: int = None,
    ):
        self.duration = duration
        self.file_length = file_length
        self.file_name = file_name
        self.height = height
        self.tmp_url = tmp_url
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_length is not None:
            result['FileLength'] = self.file_length
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.height is not None:
            result['Height'] = self.height
        if self.tmp_url is not None:
            result['TmpUrl'] = self.tmp_url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileLength') is not None:
            self.file_length = m.get('FileLength')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('TmpUrl') is not None:
            self.tmp_url = m.get('TmpUrl')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetSmartClipTaskResponseBodyDataSubJobs(TeaModel):
    def __init__(
        self,
        error_message: str = None,
        file_attr: GetSmartClipTaskResponseBodyDataSubJobsFileAttr = None,
        file_key: str = None,
        status: str = None,
        sub_job_id: str = None,
    ):
        self.error_message = error_message
        self.file_attr = file_attr
        self.file_key = file_key
        self.status = status
        self.sub_job_id = sub_job_id

    def validate(self):
        if self.file_attr:
            self.file_attr.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file_attr is not None:
            result['FileAttr'] = self.file_attr.to_map()
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        if self.status is not None:
            result['Status'] = self.status
        if self.sub_job_id is not None:
            result['SubJobId'] = self.sub_job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FileAttr') is not None:
            temp_model = GetSmartClipTaskResponseBodyDataSubJobsFileAttr()
            self.file_attr = temp_model.from_map(m['FileAttr'])
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubJobId') is not None:
            self.sub_job_id = m.get('SubJobId')
        return self


class GetSmartClipTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        error_message: str = None,
        status: str = None,
        sub_jobs: List[GetSmartClipTaskResponseBodyDataSubJobs] = None,
    ):
        self.error_message = error_message
        self.status = status
        self.sub_jobs = sub_jobs

    def validate(self):
        if self.sub_jobs:
            for k in self.sub_jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.status is not None:
            result['Status'] = self.status
        result['SubJobs'] = []
        if self.sub_jobs is not None:
            for k in self.sub_jobs:
                result['SubJobs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.sub_jobs = []
        if m.get('SubJobs') is not None:
            for k in m.get('SubJobs'):
                temp_model = GetSmartClipTaskResponseBodyDataSubJobs()
                self.sub_jobs.append(temp_model.from_map(k))
        return self


class GetSmartClipTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetSmartClipTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetSmartClipTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSmartClipTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSmartClipTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSmartClipTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStyleLearningResultRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        id: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetStyleLearningResultResponseBodyDataContentList(TeaModel):
    def __init__(
        self,
        content: str = None,
        create_time: str = None,
        create_user: str = None,
        id: int = None,
        title: str = None,
        update_time: str = None,
        update_user: str = None,
    ):
        self.content = content
        self.create_time = create_time
        self.create_user = create_user
        self.id = id
        self.title = title
        self.update_time = update_time
        self.update_user = update_user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.id is not None:
            result['Id'] = self.id
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_user is not None:
            result['UpdateUser'] = self.update_user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateUser') is not None:
            self.update_user = m.get('UpdateUser')
        return self


class GetStyleLearningResultResponseBodyDataMaterialInfoList(TeaModel):
    def __init__(
        self,
        author: str = None,
        create_time: str = None,
        create_user: str = None,
        create_user_name: str = None,
        doc_keywords: List[str] = None,
        doc_type: str = None,
        external_url: str = None,
        file_length: int = None,
        html_content: str = None,
        id: int = None,
        pub_time: str = None,
        public_url: str = None,
        share_attr: int = None,
        src_from: str = None,
        summary: str = None,
        text_content: str = None,
        thumbnail_in_base_64: str = None,
        title: str = None,
        update_time: str = None,
        update_user: str = None,
        update_user_name: str = None,
        url: str = None,
    ):
        self.author = author
        self.create_time = create_time
        self.create_user = create_user
        self.create_user_name = create_user_name
        self.doc_keywords = doc_keywords
        self.doc_type = doc_type
        self.external_url = external_url
        self.file_length = file_length
        self.html_content = html_content
        self.id = id
        self.pub_time = pub_time
        self.public_url = public_url
        self.share_attr = share_attr
        self.src_from = src_from
        self.summary = summary
        self.text_content = text_content
        self.thumbnail_in_base_64 = thumbnail_in_base_64
        self.title = title
        self.update_time = update_time
        self.update_user = update_user
        self.update_user_name = update_user_name
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.create_user_name is not None:
            result['CreateUserName'] = self.create_user_name
        if self.doc_keywords is not None:
            result['DocKeywords'] = self.doc_keywords
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.external_url is not None:
            result['ExternalUrl'] = self.external_url
        if self.file_length is not None:
            result['FileLength'] = self.file_length
        if self.html_content is not None:
            result['HtmlContent'] = self.html_content
        if self.id is not None:
            result['Id'] = self.id
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.public_url is not None:
            result['PublicUrl'] = self.public_url
        if self.share_attr is not None:
            result['ShareAttr'] = self.share_attr
        if self.src_from is not None:
            result['SrcFrom'] = self.src_from
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.text_content is not None:
            result['TextContent'] = self.text_content
        if self.thumbnail_in_base_64 is not None:
            result['ThumbnailInBase64'] = self.thumbnail_in_base_64
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_user is not None:
            result['UpdateUser'] = self.update_user
        if self.update_user_name is not None:
            result['UpdateUserName'] = self.update_user_name
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('CreateUserName') is not None:
            self.create_user_name = m.get('CreateUserName')
        if m.get('DocKeywords') is not None:
            self.doc_keywords = m.get('DocKeywords')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('ExternalUrl') is not None:
            self.external_url = m.get('ExternalUrl')
        if m.get('FileLength') is not None:
            self.file_length = m.get('FileLength')
        if m.get('HtmlContent') is not None:
            self.html_content = m.get('HtmlContent')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('PublicUrl') is not None:
            self.public_url = m.get('PublicUrl')
        if m.get('ShareAttr') is not None:
            self.share_attr = m.get('ShareAttr')
        if m.get('SrcFrom') is not None:
            self.src_from = m.get('SrcFrom')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TextContent') is not None:
            self.text_content = m.get('TextContent')
        if m.get('ThumbnailInBase64') is not None:
            self.thumbnail_in_base_64 = m.get('ThumbnailInBase64')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateUser') is not None:
            self.update_user = m.get('UpdateUser')
        if m.get('UpdateUserName') is not None:
            self.update_user_name = m.get('UpdateUserName')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetStyleLearningResultResponseBodyData(TeaModel):
    def __init__(
        self,
        aigc_result: str = None,
        content_list: List[GetStyleLearningResultResponseBodyDataContentList] = None,
        custom_text_id_list: List[int] = None,
        id: int = None,
        material_id_list: List[int] = None,
        material_info_list: List[GetStyleLearningResultResponseBodyDataMaterialInfoList] = None,
        rewrite_result: str = None,
        style_name: str = None,
        task_id: str = None,
    ):
        self.aigc_result = aigc_result
        self.content_list = content_list
        self.custom_text_id_list = custom_text_id_list
        self.id = id
        self.material_id_list = material_id_list
        self.material_info_list = material_info_list
        self.rewrite_result = rewrite_result
        self.style_name = style_name
        self.task_id = task_id

    def validate(self):
        if self.content_list:
            for k in self.content_list:
                if k:
                    k.validate()
        if self.material_info_list:
            for k in self.material_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aigc_result is not None:
            result['AigcResult'] = self.aigc_result
        result['ContentList'] = []
        if self.content_list is not None:
            for k in self.content_list:
                result['ContentList'].append(k.to_map() if k else None)
        if self.custom_text_id_list is not None:
            result['CustomTextIdList'] = self.custom_text_id_list
        if self.id is not None:
            result['Id'] = self.id
        if self.material_id_list is not None:
            result['MaterialIdList'] = self.material_id_list
        result['MaterialInfoList'] = []
        if self.material_info_list is not None:
            for k in self.material_info_list:
                result['MaterialInfoList'].append(k.to_map() if k else None)
        if self.rewrite_result is not None:
            result['RewriteResult'] = self.rewrite_result
        if self.style_name is not None:
            result['StyleName'] = self.style_name
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AigcResult') is not None:
            self.aigc_result = m.get('AigcResult')
        self.content_list = []
        if m.get('ContentList') is not None:
            for k in m.get('ContentList'):
                temp_model = GetStyleLearningResultResponseBodyDataContentList()
                self.content_list.append(temp_model.from_map(k))
        if m.get('CustomTextIdList') is not None:
            self.custom_text_id_list = m.get('CustomTextIdList')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MaterialIdList') is not None:
            self.material_id_list = m.get('MaterialIdList')
        self.material_info_list = []
        if m.get('MaterialInfoList') is not None:
            for k in m.get('MaterialInfoList'):
                temp_model = GetStyleLearningResultResponseBodyDataMaterialInfoList()
                self.material_info_list.append(temp_model.from_map(k))
        if m.get('RewriteResult') is not None:
            self.rewrite_result = m.get('RewriteResult')
        if m.get('StyleName') is not None:
            self.style_name = m.get('StyleName')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetStyleLearningResultResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetStyleLearningResultResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetStyleLearningResultResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStyleLearningResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStyleLearningResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStyleLearningResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTopicByIdRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class GetTopicByIdResponseBodyDataStructureSummaryDocList(TeaModel):
    def __init__(
        self,
        source: str = None,
        title: str = None,
        url: str = None,
    ):
        self.source = source
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['Source'] = self.source
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetTopicByIdResponseBodyDataStructureSummary(TeaModel):
    def __init__(
        self,
        doc_list: List[GetTopicByIdResponseBodyDataStructureSummaryDocList] = None,
        summary: str = None,
        title: str = None,
    ):
        self.doc_list = doc_list
        self.summary = summary
        self.title = title

    def validate(self):
        if self.doc_list:
            for k in self.doc_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DocList'] = []
        if self.doc_list is not None:
            for k in self.doc_list:
                result['DocList'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.doc_list = []
        if m.get('DocList') is not None:
            for k in m.get('DocList'):
                temp_model = GetTopicByIdResponseBodyDataStructureSummaryDocList()
                self.doc_list.append(temp_model.from_map(k))
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetTopicByIdResponseBodyData(TeaModel):
    def __init__(
        self,
        async_task_id: str = None,
        create_user: str = None,
        hot_value: int = None,
        id: str = None,
        status: str = None,
        structure_summary: List[GetTopicByIdResponseBodyDataStructureSummary] = None,
        summary: str = None,
        task_error_message: str = None,
        task_status: int = None,
        topic: str = None,
        topic_source: str = None,
        version: str = None,
    ):
        self.async_task_id = async_task_id
        self.create_user = create_user
        self.hot_value = hot_value
        self.id = id
        self.status = status
        self.structure_summary = structure_summary
        self.summary = summary
        self.task_error_message = task_error_message
        self.task_status = task_status
        self.topic = topic
        self.topic_source = topic_source
        self.version = version

    def validate(self):
        if self.structure_summary:
            for k in self.structure_summary:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['AsyncTaskId'] = self.async_task_id
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.hot_value is not None:
            result['HotValue'] = self.hot_value
        if self.id is not None:
            result['Id'] = self.id
        if self.status is not None:
            result['Status'] = self.status
        result['StructureSummary'] = []
        if self.structure_summary is not None:
            for k in self.structure_summary:
                result['StructureSummary'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.task_error_message is not None:
            result['TaskErrorMessage'] = self.task_error_message
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsyncTaskId') is not None:
            self.async_task_id = m.get('AsyncTaskId')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('HotValue') is not None:
            self.hot_value = m.get('HotValue')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.structure_summary = []
        if m.get('StructureSummary') is not None:
            for k in m.get('StructureSummary'):
                temp_model = GetTopicByIdResponseBodyDataStructureSummary()
                self.structure_summary.append(temp_model.from_map(k))
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TaskErrorMessage') is not None:
            self.task_error_message = m.get('TaskErrorMessage')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetTopicByIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetTopicByIdResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetTopicByIdResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTopicByIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTopicByIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTopicByIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTopicSelectionPerspectiveAnalysisTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPointsOutlines(TeaModel):
    def __init__(
        self,
        outline: str = None,
        summary: str = None,
    ):
        self.outline = outline
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.outline is not None:
            result['Outline'] = self.outline
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPoints(TeaModel):
    def __init__(
        self,
        outlines: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPointsOutlines] = None,
        point: str = None,
        summary: str = None,
    ):
        self.outlines = outlines
        self.point = point
        self.summary = summary

    def validate(self):
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.point is not None:
            result['Point'] = self.point
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPointsOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Point') is not None:
            self.point = m.get('Point')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudes(TeaModel):
    def __init__(
        self,
        attitude: str = None,
        attitude_type: str = None,
        ratio: str = None,
        view_points: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPoints] = None,
    ):
        self.attitude = attitude
        self.attitude_type = attitude_type
        self.ratio = ratio
        self.view_points = view_points

    def validate(self):
        if self.view_points:
            for k in self.view_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.attitude_type is not None:
            result['AttitudeType'] = self.attitude_type
        if self.ratio is not None:
            result['Ratio'] = self.ratio
        result['ViewPoints'] = []
        if self.view_points is not None:
            for k in self.view_points:
                result['ViewPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('AttitudeType') is not None:
            self.attitude_type = m.get('AttitudeType')
        if m.get('Ratio') is not None:
            self.ratio = m.get('Ratio')
        self.view_points = []
        if m.get('ViewPoints') is not None:
            for k in m.get('ViewPoints'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPoints()
                self.view_points.append(temp_model.from_map(k))
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResult(TeaModel):
    def __init__(
        self,
        attitudes: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudes] = None,
    ):
        self.attitudes = attitudes

    def validate(self):
        if self.attitudes:
            for k in self.attitudes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attitudes'] = []
        if self.attitudes is not None:
            for k in self.attitudes:
                result['Attitudes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attitudes = []
        if m.get('Attitudes') is not None:
            for k in m.get('Attitudes'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudes()
                self.attitudes.append(temp_model.from_map(k))
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesNews(TeaModel):
    def __init__(
        self,
        content: str = None,
        create_time: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        image_urls: List[str] = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        tags: List[str] = None,
        title: str = None,
        topic: str = None,
        url: str = None,
    ):
        self.content = content
        self.create_time = create_time
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.image_urls = image_urls
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.tags = tags
        self.title = title
        self.topic = topic
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.image_urls is not None:
            result['ImageUrls'] = self.image_urls
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.title is not None:
            result['Title'] = self.title
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('ImageUrls') is not None:
            self.image_urls = m.get('ImageUrls')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPointsOutlines(TeaModel):
    def __init__(
        self,
        outline: str = None,
        summary: str = None,
    ):
        self.outline = outline
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.outline is not None:
            result['Outline'] = self.outline
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPoints(TeaModel):
    def __init__(
        self,
        outlines: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPointsOutlines] = None,
        point: str = None,
        summary: str = None,
    ):
        self.outlines = outlines
        self.point = point
        self.summary = summary

    def validate(self):
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.point is not None:
            result['Point'] = self.point
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPointsOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Point') is not None:
            self.point = m.get('Point')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudes(TeaModel):
    def __init__(
        self,
        attitude: str = None,
        attitude_type: str = None,
        news: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesNews] = None,
        ratio: str = None,
        view_points: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPoints] = None,
    ):
        self.attitude = attitude
        self.attitude_type = attitude_type
        self.news = news
        self.ratio = ratio
        self.view_points = view_points

    def validate(self):
        if self.news:
            for k in self.news:
                if k:
                    k.validate()
        if self.view_points:
            for k in self.view_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.attitude_type is not None:
            result['AttitudeType'] = self.attitude_type
        result['News'] = []
        if self.news is not None:
            for k in self.news:
                result['News'].append(k.to_map() if k else None)
        if self.ratio is not None:
            result['Ratio'] = self.ratio
        result['ViewPoints'] = []
        if self.view_points is not None:
            for k in self.view_points:
                result['ViewPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('AttitudeType') is not None:
            self.attitude_type = m.get('AttitudeType')
        self.news = []
        if m.get('News') is not None:
            for k in m.get('News'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesNews()
                self.news.append(temp_model.from_map(k))
        if m.get('Ratio') is not None:
            self.ratio = m.get('Ratio')
        self.view_points = []
        if m.get('ViewPoints') is not None:
            for k in m.get('ViewPoints'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPoints()
                self.view_points.append(temp_model.from_map(k))
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResult(TeaModel):
    def __init__(
        self,
        attitudes: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudes] = None,
    ):
        self.attitudes = attitudes

    def validate(self):
        if self.attitudes:
            for k in self.attitudes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attitudes'] = []
        if self.attitudes is not None:
            for k in self.attitudes:
                result['Attitudes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attitudes = []
        if m.get('Attitudes') is not None:
            for k in m.get('Attitudes'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudes()
                self.attitudes.append(temp_model.from_map(k))
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPointsOutlines(TeaModel):
    def __init__(
        self,
        outline: str = None,
        summary: str = None,
    ):
        self.outline = outline
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.outline is not None:
            result['Outline'] = self.outline
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPoints(TeaModel):
    def __init__(
        self,
        outlines: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPointsOutlines] = None,
        point: str = None,
        summary: str = None,
    ):
        self.outlines = outlines
        self.point = point
        self.summary = summary

    def validate(self):
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.point is not None:
            result['Point'] = self.point
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPointsOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Point') is not None:
            self.point = m.get('Point')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudes(TeaModel):
    def __init__(
        self,
        attitude: str = None,
        attitude_type: str = None,
        pub_time: str = None,
        ratio: str = None,
        source: str = None,
        title: str = None,
        url: str = None,
        view_points: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPoints] = None,
    ):
        self.attitude = attitude
        self.attitude_type = attitude_type
        self.pub_time = pub_time
        self.ratio = ratio
        self.source = source
        self.title = title
        self.url = url
        self.view_points = view_points

    def validate(self):
        if self.view_points:
            for k in self.view_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.attitude_type is not None:
            result['AttitudeType'] = self.attitude_type
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.ratio is not None:
            result['Ratio'] = self.ratio
        if self.source is not None:
            result['Source'] = self.source
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        result['ViewPoints'] = []
        if self.view_points is not None:
            for k in self.view_points:
                result['ViewPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('AttitudeType') is not None:
            self.attitude_type = m.get('AttitudeType')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Ratio') is not None:
            self.ratio = m.get('Ratio')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        self.view_points = []
        if m.get('ViewPoints') is not None:
            for k in m.get('ViewPoints'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPoints()
                self.view_points.append(temp_model.from_map(k))
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResult(TeaModel):
    def __init__(
        self,
        attitudes: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudes] = None,
    ):
        self.attitudes = attitudes

    def validate(self):
        if self.attitudes:
            for k in self.attitudes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attitudes'] = []
        if self.attitudes is not None:
            for k in self.attitudes:
                result['Attitudes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attitudes = []
        if m.get('Attitudes') is not None:
            for k in m.get('Attitudes'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudes()
                self.attitudes.append(temp_model.from_map(k))
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummariesDocList(TeaModel):
    def __init__(
        self,
        source: str = None,
        title: str = None,
        url: str = None,
    ):
        self.source = source
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['Source'] = self.source
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummaries(TeaModel):
    def __init__(
        self,
        doc_list: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummariesDocList] = None,
        summary: str = None,
        title: str = None,
    ):
        self.doc_list = doc_list
        self.summary = summary
        self.title = title

    def validate(self):
        if self.doc_list:
            for k in self.doc_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DocList'] = []
        if self.doc_list is not None:
            for k in self.doc_list:
                result['DocList'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.doc_list = []
        if m.get('DocList') is not None:
            for k in m.get('DocList'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummariesDocList()
                self.doc_list.append(temp_model.from_map(k))
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResult(TeaModel):
    def __init__(
        self,
        summaries: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummaries] = None,
    ):
        self.summaries = summaries

    def validate(self):
        if self.summaries:
            for k in self.summaries:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Summaries'] = []
        if self.summaries is not None:
            for k in self.summaries:
                result['Summaries'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.summaries = []
        if m.get('Summaries') is not None:
            for k in m.get('Summaries'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummaries()
                self.summaries.append(temp_model.from_map(k))
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesComments(TeaModel):
    def __init__(
        self,
        source: str = None,
        text: str = None,
        title: str = None,
        url: str = None,
        username: str = None,
    ):
        self.source = source
        self.text = text
        self.title = title
        self.url = url
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['Source'] = self.source
        if self.text is not None:
            result['Text'] = self.text
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPointsOutlines(TeaModel):
    def __init__(
        self,
        outline: str = None,
        summary: str = None,
    ):
        self.outline = outline
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.outline is not None:
            result['Outline'] = self.outline
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPoints(TeaModel):
    def __init__(
        self,
        outlines: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPointsOutlines] = None,
        point: str = None,
        summary: str = None,
    ):
        self.outlines = outlines
        self.point = point
        self.summary = summary

    def validate(self):
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.point is not None:
            result['Point'] = self.point
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPointsOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Point') is not None:
            self.point = m.get('Point')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudes(TeaModel):
    def __init__(
        self,
        attitude: str = None,
        attitude_type: str = None,
        comments: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesComments] = None,
        ratio: str = None,
        view_points: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPoints] = None,
    ):
        self.attitude = attitude
        self.attitude_type = attitude_type
        self.comments = comments
        self.ratio = ratio
        self.view_points = view_points

    def validate(self):
        if self.comments:
            for k in self.comments:
                if k:
                    k.validate()
        if self.view_points:
            for k in self.view_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.attitude_type is not None:
            result['AttitudeType'] = self.attitude_type
        result['Comments'] = []
        if self.comments is not None:
            for k in self.comments:
                result['Comments'].append(k.to_map() if k else None)
        if self.ratio is not None:
            result['Ratio'] = self.ratio
        result['ViewPoints'] = []
        if self.view_points is not None:
            for k in self.view_points:
                result['ViewPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('AttitudeType') is not None:
            self.attitude_type = m.get('AttitudeType')
        self.comments = []
        if m.get('Comments') is not None:
            for k in m.get('Comments'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesComments()
                self.comments.append(temp_model.from_map(k))
        if m.get('Ratio') is not None:
            self.ratio = m.get('Ratio')
        self.view_points = []
        if m.get('ViewPoints') is not None:
            for k in m.get('ViewPoints'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPoints()
                self.view_points.append(temp_model.from_map(k))
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResult(TeaModel):
    def __init__(
        self,
        attitudes: List[GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudes] = None,
    ):
        self.attitudes = attitudes

    def validate(self):
        if self.attitudes:
            for k in self.attitudes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attitudes'] = []
        if self.attitudes is not None:
            for k in self.attitudes:
                result['Attitudes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attitudes = []
        if m.get('Attitudes') is not None:
            for k in m.get('Attitudes'):
                temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudes()
                self.attitudes.append(temp_model.from_map(k))
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        error_message: str = None,
        fresh_view_points_result: GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResult = None,
        hot_view_points_result: GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResult = None,
        status: str = None,
        timed_view_points_result: GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResult = None,
        topic: str = None,
        topic_summary_result: GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResult = None,
        web_review_points_result: GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResult = None,
    ):
        self.error_message = error_message
        self.fresh_view_points_result = fresh_view_points_result
        self.hot_view_points_result = hot_view_points_result
        self.status = status
        self.timed_view_points_result = timed_view_points_result
        self.topic = topic
        self.topic_summary_result = topic_summary_result
        self.web_review_points_result = web_review_points_result

    def validate(self):
        if self.fresh_view_points_result:
            self.fresh_view_points_result.validate()
        if self.hot_view_points_result:
            self.hot_view_points_result.validate()
        if self.timed_view_points_result:
            self.timed_view_points_result.validate()
        if self.topic_summary_result:
            self.topic_summary_result.validate()
        if self.web_review_points_result:
            self.web_review_points_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.fresh_view_points_result is not None:
            result['FreshViewPointsResult'] = self.fresh_view_points_result.to_map()
        if self.hot_view_points_result is not None:
            result['HotViewPointsResult'] = self.hot_view_points_result.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.timed_view_points_result is not None:
            result['TimedViewPointsResult'] = self.timed_view_points_result.to_map()
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_summary_result is not None:
            result['TopicSummaryResult'] = self.topic_summary_result.to_map()
        if self.web_review_points_result is not None:
            result['WebReviewPointsResult'] = self.web_review_points_result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FreshViewPointsResult') is not None:
            temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResult()
            self.fresh_view_points_result = temp_model.from_map(m['FreshViewPointsResult'])
        if m.get('HotViewPointsResult') is not None:
            temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResult()
            self.hot_view_points_result = temp_model.from_map(m['HotViewPointsResult'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TimedViewPointsResult') is not None:
            temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResult()
            self.timed_view_points_result = temp_model.from_map(m['TimedViewPointsResult'])
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicSummaryResult') is not None:
            temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResult()
            self.topic_summary_result = temp_model.from_map(m['TopicSummaryResult'])
        if m.get('WebReviewPointsResult') is not None:
            temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResult()
            self.web_review_points_result = temp_model.from_map(m['WebReviewPointsResult'])
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetTopicSelectionPerspectiveAnalysisTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTopicSelectionPerspectiveAnalysisTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTopicSelectionPerspectiveAnalysisTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTopicSelectionPerspectiveAnalysisTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportInterveneFileRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        doc_name: str = None,
        file_key: str = None,
        file_url: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.doc_name = doc_name
        self.file_key = file_key
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.doc_name is not None:
            result['DocName'] = self.doc_name
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('DocName') is not None:
            self.doc_name = m.get('DocName')
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class ImportInterveneFileResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        fail_id_list: List[str] = None,
        task_id: str = None,
    ):
        self.code = code
        self.fail_id_list = fail_id_list
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.fail_id_list is not None:
            result['FailIdList'] = self.fail_id_list
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('FailIdList') is not None:
            self.fail_id_list = m.get('FailIdList')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ImportInterveneFileResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ImportInterveneFileResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ImportInterveneFileResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ImportInterveneFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportInterveneFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportInterveneFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportInterveneFileAsyncRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        doc_name: str = None,
        file_key: str = None,
        file_url: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.doc_name = doc_name
        self.file_key = file_key
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.doc_name is not None:
            result['DocName'] = self.doc_name
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('DocName') is not None:
            self.doc_name = m.get('DocName')
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class ImportInterveneFileAsyncResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        fail_id_list: List[str] = None,
        task_id: str = None,
    ):
        self.code = code
        self.fail_id_list = fail_id_list
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.fail_id_list is not None:
            result['FailIdList'] = self.fail_id_list
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('FailIdList') is not None:
            self.fail_id_list = m.get('FailIdList')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ImportInterveneFileAsyncResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ImportInterveneFileAsyncResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ImportInterveneFileAsyncResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ImportInterveneFileAsyncResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportInterveneFileAsyncResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportInterveneFileAsyncResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertInterveneGlobalReplyRequestReplyMessagList(TeaModel):
    def __init__(
        self,
        message: str = None,
        reply_type: str = None,
    ):
        self.message = message
        self.reply_type = reply_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.reply_type is not None:
            result['ReplyType'] = self.reply_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ReplyType') is not None:
            self.reply_type = m.get('ReplyType')
        return self


class InsertInterveneGlobalReplyRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        reply_messag_list: List[InsertInterveneGlobalReplyRequestReplyMessagList] = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.reply_messag_list = reply_messag_list

    def validate(self):
        if self.reply_messag_list:
            for k in self.reply_messag_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        result['ReplyMessagList'] = []
        if self.reply_messag_list is not None:
            for k in self.reply_messag_list:
                result['ReplyMessagList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        self.reply_messag_list = []
        if m.get('ReplyMessagList') is not None:
            for k in m.get('ReplyMessagList'):
                temp_model = InsertInterveneGlobalReplyRequestReplyMessagList()
                self.reply_messag_list.append(temp_model.from_map(k))
        return self


class InsertInterveneGlobalReplyShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        reply_messag_list_shrink: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.reply_messag_list_shrink = reply_messag_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.reply_messag_list_shrink is not None:
            result['ReplyMessagList'] = self.reply_messag_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('ReplyMessagList') is not None:
            self.reply_messag_list_shrink = m.get('ReplyMessagList')
        return self


class InsertInterveneGlobalReplyResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        fail_id_list: List[str] = None,
        task_id: str = None,
    ):
        self.code = code
        self.fail_id_list = fail_id_list
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.fail_id_list is not None:
            result['FailIdList'] = self.fail_id_list
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('FailIdList') is not None:
            self.fail_id_list = m.get('FailIdList')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class InsertInterveneGlobalReplyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: InsertInterveneGlobalReplyResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = InsertInterveneGlobalReplyResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InsertInterveneGlobalReplyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertInterveneGlobalReplyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertInterveneGlobalReplyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InsertInterveneRuleRequestInterveneRuleConfigAnswerConfig(TeaModel):
    def __init__(
        self,
        answer_type: int = None,
        message: str = None,
        namespace: str = None,
    ):
        self.answer_type = answer_type
        self.message = message
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_type is not None:
            result['AnswerType'] = self.answer_type
        if self.message is not None:
            result['Message'] = self.message
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerType') is not None:
            self.answer_type = m.get('AnswerType')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class InsertInterveneRuleRequestInterveneRuleConfigEffectConfig(TeaModel):
    def __init__(
        self,
        effect_type: int = None,
        end_time: str = None,
        start_time: str = None,
    ):
        self.effect_type = effect_type
        self.end_time = end_time
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effect_type is not None:
            result['EffectType'] = self.effect_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EffectType') is not None:
            self.effect_type = m.get('EffectType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class InsertInterveneRuleRequestInterveneRuleConfigInterveneConfigList(TeaModel):
    def __init__(
        self,
        id: str = None,
        operation_type: int = None,
        query: str = None,
    ):
        # id
        self.id = id
        self.operation_type = operation_type
        self.query = query

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.operation_type is not None:
            result['OperationType'] = self.operation_type
        if self.query is not None:
            result['Query'] = self.query
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('OperationType') is not None:
            self.operation_type = m.get('OperationType')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        return self


class InsertInterveneRuleRequestInterveneRuleConfig(TeaModel):
    def __init__(
        self,
        answer_config: List[InsertInterveneRuleRequestInterveneRuleConfigAnswerConfig] = None,
        effect_config: InsertInterveneRuleRequestInterveneRuleConfigEffectConfig = None,
        intervene_config_list: List[InsertInterveneRuleRequestInterveneRuleConfigInterveneConfigList] = None,
        intervene_type: int = None,
        namespace_list: List[str] = None,
        rule_id: int = None,
        rule_name: str = None,
    ):
        self.answer_config = answer_config
        self.effect_config = effect_config
        self.intervene_config_list = intervene_config_list
        self.intervene_type = intervene_type
        self.namespace_list = namespace_list
        self.rule_id = rule_id
        self.rule_name = rule_name

    def validate(self):
        if self.answer_config:
            for k in self.answer_config:
                if k:
                    k.validate()
        if self.effect_config:
            self.effect_config.validate()
        if self.intervene_config_list:
            for k in self.intervene_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AnswerConfig'] = []
        if self.answer_config is not None:
            for k in self.answer_config:
                result['AnswerConfig'].append(k.to_map() if k else None)
        if self.effect_config is not None:
            result['EffectConfig'] = self.effect_config.to_map()
        result['InterveneConfigList'] = []
        if self.intervene_config_list is not None:
            for k in self.intervene_config_list:
                result['InterveneConfigList'].append(k.to_map() if k else None)
        if self.intervene_type is not None:
            result['InterveneType'] = self.intervene_type
        if self.namespace_list is not None:
            result['NamespaceList'] = self.namespace_list
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.answer_config = []
        if m.get('AnswerConfig') is not None:
            for k in m.get('AnswerConfig'):
                temp_model = InsertInterveneRuleRequestInterveneRuleConfigAnswerConfig()
                self.answer_config.append(temp_model.from_map(k))
        if m.get('EffectConfig') is not None:
            temp_model = InsertInterveneRuleRequestInterveneRuleConfigEffectConfig()
            self.effect_config = temp_model.from_map(m['EffectConfig'])
        self.intervene_config_list = []
        if m.get('InterveneConfigList') is not None:
            for k in m.get('InterveneConfigList'):
                temp_model = InsertInterveneRuleRequestInterveneRuleConfigInterveneConfigList()
                self.intervene_config_list.append(temp_model.from_map(k))
        if m.get('InterveneType') is not None:
            self.intervene_type = m.get('InterveneType')
        if m.get('NamespaceList') is not None:
            self.namespace_list = m.get('NamespaceList')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class InsertInterveneRuleRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        intervene_rule_config: InsertInterveneRuleRequestInterveneRuleConfig = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.intervene_rule_config = intervene_rule_config

    def validate(self):
        if self.intervene_rule_config:
            self.intervene_rule_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.intervene_rule_config is not None:
            result['InterveneRuleConfig'] = self.intervene_rule_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('InterveneRuleConfig') is not None:
            temp_model = InsertInterveneRuleRequestInterveneRuleConfig()
            self.intervene_rule_config = temp_model.from_map(m['InterveneRuleConfig'])
        return self


class InsertInterveneRuleShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        intervene_rule_config_shrink: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.intervene_rule_config_shrink = intervene_rule_config_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.intervene_rule_config_shrink is not None:
            result['InterveneRuleConfig'] = self.intervene_rule_config_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('InterveneRuleConfig') is not None:
            self.intervene_rule_config_shrink = m.get('InterveneRuleConfig')
        return self


class InsertInterveneRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        rule_id: int = None,
    ):
        self.code = code
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class InsertInterveneRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: InsertInterveneRuleResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = InsertInterveneRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InsertInterveneRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InsertInterveneRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InsertInterveneRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAnalysisTagDetailByTaskIdRequest(TeaModel):
    def __init__(
        self,
        categories: List[str] = None,
        current: int = None,
        max_results: int = None,
        next_token: str = None,
        size: int = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.categories = categories
        self.current = current
        self.max_results = max_results
        self.next_token = next_token
        self.size = size
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.categories is not None:
            result['Categories'] = self.categories
        if self.current is not None:
            result['Current'] = self.current
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.size is not None:
            result['Size'] = self.size
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Categories') is not None:
            self.categories = m.get('Categories')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListAnalysisTagDetailByTaskIdShrinkRequest(TeaModel):
    def __init__(
        self,
        categories_shrink: str = None,
        current: int = None,
        max_results: int = None,
        next_token: str = None,
        size: int = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.categories_shrink = categories_shrink
        self.current = current
        self.max_results = max_results
        self.next_token = next_token
        self.size = size
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.categories_shrink is not None:
            result['Categories'] = self.categories_shrink
        if self.current is not None:
            result['Current'] = self.current
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.size is not None:
            result['Size'] = self.size
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Categories') is not None:
            self.categories_shrink = m.get('Categories')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListAnalysisTagDetailByTaskIdResponseBodyDataContentTags(TeaModel):
    def __init__(
        self,
        summary_overview: str = None,
        tag_name: str = None,
        tags: List[str] = None,
    ):
        self.summary_overview = summary_overview
        self.tag_name = tag_name
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.summary_overview is not None:
            result['SummaryOverview'] = self.summary_overview
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SummaryOverview') is not None:
            self.summary_overview = m.get('SummaryOverview')
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class ListAnalysisTagDetailByTaskIdResponseBodyData(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_tags: List[ListAnalysisTagDetailByTaskIdResponseBodyDataContentTags] = None,
        id: int = None,
        tag_task_type: str = None,
        task_id: str = None,
    ):
        self.content = content
        self.content_tags = content_tags
        self.id = id
        self.tag_task_type = tag_task_type
        self.task_id = task_id

    def validate(self):
        if self.content_tags:
            for k in self.content_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        result['ContentTags'] = []
        if self.content_tags is not None:
            for k in self.content_tags:
                result['ContentTags'].append(k.to_map() if k else None)
        if self.id is not None:
            result['Id'] = self.id
        if self.tag_task_type is not None:
            result['TagTaskType'] = self.tag_task_type
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        self.content_tags = []
        if m.get('ContentTags') is not None:
            for k in m.get('ContentTags'):
                temp_model = ListAnalysisTagDetailByTaskIdResponseBodyDataContentTags()
                self.content_tags.append(temp_model.from_map(k))
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('TagTaskType') is not None:
            self.tag_task_type = m.get('TagTaskType')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ListAnalysisTagDetailByTaskIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListAnalysisTagDetailByTaskIdResponseBodyData] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAnalysisTagDetailByTaskIdResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAnalysisTagDetailByTaskIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAnalysisTagDetailByTaskIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAnalysisTagDetailByTaskIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAsyncTasksRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        create_time_end: str = None,
        create_time_start: str = None,
        current: int = None,
        size: int = None,
        task_code: str = None,
        task_name: str = None,
        task_status: int = None,
        task_status_list: List[int] = None,
        task_type: str = None,
        task_type_list: List[str] = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.create_time_end = create_time_end
        self.create_time_start = create_time_start
        self.current = current
        self.size = size
        self.task_code = task_code
        self.task_name = task_name
        self.task_status = task_status
        self.task_status_list = task_status_list
        self.task_type = task_type
        self.task_type_list = task_type_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.create_time_end is not None:
            result['CreateTimeEnd'] = self.create_time_end
        if self.create_time_start is not None:
            result['CreateTimeStart'] = self.create_time_start
        if self.current is not None:
            result['Current'] = self.current
        if self.size is not None:
            result['Size'] = self.size
        if self.task_code is not None:
            result['TaskCode'] = self.task_code
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.task_status_list is not None:
            result['TaskStatusList'] = self.task_status_list
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.task_type_list is not None:
            result['TaskTypeList'] = self.task_type_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CreateTimeEnd') is not None:
            self.create_time_end = m.get('CreateTimeEnd')
        if m.get('CreateTimeStart') is not None:
            self.create_time_start = m.get('CreateTimeStart')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TaskCode') is not None:
            self.task_code = m.get('TaskCode')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('TaskStatusList') is not None:
            self.task_status_list = m.get('TaskStatusList')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TaskTypeList') is not None:
            self.task_type_list = m.get('TaskTypeList')
        return self


class ListAsyncTasksShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        create_time_end: str = None,
        create_time_start: str = None,
        current: int = None,
        size: int = None,
        task_code: str = None,
        task_name: str = None,
        task_status: int = None,
        task_status_list_shrink: str = None,
        task_type: str = None,
        task_type_list_shrink: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.create_time_end = create_time_end
        self.create_time_start = create_time_start
        self.current = current
        self.size = size
        self.task_code = task_code
        self.task_name = task_name
        self.task_status = task_status
        self.task_status_list_shrink = task_status_list_shrink
        self.task_type = task_type
        self.task_type_list_shrink = task_type_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.create_time_end is not None:
            result['CreateTimeEnd'] = self.create_time_end
        if self.create_time_start is not None:
            result['CreateTimeStart'] = self.create_time_start
        if self.current is not None:
            result['Current'] = self.current
        if self.size is not None:
            result['Size'] = self.size
        if self.task_code is not None:
            result['TaskCode'] = self.task_code
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.task_status_list_shrink is not None:
            result['TaskStatusList'] = self.task_status_list_shrink
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.task_type_list_shrink is not None:
            result['TaskTypeList'] = self.task_type_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CreateTimeEnd') is not None:
            self.create_time_end = m.get('CreateTimeEnd')
        if m.get('CreateTimeStart') is not None:
            self.create_time_start = m.get('CreateTimeStart')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TaskCode') is not None:
            self.task_code = m.get('TaskCode')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('TaskStatusList') is not None:
            self.task_status_list_shrink = m.get('TaskStatusList')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TaskTypeList') is not None:
            self.task_type_list_shrink = m.get('TaskTypeList')
        return self


class ListAsyncTasksResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_user: str = None,
        id: int = None,
        task_code: str = None,
        task_definition: str = None,
        task_end_time: str = None,
        task_error_message: str = None,
        task_execute_time: str = None,
        task_id: str = None,
        task_inner_error_message: str = None,
        task_intermediate_result: str = None,
        task_name: str = None,
        task_param: str = None,
        task_progress_message: str = None,
        task_result: str = None,
        task_retry_count: str = None,
        task_start_time: str = None,
        task_status: int = None,
        task_type: str = None,
        update_time: str = None,
        update_user: str = None,
    ):
        self.create_time = create_time
        self.create_user = create_user
        self.id = id
        self.task_code = task_code
        self.task_definition = task_definition
        self.task_end_time = task_end_time
        self.task_error_message = task_error_message
        self.task_execute_time = task_execute_time
        self.task_id = task_id
        self.task_inner_error_message = task_inner_error_message
        self.task_intermediate_result = task_intermediate_result
        self.task_name = task_name
        self.task_param = task_param
        self.task_progress_message = task_progress_message
        self.task_result = task_result
        self.task_retry_count = task_retry_count
        self.task_start_time = task_start_time
        self.task_status = task_status
        self.task_type = task_type
        self.update_time = update_time
        self.update_user = update_user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.id is not None:
            result['Id'] = self.id
        if self.task_code is not None:
            result['TaskCode'] = self.task_code
        if self.task_definition is not None:
            result['TaskDefinition'] = self.task_definition
        if self.task_end_time is not None:
            result['TaskEndTime'] = self.task_end_time
        if self.task_error_message is not None:
            result['TaskErrorMessage'] = self.task_error_message
        if self.task_execute_time is not None:
            result['TaskExecuteTime'] = self.task_execute_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_inner_error_message is not None:
            result['TaskInnerErrorMessage'] = self.task_inner_error_message
        if self.task_intermediate_result is not None:
            result['TaskIntermediateResult'] = self.task_intermediate_result
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_param is not None:
            result['TaskParam'] = self.task_param
        if self.task_progress_message is not None:
            result['TaskProgressMessage'] = self.task_progress_message
        if self.task_result is not None:
            result['TaskResult'] = self.task_result
        if self.task_retry_count is not None:
            result['TaskRetryCount'] = self.task_retry_count
        if self.task_start_time is not None:
            result['TaskStartTime'] = self.task_start_time
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_user is not None:
            result['UpdateUser'] = self.update_user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('TaskCode') is not None:
            self.task_code = m.get('TaskCode')
        if m.get('TaskDefinition') is not None:
            self.task_definition = m.get('TaskDefinition')
        if m.get('TaskEndTime') is not None:
            self.task_end_time = m.get('TaskEndTime')
        if m.get('TaskErrorMessage') is not None:
            self.task_error_message = m.get('TaskErrorMessage')
        if m.get('TaskExecuteTime') is not None:
            self.task_execute_time = m.get('TaskExecuteTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskInnerErrorMessage') is not None:
            self.task_inner_error_message = m.get('TaskInnerErrorMessage')
        if m.get('TaskIntermediateResult') is not None:
            self.task_intermediate_result = m.get('TaskIntermediateResult')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskParam') is not None:
            self.task_param = m.get('TaskParam')
        if m.get('TaskProgressMessage') is not None:
            self.task_progress_message = m.get('TaskProgressMessage')
        if m.get('TaskResult') is not None:
            self.task_result = m.get('TaskResult')
        if m.get('TaskRetryCount') is not None:
            self.task_retry_count = m.get('TaskRetryCount')
        if m.get('TaskStartTime') is not None:
            self.task_start_time = m.get('TaskStartTime')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateUser') is not None:
            self.update_user = m.get('UpdateUser')
        return self


class ListAsyncTasksResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current: int = None,
        data: List[ListAsyncTasksResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        size: int = None,
        success: bool = None,
        total: int = None,
    ):
        self.code = code
        self.current = current
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.size = size
        self.success = success
        self.total = total

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current is not None:
            result['Current'] = self.current
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.size is not None:
            result['Size'] = self.size
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAsyncTasksResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListAsyncTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAsyncTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAsyncTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAuditContentErrorTypesRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        workspace_id: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListAuditContentErrorTypesResponseBodyDataSubClasses(TeaModel):
    def __init__(
        self,
        class_code: str = None,
        class_name: str = None,
    ):
        self.class_code = class_code
        self.class_name = class_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.class_code is not None:
            result['ClassCode'] = self.class_code
        if self.class_name is not None:
            result['ClassName'] = self.class_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClassCode') is not None:
            self.class_code = m.get('ClassCode')
        if m.get('ClassName') is not None:
            self.class_name = m.get('ClassName')
        return self


class ListAuditContentErrorTypesResponseBodyData(TeaModel):
    def __init__(
        self,
        major_class_code: str = None,
        major_class_name: str = None,
        sub_classes: List[ListAuditContentErrorTypesResponseBodyDataSubClasses] = None,
    ):
        self.major_class_code = major_class_code
        self.major_class_name = major_class_name
        self.sub_classes = sub_classes

    def validate(self):
        if self.sub_classes:
            for k in self.sub_classes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.major_class_code is not None:
            result['MajorClassCode'] = self.major_class_code
        if self.major_class_name is not None:
            result['MajorClassName'] = self.major_class_name
        result['SubClasses'] = []
        if self.sub_classes is not None:
            for k in self.sub_classes:
                result['SubClasses'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MajorClassCode') is not None:
            self.major_class_code = m.get('MajorClassCode')
        if m.get('MajorClassName') is not None:
            self.major_class_name = m.get('MajorClassName')
        self.sub_classes = []
        if m.get('SubClasses') is not None:
            for k in m.get('SubClasses'):
                temp_model = ListAuditContentErrorTypesResponseBodyDataSubClasses()
                self.sub_classes.append(temp_model.from_map(k))
        return self


class ListAuditContentErrorTypesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListAuditContentErrorTypesResponseBodyData] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        # Id of the request
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAuditContentErrorTypesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAuditContentErrorTypesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAuditContentErrorTypesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAuditContentErrorTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAuditTermsRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        workspace_id: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListAuditTermsResponseBodyData(TeaModel):
    def __init__(
        self,
        exception_word: List[str] = None,
        id: str = None,
        keyword: str = None,
        suggest_word: str = None,
        terms_desc: str = None,
    ):
        self.exception_word = exception_word
        self.id = id
        self.keyword = keyword
        self.suggest_word = suggest_word
        self.terms_desc = terms_desc

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exception_word is not None:
            result['ExceptionWord'] = self.exception_word
        if self.id is not None:
            result['Id'] = self.id
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.suggest_word is not None:
            result['SuggestWord'] = self.suggest_word
        if self.terms_desc is not None:
            result['TermsDesc'] = self.terms_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExceptionWord') is not None:
            self.exception_word = m.get('ExceptionWord')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('SuggestWord') is not None:
            self.suggest_word = m.get('SuggestWord')
        if m.get('TermsDesc') is not None:
            self.terms_desc = m.get('TermsDesc')
        return self


class ListAuditTermsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListAuditTermsResponseBodyData] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        # Id of the request
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAuditTermsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListAuditTermsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAuditTermsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAuditTermsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListBuildConfigsRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        region_id: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.region_id = region_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListBuildConfigsResponseBodyDataKeywords(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
    ):
        self.description = description
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class ListBuildConfigsResponseBodyData(TeaModel):
    def __init__(
        self,
        build_in: bool = None,
        create_time: str = None,
        create_user: str = None,
        id: int = None,
        keywords: List[ListBuildConfigsResponseBodyDataKeywords] = None,
        tag: str = None,
        tag_description: str = None,
        type: str = None,
        update_time: str = None,
        update_user: str = None,
    ):
        self.build_in = build_in
        self.create_time = create_time
        self.create_user = create_user
        self.id = id
        self.keywords = keywords
        self.tag = tag
        self.tag_description = tag_description
        self.type = type
        self.update_time = update_time
        self.update_user = update_user

    def validate(self):
        if self.keywords:
            for k in self.keywords:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.build_in is not None:
            result['BuildIn'] = self.build_in
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.id is not None:
            result['Id'] = self.id
        result['Keywords'] = []
        if self.keywords is not None:
            for k in self.keywords:
                result['Keywords'].append(k.to_map() if k else None)
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.tag_description is not None:
            result['TagDescription'] = self.tag_description
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_user is not None:
            result['UpdateUser'] = self.update_user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BuildIn') is not None:
            self.build_in = m.get('BuildIn')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        self.keywords = []
        if m.get('Keywords') is not None:
            for k in m.get('Keywords'):
                temp_model = ListBuildConfigsResponseBodyDataKeywords()
                self.keywords.append(temp_model.from_map(k))
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('TagDescription') is not None:
            self.tag_description = m.get('TagDescription')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateUser') is not None:
            self.update_user = m.get('UpdateUser')
        return self


class ListBuildConfigsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListBuildConfigsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListBuildConfigsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListBuildConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListBuildConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListBuildConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCustomTextRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        commodity_code: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.commodity_code = commodity_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        return self


class ListCustomTextResponseBodyData(TeaModel):
    def __init__(
        self,
        content: str = None,
        create_time: str = None,
        create_user: str = None,
        id: int = None,
        title: str = None,
        update_time: str = None,
        update_user: str = None,
    ):
        self.content = content
        self.create_time = create_time
        self.create_user = create_user
        self.id = id
        self.title = title
        self.update_time = update_time
        self.update_user = update_user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.id is not None:
            result['Id'] = self.id
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_user is not None:
            result['UpdateUser'] = self.update_user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateUser') is not None:
            self.update_user = m.get('UpdateUser')
        return self


class ListCustomTextResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListCustomTextResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListCustomTextResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListCustomTextResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCustomTextResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCustomTextResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCustomViewPointsRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        attitude: str = None,
        attitudes: List[str] = None,
        custom_view_point_id: str = None,
        custom_view_point_ids: List[str] = None,
        max_results: int = None,
        next_token: str = None,
        topic: str = None,
        topic_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.attitude = attitude
        self.attitudes = attitudes
        self.custom_view_point_id = custom_view_point_id
        self.custom_view_point_ids = custom_view_point_ids
        self.max_results = max_results
        self.next_token = next_token
        self.topic = topic
        self.topic_id = topic_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.attitudes is not None:
            result['Attitudes'] = self.attitudes
        if self.custom_view_point_id is not None:
            result['CustomViewPointId'] = self.custom_view_point_id
        if self.custom_view_point_ids is not None:
            result['CustomViewPointIds'] = self.custom_view_point_ids
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_id is not None:
            result['TopicId'] = self.topic_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('Attitudes') is not None:
            self.attitudes = m.get('Attitudes')
        if m.get('CustomViewPointId') is not None:
            self.custom_view_point_id = m.get('CustomViewPointId')
        if m.get('CustomViewPointIds') is not None:
            self.custom_view_point_ids = m.get('CustomViewPointIds')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicId') is not None:
            self.topic_id = m.get('TopicId')
        return self


class ListCustomViewPointsShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        attitude: str = None,
        attitudes_shrink: str = None,
        custom_view_point_id: str = None,
        custom_view_point_ids_shrink: str = None,
        max_results: int = None,
        next_token: str = None,
        topic: str = None,
        topic_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.attitude = attitude
        self.attitudes_shrink = attitudes_shrink
        self.custom_view_point_id = custom_view_point_id
        self.custom_view_point_ids_shrink = custom_view_point_ids_shrink
        self.max_results = max_results
        self.next_token = next_token
        self.topic = topic
        self.topic_id = topic_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.attitudes_shrink is not None:
            result['Attitudes'] = self.attitudes_shrink
        if self.custom_view_point_id is not None:
            result['CustomViewPointId'] = self.custom_view_point_id
        if self.custom_view_point_ids_shrink is not None:
            result['CustomViewPointIds'] = self.custom_view_point_ids_shrink
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_id is not None:
            result['TopicId'] = self.topic_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('Attitudes') is not None:
            self.attitudes_shrink = m.get('Attitudes')
        if m.get('CustomViewPointId') is not None:
            self.custom_view_point_id = m.get('CustomViewPointId')
        if m.get('CustomViewPointIds') is not None:
            self.custom_view_point_ids_shrink = m.get('CustomViewPointIds')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicId') is not None:
            self.topic_id = m.get('TopicId')
        return self


class ListCustomViewPointsResponseBodyDataViewPointsOutlines(TeaModel):
    def __init__(
        self,
        outline: str = None,
        summary: str = None,
    ):
        self.outline = outline
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.outline is not None:
            result['Outline'] = self.outline
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class ListCustomViewPointsResponseBodyDataViewPoints(TeaModel):
    def __init__(
        self,
        outlines: List[ListCustomViewPointsResponseBodyDataViewPointsOutlines] = None,
        point: str = None,
        summary: str = None,
    ):
        self.outlines = outlines
        self.point = point
        self.summary = summary

    def validate(self):
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.point is not None:
            result['Point'] = self.point
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = ListCustomViewPointsResponseBodyDataViewPointsOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Point') is not None:
            self.point = m.get('Point')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class ListCustomViewPointsResponseBodyData(TeaModel):
    def __init__(
        self,
        async_task_id: str = None,
        attitude: str = None,
        create_time: str = None,
        create_user: str = None,
        id: str = None,
        status: str = None,
        task_error_message: str = None,
        task_status: int = None,
        view_points: List[ListCustomViewPointsResponseBodyDataViewPoints] = None,
    ):
        self.async_task_id = async_task_id
        self.attitude = attitude
        self.create_time = create_time
        self.create_user = create_user
        self.id = id
        self.status = status
        self.task_error_message = task_error_message
        self.task_status = task_status
        self.view_points = view_points

    def validate(self):
        if self.view_points:
            for k in self.view_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['AsyncTaskId'] = self.async_task_id
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.id is not None:
            result['Id'] = self.id
        if self.status is not None:
            result['Status'] = self.status
        if self.task_error_message is not None:
            result['TaskErrorMessage'] = self.task_error_message
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        result['ViewPoints'] = []
        if self.view_points is not None:
            for k in self.view_points:
                result['ViewPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsyncTaskId') is not None:
            self.async_task_id = m.get('AsyncTaskId')
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskErrorMessage') is not None:
            self.task_error_message = m.get('TaskErrorMessage')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        self.view_points = []
        if m.get('ViewPoints') is not None:
            for k in m.get('ViewPoints'):
                temp_model = ListCustomViewPointsResponseBodyDataViewPoints()
                self.view_points.append(temp_model.from_map(k))
        return self


class ListCustomViewPointsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListCustomViewPointsResponseBodyData] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListCustomViewPointsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListCustomViewPointsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCustomViewPointsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCustomViewPointsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDatasetDocumentsRequest(TeaModel):
    def __init__(
        self,
        dataset_description: str = None,
        dataset_id: int = None,
        dataset_name: str = None,
        doc_type: str = None,
        exclude_fields: List[str] = None,
        include_fields: List[str] = None,
        page_number: int = None,
        page_size: int = None,
        query: str = None,
        status: int = None,
        workspace_id: str = None,
    ):
        self.dataset_description = dataset_description
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        self.doc_type = doc_type
        self.exclude_fields = exclude_fields
        self.include_fields = include_fields
        self.page_number = page_number
        self.page_size = page_size
        self.query = query
        self.status = status
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_description is not None:
            result['DatasetDescription'] = self.dataset_description
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.exclude_fields is not None:
            result['ExcludeFields'] = self.exclude_fields
        if self.include_fields is not None:
            result['IncludeFields'] = self.include_fields
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query is not None:
            result['Query'] = self.query
        if self.status is not None:
            result['Status'] = self.status
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetDescription') is not None:
            self.dataset_description = m.get('DatasetDescription')
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('ExcludeFields') is not None:
            self.exclude_fields = m.get('ExcludeFields')
        if m.get('IncludeFields') is not None:
            self.include_fields = m.get('IncludeFields')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDatasetDocumentsShrinkRequest(TeaModel):
    def __init__(
        self,
        dataset_description: str = None,
        dataset_id: int = None,
        dataset_name: str = None,
        doc_type: str = None,
        exclude_fields_shrink: str = None,
        include_fields_shrink: str = None,
        page_number: int = None,
        page_size: int = None,
        query: str = None,
        status: int = None,
        workspace_id: str = None,
    ):
        self.dataset_description = dataset_description
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        self.doc_type = doc_type
        self.exclude_fields_shrink = exclude_fields_shrink
        self.include_fields_shrink = include_fields_shrink
        self.page_number = page_number
        self.page_size = page_size
        self.query = query
        self.status = status
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_description is not None:
            result['DatasetDescription'] = self.dataset_description
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.exclude_fields_shrink is not None:
            result['ExcludeFields'] = self.exclude_fields_shrink
        if self.include_fields_shrink is not None:
            result['IncludeFields'] = self.include_fields_shrink
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query is not None:
            result['Query'] = self.query
        if self.status is not None:
            result['Status'] = self.status
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetDescription') is not None:
            self.dataset_description = m.get('DatasetDescription')
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('ExcludeFields') is not None:
            self.exclude_fields_shrink = m.get('ExcludeFields')
        if m.get('IncludeFields') is not None:
            self.include_fields_shrink = m.get('IncludeFields')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDatasetDocumentsResponseBodyDataMultimodalMedias(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        media_id: str = None,
        media_type: str = None,
    ):
        self.file_url = file_url
        self.media_id = media_id
        self.media_type = media_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class ListDatasetDocumentsResponseBodyData(TeaModel):
    def __init__(
        self,
        category_uuid: str = None,
        content: str = None,
        create_time: str = None,
        disable_handle_multimodal_media: bool = None,
        doc_id: str = None,
        doc_type: str = None,
        doc_uuid: str = None,
        extend_1: str = None,
        extend_2: str = None,
        extend_3: str = None,
        multimodal_medias: List[ListDatasetDocumentsResponseBodyDataMultimodalMedias] = None,
        pub_time: str = None,
        source_from: str = None,
        status: int = None,
        summary: str = None,
        title: str = None,
        update_time: str = None,
        url: str = None,
    ):
        self.category_uuid = category_uuid
        self.content = content
        self.create_time = create_time
        self.disable_handle_multimodal_media = disable_handle_multimodal_media
        self.doc_id = doc_id
        self.doc_type = doc_type
        self.doc_uuid = doc_uuid
        self.extend_1 = extend_1
        self.extend_2 = extend_2
        self.extend_3 = extend_3
        self.multimodal_medias = multimodal_medias
        self.pub_time = pub_time
        self.source_from = source_from
        self.status = status
        self.summary = summary
        self.title = title
        self.update_time = update_time
        # url
        self.url = url

    def validate(self):
        if self.multimodal_medias:
            for k in self.multimodal_medias:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_uuid is not None:
            result['CategoryUuid'] = self.category_uuid
        if self.content is not None:
            result['Content'] = self.content
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.disable_handle_multimodal_media is not None:
            result['DisableHandleMultimodalMedia'] = self.disable_handle_multimodal_media
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.extend_1 is not None:
            result['Extend1'] = self.extend_1
        if self.extend_2 is not None:
            result['Extend2'] = self.extend_2
        if self.extend_3 is not None:
            result['Extend3'] = self.extend_3
        result['MultimodalMedias'] = []
        if self.multimodal_medias is not None:
            for k in self.multimodal_medias:
                result['MultimodalMedias'].append(k.to_map() if k else None)
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source_from is not None:
            result['SourceFrom'] = self.source_from
        if self.status is not None:
            result['Status'] = self.status
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryUuid') is not None:
            self.category_uuid = m.get('CategoryUuid')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DisableHandleMultimodalMedia') is not None:
            self.disable_handle_multimodal_media = m.get('DisableHandleMultimodalMedia')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('Extend1') is not None:
            self.extend_1 = m.get('Extend1')
        if m.get('Extend2') is not None:
            self.extend_2 = m.get('Extend2')
        if m.get('Extend3') is not None:
            self.extend_3 = m.get('Extend3')
        self.multimodal_medias = []
        if m.get('MultimodalMedias') is not None:
            for k in m.get('MultimodalMedias'):
                temp_model = ListDatasetDocumentsResponseBodyDataMultimodalMedias()
                self.multimodal_medias.append(temp_model.from_map(k))
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('SourceFrom') is not None:
            self.source_from = m.get('SourceFrom')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListDatasetDocumentsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListDatasetDocumentsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDatasetDocumentsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDatasetDocumentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDatasetDocumentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDatasetDocumentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDatasetsRequest(TeaModel):
    def __init__(
        self,
        dataset_id: int = None,
        dataset_name: str = None,
        dataset_type: str = None,
        end_time: str = None,
        include_config: bool = None,
        page_number: int = None,
        page_size: str = None,
        search_dataset_enable: int = None,
        start_time: str = None,
        workspace_id: str = None,
    ):
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        self.dataset_type = dataset_type
        self.end_time = end_time
        self.include_config = include_config
        self.page_number = page_number
        self.page_size = page_size
        self.search_dataset_enable = search_dataset_enable
        self.start_time = start_time
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.dataset_type is not None:
            result['DatasetType'] = self.dataset_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.include_config is not None:
            result['IncludeConfig'] = self.include_config
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_dataset_enable is not None:
            result['SearchDatasetEnable'] = self.search_dataset_enable
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('DatasetType') is not None:
            self.dataset_type = m.get('DatasetType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IncludeConfig') is not None:
            self.include_config = m.get('IncludeConfig')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchDatasetEnable') is not None:
            self.search_dataset_enable = m.get('SearchDatasetEnable')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDatasetsResponseBodyCustomSemanticSearchConfig(TeaModel):
    def __init__(
        self,
        dataset_quota: int = None,
        dataset_used_quota: int = None,
        doc_quota: int = None,
        doc_used_quota: int = None,
    ):
        self.dataset_quota = dataset_quota
        self.dataset_used_quota = dataset_used_quota
        self.doc_quota = doc_quota
        self.doc_used_quota = doc_used_quota

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_quota is not None:
            result['DatasetQuota'] = self.dataset_quota
        if self.dataset_used_quota is not None:
            result['DatasetUsedQuota'] = self.dataset_used_quota
        if self.doc_quota is not None:
            result['DocQuota'] = self.doc_quota
        if self.doc_used_quota is not None:
            result['DocUsedQuota'] = self.doc_used_quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetQuota') is not None:
            self.dataset_quota = m.get('DatasetQuota')
        if m.get('DatasetUsedQuota') is not None:
            self.dataset_used_quota = m.get('DatasetUsedQuota')
        if m.get('DocQuota') is not None:
            self.doc_quota = m.get('DocQuota')
        if m.get('DocUsedQuota') is not None:
            self.doc_used_quota = m.get('DocUsedQuota')
        return self


class ListDatasetsResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_user: str = None,
        dataset_description: str = None,
        dataset_id: int = None,
        dataset_name: str = None,
        dataset_type: str = None,
        doc_used_quota: int = None,
        search_dataset_enable: int = None,
    ):
        self.create_time = create_time
        self.create_user = create_user
        self.dataset_description = dataset_description
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        self.dataset_type = dataset_type
        self.doc_used_quota = doc_used_quota
        self.search_dataset_enable = search_dataset_enable

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.dataset_description is not None:
            result['DatasetDescription'] = self.dataset_description
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.dataset_type is not None:
            result['DatasetType'] = self.dataset_type
        if self.doc_used_quota is not None:
            result['DocUsedQuota'] = self.doc_used_quota
        if self.search_dataset_enable is not None:
            result['SearchDatasetEnable'] = self.search_dataset_enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DatasetDescription') is not None:
            self.dataset_description = m.get('DatasetDescription')
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('DatasetType') is not None:
            self.dataset_type = m.get('DatasetType')
        if m.get('DocUsedQuota') is not None:
            self.doc_used_quota = m.get('DocUsedQuota')
        if m.get('SearchDatasetEnable') is not None:
            self.search_dataset_enable = m.get('SearchDatasetEnable')
        return self


class ListDatasetsResponseBodyThirdSearchConfig(TeaModel):
    def __init__(
        self,
        dataset_quota: int = None,
        dataset_used_quota: int = None,
    ):
        self.dataset_quota = dataset_quota
        self.dataset_used_quota = dataset_used_quota

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_quota is not None:
            result['DatasetQuota'] = self.dataset_quota
        if self.dataset_used_quota is not None:
            result['DatasetUsedQuota'] = self.dataset_used_quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetQuota') is not None:
            self.dataset_quota = m.get('DatasetQuota')
        if m.get('DatasetUsedQuota') is not None:
            self.dataset_used_quota = m.get('DatasetUsedQuota')
        return self


class ListDatasetsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        custom_semantic_search_config: ListDatasetsResponseBodyCustomSemanticSearchConfig = None,
        data: List[ListDatasetsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        third_search_config: ListDatasetsResponseBodyThirdSearchConfig = None,
        total_count: int = None,
    ):
        self.code = code
        self.custom_semantic_search_config = custom_semantic_search_config
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.success = success
        self.third_search_config = third_search_config
        self.total_count = total_count

    def validate(self):
        if self.custom_semantic_search_config:
            self.custom_semantic_search_config.validate()
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.third_search_config:
            self.third_search_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.custom_semantic_search_config is not None:
            result['CustomSemanticSearchConfig'] = self.custom_semantic_search_config.to_map()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.third_search_config is not None:
            result['ThirdSearchConfig'] = self.third_search_config.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CustomSemanticSearchConfig') is not None:
            temp_model = ListDatasetsResponseBodyCustomSemanticSearchConfig()
            self.custom_semantic_search_config = temp_model.from_map(m['CustomSemanticSearchConfig'])
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDatasetsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('ThirdSearchConfig') is not None:
            temp_model = ListDatasetsResponseBodyThirdSearchConfig()
            self.third_search_config = temp_model.from_map(m['ThirdSearchConfig'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDatasetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDatasetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDatasetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDialoguesRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        current: int = None,
        dialogue_type: int = None,
        end_time: str = None,
        size: int = None,
        start_time: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.current = current
        self.dialogue_type = dialogue_type
        self.end_time = end_time
        self.size = size
        self.start_time = start_time
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.current is not None:
            result['Current'] = self.current
        if self.dialogue_type is not None:
            result['DialogueType'] = self.dialogue_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('DialogueType') is not None:
            self.dialogue_type = m.get('DialogueType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ListDialoguesResponseBodyData(TeaModel):
    def __init__(
        self,
        bot: str = None,
        create_time: str = None,
        create_user: str = None,
        dialogue_type: int = None,
        task_id: str = None,
        user: str = None,
    ):
        self.bot = bot
        self.create_time = create_time
        self.create_user = create_user
        self.dialogue_type = dialogue_type
        self.task_id = task_id
        self.user = user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bot is not None:
            result['Bot'] = self.bot
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.dialogue_type is not None:
            result['DialogueType'] = self.dialogue_type
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bot') is not None:
            self.bot = m.get('Bot')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DialogueType') is not None:
            self.dialogue_type = m.get('DialogueType')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class ListDialoguesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current: int = None,
        data: List[ListDialoguesResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        size: int = None,
        success: bool = None,
        total: int = None,
    ):
        self.code = code
        self.current = current
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.size = size
        self.success = success
        self.total = total

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current is not None:
            result['Current'] = self.current
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.size is not None:
            result['Size'] = self.size
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDialoguesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListDialoguesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDialoguesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDialoguesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDocsRequest(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        doc_name: str = None,
        doc_type: str = None,
        max_results: int = None,
        next_token: str = None,
        skip: int = None,
        statuses: List[int] = None,
        workspace_id: str = None,
    ):
        self.category_id = category_id
        self.doc_name = doc_name
        self.doc_type = doc_type
        self.max_results = max_results
        self.next_token = next_token
        self.skip = skip
        self.statuses = statuses
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.doc_name is not None:
            result['DocName'] = self.doc_name
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.skip is not None:
            result['Skip'] = self.skip
        if self.statuses is not None:
            result['Statuses'] = self.statuses
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('DocName') is not None:
            self.doc_name = m.get('DocName')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Skip') is not None:
            self.skip = m.get('Skip')
        if m.get('Statuses') is not None:
            self.statuses = m.get('Statuses')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDocsShrinkRequest(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        doc_name: str = None,
        doc_type: str = None,
        max_results: int = None,
        next_token: str = None,
        skip: int = None,
        statuses_shrink: str = None,
        workspace_id: str = None,
    ):
        self.category_id = category_id
        self.doc_name = doc_name
        self.doc_type = doc_type
        self.max_results = max_results
        self.next_token = next_token
        self.skip = skip
        self.statuses_shrink = statuses_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.doc_name is not None:
            result['DocName'] = self.doc_name
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.skip is not None:
            result['Skip'] = self.skip
        if self.statuses_shrink is not None:
            result['Statuses'] = self.statuses_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('DocName') is not None:
            self.doc_name = m.get('DocName')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Skip') is not None:
            self.skip = m.get('Skip')
        if m.get('Statuses') is not None:
            self.statuses_shrink = m.get('Statuses')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListDocsResponseBodyData(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        create_time: int = None,
        doc_id: str = None,
        doc_name: str = None,
        doc_type: str = None,
        status: int = None,
        status_message: str = None,
    ):
        self.category_id = category_id
        self.create_time = create_time
        self.doc_id = doc_id
        self.doc_name = doc_name
        self.doc_type = doc_type
        self.status = status
        self.status_message = status_message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_name is not None:
            result['DocName'] = self.doc_name
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.status is not None:
            result['Status'] = self.status
        if self.status_message is not None:
            result['StatusMessage'] = self.status_message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocName') is not None:
            self.doc_name = m.get('DocName')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusMessage') is not None:
            self.status_message = m.get('StatusMessage')
        return self


class ListDocsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListDocsResponseBodyData] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListDocsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListDocsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDocsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDocsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFreshViewPointsRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        max_results: int = None,
        next_token: str = None,
        topic: str = None,
        topic_source: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.topic = topic
        # This parameter is required.
        self.topic_source = topic_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        return self


class ListFreshViewPointsResponseBodyDataOutlines(TeaModel):
    def __init__(
        self,
        outline: str = None,
        summary: str = None,
    ):
        self.outline = outline
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.outline is not None:
            result['Outline'] = self.outline
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class ListFreshViewPointsResponseBodyData(TeaModel):
    def __init__(
        self,
        outlines: List[ListFreshViewPointsResponseBodyDataOutlines] = None,
        point: str = None,
        summary: str = None,
    ):
        self.outlines = outlines
        self.point = point
        self.summary = summary

    def validate(self):
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.point is not None:
            result['Point'] = self.point
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = ListFreshViewPointsResponseBodyDataOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Point') is not None:
            self.point = m.get('Point')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class ListFreshViewPointsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListFreshViewPointsResponseBodyData] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListFreshViewPointsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListFreshViewPointsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFreshViewPointsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFreshViewPointsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListGeneratedContentsRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        content_domain: str = None,
        current: int = None,
        data_type: str = None,
        end_time: str = None,
        query: str = None,
        size: int = None,
        start_time: str = None,
        task_id: str = None,
        title: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.content_domain = content_domain
        self.current = current
        self.data_type = data_type
        self.end_time = end_time
        self.query = query
        self.size = size
        self.start_time = start_time
        self.task_id = task_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.content_domain is not None:
            result['ContentDomain'] = self.content_domain
        if self.current is not None:
            result['Current'] = self.current
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.query is not None:
            result['Query'] = self.query
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('ContentDomain') is not None:
            self.content_domain = m.get('ContentDomain')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class ListGeneratedContentsResponseBodyDataFileAttr(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        height: int = None,
        tmp_url: str = None,
        width: int = None,
    ):
        self.file_name = file_name
        self.height = height
        self.tmp_url = tmp_url
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.height is not None:
            result['Height'] = self.height
        if self.tmp_url is not None:
            result['TmpUrl'] = self.tmp_url
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('TmpUrl') is not None:
            self.tmp_url = m.get('TmpUrl')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListGeneratedContentsResponseBodyData(TeaModel):
    def __init__(
        self,
        content: str = None,
        content_domain: str = None,
        content_text: str = None,
        create_time: str = None,
        create_user: str = None,
        device_id: str = None,
        file_attr: ListGeneratedContentsResponseBodyDataFileAttr = None,
        file_key: str = None,
        id: int = None,
        keyword_list: List[str] = None,
        keywords: str = None,
        prompt: str = None,
        task_id: str = None,
        title: str = None,
        update_time: str = None,
        update_user: str = None,
        uuid: str = None,
    ):
        self.content = content
        self.content_domain = content_domain
        self.content_text = content_text
        self.create_time = create_time
        self.create_user = create_user
        self.device_id = device_id
        self.file_attr = file_attr
        self.file_key = file_key
        self.id = id
        self.keyword_list = keyword_list
        self.keywords = keywords
        self.prompt = prompt
        self.task_id = task_id
        self.title = title
        self.update_time = update_time
        self.update_user = update_user
        self.uuid = uuid

    def validate(self):
        if self.file_attr:
            self.file_attr.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.content_domain is not None:
            result['ContentDomain'] = self.content_domain
        if self.content_text is not None:
            result['ContentText'] = self.content_text
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.file_attr is not None:
            result['FileAttr'] = self.file_attr.to_map()
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        if self.id is not None:
            result['Id'] = self.id
        if self.keyword_list is not None:
            result['KeywordList'] = self.keyword_list
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_user is not None:
            result['UpdateUser'] = self.update_user
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentDomain') is not None:
            self.content_domain = m.get('ContentDomain')
        if m.get('ContentText') is not None:
            self.content_text = m.get('ContentText')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('FileAttr') is not None:
            temp_model = ListGeneratedContentsResponseBodyDataFileAttr()
            self.file_attr = temp_model.from_map(m['FileAttr'])
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('KeywordList') is not None:
            self.keyword_list = m.get('KeywordList')
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateUser') is not None:
            self.update_user = m.get('UpdateUser')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ListGeneratedContentsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current: int = None,
        data: List[ListGeneratedContentsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        size: int = None,
        success: bool = None,
        total: int = None,
    ):
        self.code = code
        self.current = current
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.size = size
        self.success = success
        self.total = total

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current is not None:
            result['Current'] = self.current
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.size is not None:
            result['Size'] = self.size
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListGeneratedContentsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListGeneratedContentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListGeneratedContentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListGeneratedContentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHotNewsWithTypeRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        current: int = None,
        news_type: str = None,
        news_types: List[str] = None,
        size: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.current = current
        self.news_type = news_type
        self.news_types = news_types
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.current is not None:
            result['Current'] = self.current
        if self.news_type is not None:
            result['NewsType'] = self.news_type
        if self.news_types is not None:
            result['NewsTypes'] = self.news_types
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('NewsType') is not None:
            self.news_type = m.get('NewsType')
        if m.get('NewsTypes') is not None:
            self.news_types = m.get('NewsTypes')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class ListHotNewsWithTypeShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        current: int = None,
        news_type: str = None,
        news_types_shrink: str = None,
        size: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.current = current
        self.news_type = news_type
        self.news_types_shrink = news_types_shrink
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.current is not None:
            result['Current'] = self.current
        if self.news_type is not None:
            result['NewsType'] = self.news_type
        if self.news_types_shrink is not None:
            result['NewsTypes'] = self.news_types_shrink
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('NewsType') is not None:
            self.news_type = m.get('NewsType')
        if m.get('NewsTypes') is not None:
            self.news_types_shrink = m.get('NewsTypes')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class ListHotNewsWithTypeResponseBodyDataNews(TeaModel):
    def __init__(
        self,
        author: str = None,
        content: str = None,
        doc_uuid: str = None,
        image_urls: List[str] = None,
        pub_time: str = None,
        search_source: str = None,
        search_source_name: str = None,
        source: str = None,
        summary: str = None,
        tag: str = None,
        title: str = None,
        update_time: str = None,
        url: str = None,
    ):
        self.author = author
        self.content = content
        self.doc_uuid = doc_uuid
        self.image_urls = image_urls
        self.pub_time = pub_time
        self.search_source = search_source
        self.search_source_name = search_source_name
        self.source = source
        self.summary = summary
        self.tag = tag
        self.title = title
        self.update_time = update_time
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.image_urls is not None:
            result['ImageUrls'] = self.image_urls
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.search_source is not None:
            result['SearchSource'] = self.search_source
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('ImageUrls') is not None:
            self.image_urls = m.get('ImageUrls')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('SearchSource') is not None:
            self.search_source = m.get('SearchSource')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListHotNewsWithTypeResponseBodyData(TeaModel):
    def __init__(
        self,
        news: List[ListHotNewsWithTypeResponseBodyDataNews] = None,
        news_type: str = None,
        news_type_name: str = None,
        total_pages: int = None,
    ):
        self.news = news
        self.news_type = news_type
        self.news_type_name = news_type_name
        self.total_pages = total_pages

    def validate(self):
        if self.news:
            for k in self.news:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['News'] = []
        if self.news is not None:
            for k in self.news:
                result['News'].append(k.to_map() if k else None)
        if self.news_type is not None:
            result['NewsType'] = self.news_type
        if self.news_type_name is not None:
            result['NewsTypeName'] = self.news_type_name
        if self.total_pages is not None:
            result['TotalPages'] = self.total_pages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.news = []
        if m.get('News') is not None:
            for k in m.get('News'):
                temp_model = ListHotNewsWithTypeResponseBodyDataNews()
                self.news.append(temp_model.from_map(k))
        if m.get('NewsType') is not None:
            self.news_type = m.get('NewsType')
        if m.get('NewsTypeName') is not None:
            self.news_type_name = m.get('NewsTypeName')
        if m.get('TotalPages') is not None:
            self.total_pages = m.get('TotalPages')
        return self


class ListHotNewsWithTypeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListHotNewsWithTypeResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListHotNewsWithTypeResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListHotNewsWithTypeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHotNewsWithTypeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHotNewsWithTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHotSourcesRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        max_results: int = None,
        next_token: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        return self


class ListHotSourcesResponseBodyData(TeaModel):
    def __init__(
        self,
        description: str = None,
        show: bool = None,
        sort: int = None,
        source: str = None,
    ):
        self.description = description
        self.show = show
        self.sort = sort
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.show is not None:
            result['Show'] = self.show
        if self.sort is not None:
            result['Sort'] = self.sort
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Show') is not None:
            self.show = m.get('Show')
        if m.get('Sort') is not None:
            self.sort = m.get('Sort')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class ListHotSourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListHotSourcesResponseBodyData] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListHotSourcesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHotSourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHotSourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHotSourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHotTopicsRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        max_results: int = None,
        next_token: str = None,
        topic_ids: List[str] = None,
        topic_query: str = None,
        topic_source: str = None,
        topic_version: str = None,
        topics: List[str] = None,
        with_news: bool = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.max_results = max_results
        self.next_token = next_token
        self.topic_ids = topic_ids
        self.topic_query = topic_query
        self.topic_source = topic_source
        self.topic_version = topic_version
        self.topics = topics
        self.with_news = with_news

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.topic_ids is not None:
            result['TopicIds'] = self.topic_ids
        if self.topic_query is not None:
            result['TopicQuery'] = self.topic_query
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        if self.topic_version is not None:
            result['TopicVersion'] = self.topic_version
        if self.topics is not None:
            result['Topics'] = self.topics
        if self.with_news is not None:
            result['WithNews'] = self.with_news
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TopicIds') is not None:
            self.topic_ids = m.get('TopicIds')
        if m.get('TopicQuery') is not None:
            self.topic_query = m.get('TopicQuery')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        if m.get('TopicVersion') is not None:
            self.topic_version = m.get('TopicVersion')
        if m.get('Topics') is not None:
            self.topics = m.get('Topics')
        if m.get('WithNews') is not None:
            self.with_news = m.get('WithNews')
        return self


class ListHotTopicsShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        max_results: int = None,
        next_token: str = None,
        topic_ids_shrink: str = None,
        topic_query: str = None,
        topic_source: str = None,
        topic_version: str = None,
        topics_shrink: str = None,
        with_news: bool = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.max_results = max_results
        self.next_token = next_token
        self.topic_ids_shrink = topic_ids_shrink
        self.topic_query = topic_query
        self.topic_source = topic_source
        self.topic_version = topic_version
        self.topics_shrink = topics_shrink
        self.with_news = with_news

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.topic_ids_shrink is not None:
            result['TopicIds'] = self.topic_ids_shrink
        if self.topic_query is not None:
            result['TopicQuery'] = self.topic_query
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        if self.topic_version is not None:
            result['TopicVersion'] = self.topic_version
        if self.topics_shrink is not None:
            result['Topics'] = self.topics_shrink
        if self.with_news is not None:
            result['WithNews'] = self.with_news
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('TopicIds') is not None:
            self.topic_ids_shrink = m.get('TopicIds')
        if m.get('TopicQuery') is not None:
            self.topic_query = m.get('TopicQuery')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        if m.get('TopicVersion') is not None:
            self.topic_version = m.get('TopicVersion')
        if m.get('Topics') is not None:
            self.topics_shrink = m.get('Topics')
        if m.get('WithNews') is not None:
            self.with_news = m.get('WithNews')
        return self


class ListHotTopicsResponseBodyDataStructureSummaryDocList(TeaModel):
    def __init__(
        self,
        source: str = None,
        title: str = None,
        url: str = None,
    ):
        self.source = source
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['Source'] = self.source
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListHotTopicsResponseBodyDataStructureSummary(TeaModel):
    def __init__(
        self,
        doc_list: List[ListHotTopicsResponseBodyDataStructureSummaryDocList] = None,
        summary: str = None,
        title: str = None,
    ):
        self.doc_list = doc_list
        self.summary = summary
        self.title = title

    def validate(self):
        if self.doc_list:
            for k in self.doc_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DocList'] = []
        if self.doc_list is not None:
            for k in self.doc_list:
                result['DocList'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.doc_list = []
        if m.get('DocList') is not None:
            for k in m.get('DocList'):
                temp_model = ListHotTopicsResponseBodyDataStructureSummaryDocList()
                self.doc_list.append(temp_model.from_map(k))
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class ListHotTopicsResponseBodyData(TeaModel):
    def __init__(
        self,
        async_task_id: str = None,
        create_user: str = None,
        hot_value: int = None,
        id: str = None,
        status: str = None,
        structure_summary: List[ListHotTopicsResponseBodyDataStructureSummary] = None,
        summary: str = None,
        task_error_message: str = None,
        task_status: int = None,
        topic: str = None,
        topic_source: str = None,
        version: str = None,
    ):
        self.async_task_id = async_task_id
        self.create_user = create_user
        self.hot_value = hot_value
        self.id = id
        self.status = status
        self.structure_summary = structure_summary
        self.summary = summary
        self.task_error_message = task_error_message
        self.task_status = task_status
        self.topic = topic
        self.topic_source = topic_source
        self.version = version

    def validate(self):
        if self.structure_summary:
            for k in self.structure_summary:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['AsyncTaskId'] = self.async_task_id
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.hot_value is not None:
            result['HotValue'] = self.hot_value
        if self.id is not None:
            result['Id'] = self.id
        if self.status is not None:
            result['Status'] = self.status
        result['StructureSummary'] = []
        if self.structure_summary is not None:
            for k in self.structure_summary:
                result['StructureSummary'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.task_error_message is not None:
            result['TaskErrorMessage'] = self.task_error_message
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsyncTaskId') is not None:
            self.async_task_id = m.get('AsyncTaskId')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('HotValue') is not None:
            self.hot_value = m.get('HotValue')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.structure_summary = []
        if m.get('StructureSummary') is not None:
            for k in m.get('StructureSummary'):
                temp_model = ListHotTopicsResponseBodyDataStructureSummary()
                self.structure_summary.append(temp_model.from_map(k))
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TaskErrorMessage') is not None:
            self.task_error_message = m.get('TaskErrorMessage')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListHotTopicsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListHotTopicsResponseBodyData] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListHotTopicsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHotTopicsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHotTopicsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHotTopicsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHotViewPointsRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        max_results: int = None,
        next_token: str = None,
        topic: str = None,
        topic_source: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.topic = topic
        # This parameter is required.
        self.topic_source = topic_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        return self


class ListHotViewPointsResponseBodyDataNews(TeaModel):
    def __init__(
        self,
        author: str = None,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        image_urls: List[str] = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        tags: List[str] = None,
        title: str = None,
        topic: str = None,
        url: str = None,
    ):
        self.author = author
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.image_urls = image_urls
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.tags = tags
        self.title = title
        self.topic = topic
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.image_urls is not None:
            result['ImageUrls'] = self.image_urls
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.title is not None:
            result['Title'] = self.title
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('ImageUrls') is not None:
            self.image_urls = m.get('ImageUrls')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListHotViewPointsResponseBodyDataViewPointsOutlines(TeaModel):
    def __init__(
        self,
        outline: str = None,
        summary: str = None,
    ):
        self.outline = outline
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.outline is not None:
            result['Outline'] = self.outline
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class ListHotViewPointsResponseBodyDataViewPoints(TeaModel):
    def __init__(
        self,
        outlines: List[ListHotViewPointsResponseBodyDataViewPointsOutlines] = None,
        point: str = None,
        summary: str = None,
    ):
        self.outlines = outlines
        self.point = point
        self.summary = summary

    def validate(self):
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.point is not None:
            result['Point'] = self.point
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = ListHotViewPointsResponseBodyDataViewPointsOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Point') is not None:
            self.point = m.get('Point')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class ListHotViewPointsResponseBodyData(TeaModel):
    def __init__(
        self,
        attitude: str = None,
        attitude_type: str = None,
        news: List[ListHotViewPointsResponseBodyDataNews] = None,
        ratio: str = None,
        view_points: List[ListHotViewPointsResponseBodyDataViewPoints] = None,
    ):
        self.attitude = attitude
        self.attitude_type = attitude_type
        self.news = news
        self.ratio = ratio
        self.view_points = view_points

    def validate(self):
        if self.news:
            for k in self.news:
                if k:
                    k.validate()
        if self.view_points:
            for k in self.view_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.attitude_type is not None:
            result['AttitudeType'] = self.attitude_type
        result['News'] = []
        if self.news is not None:
            for k in self.news:
                result['News'].append(k.to_map() if k else None)
        if self.ratio is not None:
            result['Ratio'] = self.ratio
        result['ViewPoints'] = []
        if self.view_points is not None:
            for k in self.view_points:
                result['ViewPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('AttitudeType') is not None:
            self.attitude_type = m.get('AttitudeType')
        self.news = []
        if m.get('News') is not None:
            for k in m.get('News'):
                temp_model = ListHotViewPointsResponseBodyDataNews()
                self.news.append(temp_model.from_map(k))
        if m.get('Ratio') is not None:
            self.ratio = m.get('Ratio')
        self.view_points = []
        if m.get('ViewPoints') is not None:
            for k in m.get('ViewPoints'):
                temp_model = ListHotViewPointsResponseBodyDataViewPoints()
                self.view_points.append(temp_model.from_map(k))
        return self


class ListHotViewPointsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListHotViewPointsResponseBodyData] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListHotViewPointsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListHotViewPointsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHotViewPointsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHotViewPointsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInterveneCntRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        page_index: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.page_index = page_index
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListInterveneCntResponseBodyData(TeaModel):
    def __init__(
        self,
        cnt_list: List[Any] = None,
        code: int = None,
        page_cnt: int = None,
        page_index: int = None,
        page_size: int = None,
    ):
        self.cnt_list = cnt_list
        self.code = code
        self.page_cnt = page_cnt
        self.page_index = page_index
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cnt_list is not None:
            result['CntList'] = self.cnt_list
        if self.code is not None:
            result['Code'] = self.code
        if self.page_cnt is not None:
            result['PageCnt'] = self.page_cnt
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CntList') is not None:
            self.cnt_list = m.get('CntList')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('PageCnt') is not None:
            self.page_cnt = m.get('PageCnt')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListInterveneCntResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListInterveneCntResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListInterveneCntResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListInterveneCntResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInterveneCntResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInterveneCntResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInterveneImportTasksRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        page_index: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.page_index = page_index
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListInterveneImportTasksResponseBodyDataStatusList(TeaModel):
    def __init__(
        self,
        msg: str = None,
        percentage: int = None,
        status: int = None,
        task_id: str = None,
        task_name: str = None,
    ):
        self.msg = msg
        self.percentage = percentage
        self.status = status
        self.task_id = task_id
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.percentage is not None:
            result['Percentage'] = self.percentage
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Percentage') is not None:
            self.percentage = m.get('Percentage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class ListInterveneImportTasksResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        page_index: int = None,
        page_size: int = None,
        status_list: List[ListInterveneImportTasksResponseBodyDataStatusList] = None,
        total_size: int = None,
    ):
        self.code = code
        self.page_index = page_index
        self.page_size = page_size
        self.status_list = status_list
        self.total_size = total_size

    def validate(self):
        if self.status_list:
            for k in self.status_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['StatusList'] = []
        if self.status_list is not None:
            for k in self.status_list:
                result['StatusList'].append(k.to_map() if k else None)
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.status_list = []
        if m.get('StatusList') is not None:
            for k in m.get('StatusList'):
                temp_model = ListInterveneImportTasksResponseBodyDataStatusList()
                self.status_list.append(temp_model.from_map(k))
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListInterveneImportTasksResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListInterveneImportTasksResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListInterveneImportTasksResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListInterveneImportTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInterveneImportTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInterveneImportTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInterveneRulesRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        page_index: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.page_index = page_index
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListInterveneRulesResponseBodyDataInterveneRuleListAnswerConfig(TeaModel):
    def __init__(
        self,
        answer_type: int = None,
        message: str = None,
        namespace: str = None,
    ):
        self.answer_type = answer_type
        self.message = message
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.answer_type is not None:
            result['AnswerType'] = self.answer_type
        if self.message is not None:
            result['Message'] = self.message
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnswerType') is not None:
            self.answer_type = m.get('AnswerType')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class ListInterveneRulesResponseBodyDataInterveneRuleList(TeaModel):
    def __init__(
        self,
        answer_config: List[ListInterveneRulesResponseBodyDataInterveneRuleListAnswerConfig] = None,
        create_time: str = None,
        effect_time: str = None,
        intervene_type: int = None,
        namespace_list: List[str] = None,
        rule_id: int = None,
        rule_name: str = None,
    ):
        self.answer_config = answer_config
        self.create_time = create_time
        self.effect_time = effect_time
        self.intervene_type = intervene_type
        self.namespace_list = namespace_list
        self.rule_id = rule_id
        self.rule_name = rule_name

    def validate(self):
        if self.answer_config:
            for k in self.answer_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AnswerConfig'] = []
        if self.answer_config is not None:
            for k in self.answer_config:
                result['AnswerConfig'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.effect_time is not None:
            result['EffectTime'] = self.effect_time
        if self.intervene_type is not None:
            result['InterveneType'] = self.intervene_type
        if self.namespace_list is not None:
            result['NamespaceList'] = self.namespace_list
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.answer_config = []
        if m.get('AnswerConfig') is not None:
            for k in m.get('AnswerConfig'):
                temp_model = ListInterveneRulesResponseBodyDataInterveneRuleListAnswerConfig()
                self.answer_config.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EffectTime') is not None:
            self.effect_time = m.get('EffectTime')
        if m.get('InterveneType') is not None:
            self.intervene_type = m.get('InterveneType')
        if m.get('NamespaceList') is not None:
            self.namespace_list = m.get('NamespaceList')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class ListInterveneRulesResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        count: int = None,
        intervene_rule_list: List[ListInterveneRulesResponseBodyDataInterveneRuleList] = None,
        page_index: int = None,
        page_size: int = None,
    ):
        self.code = code
        self.count = count
        self.intervene_rule_list = intervene_rule_list
        self.page_index = page_index
        self.page_size = page_size

    def validate(self):
        if self.intervene_rule_list:
            for k in self.intervene_rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        result['InterveneRuleList'] = []
        if self.intervene_rule_list is not None:
            for k in self.intervene_rule_list:
                result['InterveneRuleList'].append(k.to_map() if k else None)
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.intervene_rule_list = []
        if m.get('InterveneRuleList') is not None:
            for k in m.get('InterveneRuleList'):
                temp_model = ListInterveneRulesResponseBodyDataInterveneRuleList()
                self.intervene_rule_list.append(temp_model.from_map(k))
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListInterveneRulesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListInterveneRulesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListInterveneRulesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListInterveneRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInterveneRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInterveneRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntervenesRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        intervene_type: int = None,
        page_index: int = None,
        page_size: int = None,
        query: str = None,
        rule_id: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.intervene_type = intervene_type
        self.page_index = page_index
        self.page_size = page_size
        self.query = query
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.intervene_type is not None:
            result['InterveneType'] = self.intervene_type
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query is not None:
            result['Query'] = self.query
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('InterveneType') is not None:
            self.intervene_type = m.get('InterveneType')
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class ListIntervenesResponseBodyDataInterveneList(TeaModel):
    def __init__(
        self,
        id: str = None,
        query: str = None,
    ):
        # id
        self.id = id
        self.query = query

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.query is not None:
            result['Query'] = self.query
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        return self


class ListIntervenesResponseBodyData(TeaModel):
    def __init__(
        self,
        code: int = None,
        intervene_list: List[ListIntervenesResponseBodyDataInterveneList] = None,
        page_index: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        self.code = code
        self.intervene_list = intervene_list
        self.page_index = page_index
        self.page_size = page_size
        self.total_size = total_size

    def validate(self):
        if self.intervene_list:
            for k in self.intervene_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['InterveneList'] = []
        if self.intervene_list is not None:
            for k in self.intervene_list:
                result['InterveneList'].append(k.to_map() if k else None)
        if self.page_index is not None:
            result['PageIndex'] = self.page_index
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.intervene_list = []
        if m.get('InterveneList') is not None:
            for k in m.get('InterveneList'):
                temp_model = ListIntervenesResponseBodyDataInterveneList()
                self.intervene_list.append(temp_model.from_map(k))
        if m.get('PageIndex') is not None:
            self.page_index = m.get('PageIndex')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ListIntervenesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListIntervenesResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListIntervenesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListIntervenesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntervenesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntervenesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMaterialDocumentsRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        content: str = None,
        create_time_end: str = None,
        create_time_start: str = None,
        current: int = None,
        doc_type: str = None,
        doc_type_list: List[str] = None,
        generate_public_url: bool = None,
        id: int = None,
        keywords: List[str] = None,
        query: str = None,
        share_attr: int = None,
        size: int = None,
        title: str = None,
        update_time_end: str = None,
        update_time_start: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.content = content
        self.create_time_end = create_time_end
        self.create_time_start = create_time_start
        self.current = current
        self.doc_type = doc_type
        self.doc_type_list = doc_type_list
        self.generate_public_url = generate_public_url
        self.id = id
        self.keywords = keywords
        self.query = query
        self.share_attr = share_attr
        self.size = size
        self.title = title
        self.update_time_end = update_time_end
        self.update_time_start = update_time_start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.content is not None:
            result['Content'] = self.content
        if self.create_time_end is not None:
            result['CreateTimeEnd'] = self.create_time_end
        if self.create_time_start is not None:
            result['CreateTimeStart'] = self.create_time_start
        if self.current is not None:
            result['Current'] = self.current
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.doc_type_list is not None:
            result['DocTypeList'] = self.doc_type_list
        if self.generate_public_url is not None:
            result['GeneratePublicUrl'] = self.generate_public_url
        if self.id is not None:
            result['Id'] = self.id
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        if self.query is not None:
            result['Query'] = self.query
        if self.share_attr is not None:
            result['ShareAttr'] = self.share_attr
        if self.size is not None:
            result['Size'] = self.size
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time_end is not None:
            result['UpdateTimeEnd'] = self.update_time_end
        if self.update_time_start is not None:
            result['UpdateTimeStart'] = self.update_time_start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateTimeEnd') is not None:
            self.create_time_end = m.get('CreateTimeEnd')
        if m.get('CreateTimeStart') is not None:
            self.create_time_start = m.get('CreateTimeStart')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('DocTypeList') is not None:
            self.doc_type_list = m.get('DocTypeList')
        if m.get('GeneratePublicUrl') is not None:
            self.generate_public_url = m.get('GeneratePublicUrl')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('ShareAttr') is not None:
            self.share_attr = m.get('ShareAttr')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTimeEnd') is not None:
            self.update_time_end = m.get('UpdateTimeEnd')
        if m.get('UpdateTimeStart') is not None:
            self.update_time_start = m.get('UpdateTimeStart')
        return self


class ListMaterialDocumentsShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        content: str = None,
        create_time_end: str = None,
        create_time_start: str = None,
        current: int = None,
        doc_type: str = None,
        doc_type_list_shrink: str = None,
        generate_public_url: bool = None,
        id: int = None,
        keywords_shrink: str = None,
        query: str = None,
        share_attr: int = None,
        size: int = None,
        title: str = None,
        update_time_end: str = None,
        update_time_start: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.content = content
        self.create_time_end = create_time_end
        self.create_time_start = create_time_start
        self.current = current
        self.doc_type = doc_type
        self.doc_type_list_shrink = doc_type_list_shrink
        self.generate_public_url = generate_public_url
        self.id = id
        self.keywords_shrink = keywords_shrink
        self.query = query
        self.share_attr = share_attr
        self.size = size
        self.title = title
        self.update_time_end = update_time_end
        self.update_time_start = update_time_start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.content is not None:
            result['Content'] = self.content
        if self.create_time_end is not None:
            result['CreateTimeEnd'] = self.create_time_end
        if self.create_time_start is not None:
            result['CreateTimeStart'] = self.create_time_start
        if self.current is not None:
            result['Current'] = self.current
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.doc_type_list_shrink is not None:
            result['DocTypeList'] = self.doc_type_list_shrink
        if self.generate_public_url is not None:
            result['GeneratePublicUrl'] = self.generate_public_url
        if self.id is not None:
            result['Id'] = self.id
        if self.keywords_shrink is not None:
            result['Keywords'] = self.keywords_shrink
        if self.query is not None:
            result['Query'] = self.query
        if self.share_attr is not None:
            result['ShareAttr'] = self.share_attr
        if self.size is not None:
            result['Size'] = self.size
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time_end is not None:
            result['UpdateTimeEnd'] = self.update_time_end
        if self.update_time_start is not None:
            result['UpdateTimeStart'] = self.update_time_start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateTimeEnd') is not None:
            self.create_time_end = m.get('CreateTimeEnd')
        if m.get('CreateTimeStart') is not None:
            self.create_time_start = m.get('CreateTimeStart')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('DocTypeList') is not None:
            self.doc_type_list_shrink = m.get('DocTypeList')
        if m.get('GeneratePublicUrl') is not None:
            self.generate_public_url = m.get('GeneratePublicUrl')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Keywords') is not None:
            self.keywords_shrink = m.get('Keywords')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('ShareAttr') is not None:
            self.share_attr = m.get('ShareAttr')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTimeEnd') is not None:
            self.update_time_end = m.get('UpdateTimeEnd')
        if m.get('UpdateTimeStart') is not None:
            self.update_time_start = m.get('UpdateTimeStart')
        return self


class ListMaterialDocumentsResponseBodyDataFileAttr(TeaModel):
    def __init__(
        self,
        duration: float = None,
        file_length: int = None,
        file_name: str = None,
        height: int = None,
        mime_type: str = None,
        width: int = None,
    ):
        self.duration = duration
        self.file_length = file_length
        self.file_name = file_name
        self.height = height
        self.mime_type = mime_type
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_length is not None:
            result['FileLength'] = self.file_length
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.height is not None:
            result['Height'] = self.height
        if self.mime_type is not None:
            result['MimeType'] = self.mime_type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileLength') is not None:
            self.file_length = m.get('FileLength')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MimeType') is not None:
            self.mime_type = m.get('MimeType')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListMaterialDocumentsResponseBodyData(TeaModel):
    def __init__(
        self,
        author: str = None,
        create_time: str = None,
        create_user: str = None,
        create_user_name: str = None,
        doc_keywords: List[str] = None,
        doc_type: str = None,
        external_url: str = None,
        file_attr: ListMaterialDocumentsResponseBodyDataFileAttr = None,
        file_key: str = None,
        html_content: str = None,
        id: int = None,
        pub_time: str = None,
        public_url: str = None,
        share_attr: int = None,
        src_from: str = None,
        summary: str = None,
        text_content: str = None,
        thumbnail_in_base_64: str = None,
        title: str = None,
        update_time: str = None,
        update_user: str = None,
        update_user_name: str = None,
        url: str = None,
    ):
        self.author = author
        self.create_time = create_time
        self.create_user = create_user
        self.create_user_name = create_user_name
        self.doc_keywords = doc_keywords
        self.doc_type = doc_type
        self.external_url = external_url
        self.file_attr = file_attr
        self.file_key = file_key
        self.html_content = html_content
        self.id = id
        self.pub_time = pub_time
        self.public_url = public_url
        self.share_attr = share_attr
        self.src_from = src_from
        self.summary = summary
        self.text_content = text_content
        self.thumbnail_in_base_64 = thumbnail_in_base_64
        self.title = title
        self.update_time = update_time
        self.update_user = update_user
        self.update_user_name = update_user_name
        self.url = url

    def validate(self):
        if self.file_attr:
            self.file_attr.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.create_user_name is not None:
            result['CreateUserName'] = self.create_user_name
        if self.doc_keywords is not None:
            result['DocKeywords'] = self.doc_keywords
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.external_url is not None:
            result['ExternalUrl'] = self.external_url
        if self.file_attr is not None:
            result['FileAttr'] = self.file_attr.to_map()
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        if self.html_content is not None:
            result['HtmlContent'] = self.html_content
        if self.id is not None:
            result['Id'] = self.id
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.public_url is not None:
            result['PublicUrl'] = self.public_url
        if self.share_attr is not None:
            result['ShareAttr'] = self.share_attr
        if self.src_from is not None:
            result['SrcFrom'] = self.src_from
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.text_content is not None:
            result['TextContent'] = self.text_content
        if self.thumbnail_in_base_64 is not None:
            result['ThumbnailInBase64'] = self.thumbnail_in_base_64
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_user is not None:
            result['UpdateUser'] = self.update_user
        if self.update_user_name is not None:
            result['UpdateUserName'] = self.update_user_name
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('CreateUserName') is not None:
            self.create_user_name = m.get('CreateUserName')
        if m.get('DocKeywords') is not None:
            self.doc_keywords = m.get('DocKeywords')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('ExternalUrl') is not None:
            self.external_url = m.get('ExternalUrl')
        if m.get('FileAttr') is not None:
            temp_model = ListMaterialDocumentsResponseBodyDataFileAttr()
            self.file_attr = temp_model.from_map(m['FileAttr'])
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        if m.get('HtmlContent') is not None:
            self.html_content = m.get('HtmlContent')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('PublicUrl') is not None:
            self.public_url = m.get('PublicUrl')
        if m.get('ShareAttr') is not None:
            self.share_attr = m.get('ShareAttr')
        if m.get('SrcFrom') is not None:
            self.src_from = m.get('SrcFrom')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TextContent') is not None:
            self.text_content = m.get('TextContent')
        if m.get('ThumbnailInBase64') is not None:
            self.thumbnail_in_base_64 = m.get('ThumbnailInBase64')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateUser') is not None:
            self.update_user = m.get('UpdateUser')
        if m.get('UpdateUserName') is not None:
            self.update_user_name = m.get('UpdateUserName')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListMaterialDocumentsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current: int = None,
        data: List[ListMaterialDocumentsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        size: int = None,
        success: bool = None,
        total: int = None,
    ):
        self.code = code
        self.current = current
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.size = size
        self.success = success
        self.total = total

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current is not None:
            result['Current'] = self.current
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.size is not None:
            result['Size'] = self.size
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListMaterialDocumentsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListMaterialDocumentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMaterialDocumentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMaterialDocumentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPlanningProposalRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        custom_view_point_id: str = None,
        custom_view_point_ids: List[str] = None,
        max_results: int = None,
        next_token: str = None,
        titles: List[str] = None,
        topic: str = None,
        topic_source: str = None,
        topic_version: str = None,
        view_point_type: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.custom_view_point_id = custom_view_point_id
        self.custom_view_point_ids = custom_view_point_ids
        self.max_results = max_results
        self.next_token = next_token
        self.titles = titles
        # This parameter is required.
        self.topic = topic
        # This parameter is required.
        self.topic_source = topic_source
        self.topic_version = topic_version
        # This parameter is required.
        self.view_point_type = view_point_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.custom_view_point_id is not None:
            result['CustomViewPointId'] = self.custom_view_point_id
        if self.custom_view_point_ids is not None:
            result['CustomViewPointIds'] = self.custom_view_point_ids
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.titles is not None:
            result['Titles'] = self.titles
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        if self.topic_version is not None:
            result['TopicVersion'] = self.topic_version
        if self.view_point_type is not None:
            result['ViewPointType'] = self.view_point_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CustomViewPointId') is not None:
            self.custom_view_point_id = m.get('CustomViewPointId')
        if m.get('CustomViewPointIds') is not None:
            self.custom_view_point_ids = m.get('CustomViewPointIds')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Titles') is not None:
            self.titles = m.get('Titles')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        if m.get('TopicVersion') is not None:
            self.topic_version = m.get('TopicVersion')
        if m.get('ViewPointType') is not None:
            self.view_point_type = m.get('ViewPointType')
        return self


class ListPlanningProposalShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        custom_view_point_id: str = None,
        custom_view_point_ids_shrink: str = None,
        max_results: int = None,
        next_token: str = None,
        titles_shrink: str = None,
        topic: str = None,
        topic_source: str = None,
        topic_version: str = None,
        view_point_type: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.custom_view_point_id = custom_view_point_id
        self.custom_view_point_ids_shrink = custom_view_point_ids_shrink
        self.max_results = max_results
        self.next_token = next_token
        self.titles_shrink = titles_shrink
        # This parameter is required.
        self.topic = topic
        # This parameter is required.
        self.topic_source = topic_source
        self.topic_version = topic_version
        # This parameter is required.
        self.view_point_type = view_point_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.custom_view_point_id is not None:
            result['CustomViewPointId'] = self.custom_view_point_id
        if self.custom_view_point_ids_shrink is not None:
            result['CustomViewPointIds'] = self.custom_view_point_ids_shrink
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.titles_shrink is not None:
            result['Titles'] = self.titles_shrink
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        if self.topic_version is not None:
            result['TopicVersion'] = self.topic_version
        if self.view_point_type is not None:
            result['ViewPointType'] = self.view_point_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CustomViewPointId') is not None:
            self.custom_view_point_id = m.get('CustomViewPointId')
        if m.get('CustomViewPointIds') is not None:
            self.custom_view_point_ids_shrink = m.get('CustomViewPointIds')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Titles') is not None:
            self.titles_shrink = m.get('Titles')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        if m.get('TopicVersion') is not None:
            self.topic_version = m.get('TopicVersion')
        if m.get('ViewPointType') is not None:
            self.view_point_type = m.get('ViewPointType')
        return self


class ListPlanningProposalResponseBodyDataOutlines(TeaModel):
    def __init__(
        self,
        outline: str = None,
        summary: str = None,
    ):
        self.outline = outline
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.outline is not None:
            result['Outline'] = self.outline
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class ListPlanningProposalResponseBodyData(TeaModel):
    def __init__(
        self,
        outlines: List[ListPlanningProposalResponseBodyDataOutlines] = None,
        summary: str = None,
        title: str = None,
    ):
        self.outlines = outlines
        self.summary = summary
        self.title = title

    def validate(self):
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = ListPlanningProposalResponseBodyDataOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class ListPlanningProposalResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListPlanningProposalResponseBodyData] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListPlanningProposalResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListPlanningProposalResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPlanningProposalResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPlanningProposalResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSearchTaskDialogueDatasRequest(TeaModel):
    def __init__(
        self,
        include_content: bool = None,
        multimodal_search_type: str = None,
        original_session_id: str = None,
        page_number: int = None,
        page_size: int = None,
        query: str = None,
        search_model: str = None,
        search_model_data_value: str = None,
        session_id: str = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.include_content = include_content
        self.multimodal_search_type = multimodal_search_type
        self.original_session_id = original_session_id
        self.page_number = page_number
        self.page_size = page_size
        self.query = query
        self.search_model = search_model
        self.search_model_data_value = search_model_data_value
        # This parameter is required.
        self.session_id = session_id
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.include_content is not None:
            result['IncludeContent'] = self.include_content
        if self.multimodal_search_type is not None:
            result['MultimodalSearchType'] = self.multimodal_search_type
        if self.original_session_id is not None:
            result['OriginalSessionId'] = self.original_session_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query is not None:
            result['Query'] = self.query
        if self.search_model is not None:
            result['SearchModel'] = self.search_model
        if self.search_model_data_value is not None:
            result['SearchModelDataValue'] = self.search_model_data_value
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IncludeContent') is not None:
            self.include_content = m.get('IncludeContent')
        if m.get('MultimodalSearchType') is not None:
            self.multimodal_search_type = m.get('MultimodalSearchType')
        if m.get('OriginalSessionId') is not None:
            self.original_session_id = m.get('OriginalSessionId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('SearchModel') is not None:
            self.search_model = m.get('SearchModel')
        if m.get('SearchModelDataValue') is not None:
            self.search_model_data_value = m.get('SearchModelDataValue')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListSearchTaskDialogueDatasResponseBodyArticlesMultimodalMedias(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        media_id: str = None,
        media_type: str = None,
    ):
        self.file_url = file_url
        self.media_id = media_id
        self.media_type = media_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class ListSearchTaskDialogueDatasResponseBodyArticles(TeaModel):
    def __init__(
        self,
        author: str = None,
        category_uuid: str = None,
        content: str = None,
        doc_id: str = None,
        doc_type: str = None,
        doc_uuid: str = None,
        extend_1: str = None,
        extend_2: str = None,
        extend_3: str = None,
        multimodal_medias: List[ListSearchTaskDialogueDatasResponseBodyArticlesMultimodalMedias] = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.author = author
        self.category_uuid = category_uuid
        self.content = content
        self.doc_id = doc_id
        self.doc_type = doc_type
        self.doc_uuid = doc_uuid
        self.extend_1 = extend_1
        self.extend_2 = extend_2
        self.extend_3 = extend_3
        self.multimodal_medias = multimodal_medias
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        if self.multimodal_medias:
            for k in self.multimodal_medias:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.category_uuid is not None:
            result['CategoryUuid'] = self.category_uuid
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.extend_1 is not None:
            result['Extend1'] = self.extend_1
        if self.extend_2 is not None:
            result['Extend2'] = self.extend_2
        if self.extend_3 is not None:
            result['Extend3'] = self.extend_3
        result['MultimodalMedias'] = []
        if self.multimodal_medias is not None:
            for k in self.multimodal_medias:
                result['MultimodalMedias'].append(k.to_map() if k else None)
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('CategoryUuid') is not None:
            self.category_uuid = m.get('CategoryUuid')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('Extend1') is not None:
            self.extend_1 = m.get('Extend1')
        if m.get('Extend2') is not None:
            self.extend_2 = m.get('Extend2')
        if m.get('Extend3') is not None:
            self.extend_3 = m.get('Extend3')
        self.multimodal_medias = []
        if m.get('MultimodalMedias') is not None:
            for k in m.get('MultimodalMedias'):
                temp_model = ListSearchTaskDialogueDatasResponseBodyArticlesMultimodalMedias()
                self.multimodal_medias.append(temp_model.from_map(k))
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListSearchTaskDialogueDatasResponseBodyImages(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        media_id: str = None,
        media_type: str = None,
    ):
        self.file_url = file_url
        self.media_id = media_id
        self.media_type = media_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class ListSearchTaskDialogueDatasResponseBodyVideos(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        media_id: str = None,
        media_type: str = None,
    ):
        self.file_url = file_url
        self.media_id = media_id
        self.media_type = media_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class ListSearchTaskDialogueDatasResponseBody(TeaModel):
    def __init__(
        self,
        articles: List[ListSearchTaskDialogueDatasResponseBodyArticles] = None,
        code: str = None,
        http_status_code: int = None,
        images: List[ListSearchTaskDialogueDatasResponseBodyImages] = None,
        message: str = None,
        page_number: int = None,
        page_size: int = None,
        realtime_search: bool = None,
        request_id: str = None,
        search_type: str = None,
        success: bool = None,
        total_count: int = None,
        videos: List[ListSearchTaskDialogueDatasResponseBodyVideos] = None,
    ):
        self.articles = articles
        self.code = code
        self.http_status_code = http_status_code
        self.images = images
        self.message = message
        self.page_number = page_number
        self.page_size = page_size
        self.realtime_search = realtime_search
        self.request_id = request_id
        self.search_type = search_type
        self.success = success
        self.total_count = total_count
        self.videos = videos

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.videos:
            for k in self.videos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.realtime_search is not None:
            result['RealtimeSearch'] = self.realtime_search
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.search_type is not None:
            result['SearchType'] = self.search_type
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['Videos'] = []
        if self.videos is not None:
            for k in self.videos:
                result['Videos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = ListSearchTaskDialogueDatasResponseBodyArticles()
                self.articles.append(temp_model.from_map(k))
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = ListSearchTaskDialogueDatasResponseBodyImages()
                self.images.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RealtimeSearch') is not None:
            self.realtime_search = m.get('RealtimeSearch')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SearchType') is not None:
            self.search_type = m.get('SearchType')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.videos = []
        if m.get('Videos') is not None:
            for k in m.get('Videos'):
                temp_model = ListSearchTaskDialogueDatasResponseBodyVideos()
                self.videos.append(temp_model.from_map(k))
        return self


class ListSearchTaskDialogueDatasResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSearchTaskDialogueDatasResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSearchTaskDialogueDatasResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSearchTaskDialoguesRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListSearchTaskDialoguesResponseBodyDataChatConfigSearchParamSearchSources(TeaModel):
    def __init__(
        self,
        code: str = None,
        dataset_name: str = None,
        name: str = None,
    ):
        self.code = code
        self.dataset_name = dataset_name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListSearchTaskDialoguesResponseBodyDataChatConfigSearchParam(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        multimodal_search_types: List[str] = None,
        search_sources: List[ListSearchTaskDialoguesResponseBodyDataChatConfigSearchParamSearchSources] = None,
        start_time: str = None,
    ):
        self.end_time = end_time
        self.multimodal_search_types = multimodal_search_types
        self.search_sources = search_sources
        self.start_time = start_time

    def validate(self):
        if self.search_sources:
            for k in self.search_sources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.multimodal_search_types is not None:
            result['MultimodalSearchTypes'] = self.multimodal_search_types
        result['SearchSources'] = []
        if self.search_sources is not None:
            for k in self.search_sources:
                result['SearchSources'].append(k.to_map() if k else None)
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MultimodalSearchTypes') is not None:
            self.multimodal_search_types = m.get('MultimodalSearchTypes')
        self.search_sources = []
        if m.get('SearchSources') is not None:
            for k in m.get('SearchSources'):
                temp_model = ListSearchTaskDialoguesResponseBodyDataChatConfigSearchParamSearchSources()
                self.search_sources.append(temp_model.from_map(k))
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListSearchTaskDialoguesResponseBodyDataChatConfig(TeaModel):
    def __init__(
        self,
        dialogue_type: int = None,
        end_to_end: bool = None,
        generate_level: str = None,
        generate_technology: str = None,
        search_models: List[str] = None,
        search_param: ListSearchTaskDialoguesResponseBodyDataChatConfigSearchParam = None,
    ):
        self.dialogue_type = dialogue_type
        self.end_to_end = end_to_end
        self.generate_level = generate_level
        self.generate_technology = generate_technology
        self.search_models = search_models
        self.search_param = search_param

    def validate(self):
        if self.search_param:
            self.search_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialogue_type is not None:
            result['DialogueType'] = self.dialogue_type
        if self.end_to_end is not None:
            result['EndToEnd'] = self.end_to_end
        if self.generate_level is not None:
            result['GenerateLevel'] = self.generate_level
        if self.generate_technology is not None:
            result['GenerateTechnology'] = self.generate_technology
        if self.search_models is not None:
            result['SearchModels'] = self.search_models
        if self.search_param is not None:
            result['SearchParam'] = self.search_param.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DialogueType') is not None:
            self.dialogue_type = m.get('DialogueType')
        if m.get('EndToEnd') is not None:
            self.end_to_end = m.get('EndToEnd')
        if m.get('GenerateLevel') is not None:
            self.generate_level = m.get('GenerateLevel')
        if m.get('GenerateTechnology') is not None:
            self.generate_technology = m.get('GenerateTechnology')
        if m.get('SearchModels') is not None:
            self.search_models = m.get('SearchModels')
        if m.get('SearchParam') is not None:
            temp_model = ListSearchTaskDialoguesResponseBodyDataChatConfigSearchParam()
            self.search_param = temp_model.from_map(m['SearchParam'])
        return self


class ListSearchTaskDialoguesResponseBodyData(TeaModel):
    def __init__(
        self,
        chat_config: ListSearchTaskDialoguesResponseBodyDataChatConfig = None,
        create_time: str = None,
        dialogue_type: int = None,
        good_text: str = None,
        origin_session_id: str = None,
        prompt: str = None,
        rating: str = None,
        response_body_str: str = None,
        session_id: str = None,
        tags: List[str] = None,
        task_id: str = None,
        text: str = None,
    ):
        self.chat_config = chat_config
        self.create_time = create_time
        self.dialogue_type = dialogue_type
        self.good_text = good_text
        self.origin_session_id = origin_session_id
        self.prompt = prompt
        self.rating = rating
        self.response_body_str = response_body_str
        self.session_id = session_id
        self.tags = tags
        self.task_id = task_id
        self.text = text

    def validate(self):
        if self.chat_config:
            self.chat_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chat_config is not None:
            result['ChatConfig'] = self.chat_config.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dialogue_type is not None:
            result['DialogueType'] = self.dialogue_type
        if self.good_text is not None:
            result['GoodText'] = self.good_text
        if self.origin_session_id is not None:
            result['OriginSessionId'] = self.origin_session_id
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.rating is not None:
            result['Rating'] = self.rating
        if self.response_body_str is not None:
            result['ResponseBodyStr'] = self.response_body_str
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChatConfig') is not None:
            temp_model = ListSearchTaskDialoguesResponseBodyDataChatConfig()
            self.chat_config = temp_model.from_map(m['ChatConfig'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DialogueType') is not None:
            self.dialogue_type = m.get('DialogueType')
        if m.get('GoodText') is not None:
            self.good_text = m.get('GoodText')
        if m.get('OriginSessionId') is not None:
            self.origin_session_id = m.get('OriginSessionId')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('Rating') is not None:
            self.rating = m.get('Rating')
        if m.get('ResponseBodyStr') is not None:
            self.response_body_str = m.get('ResponseBodyStr')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class ListSearchTaskDialoguesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListSearchTaskDialoguesResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListSearchTaskDialoguesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSearchTaskDialoguesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSearchTaskDialoguesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSearchTaskDialoguesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSearchTasksRequest(TeaModel):
    def __init__(
        self,
        dialogue_types: List[int] = None,
        page_number: int = None,
        page_size: int = None,
        workspace_id: str = None,
    ):
        self.dialogue_types = dialogue_types
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialogue_types is not None:
            result['DialogueTypes'] = self.dialogue_types
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DialogueTypes') is not None:
            self.dialogue_types = m.get('DialogueTypes')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListSearchTasksShrinkRequest(TeaModel):
    def __init__(
        self,
        dialogue_types_shrink: str = None,
        page_number: int = None,
        page_size: int = None,
        workspace_id: str = None,
    ):
        self.dialogue_types_shrink = dialogue_types_shrink
        self.page_number = page_number
        self.page_size = page_size
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dialogue_types_shrink is not None:
            result['DialogueTypes'] = self.dialogue_types_shrink
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DialogueTypes') is not None:
            self.dialogue_types_shrink = m.get('DialogueTypes')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListSearchTasksResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        dialogue_type: int = None,
        task_id: str = None,
        task_name: str = None,
        update_time: str = None,
        username: str = None,
    ):
        self.create_time = create_time
        self.dialogue_type = dialogue_type
        self.task_id = task_id
        self.task_name = task_name
        self.update_time = update_time
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dialogue_type is not None:
            result['DialogueType'] = self.dialogue_type
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DialogueType') is not None:
            self.dialogue_type = m.get('DialogueType')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class ListSearchTasksResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListSearchTasksResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListSearchTasksResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSearchTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSearchTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSearchTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListStyleLearningResultRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        current: int = None,
        size: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.current = current
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.current is not None:
            result['Current'] = self.current
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class ListStyleLearningResultResponseBodyData(TeaModel):
    def __init__(
        self,
        aigc_result: str = None,
        id: int = None,
        rewrite_result: str = None,
        style_name: str = None,
        task_id: str = None,
    ):
        self.aigc_result = aigc_result
        self.id = id
        self.rewrite_result = rewrite_result
        self.style_name = style_name
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aigc_result is not None:
            result['AigcResult'] = self.aigc_result
        if self.id is not None:
            result['Id'] = self.id
        if self.rewrite_result is not None:
            result['RewriteResult'] = self.rewrite_result
        if self.style_name is not None:
            result['StyleName'] = self.style_name
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AigcResult') is not None:
            self.aigc_result = m.get('AigcResult')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RewriteResult') is not None:
            self.rewrite_result = m.get('RewriteResult')
        if m.get('StyleName') is not None:
            self.style_name = m.get('StyleName')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ListStyleLearningResultResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current: int = None,
        data: List[ListStyleLearningResultResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        size: int = None,
        success: bool = None,
        total: int = None,
    ):
        self.code = code
        self.current = current
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.size = size
        self.success = success
        self.total = total

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current is not None:
            result['Current'] = self.current
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.size is not None:
            result['Size'] = self.size
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListStyleLearningResultResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListStyleLearningResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListStyleLearningResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListStyleLearningResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTimedViewAttitudeRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        max_results: int = None,
        next_token: str = None,
        topic: str = None,
        topic_source: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.topic = topic
        # This parameter is required.
        self.topic_source = topic_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        return self


class ListTimedViewAttitudeResponseBodyDataViewPointsOutlines(TeaModel):
    def __init__(
        self,
        outline: str = None,
        summary: str = None,
    ):
        self.outline = outline
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.outline is not None:
            result['Outline'] = self.outline
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class ListTimedViewAttitudeResponseBodyDataViewPoints(TeaModel):
    def __init__(
        self,
        outlines: List[ListTimedViewAttitudeResponseBodyDataViewPointsOutlines] = None,
        point: str = None,
        summary: str = None,
    ):
        self.outlines = outlines
        self.point = point
        self.summary = summary

    def validate(self):
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.point is not None:
            result['Point'] = self.point
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = ListTimedViewAttitudeResponseBodyDataViewPointsOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Point') is not None:
            self.point = m.get('Point')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class ListTimedViewAttitudeResponseBodyData(TeaModel):
    def __init__(
        self,
        attitude: str = None,
        attitude_type: str = None,
        pub_time: str = None,
        ratio: str = None,
        source: str = None,
        title: str = None,
        url: str = None,
        view_points: List[ListTimedViewAttitudeResponseBodyDataViewPoints] = None,
    ):
        self.attitude = attitude
        self.attitude_type = attitude_type
        self.pub_time = pub_time
        self.ratio = ratio
        self.source = source
        self.title = title
        self.url = url
        self.view_points = view_points

    def validate(self):
        if self.view_points:
            for k in self.view_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.attitude_type is not None:
            result['AttitudeType'] = self.attitude_type
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.ratio is not None:
            result['Ratio'] = self.ratio
        if self.source is not None:
            result['Source'] = self.source
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        result['ViewPoints'] = []
        if self.view_points is not None:
            for k in self.view_points:
                result['ViewPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('AttitudeType') is not None:
            self.attitude_type = m.get('AttitudeType')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Ratio') is not None:
            self.ratio = m.get('Ratio')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        self.view_points = []
        if m.get('ViewPoints') is not None:
            for k in m.get('ViewPoints'):
                temp_model = ListTimedViewAttitudeResponseBodyDataViewPoints()
                self.view_points.append(temp_model.from_map(k))
        return self


class ListTimedViewAttitudeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListTimedViewAttitudeResponseBodyData] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListTimedViewAttitudeResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTimedViewAttitudeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTimedViewAttitudeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTimedViewAttitudeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTopicRecommendEventListRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        max_results: int = None,
        next_token: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        return self


class ListTopicRecommendEventListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[str] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTopicRecommendEventListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTopicRecommendEventListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTopicRecommendEventListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTopicViewPointRecommendEventListRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        id: str = None,
        max_results: int = None,
        next_token: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.id = id
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.id is not None:
            result['Id'] = self.id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        return self


class ListTopicViewPointRecommendEventListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[str] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTopicViewPointRecommendEventListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTopicViewPointRecommendEventListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTopicViewPointRecommendEventListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListVersionsRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        return self


class ListVersionsResponseBodyData(TeaModel):
    def __init__(
        self,
        concurrent_count: int = None,
        end_time: str = None,
        instance_count: int = None,
        instance_id: str = None,
        order_id: int = None,
        product_type: str = None,
        quota: int = None,
        start_time: str = None,
        use_quota: int = None,
        version_detail: str = None,
        version_name: str = None,
        version_status: int = None,
    ):
        self.concurrent_count = concurrent_count
        self.end_time = end_time
        self.instance_count = instance_count
        self.instance_id = instance_id
        self.order_id = order_id
        self.product_type = product_type
        self.quota = quota
        self.start_time = start_time
        self.use_quota = use_quota
        self.version_detail = version_detail
        self.version_name = version_name
        self.version_status = version_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.concurrent_count is not None:
            result['ConcurrentCount'] = self.concurrent_count
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.product_type is not None:
            result['ProductType'] = self.product_type
        if self.quota is not None:
            result['Quota'] = self.quota
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.use_quota is not None:
            result['UseQuota'] = self.use_quota
        if self.version_detail is not None:
            result['VersionDetail'] = self.version_detail
        if self.version_name is not None:
            result['VersionName'] = self.version_name
        if self.version_status is not None:
            result['VersionStatus'] = self.version_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConcurrentCount') is not None:
            self.concurrent_count = m.get('ConcurrentCount')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('ProductType') is not None:
            self.product_type = m.get('ProductType')
        if m.get('Quota') is not None:
            self.quota = m.get('Quota')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('UseQuota') is not None:
            self.use_quota = m.get('UseQuota')
        if m.get('VersionDetail') is not None:
            self.version_detail = m.get('VersionDetail')
        if m.get('VersionName') is not None:
            self.version_name = m.get('VersionName')
        if m.get('VersionStatus') is not None:
            self.version_status = m.get('VersionStatus')
        return self


class ListVersionsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListVersionsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListVersionsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListVersionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListVersionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListVersionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWebReviewPointsRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        max_results: int = None,
        next_token: str = None,
        topic: str = None,
        topic_source: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.topic = topic
        # This parameter is required.
        self.topic_source = topic_source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        return self


class ListWebReviewPointsResponseBodyDataComments(TeaModel):
    def __init__(
        self,
        source: str = None,
        text: str = None,
        title: str = None,
        url: str = None,
        username: str = None,
    ):
        self.source = source
        self.text = text
        self.title = title
        self.url = url
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['Source'] = self.source
        if self.text is not None:
            result['Text'] = self.text
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class ListWebReviewPointsResponseBodyDataViewPointsOutlines(TeaModel):
    def __init__(
        self,
        outline: str = None,
        summary: str = None,
    ):
        self.outline = outline
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.outline is not None:
            result['Outline'] = self.outline
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class ListWebReviewPointsResponseBodyDataViewPoints(TeaModel):
    def __init__(
        self,
        outlines: List[ListWebReviewPointsResponseBodyDataViewPointsOutlines] = None,
        point: str = None,
        summary: str = None,
    ):
        self.outlines = outlines
        self.point = point
        self.summary = summary

    def validate(self):
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.point is not None:
            result['Point'] = self.point
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = ListWebReviewPointsResponseBodyDataViewPointsOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Point') is not None:
            self.point = m.get('Point')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class ListWebReviewPointsResponseBodyData(TeaModel):
    def __init__(
        self,
        attitude: str = None,
        attitude_type: str = None,
        comments: List[ListWebReviewPointsResponseBodyDataComments] = None,
        ratio: str = None,
        view_points: List[ListWebReviewPointsResponseBodyDataViewPoints] = None,
    ):
        self.attitude = attitude
        self.attitude_type = attitude_type
        self.comments = comments
        self.ratio = ratio
        self.view_points = view_points

    def validate(self):
        if self.comments:
            for k in self.comments:
                if k:
                    k.validate()
        if self.view_points:
            for k in self.view_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.attitude_type is not None:
            result['AttitudeType'] = self.attitude_type
        result['Comments'] = []
        if self.comments is not None:
            for k in self.comments:
                result['Comments'].append(k.to_map() if k else None)
        if self.ratio is not None:
            result['Ratio'] = self.ratio
        result['ViewPoints'] = []
        if self.view_points is not None:
            for k in self.view_points:
                result['ViewPoints'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('AttitudeType') is not None:
            self.attitude_type = m.get('AttitudeType')
        self.comments = []
        if m.get('Comments') is not None:
            for k in m.get('Comments'):
                temp_model = ListWebReviewPointsResponseBodyDataComments()
                self.comments.append(temp_model.from_map(k))
        if m.get('Ratio') is not None:
            self.ratio = m.get('Ratio')
        self.view_points = []
        if m.get('ViewPoints') is not None:
            for k in m.get('ViewPoints'):
                temp_model = ListWebReviewPointsResponseBodyDataViewPoints()
                self.view_points.append(temp_model.from_map(k))
        return self


class ListWebReviewPointsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListWebReviewPointsResponseBodyData] = None,
        http_status_code: int = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListWebReviewPointsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListWebReviewPointsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWebReviewPointsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWebReviewPointsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWritingStylesRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        scene: str = None,
        workspace_id: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.scene = scene
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ListWritingStylesResponseBodyData(TeaModel):
    def __init__(
        self,
        distribute_step_template_define: WritingStyleTemplateDefine = None,
        distribute_writing: bool = None,
        emoji: str = None,
        style_description: str = None,
        style_image: str = None,
        style_key: str = None,
        style_name: str = None,
        template_define: WritingStyleTemplateDefine = None,
    ):
        self.distribute_step_template_define = distribute_step_template_define
        self.distribute_writing = distribute_writing
        self.emoji = emoji
        self.style_description = style_description
        self.style_image = style_image
        self.style_key = style_key
        self.style_name = style_name
        self.template_define = template_define

    def validate(self):
        if self.distribute_step_template_define:
            self.distribute_step_template_define.validate()
        if self.template_define:
            self.template_define.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.distribute_step_template_define is not None:
            result['DistributeStepTemplateDefine'] = self.distribute_step_template_define.to_map()
        if self.distribute_writing is not None:
            result['DistributeWriting'] = self.distribute_writing
        if self.emoji is not None:
            result['Emoji'] = self.emoji
        if self.style_description is not None:
            result['StyleDescription'] = self.style_description
        if self.style_image is not None:
            result['StyleImage'] = self.style_image
        if self.style_key is not None:
            result['StyleKey'] = self.style_key
        if self.style_name is not None:
            result['StyleName'] = self.style_name
        if self.template_define is not None:
            result['TemplateDefine'] = self.template_define.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DistributeStepTemplateDefine') is not None:
            temp_model = WritingStyleTemplateDefine()
            self.distribute_step_template_define = temp_model.from_map(m['DistributeStepTemplateDefine'])
        if m.get('DistributeWriting') is not None:
            self.distribute_writing = m.get('DistributeWriting')
        if m.get('Emoji') is not None:
            self.emoji = m.get('Emoji')
        if m.get('StyleDescription') is not None:
            self.style_description = m.get('StyleDescription')
        if m.get('StyleImage') is not None:
            self.style_image = m.get('StyleImage')
        if m.get('StyleKey') is not None:
            self.style_key = m.get('StyleKey')
        if m.get('StyleName') is not None:
            self.style_name = m.get('StyleName')
        if m.get('TemplateDefine') is not None:
            temp_model = WritingStyleTemplateDefine()
            self.template_define = temp_model.from_map(m['TemplateDefine'])
        return self


class ListWritingStylesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListWritingStylesResponseBodyData] = None,
        max_results: int = None,
        message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: str = None,
        total_count: int = None,
    ):
        self.code = code
        self.data = data
        self.max_results = max_results
        self.message = message
        self.next_token = next_token
        # Id of the request
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListWritingStylesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListWritingStylesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWritingStylesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWritingStylesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryAsyncTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class QueryAsyncTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_user: str = None,
        task_code: str = None,
        task_error_message: str = None,
        task_id: str = None,
        task_intermediate_result: str = None,
        task_name: str = None,
        task_param: str = None,
        task_progress_message: str = None,
        task_result: str = None,
        task_retry_count: str = None,
        task_status: int = None,
        update_time: str = None,
        update_user: str = None,
    ):
        self.create_time = create_time
        self.create_user = create_user
        self.task_code = task_code
        self.task_error_message = task_error_message
        self.task_id = task_id
        self.task_intermediate_result = task_intermediate_result
        self.task_name = task_name
        self.task_param = task_param
        self.task_progress_message = task_progress_message
        self.task_result = task_result
        self.task_retry_count = task_retry_count
        self.task_status = task_status
        self.update_time = update_time
        self.update_user = update_user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.task_code is not None:
            result['TaskCode'] = self.task_code
        if self.task_error_message is not None:
            result['TaskErrorMessage'] = self.task_error_message
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_intermediate_result is not None:
            result['TaskIntermediateResult'] = self.task_intermediate_result
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_param is not None:
            result['TaskParam'] = self.task_param
        if self.task_progress_message is not None:
            result['TaskProgressMessage'] = self.task_progress_message
        if self.task_result is not None:
            result['TaskResult'] = self.task_result
        if self.task_retry_count is not None:
            result['TaskRetryCount'] = self.task_retry_count
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.update_user is not None:
            result['UpdateUser'] = self.update_user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('TaskCode') is not None:
            self.task_code = m.get('TaskCode')
        if m.get('TaskErrorMessage') is not None:
            self.task_error_message = m.get('TaskErrorMessage')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskIntermediateResult') is not None:
            self.task_intermediate_result = m.get('TaskIntermediateResult')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskParam') is not None:
            self.task_param = m.get('TaskParam')
        if m.get('TaskProgressMessage') is not None:
            self.task_progress_message = m.get('TaskProgressMessage')
        if m.get('TaskResult') is not None:
            self.task_result = m.get('TaskResult')
        if m.get('TaskRetryCount') is not None:
            self.task_retry_count = m.get('TaskRetryCount')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UpdateUser') is not None:
            self.update_user = m.get('UpdateUser')
        return self


class QueryAsyncTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryAsyncTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryAsyncTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryAsyncTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryAsyncTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryAsyncTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryAuditTaskRequest(TeaModel):
    def __init__(
        self,
        article_id: str = None,
        content_audit_task_id: str = None,
        workspace_id: str = None,
    ):
        self.article_id = article_id
        self.content_audit_task_id = content_audit_task_id
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article_id is not None:
            result['ArticleId'] = self.article_id
        if self.content_audit_task_id is not None:
            result['ContentAuditTaskId'] = self.content_audit_task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArticleId') is not None:
            self.article_id = m.get('ArticleId')
        if m.get('ContentAuditTaskId') is not None:
            self.content_audit_task_id = m.get('ContentAuditTaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class QueryAuditTaskResponseBodyDataResponseHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        session_id: str = None,
        task_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.session_id = session_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class QueryAuditTaskResponseBodyDataResponsePayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class QueryAuditTaskResponseBodyDataResponsePayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class QueryAuditTaskResponseBodyDataResponsePayload(TeaModel):
    def __init__(
        self,
        output: QueryAuditTaskResponseBodyDataResponsePayloadOutput = None,
        usage: QueryAuditTaskResponseBodyDataResponsePayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = QueryAuditTaskResponseBodyDataResponsePayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = QueryAuditTaskResponseBodyDataResponsePayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class QueryAuditTaskResponseBodyDataResponse(TeaModel):
    def __init__(
        self,
        header: QueryAuditTaskResponseBodyDataResponseHeader = None,
        payload: QueryAuditTaskResponseBodyDataResponsePayload = None,
    ):
        self.header = header
        self.payload = payload

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = QueryAuditTaskResponseBodyDataResponseHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = QueryAuditTaskResponseBodyDataResponsePayload()
            self.payload = temp_model.from_map(m['Payload'])
        return self


class QueryAuditTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        audit_time: str = None,
        content: str = None,
        html_content: str = None,
        response: QueryAuditTaskResponseBodyDataResponse = None,
        status: str = None,
        task_status: int = None,
        title: str = None,
    ):
        self.audit_time = audit_time
        self.content = content
        self.html_content = html_content
        self.response = response
        self.status = status
        self.task_status = task_status
        self.title = title

    def validate(self):
        if self.response:
            self.response.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_time is not None:
            result['AuditTime'] = self.audit_time
        if self.content is not None:
            result['Content'] = self.content
        if self.html_content is not None:
            result['HtmlContent'] = self.html_content
        if self.response is not None:
            result['Response'] = self.response.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditTime') is not None:
            self.audit_time = m.get('AuditTime')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('HtmlContent') is not None:
            self.html_content = m.get('HtmlContent')
        if m.get('Response') is not None:
            temp_model = QueryAuditTaskResponseBodyDataResponse()
            self.response = temp_model.from_map(m['Response'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class QueryAuditTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryAuditTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryAuditTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryAuditTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryAuditTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryAuditTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunAbbreviationContentRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        prompt: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.content = content
        self.prompt = prompt
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunAbbreviationContentResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunAbbreviationContentResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunAbbreviationContentResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunAbbreviationContentResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunAbbreviationContentResponseBodyPayloadOutput = None,
        usage: RunAbbreviationContentResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunAbbreviationContentResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunAbbreviationContentResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunAbbreviationContentResponseBody(TeaModel):
    def __init__(
        self,
        end: bool = None,
        header: RunAbbreviationContentResponseBodyHeader = None,
        payload: RunAbbreviationContentResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.end = end
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Header') is not None:
            temp_model = RunAbbreviationContentResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunAbbreviationContentResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunAbbreviationContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunAbbreviationContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunAbbreviationContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunBookBrainmapRequest(TeaModel):
    def __init__(
        self,
        clean_cache: bool = None,
        doc_id: str = None,
        node_number: int = None,
        prompt: str = None,
        session_id: str = None,
        word_number: int = None,
        workspace_id: str = None,
    ):
        self.clean_cache = clean_cache
        # This parameter is required.
        self.doc_id = doc_id
        self.node_number = node_number
        self.prompt = prompt
        # This parameter is required.
        self.session_id = session_id
        self.word_number = word_number
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clean_cache is not None:
            result['CleanCache'] = self.clean_cache
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.node_number is not None:
            result['NodeNumber'] = self.node_number
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.word_number is not None:
            result['WordNumber'] = self.word_number
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CleanCache') is not None:
            self.clean_cache = m.get('CleanCache')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('NodeNumber') is not None:
            self.node_number = m.get('NodeNumber')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('WordNumber') is not None:
            self.word_number = m.get('WordNumber')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunBookBrainmapResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunBookBrainmapResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        content: str = None,
    ):
        self.content = content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        return self


class RunBookBrainmapResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunBookBrainmapResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunBookBrainmapResponseBodyPayloadOutput = None,
        usage: RunBookBrainmapResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunBookBrainmapResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunBookBrainmapResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunBookBrainmapResponseBody(TeaModel):
    def __init__(
        self,
        header: RunBookBrainmapResponseBodyHeader = None,
        payload: RunBookBrainmapResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunBookBrainmapResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunBookBrainmapResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunBookBrainmapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunBookBrainmapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunBookBrainmapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunBookIntroductionRequest(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        key_point_prompt: str = None,
        session_id: str = None,
        summary_prompt: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.doc_id = doc_id
        self.key_point_prompt = key_point_prompt
        # This parameter is required.
        self.session_id = session_id
        self.summary_prompt = summary_prompt
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.key_point_prompt is not None:
            result['KeyPointPrompt'] = self.key_point_prompt
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.summary_prompt is not None:
            result['SummaryPrompt'] = self.summary_prompt
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('KeyPointPrompt') is not None:
            self.key_point_prompt = m.get('KeyPointPrompt')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('SummaryPrompt') is not None:
            self.summary_prompt = m.get('SummaryPrompt')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunBookIntroductionResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunBookIntroductionResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        key_point: str = None,
        summary: str = None,
    ):
        self.key_point = key_point
        self.summary = summary

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_point is not None:
            result['KeyPoint'] = self.key_point
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyPoint') is not None:
            self.key_point = m.get('KeyPoint')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class RunBookIntroductionResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunBookIntroductionResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunBookIntroductionResponseBodyPayloadOutput = None,
        usage: RunBookIntroductionResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunBookIntroductionResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunBookIntroductionResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunBookIntroductionResponseBody(TeaModel):
    def __init__(
        self,
        header: RunBookIntroductionResponseBodyHeader = None,
        payload: RunBookIntroductionResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunBookIntroductionResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunBookIntroductionResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunBookIntroductionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunBookIntroductionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunBookIntroductionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunBookSmartCardRequest(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        session_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.doc_id = doc_id
        # This parameter is required.
        self.session_id = session_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunBookSmartCardResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunBookSmartCardResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        content: str = None,
        tags: List[str] = None,
    ):
        self.content = content
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class RunBookSmartCardResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunBookSmartCardResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunBookSmartCardResponseBodyPayloadOutput = None,
        usage: RunBookSmartCardResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunBookSmartCardResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunBookSmartCardResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunBookSmartCardResponseBody(TeaModel):
    def __init__(
        self,
        header: RunBookSmartCardResponseBodyHeader = None,
        payload: RunBookSmartCardResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunBookSmartCardResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunBookSmartCardResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunBookSmartCardResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunBookSmartCardResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunBookSmartCardResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunCommentGenerationRequest(TeaModel):
    def __init__(
        self,
        allow_emoji: bool = None,
        extra_info: str = None,
        length: str = None,
        length_range: Dict[str, Any] = None,
        model_id: str = None,
        num_comments: str = None,
        sentiment: Dict[str, Any] = None,
        session_id: str = None,
        source_material: str = None,
        style: str = None,
        type: Dict[str, Any] = None,
        workspace_id: str = None,
    ):
        self.allow_emoji = allow_emoji
        self.extra_info = extra_info
        self.length = length
        # This parameter is required.
        self.length_range = length_range
        self.model_id = model_id
        # This parameter is required.
        self.num_comments = num_comments
        # This parameter is required.
        self.sentiment = sentiment
        self.session_id = session_id
        # This parameter is required.
        self.source_material = source_material
        self.style = style
        # This parameter is required.
        self.type = type
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_emoji is not None:
            result['AllowEmoji'] = self.allow_emoji
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info
        if self.length is not None:
            result['Length'] = self.length
        if self.length_range is not None:
            result['LengthRange'] = self.length_range
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.num_comments is not None:
            result['NumComments'] = self.num_comments
        if self.sentiment is not None:
            result['Sentiment'] = self.sentiment
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.source_material is not None:
            result['SourceMaterial'] = self.source_material
        if self.style is not None:
            result['Style'] = self.style
        if self.type is not None:
            result['Type'] = self.type
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowEmoji') is not None:
            self.allow_emoji = m.get('AllowEmoji')
        if m.get('ExtraInfo') is not None:
            self.extra_info = m.get('ExtraInfo')
        if m.get('Length') is not None:
            self.length = m.get('Length')
        if m.get('LengthRange') is not None:
            self.length_range = m.get('LengthRange')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('NumComments') is not None:
            self.num_comments = m.get('NumComments')
        if m.get('Sentiment') is not None:
            self.sentiment = m.get('Sentiment')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('SourceMaterial') is not None:
            self.source_material = m.get('SourceMaterial')
        if m.get('Style') is not None:
            self.style = m.get('Style')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunCommentGenerationShrinkRequest(TeaModel):
    def __init__(
        self,
        allow_emoji: bool = None,
        extra_info: str = None,
        length: str = None,
        length_range_shrink: str = None,
        model_id: str = None,
        num_comments: str = None,
        sentiment_shrink: str = None,
        session_id: str = None,
        source_material: str = None,
        style: str = None,
        type_shrink: str = None,
        workspace_id: str = None,
    ):
        self.allow_emoji = allow_emoji
        self.extra_info = extra_info
        self.length = length
        # This parameter is required.
        self.length_range_shrink = length_range_shrink
        self.model_id = model_id
        # This parameter is required.
        self.num_comments = num_comments
        # This parameter is required.
        self.sentiment_shrink = sentiment_shrink
        self.session_id = session_id
        # This parameter is required.
        self.source_material = source_material
        self.style = style
        # This parameter is required.
        self.type_shrink = type_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_emoji is not None:
            result['AllowEmoji'] = self.allow_emoji
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info
        if self.length is not None:
            result['Length'] = self.length
        if self.length_range_shrink is not None:
            result['LengthRange'] = self.length_range_shrink
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.num_comments is not None:
            result['NumComments'] = self.num_comments
        if self.sentiment_shrink is not None:
            result['Sentiment'] = self.sentiment_shrink
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.source_material is not None:
            result['SourceMaterial'] = self.source_material
        if self.style is not None:
            result['Style'] = self.style
        if self.type_shrink is not None:
            result['Type'] = self.type_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllowEmoji') is not None:
            self.allow_emoji = m.get('AllowEmoji')
        if m.get('ExtraInfo') is not None:
            self.extra_info = m.get('ExtraInfo')
        if m.get('Length') is not None:
            self.length = m.get('Length')
        if m.get('LengthRange') is not None:
            self.length_range_shrink = m.get('LengthRange')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('NumComments') is not None:
            self.num_comments = m.get('NumComments')
        if m.get('Sentiment') is not None:
            self.sentiment_shrink = m.get('Sentiment')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('SourceMaterial') is not None:
            self.source_material = m.get('SourceMaterial')
        if m.get('Style') is not None:
            self.style = m.get('Style')
        if m.get('Type') is not None:
            self.type_shrink = m.get('Type')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunCommentGenerationResponseBodyHeader(TeaModel):
    def __init__(
        self,
        event: str = None,
        event_info: str = None,
        request_id: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.event = event
        self.event_info = event_info
        self.request_id = request_id
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunCommentGenerationResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunCommentGenerationResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunCommentGenerationResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunCommentGenerationResponseBodyPayloadOutput = None,
        usage: RunCommentGenerationResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunCommentGenerationResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunCommentGenerationResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunCommentGenerationResponseBody(TeaModel):
    def __init__(
        self,
        end: bool = None,
        header: RunCommentGenerationResponseBodyHeader = None,
        payload: RunCommentGenerationResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.end = end
        self.header = header
        self.payload = payload
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Header') is not None:
            temp_model = RunCommentGenerationResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunCommentGenerationResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunCommentGenerationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunCommentGenerationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunCommentGenerationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunContinueContentRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunContinueContentResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunContinueContentResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunContinueContentResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunContinueContentResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunContinueContentResponseBodyPayloadOutput = None,
        usage: RunContinueContentResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunContinueContentResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunContinueContentResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunContinueContentResponseBody(TeaModel):
    def __init__(
        self,
        end: bool = None,
        header: RunContinueContentResponseBodyHeader = None,
        payload: RunContinueContentResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.end = end
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Header') is not None:
            temp_model = RunContinueContentResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunContinueContentResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunContinueContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunContinueContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunContinueContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunCustomHotTopicAnalysisRequest(TeaModel):
    def __init__(
        self,
        ask_user: str = None,
        force_analysis_exists_topic: bool = None,
        prompt: str = None,
        session_id: str = None,
        task_id: str = None,
        user_back: str = None,
        workspace_id: str = None,
    ):
        self.ask_user = ask_user
        self.force_analysis_exists_topic = force_analysis_exists_topic
        # This parameter is required.
        self.prompt = prompt
        self.session_id = session_id
        self.task_id = task_id
        self.user_back = user_back
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ask_user is not None:
            result['AskUser'] = self.ask_user
        if self.force_analysis_exists_topic is not None:
            result['ForceAnalysisExistsTopic'] = self.force_analysis_exists_topic
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.user_back is not None:
            result['UserBack'] = self.user_back
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AskUser') is not None:
            self.ask_user = m.get('AskUser')
        if m.get('ForceAnalysisExistsTopic') is not None:
            self.force_analysis_exists_topic = m.get('ForceAnalysisExistsTopic')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('UserBack') is not None:
            self.user_back = m.get('UserBack')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunCustomHotTopicAnalysisResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        origin_session_id: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.origin_session_id = origin_session_id
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.origin_session_id is not None:
            result['OriginSessionId'] = self.origin_session_id
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('OriginSessionId') is not None:
            self.origin_session_id = m.get('OriginSessionId')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunCustomHotTopicAnalysisResponseBodyPayloadOutputArticles(TeaModel):
    def __init__(
        self,
        author: str = None,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        tag: str = None,
        title: str = None,
        url: str = None,
    ):
        self.author = author
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.tag = tag
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunCustomHotTopicAnalysisResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        articles: List[RunCustomHotTopicAnalysisResponseBodyPayloadOutputArticles] = None,
        ask_user: List[str] = None,
        async_task_id: str = None,
        attitude: str = None,
        search_query: str = None,
        text: str = None,
        topic_id: str = None,
    ):
        self.articles = articles
        self.ask_user = ask_user
        self.async_task_id = async_task_id
        self.attitude = attitude
        self.search_query = search_query
        self.text = text
        self.topic_id = topic_id

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        if self.ask_user is not None:
            result['AskUser'] = self.ask_user
        if self.async_task_id is not None:
            result['AsyncTaskId'] = self.async_task_id
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.search_query is not None:
            result['SearchQuery'] = self.search_query
        if self.text is not None:
            result['Text'] = self.text
        if self.topic_id is not None:
            result['TopicId'] = self.topic_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = RunCustomHotTopicAnalysisResponseBodyPayloadOutputArticles()
                self.articles.append(temp_model.from_map(k))
        if m.get('AskUser') is not None:
            self.ask_user = m.get('AskUser')
        if m.get('AsyncTaskId') is not None:
            self.async_task_id = m.get('AsyncTaskId')
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('SearchQuery') is not None:
            self.search_query = m.get('SearchQuery')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('TopicId') is not None:
            self.topic_id = m.get('TopicId')
        return self


class RunCustomHotTopicAnalysisResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunCustomHotTopicAnalysisResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunCustomHotTopicAnalysisResponseBodyPayloadOutput = None,
        usage: RunCustomHotTopicAnalysisResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunCustomHotTopicAnalysisResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunCustomHotTopicAnalysisResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunCustomHotTopicAnalysisResponseBody(TeaModel):
    def __init__(
        self,
        header: RunCustomHotTopicAnalysisResponseBodyHeader = None,
        payload: RunCustomHotTopicAnalysisResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunCustomHotTopicAnalysisResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunCustomHotTopicAnalysisResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunCustomHotTopicAnalysisResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunCustomHotTopicAnalysisResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunCustomHotTopicAnalysisResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunCustomHotTopicViewPointAnalysisRequest(TeaModel):
    def __init__(
        self,
        ask_user: str = None,
        prompt: str = None,
        search_query: str = None,
        skip_ask_user: bool = None,
        topic: str = None,
        topic_id: str = None,
        topic_source: str = None,
        topic_version: str = None,
        user_back: str = None,
        workspace_id: str = None,
    ):
        self.ask_user = ask_user
        # This parameter is required.
        self.prompt = prompt
        self.search_query = search_query
        self.skip_ask_user = skip_ask_user
        self.topic = topic
        self.topic_id = topic_id
        self.topic_source = topic_source
        self.topic_version = topic_version
        self.user_back = user_back
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ask_user is not None:
            result['AskUser'] = self.ask_user
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.search_query is not None:
            result['SearchQuery'] = self.search_query
        if self.skip_ask_user is not None:
            result['SkipAskUser'] = self.skip_ask_user
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_id is not None:
            result['TopicId'] = self.topic_id
        if self.topic_source is not None:
            result['TopicSource'] = self.topic_source
        if self.topic_version is not None:
            result['TopicVersion'] = self.topic_version
        if self.user_back is not None:
            result['UserBack'] = self.user_back
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AskUser') is not None:
            self.ask_user = m.get('AskUser')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('SearchQuery') is not None:
            self.search_query = m.get('SearchQuery')
        if m.get('SkipAskUser') is not None:
            self.skip_ask_user = m.get('SkipAskUser')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicId') is not None:
            self.topic_id = m.get('TopicId')
        if m.get('TopicSource') is not None:
            self.topic_source = m.get('TopicSource')
        if m.get('TopicVersion') is not None:
            self.topic_version = m.get('TopicVersion')
        if m.get('UserBack') is not None:
            self.user_back = m.get('UserBack')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunCustomHotTopicViewPointAnalysisResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        origin_session_id: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.origin_session_id = origin_session_id
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.origin_session_id is not None:
            result['OriginSessionId'] = self.origin_session_id
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('OriginSessionId') is not None:
            self.origin_session_id = m.get('OriginSessionId')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutputArticles(TeaModel):
    def __init__(
        self,
        author: str = None,
        content: str = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.author = author
        self.content = content
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.content is not None:
            result['Content'] = self.content
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        articles: List[RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutputArticles] = None,
        ask_user: List[str] = None,
        async_task_id: str = None,
        attitude: str = None,
        custom_view_point_id: str = None,
        text: str = None,
        topic_id: str = None,
    ):
        self.articles = articles
        self.ask_user = ask_user
        self.async_task_id = async_task_id
        self.attitude = attitude
        self.custom_view_point_id = custom_view_point_id
        self.text = text
        self.topic_id = topic_id

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        if self.ask_user is not None:
            result['AskUser'] = self.ask_user
        if self.async_task_id is not None:
            result['AsyncTaskId'] = self.async_task_id
        if self.attitude is not None:
            result['Attitude'] = self.attitude
        if self.custom_view_point_id is not None:
            result['CustomViewPointId'] = self.custom_view_point_id
        if self.text is not None:
            result['Text'] = self.text
        if self.topic_id is not None:
            result['TopicId'] = self.topic_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutputArticles()
                self.articles.append(temp_model.from_map(k))
        if m.get('AskUser') is not None:
            self.ask_user = m.get('AskUser')
        if m.get('AsyncTaskId') is not None:
            self.async_task_id = m.get('AsyncTaskId')
        if m.get('Attitude') is not None:
            self.attitude = m.get('Attitude')
        if m.get('CustomViewPointId') is not None:
            self.custom_view_point_id = m.get('CustomViewPointId')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('TopicId') is not None:
            self.topic_id = m.get('TopicId')
        return self


class RunCustomHotTopicViewPointAnalysisResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunCustomHotTopicViewPointAnalysisResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutput = None,
        usage: RunCustomHotTopicViewPointAnalysisResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunCustomHotTopicViewPointAnalysisResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunCustomHotTopicViewPointAnalysisResponseBody(TeaModel):
    def __init__(
        self,
        header: RunCustomHotTopicViewPointAnalysisResponseBodyHeader = None,
        payload: RunCustomHotTopicViewPointAnalysisResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunCustomHotTopicViewPointAnalysisResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunCustomHotTopicViewPointAnalysisResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunCustomHotTopicViewPointAnalysisResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunCustomHotTopicViewPointAnalysisResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunCustomHotTopicViewPointAnalysisResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunDocBrainmapRequest(TeaModel):
    def __init__(
        self,
        clean_cache: bool = None,
        doc_id: str = None,
        model_name: str = None,
        node_number: int = None,
        prompt: str = None,
        session_id: str = None,
        word_number: int = None,
        workspace_id: str = None,
        reference_content: str = None,
    ):
        self.clean_cache = clean_cache
        # This parameter is required.
        self.doc_id = doc_id
        self.model_name = model_name
        self.node_number = node_number
        self.prompt = prompt
        # This parameter is required.
        self.session_id = session_id
        self.word_number = word_number
        # This parameter is required.
        self.workspace_id = workspace_id
        self.reference_content = reference_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clean_cache is not None:
            result['CleanCache'] = self.clean_cache
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.node_number is not None:
            result['NodeNumber'] = self.node_number
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.word_number is not None:
            result['WordNumber'] = self.word_number
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.reference_content is not None:
            result['referenceContent'] = self.reference_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CleanCache') is not None:
            self.clean_cache = m.get('CleanCache')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('NodeNumber') is not None:
            self.node_number = m.get('NodeNumber')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('WordNumber') is not None:
            self.word_number = m.get('WordNumber')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('referenceContent') is not None:
            self.reference_content = m.get('referenceContent')
        return self


class RunDocBrainmapResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunDocBrainmapResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        content: str = None,
    ):
        self.content = content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        return self


class RunDocBrainmapResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunDocBrainmapResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunDocBrainmapResponseBodyPayloadOutput = None,
        usage: RunDocBrainmapResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunDocBrainmapResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunDocBrainmapResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunDocBrainmapResponseBody(TeaModel):
    def __init__(
        self,
        header: RunDocBrainmapResponseBodyHeader = None,
        payload: RunDocBrainmapResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunDocBrainmapResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunDocBrainmapResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunDocBrainmapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunDocBrainmapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunDocBrainmapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunDocIntroductionRequest(TeaModel):
    def __init__(
        self,
        clean_cache: bool = None,
        doc_id: str = None,
        introduction_prompt: str = None,
        key_point_prompt: str = None,
        model_name: str = None,
        session_id: str = None,
        summary_prompt: str = None,
        workspace_id: str = None,
        reference_content: str = None,
    ):
        self.clean_cache = clean_cache
        # This parameter is required.
        self.doc_id = doc_id
        self.introduction_prompt = introduction_prompt
        self.key_point_prompt = key_point_prompt
        self.model_name = model_name
        # This parameter is required.
        self.session_id = session_id
        self.summary_prompt = summary_prompt
        # This parameter is required.
        self.workspace_id = workspace_id
        self.reference_content = reference_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clean_cache is not None:
            result['CleanCache'] = self.clean_cache
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.introduction_prompt is not None:
            result['IntroductionPrompt'] = self.introduction_prompt
        if self.key_point_prompt is not None:
            result['KeyPointPrompt'] = self.key_point_prompt
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.summary_prompt is not None:
            result['SummaryPrompt'] = self.summary_prompt
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.reference_content is not None:
            result['referenceContent'] = self.reference_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CleanCache') is not None:
            self.clean_cache = m.get('CleanCache')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('IntroductionPrompt') is not None:
            self.introduction_prompt = m.get('IntroductionPrompt')
        if m.get('KeyPointPrompt') is not None:
            self.key_point_prompt = m.get('KeyPointPrompt')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('SummaryPrompt') is not None:
            self.summary_prompt = m.get('SummaryPrompt')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('referenceContent') is not None:
            self.reference_content = m.get('referenceContent')
        return self


class RunDocIntroductionResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunDocIntroductionResponseBodyPayloadOutputIntroductionsBlocks(TeaModel):
    def __init__(
        self,
        begin_time: int = None,
        end_time: int = None,
        height: int = None,
        page_id: int = None,
        width: int = None,
        x: int = None,
        y: int = None,
    ):
        self.begin_time = begin_time
        self.end_time = end_time
        self.height = height
        self.page_id = page_id
        self.width = width
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_time is not None:
            result['BeginTime'] = self.begin_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.height is not None:
            result['Height'] = self.height
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BeginTime') is not None:
            self.begin_time = m.get('BeginTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class RunDocIntroductionResponseBodyPayloadOutputIntroductions(TeaModel):
    def __init__(
        self,
        blocks: List[RunDocIntroductionResponseBodyPayloadOutputIntroductionsBlocks] = None,
        start_page_id: int = None,
        summary: str = None,
        title: str = None,
    ):
        self.blocks = blocks
        self.start_page_id = start_page_id
        self.summary = summary
        self.title = title

    def validate(self):
        if self.blocks:
            for k in self.blocks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Blocks'] = []
        if self.blocks is not None:
            for k in self.blocks:
                result['Blocks'].append(k.to_map() if k else None)
        if self.start_page_id is not None:
            result['StartPageId'] = self.start_page_id
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.blocks = []
        if m.get('Blocks') is not None:
            for k in m.get('Blocks'):
                temp_model = RunDocIntroductionResponseBodyPayloadOutputIntroductionsBlocks()
                self.blocks.append(temp_model.from_map(k))
        if m.get('StartPageId') is not None:
            self.start_page_id = m.get('StartPageId')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class RunDocIntroductionResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        introductions: List[RunDocIntroductionResponseBodyPayloadOutputIntroductions] = None,
        key_point: str = None,
        summary: str = None,
    ):
        self.introductions = introductions
        self.key_point = key_point
        self.summary = summary

    def validate(self):
        if self.introductions:
            for k in self.introductions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Introductions'] = []
        if self.introductions is not None:
            for k in self.introductions:
                result['Introductions'].append(k.to_map() if k else None)
        if self.key_point is not None:
            result['KeyPoint'] = self.key_point
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.introductions = []
        if m.get('Introductions') is not None:
            for k in m.get('Introductions'):
                temp_model = RunDocIntroductionResponseBodyPayloadOutputIntroductions()
                self.introductions.append(temp_model.from_map(k))
        if m.get('KeyPoint') is not None:
            self.key_point = m.get('KeyPoint')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class RunDocIntroductionResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunDocIntroductionResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunDocIntroductionResponseBodyPayloadOutput = None,
        usage: RunDocIntroductionResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunDocIntroductionResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunDocIntroductionResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunDocIntroductionResponseBody(TeaModel):
    def __init__(
        self,
        header: RunDocIntroductionResponseBodyHeader = None,
        payload: RunDocIntroductionResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunDocIntroductionResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunDocIntroductionResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunDocIntroductionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunDocIntroductionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunDocIntroductionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunDocQaRequestConversationContexts(TeaModel):
    def __init__(
        self,
        content: str = None,
        role: str = None,
    ):
        self.content = content
        self.role = role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.role is not None:
            result['Role'] = self.role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        return self


class RunDocQaRequest(TeaModel):
    def __init__(
        self,
        category_ids: List[str] = None,
        conversation_contexts: List[RunDocQaRequestConversationContexts] = None,
        doc_ids: List[str] = None,
        model_name: str = None,
        query: str = None,
        reference_content: str = None,
        search_source: str = None,
        session_id: str = None,
        workspace_id: str = None,
    ):
        self.category_ids = category_ids
        self.conversation_contexts = conversation_contexts
        self.doc_ids = doc_ids
        self.model_name = model_name
        # This parameter is required.
        self.query = query
        self.reference_content = reference_content
        # This parameter is required.
        self.search_source = search_source
        # This parameter is required.
        self.session_id = session_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.conversation_contexts:
            for k in self.conversation_contexts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_ids is not None:
            result['CategoryIds'] = self.category_ids
        result['ConversationContexts'] = []
        if self.conversation_contexts is not None:
            for k in self.conversation_contexts:
                result['ConversationContexts'].append(k.to_map() if k else None)
        if self.doc_ids is not None:
            result['DocIds'] = self.doc_ids
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.query is not None:
            result['Query'] = self.query
        if self.reference_content is not None:
            result['ReferenceContent'] = self.reference_content
        if self.search_source is not None:
            result['SearchSource'] = self.search_source
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryIds') is not None:
            self.category_ids = m.get('CategoryIds')
        self.conversation_contexts = []
        if m.get('ConversationContexts') is not None:
            for k in m.get('ConversationContexts'):
                temp_model = RunDocQaRequestConversationContexts()
                self.conversation_contexts.append(temp_model.from_map(k))
        if m.get('DocIds') is not None:
            self.doc_ids = m.get('DocIds')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('ReferenceContent') is not None:
            self.reference_content = m.get('ReferenceContent')
        if m.get('SearchSource') is not None:
            self.search_source = m.get('SearchSource')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunDocQaShrinkRequest(TeaModel):
    def __init__(
        self,
        category_ids_shrink: str = None,
        conversation_contexts_shrink: str = None,
        doc_ids_shrink: str = None,
        model_name: str = None,
        query: str = None,
        reference_content: str = None,
        search_source: str = None,
        session_id: str = None,
        workspace_id: str = None,
    ):
        self.category_ids_shrink = category_ids_shrink
        self.conversation_contexts_shrink = conversation_contexts_shrink
        self.doc_ids_shrink = doc_ids_shrink
        self.model_name = model_name
        # This parameter is required.
        self.query = query
        self.reference_content = reference_content
        # This parameter is required.
        self.search_source = search_source
        # This parameter is required.
        self.session_id = session_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_ids_shrink is not None:
            result['CategoryIds'] = self.category_ids_shrink
        if self.conversation_contexts_shrink is not None:
            result['ConversationContexts'] = self.conversation_contexts_shrink
        if self.doc_ids_shrink is not None:
            result['DocIds'] = self.doc_ids_shrink
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.query is not None:
            result['Query'] = self.query
        if self.reference_content is not None:
            result['ReferenceContent'] = self.reference_content
        if self.search_source is not None:
            result['SearchSource'] = self.search_source
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryIds') is not None:
            self.category_ids_shrink = m.get('CategoryIds')
        if m.get('ConversationContexts') is not None:
            self.conversation_contexts_shrink = m.get('ConversationContexts')
        if m.get('DocIds') is not None:
            self.doc_ids_shrink = m.get('DocIds')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('ReferenceContent') is not None:
            self.reference_content = m.get('ReferenceContent')
        if m.get('SearchSource') is not None:
            self.search_source = m.get('SearchSource')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunDocQaResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunDocQaResponseBodyPayloadOutputMediaUrlListClipInfos(TeaModel):
    def __init__(
        self,
        from_: float = None,
        to: float = None,
    ):
        self.from_ = from_
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.to is not None:
            result['To'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('To') is not None:
            self.to = m.get('To')
        return self


class RunDocQaResponseBodyPayloadOutputMediaUrlList(TeaModel):
    def __init__(
        self,
        clip_infos: List[RunDocQaResponseBodyPayloadOutputMediaUrlListClipInfos] = None,
        file_url: str = None,
        media_type: str = None,
    ):
        self.clip_infos = clip_infos
        self.file_url = file_url
        self.media_type = media_type

    def validate(self):
        if self.clip_infos:
            for k in self.clip_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ClipInfos'] = []
        if self.clip_infos is not None:
            for k in self.clip_infos:
                result['ClipInfos'].append(k.to_map() if k else None)
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clip_infos = []
        if m.get('ClipInfos') is not None:
            for k in m.get('ClipInfos'):
                temp_model = RunDocQaResponseBodyPayloadOutputMediaUrlListClipInfos()
                self.clip_infos.append(temp_model.from_map(k))
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class RunDocQaResponseBodyPayloadOutputRecommends(TeaModel):
    def __init__(
        self,
        title: str = None,
        url: str = None,
    ):
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunDocQaResponseBodyPayloadOutputReferences(TeaModel):
    def __init__(
        self,
        pub_time: str = None,
        source: str = None,
        source_doc_id: str = None,
        title: str = None,
        url: str = None,
    ):
        self.pub_time = pub_time
        self.source = source
        self.source_doc_id = source_doc_id
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.source_doc_id is not None:
            result['SourceDocId'] = self.source_doc_id
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceDocId') is not None:
            self.source_doc_id = m.get('SourceDocId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunDocQaResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        content: str = None,
        intervene_content: str = None,
        is_reject: bool = None,
        media_url_list: List[RunDocQaResponseBodyPayloadOutputMediaUrlList] = None,
        recommends: List[RunDocQaResponseBodyPayloadOutputRecommends] = None,
        references: List[RunDocQaResponseBodyPayloadOutputReferences] = None,
    ):
        self.content = content
        self.intervene_content = intervene_content
        self.is_reject = is_reject
        self.media_url_list = media_url_list
        self.recommends = recommends
        self.references = references

    def validate(self):
        if self.media_url_list:
            for k in self.media_url_list:
                if k:
                    k.validate()
        if self.recommends:
            for k in self.recommends:
                if k:
                    k.validate()
        if self.references:
            for k in self.references:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.intervene_content is not None:
            result['InterveneContent'] = self.intervene_content
        if self.is_reject is not None:
            result['IsReject'] = self.is_reject
        result['MediaUrlList'] = []
        if self.media_url_list is not None:
            for k in self.media_url_list:
                result['MediaUrlList'].append(k.to_map() if k else None)
        result['Recommends'] = []
        if self.recommends is not None:
            for k in self.recommends:
                result['Recommends'].append(k.to_map() if k else None)
        result['References'] = []
        if self.references is not None:
            for k in self.references:
                result['References'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('InterveneContent') is not None:
            self.intervene_content = m.get('InterveneContent')
        if m.get('IsReject') is not None:
            self.is_reject = m.get('IsReject')
        self.media_url_list = []
        if m.get('MediaUrlList') is not None:
            for k in m.get('MediaUrlList'):
                temp_model = RunDocQaResponseBodyPayloadOutputMediaUrlList()
                self.media_url_list.append(temp_model.from_map(k))
        self.recommends = []
        if m.get('Recommends') is not None:
            for k in m.get('Recommends'):
                temp_model = RunDocQaResponseBodyPayloadOutputRecommends()
                self.recommends.append(temp_model.from_map(k))
        self.references = []
        if m.get('References') is not None:
            for k in m.get('References'):
                temp_model = RunDocQaResponseBodyPayloadOutputReferences()
                self.references.append(temp_model.from_map(k))
        return self


class RunDocQaResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunDocQaResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunDocQaResponseBodyPayloadOutput = None,
        usage: RunDocQaResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunDocQaResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunDocQaResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunDocQaResponseBody(TeaModel):
    def __init__(
        self,
        header: RunDocQaResponseBodyHeader = None,
        payload: RunDocQaResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunDocQaResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunDocQaResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunDocQaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunDocQaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunDocQaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunDocSmartCardRequest(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        model_name: str = None,
        prompt: str = None,
        session_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.doc_id = doc_id
        self.model_name = model_name
        self.prompt = prompt
        # This parameter is required.
        self.session_id = session_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunDocSmartCardResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunDocSmartCardResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        content: str = None,
        tags: List[str] = None,
    ):
        self.content = content
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class RunDocSmartCardResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunDocSmartCardResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunDocSmartCardResponseBodyPayloadOutput = None,
        usage: RunDocSmartCardResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunDocSmartCardResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunDocSmartCardResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunDocSmartCardResponseBody(TeaModel):
    def __init__(
        self,
        header: RunDocSmartCardResponseBodyHeader = None,
        payload: RunDocSmartCardResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunDocSmartCardResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunDocSmartCardResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunDocSmartCardResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunDocSmartCardResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunDocSmartCardResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunDocSummaryRequest(TeaModel):
    def __init__(
        self,
        clean_cache: bool = None,
        doc_id: str = None,
        model_name: str = None,
        query: str = None,
        recommend_content: str = None,
        session_id: str = None,
        workspace_id: str = None,
    ):
        self.clean_cache = clean_cache
        self.doc_id = doc_id
        self.model_name = model_name
        self.query = query
        self.recommend_content = recommend_content
        # This parameter is required.
        self.session_id = session_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clean_cache is not None:
            result['CleanCache'] = self.clean_cache
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.query is not None:
            result['Query'] = self.query
        if self.recommend_content is not None:
            result['RecommendContent'] = self.recommend_content
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CleanCache') is not None:
            self.clean_cache = m.get('CleanCache')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('RecommendContent') is not None:
            self.recommend_content = m.get('RecommendContent')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunDocSummaryResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunDocSummaryResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        content: str = None,
    ):
        self.content = content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        return self


class RunDocSummaryResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunDocSummaryResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunDocSummaryResponseBodyPayloadOutput = None,
        usage: RunDocSummaryResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunDocSummaryResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunDocSummaryResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunDocSummaryResponseBody(TeaModel):
    def __init__(
        self,
        header: RunDocSummaryResponseBodyHeader = None,
        payload: RunDocSummaryResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunDocSummaryResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunDocSummaryResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunDocSummaryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunDocSummaryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunDocSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunDocTranslationRequest(TeaModel):
    def __init__(
        self,
        clean_cache: bool = None,
        doc_id: str = None,
        model_name: str = None,
        recommend_content: str = None,
        session_id: str = None,
        trans_type: str = None,
        workspace_id: str = None,
    ):
        self.clean_cache = clean_cache
        self.doc_id = doc_id
        self.model_name = model_name
        self.recommend_content = recommend_content
        # This parameter is required.
        self.session_id = session_id
        self.trans_type = trans_type
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clean_cache is not None:
            result['CleanCache'] = self.clean_cache
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.recommend_content is not None:
            result['RecommendContent'] = self.recommend_content
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.trans_type is not None:
            result['TransType'] = self.trans_type
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CleanCache') is not None:
            self.clean_cache = m.get('CleanCache')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('RecommendContent') is not None:
            self.recommend_content = m.get('RecommendContent')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TransType') is not None:
            self.trans_type = m.get('TransType')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunDocTranslationResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunDocTranslationResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        content: str = None,
    ):
        self.content = content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        return self


class RunDocTranslationResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunDocTranslationResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunDocTranslationResponseBodyPayloadOutput = None,
        usage: RunDocTranslationResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunDocTranslationResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunDocTranslationResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunDocTranslationResponseBody(TeaModel):
    def __init__(
        self,
        header: RunDocTranslationResponseBodyHeader = None,
        payload: RunDocTranslationResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunDocTranslationResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunDocTranslationResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunDocTranslationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunDocTranslationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunDocTranslationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunDocWashingRequest(TeaModel):
    def __init__(
        self,
        model_id: str = None,
        prompt: str = None,
        reference_content: str = None,
        session_id: str = None,
        topic: str = None,
        word_number: int = None,
        workspace_id: str = None,
        writing_type_name: str = None,
        writing_type_ref_doc: str = None,
    ):
        self.model_id = model_id
        self.prompt = prompt
        # This parameter is required.
        self.reference_content = reference_content
        self.session_id = session_id
        self.topic = topic
        self.word_number = word_number
        # This parameter is required.
        self.workspace_id = workspace_id
        self.writing_type_name = writing_type_name
        self.writing_type_ref_doc = writing_type_ref_doc

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.reference_content is not None:
            result['ReferenceContent'] = self.reference_content
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.word_number is not None:
            result['WordNumber'] = self.word_number
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.writing_type_name is not None:
            result['WritingTypeName'] = self.writing_type_name
        if self.writing_type_ref_doc is not None:
            result['WritingTypeRefDoc'] = self.writing_type_ref_doc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ReferenceContent') is not None:
            self.reference_content = m.get('ReferenceContent')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('WordNumber') is not None:
            self.word_number = m.get('WordNumber')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('WritingTypeName') is not None:
            self.writing_type_name = m.get('WritingTypeName')
        if m.get('WritingTypeRefDoc') is not None:
            self.writing_type_ref_doc = m.get('WritingTypeRefDoc')
        return self


class RunDocWashingResponseBodyHeader(TeaModel):
    def __init__(
        self,
        event: str = None,
        event_info: str = None,
        request_id: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.event = event
        self.event_info = event_info
        self.request_id = request_id
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunDocWashingResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunDocWashingResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunDocWashingResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunDocWashingResponseBodyPayloadOutput = None,
        usage: RunDocWashingResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunDocWashingResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunDocWashingResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunDocWashingResponseBody(TeaModel):
    def __init__(
        self,
        end: bool = None,
        header: RunDocWashingResponseBodyHeader = None,
        payload: RunDocWashingResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.end = end
        self.header = header
        self.payload = payload
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Header') is not None:
            temp_model = RunDocWashingResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunDocWashingResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunDocWashingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunDocWashingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunDocWashingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunExpandContentRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        prompt: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.content = content
        self.prompt = prompt
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunExpandContentResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunExpandContentResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunExpandContentResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunExpandContentResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunExpandContentResponseBodyPayloadOutput = None,
        usage: RunExpandContentResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunExpandContentResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunExpandContentResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunExpandContentResponseBody(TeaModel):
    def __init__(
        self,
        end: bool = None,
        header: RunExpandContentResponseBodyHeader = None,
        payload: RunExpandContentResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.end = end
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Header') is not None:
            temp_model = RunExpandContentResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunExpandContentResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunExpandContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunExpandContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunExpandContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunGenerateQuestionsRequest(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        model_name: str = None,
        reference_content: str = None,
        session_id: str = None,
        workspace_id: str = None,
    ):
        self.doc_id = doc_id
        self.model_name = model_name
        self.reference_content = reference_content
        self.session_id = session_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.reference_content is not None:
            result['ReferenceContent'] = self.reference_content
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('ReferenceContent') is not None:
            self.reference_content = m.get('ReferenceContent')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunGenerateQuestionsResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunGenerateQuestionsResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        content: str = None,
    ):
        self.content = content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        return self


class RunGenerateQuestionsResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunGenerateQuestionsResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunGenerateQuestionsResponseBodyPayloadOutput = None,
        usage: RunGenerateQuestionsResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunGenerateQuestionsResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunGenerateQuestionsResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunGenerateQuestionsResponseBody(TeaModel):
    def __init__(
        self,
        header: RunGenerateQuestionsResponseBodyHeader = None,
        payload: RunGenerateQuestionsResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunGenerateQuestionsResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunGenerateQuestionsResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunGenerateQuestionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunGenerateQuestionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunGenerateQuestionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunHotwordRequest(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        model_name: str = None,
        prompt: str = None,
        reference_content: str = None,
        session_id: str = None,
        workspace_id: str = None,
    ):
        self.doc_id = doc_id
        self.model_name = model_name
        self.prompt = prompt
        self.reference_content = reference_content
        self.session_id = session_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.reference_content is not None:
            result['ReferenceContent'] = self.reference_content
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ReferenceContent') is not None:
            self.reference_content = m.get('ReferenceContent')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunHotwordResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunHotwordResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        content: str = None,
    ):
        self.content = content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        return self


class RunHotwordResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunHotwordResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunHotwordResponseBodyPayloadOutput = None,
        usage: RunHotwordResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunHotwordResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunHotwordResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunHotwordResponseBody(TeaModel):
    def __init__(
        self,
        header: RunHotwordResponseBodyHeader = None,
        payload: RunHotwordResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunHotwordResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunHotwordResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunHotwordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunHotwordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunHotwordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunKeywordsExtractionGenerationRequestReferenceData(TeaModel):
    def __init__(
        self,
        contents: List[str] = None,
    ):
        # This parameter is required.
        self.contents = contents

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contents is not None:
            result['Contents'] = self.contents
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Contents') is not None:
            self.contents = m.get('Contents')
        return self


class RunKeywordsExtractionGenerationRequest(TeaModel):
    def __init__(
        self,
        prompt: str = None,
        reference_data: RunKeywordsExtractionGenerationRequestReferenceData = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.prompt = prompt
        # This parameter is required.
        self.reference_data = reference_data
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.reference_data:
            self.reference_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.reference_data is not None:
            result['ReferenceData'] = self.reference_data.to_map()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ReferenceData') is not None:
            temp_model = RunKeywordsExtractionGenerationRequestReferenceData()
            self.reference_data = temp_model.from_map(m['ReferenceData'])
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunKeywordsExtractionGenerationShrinkRequest(TeaModel):
    def __init__(
        self,
        prompt: str = None,
        reference_data_shrink: str = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.prompt = prompt
        # This parameter is required.
        self.reference_data_shrink = reference_data_shrink
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.reference_data_shrink is not None:
            result['ReferenceData'] = self.reference_data_shrink
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ReferenceData') is not None:
            self.reference_data_shrink = m.get('ReferenceData')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunKeywordsExtractionGenerationResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunKeywordsExtractionGenerationResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunKeywordsExtractionGenerationResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunKeywordsExtractionGenerationResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunKeywordsExtractionGenerationResponseBodyPayloadOutput = None,
        usage: RunKeywordsExtractionGenerationResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunKeywordsExtractionGenerationResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunKeywordsExtractionGenerationResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunKeywordsExtractionGenerationResponseBody(TeaModel):
    def __init__(
        self,
        header: RunKeywordsExtractionGenerationResponseBodyHeader = None,
        payload: RunKeywordsExtractionGenerationResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunKeywordsExtractionGenerationResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunKeywordsExtractionGenerationResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunKeywordsExtractionGenerationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunKeywordsExtractionGenerationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunKeywordsExtractionGenerationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunMultiDocIntroductionRequest(TeaModel):
    def __init__(
        self,
        doc_ids: List[str] = None,
        key_point_prompt: str = None,
        model_name: str = None,
        session_id: str = None,
        summary_prompt: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.doc_ids = doc_ids
        self.key_point_prompt = key_point_prompt
        self.model_name = model_name
        # This parameter is required.
        self.session_id = session_id
        self.summary_prompt = summary_prompt
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_ids is not None:
            result['DocIds'] = self.doc_ids
        if self.key_point_prompt is not None:
            result['KeyPointPrompt'] = self.key_point_prompt
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.summary_prompt is not None:
            result['SummaryPrompt'] = self.summary_prompt
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocIds') is not None:
            self.doc_ids = m.get('DocIds')
        if m.get('KeyPointPrompt') is not None:
            self.key_point_prompt = m.get('KeyPointPrompt')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('SummaryPrompt') is not None:
            self.summary_prompt = m.get('SummaryPrompt')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunMultiDocIntroductionShrinkRequest(TeaModel):
    def __init__(
        self,
        doc_ids_shrink: str = None,
        key_point_prompt: str = None,
        model_name: str = None,
        session_id: str = None,
        summary_prompt: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.doc_ids_shrink = doc_ids_shrink
        self.key_point_prompt = key_point_prompt
        self.model_name = model_name
        # This parameter is required.
        self.session_id = session_id
        self.summary_prompt = summary_prompt
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_ids_shrink is not None:
            result['DocIds'] = self.doc_ids_shrink
        if self.key_point_prompt is not None:
            result['KeyPointPrompt'] = self.key_point_prompt
        if self.model_name is not None:
            result['ModelName'] = self.model_name
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.summary_prompt is not None:
            result['SummaryPrompt'] = self.summary_prompt
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocIds') is not None:
            self.doc_ids_shrink = m.get('DocIds')
        if m.get('KeyPointPrompt') is not None:
            self.key_point_prompt = m.get('KeyPointPrompt')
        if m.get('ModelName') is not None:
            self.model_name = m.get('ModelName')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('SummaryPrompt') is not None:
            self.summary_prompt = m.get('SummaryPrompt')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunMultiDocIntroductionResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunMultiDocIntroductionResponseBodyPayloadOutputKeyPoints(TeaModel):
    def __init__(
        self,
        key_point: str = None,
        source: str = None,
    ):
        self.key_point = key_point
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_point is not None:
            result['KeyPoint'] = self.key_point
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('KeyPoint') is not None:
            self.key_point = m.get('KeyPoint')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class RunMultiDocIntroductionResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        key_points: List[RunMultiDocIntroductionResponseBodyPayloadOutputKeyPoints] = None,
        summary: str = None,
    ):
        self.key_points = key_points
        self.summary = summary

    def validate(self):
        if self.key_points:
            for k in self.key_points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['KeyPoints'] = []
        if self.key_points is not None:
            for k in self.key_points:
                result['KeyPoints'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['Summary'] = self.summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.key_points = []
        if m.get('KeyPoints') is not None:
            for k in m.get('KeyPoints'):
                temp_model = RunMultiDocIntroductionResponseBodyPayloadOutputKeyPoints()
                self.key_points.append(temp_model.from_map(k))
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        return self


class RunMultiDocIntroductionResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunMultiDocIntroductionResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunMultiDocIntroductionResponseBodyPayloadOutput = None,
        usage: RunMultiDocIntroductionResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunMultiDocIntroductionResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunMultiDocIntroductionResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunMultiDocIntroductionResponseBody(TeaModel):
    def __init__(
        self,
        header: RunMultiDocIntroductionResponseBodyHeader = None,
        payload: RunMultiDocIntroductionResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunMultiDocIntroductionResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunMultiDocIntroductionResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunMultiDocIntroductionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunMultiDocIntroductionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunMultiDocIntroductionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResultSearchResult(TeaModel):
    def __init__(
        self,
        chunks: List[str] = None,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        score: float = None,
        search_source: str = None,
        search_source_name: str = None,
        search_source_type: str = None,
        source: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.chunks = chunks
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.score = score
        self.search_source = search_source
        self.search_source_name = search_source_name
        self.search_source_type = search_source_type
        self.source = source
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chunks is not None:
            result['Chunks'] = self.chunks
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.score is not None:
            result['Score'] = self.score
        if self.search_source is not None:
            result['SearchSource'] = self.search_source
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.search_source_type is not None:
            result['SearchSourceType'] = self.search_source_type
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Chunks') is not None:
            self.chunks = m.get('Chunks')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('SearchSource') is not None:
            self.search_source = m.get('SearchSource')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('SearchSourceType') is not None:
            self.search_source_type = m.get('SearchSourceType')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResult(TeaModel):
    def __init__(
        self,
        search_result: List[RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResultSearchResult] = None,
    ):
        self.search_result = search_result

    def validate(self):
        if self.search_result:
            for k in self.search_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchResult'] = []
        if self.search_result is not None:
            for k in self.search_result:
                result['SearchResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.search_result = []
        if m.get('SearchResult') is not None:
            for k in m.get('SearchResult'):
                temp_model = RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResultSearchResult()
                self.search_result.append(temp_model.from_map(k))
        return self


class RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelection(TeaModel):
    def __init__(
        self,
        original_session_id: str = None,
        search_model: str = None,
        search_model_data_value: str = None,
        selection_type: str = None,
        session_id: str = None,
        text_search_result: RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResult = None,
    ):
        self.original_session_id = original_session_id
        self.search_model = search_model
        self.search_model_data_value = search_model_data_value
        self.selection_type = selection_type
        self.session_id = session_id
        self.text_search_result = text_search_result

    def validate(self):
        if self.text_search_result:
            self.text_search_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.original_session_id is not None:
            result['OriginalSessionId'] = self.original_session_id
        if self.search_model is not None:
            result['SearchModel'] = self.search_model
        if self.search_model_data_value is not None:
            result['SearchModelDataValue'] = self.search_model_data_value
        if self.selection_type is not None:
            result['SelectionType'] = self.selection_type
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.text_search_result is not None:
            result['TextSearchResult'] = self.text_search_result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OriginalSessionId') is not None:
            self.original_session_id = m.get('OriginalSessionId')
        if m.get('SearchModel') is not None:
            self.search_model = m.get('SearchModel')
        if m.get('SearchModelDataValue') is not None:
            self.search_model_data_value = m.get('SearchModelDataValue')
        if m.get('SelectionType') is not None:
            self.selection_type = m.get('SelectionType')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TextSearchResult') is not None:
            temp_model = RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResult()
            self.text_search_result = temp_model.from_map(m['TextSearchResult'])
        return self


class RunSearchGenerationRequestAgentContextBizContext(TeaModel):
    def __init__(
        self,
        ask_user: str = None,
        ask_user_keywords: List[str] = None,
        current_step: str = None,
        multimodal_media_selection: RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelection = None,
        next_step: str = None,
        skip_current_supplement: bool = None,
        supplement_data_type: str = None,
        supplement_enable: bool = None,
        user_back: str = None,
        user_back_keywords: List[str] = None,
    ):
        self.ask_user = ask_user
        self.ask_user_keywords = ask_user_keywords
        self.current_step = current_step
        self.multimodal_media_selection = multimodal_media_selection
        self.next_step = next_step
        self.skip_current_supplement = skip_current_supplement
        self.supplement_data_type = supplement_data_type
        self.supplement_enable = supplement_enable
        self.user_back = user_back
        self.user_back_keywords = user_back_keywords

    def validate(self):
        if self.multimodal_media_selection:
            self.multimodal_media_selection.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ask_user is not None:
            result['AskUser'] = self.ask_user
        if self.ask_user_keywords is not None:
            result['AskUserKeywords'] = self.ask_user_keywords
        if self.current_step is not None:
            result['CurrentStep'] = self.current_step
        if self.multimodal_media_selection is not None:
            result['MultimodalMediaSelection'] = self.multimodal_media_selection.to_map()
        if self.next_step is not None:
            result['NextStep'] = self.next_step
        if self.skip_current_supplement is not None:
            result['SkipCurrentSupplement'] = self.skip_current_supplement
        if self.supplement_data_type is not None:
            result['SupplementDataType'] = self.supplement_data_type
        if self.supplement_enable is not None:
            result['SupplementEnable'] = self.supplement_enable
        if self.user_back is not None:
            result['UserBack'] = self.user_back
        if self.user_back_keywords is not None:
            result['UserBackKeywords'] = self.user_back_keywords
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AskUser') is not None:
            self.ask_user = m.get('AskUser')
        if m.get('AskUserKeywords') is not None:
            self.ask_user_keywords = m.get('AskUserKeywords')
        if m.get('CurrentStep') is not None:
            self.current_step = m.get('CurrentStep')
        if m.get('MultimodalMediaSelection') is not None:
            temp_model = RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelection()
            self.multimodal_media_selection = temp_model.from_map(m['MultimodalMediaSelection'])
        if m.get('NextStep') is not None:
            self.next_step = m.get('NextStep')
        if m.get('SkipCurrentSupplement') is not None:
            self.skip_current_supplement = m.get('SkipCurrentSupplement')
        if m.get('SupplementDataType') is not None:
            self.supplement_data_type = m.get('SupplementDataType')
        if m.get('SupplementEnable') is not None:
            self.supplement_enable = m.get('SupplementEnable')
        if m.get('UserBack') is not None:
            self.user_back = m.get('UserBack')
        if m.get('UserBackKeywords') is not None:
            self.user_back_keywords = m.get('UserBackKeywords')
        return self


class RunSearchGenerationRequestAgentContext(TeaModel):
    def __init__(
        self,
        biz_context: RunSearchGenerationRequestAgentContextBizContext = None,
    ):
        self.biz_context = biz_context

    def validate(self):
        if self.biz_context:
            self.biz_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_context is not None:
            result['BizContext'] = self.biz_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizContext') is not None:
            temp_model = RunSearchGenerationRequestAgentContextBizContext()
            self.biz_context = temp_model.from_map(m['BizContext'])
        return self


class RunSearchGenerationRequestChatConfigSearchParamSearchSources(TeaModel):
    def __init__(
        self,
        code: str = None,
        dataset_name: str = None,
    ):
        self.code = code
        self.dataset_name = dataset_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        return self


class RunSearchGenerationRequestChatConfigSearchParam(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        multimodal_search_types: List[str] = None,
        search_sources: List[RunSearchGenerationRequestChatConfigSearchParamSearchSources] = None,
        start_time: int = None,
    ):
        self.end_time = end_time
        self.multimodal_search_types = multimodal_search_types
        self.search_sources = search_sources
        self.start_time = start_time

    def validate(self):
        if self.search_sources:
            for k in self.search_sources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.multimodal_search_types is not None:
            result['MultimodalSearchTypes'] = self.multimodal_search_types
        result['SearchSources'] = []
        if self.search_sources is not None:
            for k in self.search_sources:
                result['SearchSources'].append(k.to_map() if k else None)
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MultimodalSearchTypes') is not None:
            self.multimodal_search_types = m.get('MultimodalSearchTypes')
        self.search_sources = []
        if m.get('SearchSources') is not None:
            for k in m.get('SearchSources'):
                temp_model = RunSearchGenerationRequestChatConfigSearchParamSearchSources()
                self.search_sources.append(temp_model.from_map(k))
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class RunSearchGenerationRequestChatConfig(TeaModel):
    def __init__(
        self,
        enable_thinking: bool = None,
        exclude_generate_options: List[str] = None,
        generate_level: str = None,
        generate_technology: str = None,
        search_models: List[str] = None,
        search_param: RunSearchGenerationRequestChatConfigSearchParam = None,
    ):
        self.enable_thinking = enable_thinking
        self.exclude_generate_options = exclude_generate_options
        self.generate_level = generate_level
        self.generate_technology = generate_technology
        self.search_models = search_models
        self.search_param = search_param

    def validate(self):
        if self.search_param:
            self.search_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_thinking is not None:
            result['EnableThinking'] = self.enable_thinking
        if self.exclude_generate_options is not None:
            result['ExcludeGenerateOptions'] = self.exclude_generate_options
        if self.generate_level is not None:
            result['GenerateLevel'] = self.generate_level
        if self.generate_technology is not None:
            result['GenerateTechnology'] = self.generate_technology
        if self.search_models is not None:
            result['SearchModels'] = self.search_models
        if self.search_param is not None:
            result['SearchParam'] = self.search_param.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableThinking') is not None:
            self.enable_thinking = m.get('EnableThinking')
        if m.get('ExcludeGenerateOptions') is not None:
            self.exclude_generate_options = m.get('ExcludeGenerateOptions')
        if m.get('GenerateLevel') is not None:
            self.generate_level = m.get('GenerateLevel')
        if m.get('GenerateTechnology') is not None:
            self.generate_technology = m.get('GenerateTechnology')
        if m.get('SearchModels') is not None:
            self.search_models = m.get('SearchModels')
        if m.get('SearchParam') is not None:
            temp_model = RunSearchGenerationRequestChatConfigSearchParam()
            self.search_param = temp_model.from_map(m['SearchParam'])
        return self


class RunSearchGenerationRequest(TeaModel):
    def __init__(
        self,
        agent_context: RunSearchGenerationRequestAgentContext = None,
        chat_config: RunSearchGenerationRequestChatConfig = None,
        model_id: str = None,
        original_session_id: str = None,
        prompt: str = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.agent_context = agent_context
        self.chat_config = chat_config
        self.model_id = model_id
        self.original_session_id = original_session_id
        self.prompt = prompt
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.agent_context:
            self.agent_context.validate()
        if self.chat_config:
            self.chat_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_context is not None:
            result['AgentContext'] = self.agent_context.to_map()
        if self.chat_config is not None:
            result['ChatConfig'] = self.chat_config.to_map()
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.original_session_id is not None:
            result['OriginalSessionId'] = self.original_session_id
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentContext') is not None:
            temp_model = RunSearchGenerationRequestAgentContext()
            self.agent_context = temp_model.from_map(m['AgentContext'])
        if m.get('ChatConfig') is not None:
            temp_model = RunSearchGenerationRequestChatConfig()
            self.chat_config = temp_model.from_map(m['ChatConfig'])
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('OriginalSessionId') is not None:
            self.original_session_id = m.get('OriginalSessionId')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunSearchGenerationShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_context_shrink: str = None,
        chat_config_shrink: str = None,
        model_id: str = None,
        original_session_id: str = None,
        prompt: str = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        self.agent_context_shrink = agent_context_shrink
        self.chat_config_shrink = chat_config_shrink
        self.model_id = model_id
        self.original_session_id = original_session_id
        self.prompt = prompt
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_context_shrink is not None:
            result['AgentContext'] = self.agent_context_shrink
        if self.chat_config_shrink is not None:
            result['ChatConfig'] = self.chat_config_shrink
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.original_session_id is not None:
            result['OriginalSessionId'] = self.original_session_id
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentContext') is not None:
            self.agent_context_shrink = m.get('AgentContext')
        if m.get('ChatConfig') is not None:
            self.chat_config_shrink = m.get('ChatConfig')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('OriginalSessionId') is not None:
            self.original_session_id = m.get('OriginalSessionId')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunSearchGenerationResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        origin_session_id: str = None,
        response_time: int = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.origin_session_id = origin_session_id
        self.response_time = response_time
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.origin_session_id is not None:
            result['OriginSessionId'] = self.origin_session_id
        if self.response_time is not None:
            result['ResponseTime'] = self.response_time
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('OriginSessionId') is not None:
            self.origin_session_id = m.get('OriginSessionId')
        if m.get('ResponseTime') is not None:
            self.response_time = m.get('ResponseTime')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResultArticle(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        search_source_name: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.search_source_name = search_source_name
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResult(TeaModel):
    def __init__(
        self,
        article: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResultArticle = None,
        file_url: str = None,
        media_id: str = None,
    ):
        self.article = article
        self.file_url = file_url
        self.media_id = media_id

    def validate(self):
        if self.article:
            self.article.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article is not None:
            result['Article'] = self.article.to_map()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Article') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResultArticle()
            self.article = temp_model.from_map(m['Article'])
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResult(TeaModel):
    def __init__(
        self,
        current: int = None,
        search_result: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResult] = None,
        size: int = None,
        total: int = None,
    ):
        self.current = current
        self.search_result = search_result
        self.size = size
        self.total = total

    def validate(self):
        if self.search_result:
            for k in self.search_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current is not None:
            result['Current'] = self.current
        result['SearchResult'] = []
        if self.search_result is not None:
            for k in self.search_result:
                result['SearchResult'].append(k.to_map() if k else None)
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Current') is not None:
            self.current = m.get('Current')
        self.search_result = []
        if m.get('SearchResult') is not None:
            for k in m.get('SearchResult'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResult()
                self.search_result.append(temp_model.from_map(k))
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResultMultimodalMedias(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        media_id: str = None,
        media_type: str = None,
    ):
        self.file_url = file_url
        self.media_id = media_id
        self.media_type = media_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResult(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        multimodal_medias: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResultMultimodalMedias] = None,
        pub_time: str = None,
        search_source: str = None,
        search_source_name: str = None,
        search_source_type: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.multimodal_medias = multimodal_medias
        self.pub_time = pub_time
        self.search_source = search_source
        self.search_source_name = search_source_name
        self.search_source_type = search_source_type
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        if self.multimodal_medias:
            for k in self.multimodal_medias:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        result['MultimodalMedias'] = []
        if self.multimodal_medias is not None:
            for k in self.multimodal_medias:
                result['MultimodalMedias'].append(k.to_map() if k else None)
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.search_source is not None:
            result['SearchSource'] = self.search_source
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.search_source_type is not None:
            result['SearchSourceType'] = self.search_source_type
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        self.multimodal_medias = []
        if m.get('MultimodalMedias') is not None:
            for k in m.get('MultimodalMedias'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResultMultimodalMedias()
                self.multimodal_medias.append(temp_model.from_map(k))
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('SearchSource') is not None:
            self.search_source = m.get('SearchSource')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('SearchSourceType') is not None:
            self.search_source_type = m.get('SearchSourceType')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResult(TeaModel):
    def __init__(
        self,
        current: int = None,
        search_result: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResult] = None,
        size: int = None,
        total: int = None,
    ):
        self.current = current
        self.search_result = search_result
        self.size = size
        self.total = total

    def validate(self):
        if self.search_result:
            for k in self.search_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current is not None:
            result['Current'] = self.current
        result['SearchResult'] = []
        if self.search_result is not None:
            for k in self.search_result:
                result['SearchResult'].append(k.to_map() if k else None)
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Current') is not None:
            self.current = m.get('Current')
        self.search_result = []
        if m.get('SearchResult') is not None:
            for k in m.get('SearchResult'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResult()
                self.search_result.append(temp_model.from_map(k))
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultArticle(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        search_source_name: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.search_source_name = search_source_name
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultClipInfos(TeaModel):
    def __init__(
        self,
        from_: float = None,
        score: float = None,
        text: str = None,
        to: float = None,
        type: str = None,
    ):
        self.from_ = from_
        self.score = score
        self.text = text
        self.to = to
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.score is not None:
            result['Score'] = self.score
        if self.text is not None:
            result['Text'] = self.text
        if self.to is not None:
            result['To'] = self.to
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('To') is not None:
            self.to = m.get('To')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResult(TeaModel):
    def __init__(
        self,
        article: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultArticle = None,
        clip_infos: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultClipInfos] = None,
        file_url: str = None,
        media_id: str = None,
    ):
        self.article = article
        self.clip_infos = clip_infos
        self.file_url = file_url
        self.media_id = media_id

    def validate(self):
        if self.article:
            self.article.validate()
        if self.clip_infos:
            for k in self.clip_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article is not None:
            result['Article'] = self.article.to_map()
        result['ClipInfos'] = []
        if self.clip_infos is not None:
            for k in self.clip_infos:
                result['ClipInfos'].append(k.to_map() if k else None)
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Article') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultArticle()
            self.article = temp_model.from_map(m['Article'])
        self.clip_infos = []
        if m.get('ClipInfos') is not None:
            for k in m.get('ClipInfos'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultClipInfos()
                self.clip_infos.append(temp_model.from_map(k))
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResult(TeaModel):
    def __init__(
        self,
        current: int = None,
        search_result: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResult] = None,
        size: int = None,
        total: int = None,
    ):
        self.current = current
        self.search_result = search_result
        self.size = size
        self.total = total

    def validate(self):
        if self.search_result:
            for k in self.search_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current is not None:
            result['Current'] = self.current
        result['SearchResult'] = []
        if self.search_result is not None:
            for k in self.search_result:
                result['SearchResult'].append(k.to_map() if k else None)
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Current') is not None:
            self.current = m.get('Current')
        self.search_result = []
        if m.get('SearchResult') is not None:
            for k in m.get('SearchResult'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResult()
                self.search_result.append(temp_model.from_map(k))
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopics(TeaModel):
    def __init__(
        self,
        image_search_result: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResult = None,
        text_search_result: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResult = None,
        topic: str = None,
        video_search_result: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResult = None,
    ):
        self.image_search_result = image_search_result
        self.text_search_result = text_search_result
        self.topic = topic
        self.video_search_result = video_search_result

    def validate(self):
        if self.image_search_result:
            self.image_search_result.validate()
        if self.text_search_result:
            self.text_search_result.validate()
        if self.video_search_result:
            self.video_search_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_search_result is not None:
            result['ImageSearchResult'] = self.image_search_result.to_map()
        if self.text_search_result is not None:
            result['TextSearchResult'] = self.text_search_result.to_map()
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.video_search_result is not None:
            result['VideoSearchResult'] = self.video_search_result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageSearchResult') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResult()
            self.image_search_result = temp_model.from_map(m['ImageSearchResult'])
        if m.get('TextSearchResult') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResult()
            self.text_search_result = temp_model.from_map(m['TextSearchResult'])
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('VideoSearchResult') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResult()
            self.video_search_result = temp_model.from_map(m['VideoSearchResult'])
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResult(TeaModel):
    def __init__(
        self,
        cluster_topics: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopics] = None,
        generate_finished: bool = None,
        text_generate: str = None,
    ):
        self.cluster_topics = cluster_topics
        self.generate_finished = generate_finished
        self.text_generate = text_generate

    def validate(self):
        if self.cluster_topics:
            for k in self.cluster_topics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ClusterTopics'] = []
        if self.cluster_topics is not None:
            for k in self.cluster_topics:
                result['ClusterTopics'].append(k.to_map() if k else None)
        if self.generate_finished is not None:
            result['GenerateFinished'] = self.generate_finished
        if self.text_generate is not None:
            result['TextGenerate'] = self.text_generate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cluster_topics = []
        if m.get('ClusterTopics') is not None:
            for k in m.get('ClusterTopics'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopics()
                self.cluster_topics.append(temp_model.from_map(k))
        if m.get('GenerateFinished') is not None:
            self.generate_finished = m.get('GenerateFinished')
        if m.get('TextGenerate') is not None:
            self.text_generate = m.get('TextGenerate')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultMultimodalMedias(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        media_id: str = None,
        media_type: str = None,
    ):
        self.file_url = file_url
        self.media_id = media_id
        self.media_type = media_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaListArticle(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        search_source_name: str = None,
        title: str = None,
        url: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.search_source_name = search_source_name
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaList(TeaModel):
    def __init__(
        self,
        article: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaListArticle = None,
        file_url: str = None,
        media_id: str = None,
        media_type: str = None,
    ):
        self.article = article
        self.file_url = file_url
        self.media_id = media_id
        self.media_type = media_type

    def validate(self):
        if self.article:
            self.article.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article is not None:
            result['Article'] = self.article.to_map()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Article') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaListArticle()
            self.article = temp_model.from_map(m['Article'])
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaList(TeaModel):
    def __init__(
        self,
        doc_uuid: str = None,
        end: int = None,
        multimodal_media_list: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaList] = None,
        start: int = None,
    ):
        self.doc_uuid = doc_uuid
        self.end = end
        self.multimodal_media_list = multimodal_media_list
        self.start = start

    def validate(self):
        if self.multimodal_media_list:
            for k in self.multimodal_media_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.end is not None:
            result['End'] = self.end
        result['MultimodalMediaList'] = []
        if self.multimodal_media_list is not None:
            for k in self.multimodal_media_list:
                result['MultimodalMediaList'].append(k.to_map() if k else None)
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('End') is not None:
            self.end = m.get('End')
        self.multimodal_media_list = []
        if m.get('MultimodalMediaList') is not None:
            for k in m.get('MultimodalMediaList'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaList()
                self.multimodal_media_list.append(temp_model.from_map(k))
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResult(TeaModel):
    def __init__(
        self,
        chunks: List[str] = None,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        excerpt: str = None,
        multimodal_medias: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultMultimodalMedias] = None,
        pub_time: str = None,
        score: float = None,
        search_source: str = None,
        search_source_name: str = None,
        search_source_type: str = None,
        select: bool = None,
        summary: str = None,
        text_generate_multimodal_media_list: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaList] = None,
        title: str = None,
        traceability_id: int = None,
        url: str = None,
    ):
        self.chunks = chunks
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.excerpt = excerpt
        self.multimodal_medias = multimodal_medias
        self.pub_time = pub_time
        self.score = score
        self.search_source = search_source
        self.search_source_name = search_source_name
        self.search_source_type = search_source_type
        self.select = select
        self.summary = summary
        self.text_generate_multimodal_media_list = text_generate_multimodal_media_list
        self.title = title
        self.traceability_id = traceability_id
        self.url = url

    def validate(self):
        if self.multimodal_medias:
            for k in self.multimodal_medias:
                if k:
                    k.validate()
        if self.text_generate_multimodal_media_list:
            for k in self.text_generate_multimodal_media_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chunks is not None:
            result['Chunks'] = self.chunks
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.excerpt is not None:
            result['Excerpt'] = self.excerpt
        result['MultimodalMedias'] = []
        if self.multimodal_medias is not None:
            for k in self.multimodal_medias:
                result['MultimodalMedias'].append(k.to_map() if k else None)
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.score is not None:
            result['Score'] = self.score
        if self.search_source is not None:
            result['SearchSource'] = self.search_source
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.search_source_type is not None:
            result['SearchSourceType'] = self.search_source_type
        if self.select is not None:
            result['Select'] = self.select
        if self.summary is not None:
            result['Summary'] = self.summary
        result['TextGenerateMultimodalMediaList'] = []
        if self.text_generate_multimodal_media_list is not None:
            for k in self.text_generate_multimodal_media_list:
                result['TextGenerateMultimodalMediaList'].append(k.to_map() if k else None)
        if self.title is not None:
            result['Title'] = self.title
        if self.traceability_id is not None:
            result['TraceabilityId'] = self.traceability_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Chunks') is not None:
            self.chunks = m.get('Chunks')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('Excerpt') is not None:
            self.excerpt = m.get('Excerpt')
        self.multimodal_medias = []
        if m.get('MultimodalMedias') is not None:
            for k in m.get('MultimodalMedias'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultMultimodalMedias()
                self.multimodal_medias.append(temp_model.from_map(k))
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('SearchSource') is not None:
            self.search_source = m.get('SearchSource')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('SearchSourceType') is not None:
            self.search_source_type = m.get('SearchSourceType')
        if m.get('Select') is not None:
            self.select = m.get('Select')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        self.text_generate_multimodal_media_list = []
        if m.get('TextGenerateMultimodalMediaList') is not None:
            for k in m.get('TextGenerateMultimodalMediaList'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaList()
                self.text_generate_multimodal_media_list.append(temp_model.from_map(k))
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TraceabilityId') is not None:
            self.traceability_id = m.get('TraceabilityId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResult(TeaModel):
    def __init__(
        self,
        generate_finished: bool = None,
        generate_level: str = None,
        reason_text_generate: str = None,
        search_result: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResult] = None,
        text_generate: str = None,
    ):
        self.generate_finished = generate_finished
        self.generate_level = generate_level
        self.reason_text_generate = reason_text_generate
        self.search_result = search_result
        self.text_generate = text_generate

    def validate(self):
        if self.search_result:
            for k in self.search_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.generate_finished is not None:
            result['GenerateFinished'] = self.generate_finished
        if self.generate_level is not None:
            result['GenerateLevel'] = self.generate_level
        if self.reason_text_generate is not None:
            result['ReasonTextGenerate'] = self.reason_text_generate
        result['SearchResult'] = []
        if self.search_result is not None:
            for k in self.search_result:
                result['SearchResult'].append(k.to_map() if k else None)
        if self.text_generate is not None:
            result['TextGenerate'] = self.text_generate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GenerateFinished') is not None:
            self.generate_finished = m.get('GenerateFinished')
        if m.get('GenerateLevel') is not None:
            self.generate_level = m.get('GenerateLevel')
        if m.get('ReasonTextGenerate') is not None:
            self.reason_text_generate = m.get('ReasonTextGenerate')
        self.search_result = []
        if m.get('SearchResult') is not None:
            for k in m.get('SearchResult'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResult()
                self.search_result.append(temp_model.from_map(k))
        if m.get('TextGenerate') is not None:
            self.text_generate = m.get('TextGenerate')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResultArticle(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        search_source_name: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.search_source_name = search_source_name
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResult(TeaModel):
    def __init__(
        self,
        article: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResultArticle = None,
        file_url: str = None,
        media_id: str = None,
    ):
        self.article = article
        self.file_url = file_url
        self.media_id = media_id

    def validate(self):
        if self.article:
            self.article.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article is not None:
            result['Article'] = self.article.to_map()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Article') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResultArticle()
            self.article = temp_model.from_map(m['Article'])
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResult(TeaModel):
    def __init__(
        self,
        search_result: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResult] = None,
    ):
        self.search_result = search_result

    def validate(self):
        if self.search_result:
            for k in self.search_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchResult'] = []
        if self.search_result is not None:
            for k in self.search_result:
                result['SearchResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.search_result = []
        if m.get('SearchResult') is not None:
            for k in m.get('SearchResult'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResult()
                self.search_result.append(temp_model.from_map(k))
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListArticle(TeaModel):
    def __init__(
        self,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        score: float = None,
        search_source: str = None,
        search_source_name: str = None,
        search_source_type: str = None,
        select: bool = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.score = score
        self.search_source = search_source
        self.search_source_name = search_source_name
        self.search_source_type = search_source_type
        self.select = select
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.score is not None:
            result['Score'] = self.score
        if self.search_source is not None:
            result['SearchSource'] = self.search_source
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.search_source_type is not None:
            result['SearchSourceType'] = self.search_source_type
        if self.select is not None:
            result['Select'] = self.select
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('SearchSource') is not None:
            self.search_source = m.get('SearchSource')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('SearchSourceType') is not None:
            self.search_source_type = m.get('SearchSourceType')
        if m.get('Select') is not None:
            self.select = m.get('Select')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementListEvent(TeaModel):
    def __init__(
        self,
        cause_list: List[str] = None,
        process_list: List[str] = None,
        result_list: List[str] = None,
    ):
        self.cause_list = cause_list
        self.process_list = process_list
        self.result_list = result_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cause_list is not None:
            result['CauseList'] = self.cause_list
        if self.process_list is not None:
            result['ProcessList'] = self.process_list
        if self.result_list is not None:
            result['ResultList'] = self.result_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CauseList') is not None:
            self.cause_list = m.get('CauseList')
        if m.get('ProcessList') is not None:
            self.process_list = m.get('ProcessList')
        if m.get('ResultList') is not None:
            self.result_list = m.get('ResultList')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementList(TeaModel):
    def __init__(
        self,
        event: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementListEvent = None,
        location: str = None,
        people: str = None,
        time: str = None,
    ):
        self.event = event
        self.location = location
        self.people = people
        self.time = time

    def validate(self):
        if self.event:
            self.event.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event is not None:
            result['Event'] = self.event.to_map()
        if self.location is not None:
            result['Location'] = self.location
        if self.people is not None:
            result['People'] = self.people
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Event') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementListEvent()
            self.event = temp_model.from_map(m['Event'])
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('People') is not None:
            self.people = m.get('People')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleList(TeaModel):
    def __init__(
        self,
        article: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListArticle = None,
        news_element_list: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementList] = None,
        text_generate: str = None,
    ):
        self.article = article
        self.news_element_list = news_element_list
        self.text_generate = text_generate

    def validate(self):
        if self.article:
            self.article.validate()
        if self.news_element_list:
            for k in self.news_element_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article is not None:
            result['Article'] = self.article.to_map()
        result['NewsElementList'] = []
        if self.news_element_list is not None:
            for k in self.news_element_list:
                result['NewsElementList'].append(k.to_map() if k else None)
        if self.text_generate is not None:
            result['TextGenerate'] = self.text_generate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Article') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListArticle()
            self.article = temp_model.from_map(m['Article'])
        self.news_element_list = []
        if m.get('NewsElementList') is not None:
            for k in m.get('NewsElementList'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementList()
                self.news_element_list.append(temp_model.from_map(k))
        if m.get('TextGenerate') is not None:
            self.text_generate = m.get('TextGenerate')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResult(TeaModel):
    def __init__(
        self,
        generate_finished: bool = None,
        news_element_article_list: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleList] = None,
        text_generate: str = None,
    ):
        self.generate_finished = generate_finished
        self.news_element_article_list = news_element_article_list
        self.text_generate = text_generate

    def validate(self):
        if self.news_element_article_list:
            for k in self.news_element_article_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.generate_finished is not None:
            result['GenerateFinished'] = self.generate_finished
        result['NewsElementArticleList'] = []
        if self.news_element_article_list is not None:
            for k in self.news_element_article_list:
                result['NewsElementArticleList'].append(k.to_map() if k else None)
        if self.text_generate is not None:
            result['TextGenerate'] = self.text_generate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GenerateFinished') is not None:
            self.generate_finished = m.get('GenerateFinished')
        self.news_element_article_list = []
        if m.get('NewsElementArticleList') is not None:
            for k in m.get('NewsElementArticleList'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleList()
                self.news_element_article_list.append(temp_model.from_map(k))
        if m.get('TextGenerate') is not None:
            self.text_generate = m.get('TextGenerate')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesGenerateCoordinate(TeaModel):
    def __init__(
        self,
        x: int = None,
        y: int = None,
        z: int = None,
    ):
        self.x = x
        self.y = y
        self.z = z

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.z is not None:
            result['Z'] = self.z
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('Z') is not None:
            self.z = m.get('Z')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesNewsCoordinate(TeaModel):
    def __init__(
        self,
        x: int = None,
        y: int = None,
        z: int = None,
    ):
        self.x = x
        self.y = y
        self.z = z

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.z is not None:
            result['Z'] = self.z
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('Z') is not None:
            self.z = m.get('Z')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinates(TeaModel):
    def __init__(
        self,
        generate_coordinate: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesGenerateCoordinate = None,
        news_coordinate: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesNewsCoordinate = None,
    ):
        self.generate_coordinate = generate_coordinate
        self.news_coordinate = news_coordinate

    def validate(self):
        if self.generate_coordinate:
            self.generate_coordinate.validate()
        if self.news_coordinate:
            self.news_coordinate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.generate_coordinate is not None:
            result['GenerateCoordinate'] = self.generate_coordinate.to_map()
        if self.news_coordinate is not None:
            result['NewsCoordinate'] = self.news_coordinate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GenerateCoordinate') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesGenerateCoordinate()
            self.generate_coordinate = temp_model.from_map(m['GenerateCoordinate'])
        if m.get('NewsCoordinate') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesNewsCoordinate()
            self.news_coordinate = temp_model.from_map(m['NewsCoordinate'])
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceability(TeaModel):
    def __init__(
        self,
        coordinates: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinates] = None,
        duplicate: float = None,
    ):
        self.coordinates = coordinates
        self.duplicate = duplicate

    def validate(self):
        if self.coordinates:
            for k in self.coordinates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Coordinates'] = []
        if self.coordinates is not None:
            for k in self.coordinates:
                result['Coordinates'].append(k.to_map() if k else None)
        if self.duplicate is not None:
            result['Duplicate'] = self.duplicate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.coordinates = []
        if m.get('Coordinates') is not None:
            for k in m.get('Coordinates'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinates()
                self.coordinates.append(temp_model.from_map(k))
        if m.get('Duplicate') is not None:
            self.duplicate = m.get('Duplicate')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultArticle(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        search_source_name: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.search_source_name = search_source_name
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultClipInfos(TeaModel):
    def __init__(
        self,
        from_: float = None,
        score: float = None,
        text: str = None,
        to: float = None,
        type: str = None,
    ):
        self.from_ = from_
        self.score = score
        self.text = text
        self.to = to
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.score is not None:
            result['Score'] = self.score
        if self.text is not None:
            result['Text'] = self.text
        if self.to is not None:
            result['To'] = self.to
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('To') is not None:
            self.to = m.get('To')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResult(TeaModel):
    def __init__(
        self,
        article: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultArticle = None,
        clip_infos: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultClipInfos] = None,
        file_url: str = None,
        media_id: str = None,
        media_type: str = None,
    ):
        self.article = article
        self.clip_infos = clip_infos
        self.file_url = file_url
        self.media_id = media_id
        self.media_type = media_type

    def validate(self):
        if self.article:
            self.article.validate()
        if self.clip_infos:
            for k in self.clip_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article is not None:
            result['Article'] = self.article.to_map()
        result['ClipInfos'] = []
        if self.clip_infos is not None:
            for k in self.clip_infos:
                result['ClipInfos'].append(k.to_map() if k else None)
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Article') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultArticle()
            self.article = temp_model.from_map(m['Article'])
        self.clip_infos = []
        if m.get('ClipInfos') is not None:
            for k in m.get('ClipInfos'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultClipInfos()
                self.clip_infos.append(temp_model.from_map(k))
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultList(TeaModel):
    def __init__(
        self,
        current: int = None,
        search_query: str = None,
        search_result: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResult] = None,
        search_type: str = None,
        size: int = None,
        timeline_date_str: str = None,
        total: int = None,
    ):
        self.current = current
        self.search_query = search_query
        self.search_result = search_result
        self.search_type = search_type
        self.size = size
        self.timeline_date_str = timeline_date_str
        self.total = total

    def validate(self):
        if self.search_result:
            for k in self.search_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current is not None:
            result['Current'] = self.current
        if self.search_query is not None:
            result['SearchQuery'] = self.search_query
        result['SearchResult'] = []
        if self.search_result is not None:
            for k in self.search_result:
                result['SearchResult'].append(k.to_map() if k else None)
        if self.search_type is not None:
            result['SearchType'] = self.search_type
        if self.size is not None:
            result['Size'] = self.size
        if self.timeline_date_str is not None:
            result['TimelineDateStr'] = self.timeline_date_str
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Current') is not None:
            self.current = m.get('Current')
        if m.get('SearchQuery') is not None:
            self.search_query = m.get('SearchQuery')
        self.search_result = []
        if m.get('SearchResult') is not None:
            for k in m.get('SearchResult'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResult()
                self.search_result.append(temp_model.from_map(k))
        if m.get('SearchType') is not None:
            self.search_type = m.get('SearchType')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TimelineDateStr') is not None:
            self.timeline_date_str = m.get('TimelineDateStr')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultReferenceList(TeaModel):
    def __init__(
        self,
        chunks: List[str] = None,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        score: float = None,
        search_source: str = None,
        search_source_name: str = None,
        search_source_type: str = None,
        select: bool = None,
        source: str = None,
        summary: str = None,
        title: str = None,
        traceability_id: int = None,
        url: str = None,
    ):
        self.chunks = chunks
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.score = score
        self.search_source = search_source
        self.search_source_name = search_source_name
        self.search_source_type = search_source_type
        self.select = select
        self.source = source
        self.summary = summary
        self.title = title
        self.traceability_id = traceability_id
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chunks is not None:
            result['Chunks'] = self.chunks
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.score is not None:
            result['Score'] = self.score
        if self.search_source is not None:
            result['SearchSource'] = self.search_source
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.search_source_type is not None:
            result['SearchSourceType'] = self.search_source_type
        if self.select is not None:
            result['Select'] = self.select
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.traceability_id is not None:
            result['TraceabilityId'] = self.traceability_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Chunks') is not None:
            self.chunks = m.get('Chunks')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('SearchSource') is not None:
            self.search_source = m.get('SearchSource')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('SearchSourceType') is not None:
            self.search_source_type = m.get('SearchSourceType')
        if m.get('Select') is not None:
            self.select = m.get('Select')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TraceabilityId') is not None:
            self.traceability_id = m.get('TraceabilityId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaListArticle(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        search_source_name: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.search_source_name = search_source_name
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaList(TeaModel):
    def __init__(
        self,
        article: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaListArticle = None,
        file_url: str = None,
        media_id: str = None,
        media_type: str = None,
    ):
        self.article = article
        self.file_url = file_url
        self.media_id = media_id
        self.media_type = media_type

    def validate(self):
        if self.article:
            self.article.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article is not None:
            result['Article'] = self.article.to_map()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Article') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaListArticle()
            self.article = temp_model.from_map(m['Article'])
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaList(TeaModel):
    def __init__(
        self,
        end: int = None,
        multimodal_media_list: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaList] = None,
        start: int = None,
    ):
        self.end = end
        self.multimodal_media_list = multimodal_media_list
        self.start = start

    def validate(self):
        if self.multimodal_media_list:
            for k in self.multimodal_media_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        result['MultimodalMediaList'] = []
        if self.multimodal_media_list is not None:
            for k in self.multimodal_media_list:
                result['MultimodalMediaList'].append(k.to_map() if k else None)
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        self.multimodal_media_list = []
        if m.get('MultimodalMediaList') is not None:
            for k in m.get('MultimodalMediaList'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaList()
                self.multimodal_media_list.append(temp_model.from_map(k))
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResult(TeaModel):
    def __init__(
        self,
        generate_finished: bool = None,
        generate_level: str = None,
        generate_traceability: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceability = None,
        multimodal_search_result_list: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultList] = None,
        reason_text_generate: str = None,
        reference_list: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultReferenceList] = None,
        text_generate: str = None,
        text_generate_multimodal_media_list: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaList] = None,
    ):
        self.generate_finished = generate_finished
        self.generate_level = generate_level
        self.generate_traceability = generate_traceability
        self.multimodal_search_result_list = multimodal_search_result_list
        self.reason_text_generate = reason_text_generate
        self.reference_list = reference_list
        self.text_generate = text_generate
        self.text_generate_multimodal_media_list = text_generate_multimodal_media_list

    def validate(self):
        if self.generate_traceability:
            self.generate_traceability.validate()
        if self.multimodal_search_result_list:
            for k in self.multimodal_search_result_list:
                if k:
                    k.validate()
        if self.reference_list:
            for k in self.reference_list:
                if k:
                    k.validate()
        if self.text_generate_multimodal_media_list:
            for k in self.text_generate_multimodal_media_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.generate_finished is not None:
            result['GenerateFinished'] = self.generate_finished
        if self.generate_level is not None:
            result['GenerateLevel'] = self.generate_level
        if self.generate_traceability is not None:
            result['GenerateTraceability'] = self.generate_traceability.to_map()
        result['MultimodalSearchResultList'] = []
        if self.multimodal_search_result_list is not None:
            for k in self.multimodal_search_result_list:
                result['MultimodalSearchResultList'].append(k.to_map() if k else None)
        if self.reason_text_generate is not None:
            result['ReasonTextGenerate'] = self.reason_text_generate
        result['ReferenceList'] = []
        if self.reference_list is not None:
            for k in self.reference_list:
                result['ReferenceList'].append(k.to_map() if k else None)
        if self.text_generate is not None:
            result['TextGenerate'] = self.text_generate
        result['TextGenerateMultimodalMediaList'] = []
        if self.text_generate_multimodal_media_list is not None:
            for k in self.text_generate_multimodal_media_list:
                result['TextGenerateMultimodalMediaList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GenerateFinished') is not None:
            self.generate_finished = m.get('GenerateFinished')
        if m.get('GenerateLevel') is not None:
            self.generate_level = m.get('GenerateLevel')
        if m.get('GenerateTraceability') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceability()
            self.generate_traceability = temp_model.from_map(m['GenerateTraceability'])
        self.multimodal_search_result_list = []
        if m.get('MultimodalSearchResultList') is not None:
            for k in m.get('MultimodalSearchResultList'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultList()
                self.multimodal_search_result_list.append(temp_model.from_map(k))
        if m.get('ReasonTextGenerate') is not None:
            self.reason_text_generate = m.get('ReasonTextGenerate')
        self.reference_list = []
        if m.get('ReferenceList') is not None:
            for k in m.get('ReferenceList'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultReferenceList()
                self.reference_list.append(temp_model.from_map(k))
        if m.get('TextGenerate') is not None:
            self.text_generate = m.get('TextGenerate')
        self.text_generate_multimodal_media_list = []
        if m.get('TextGenerateMultimodalMediaList') is not None:
            for k in m.get('TextGenerateMultimodalMediaList'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaList()
                self.text_generate_multimodal_media_list.append(temp_model.from_map(k))
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResultSearchResult(TeaModel):
    def __init__(
        self,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        search_source: str = None,
        search_source_name: str = None,
        search_source_type: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.search_source = search_source
        self.search_source_name = search_source_name
        self.search_source_type = search_source_type
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.search_source is not None:
            result['SearchSource'] = self.search_source
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.search_source_type is not None:
            result['SearchSourceType'] = self.search_source_type
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('SearchSource') is not None:
            self.search_source = m.get('SearchSource')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('SearchSourceType') is not None:
            self.search_source_type = m.get('SearchSourceType')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResult(TeaModel):
    def __init__(
        self,
        current: int = None,
        search_result: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResultSearchResult] = None,
        size: int = None,
        total: int = None,
    ):
        self.current = current
        self.search_result = search_result
        self.size = size
        self.total = total

    def validate(self):
        if self.search_result:
            for k in self.search_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current is not None:
            result['Current'] = self.current
        result['SearchResult'] = []
        if self.search_result is not None:
            for k in self.search_result:
                result['SearchResult'].append(k.to_map() if k else None)
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Current') is not None:
            self.current = m.get('Current')
        self.search_result = []
        if m.get('SearchResult') is not None:
            for k in m.get('SearchResult'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResultSearchResult()
                self.search_result.append(temp_model.from_map(k))
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesGenerateCoordinate(TeaModel):
    def __init__(
        self,
        x: int = None,
        y: int = None,
        z: int = None,
    ):
        self.x = x
        self.y = y
        self.z = z

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.z is not None:
            result['Z'] = self.z
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('Z') is not None:
            self.z = m.get('Z')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesNewsCoordinate(TeaModel):
    def __init__(
        self,
        x: int = None,
        y: int = None,
        z: int = None,
    ):
        self.x = x
        self.y = y
        self.z = z

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.z is not None:
            result['Z'] = self.z
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('Z') is not None:
            self.z = m.get('Z')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinates(TeaModel):
    def __init__(
        self,
        generate_coordinate: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesGenerateCoordinate = None,
        news_coordinate: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesNewsCoordinate = None,
    ):
        self.generate_coordinate = generate_coordinate
        self.news_coordinate = news_coordinate

    def validate(self):
        if self.generate_coordinate:
            self.generate_coordinate.validate()
        if self.news_coordinate:
            self.news_coordinate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.generate_coordinate is not None:
            result['GenerateCoordinate'] = self.generate_coordinate.to_map()
        if self.news_coordinate is not None:
            result['NewsCoordinate'] = self.news_coordinate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GenerateCoordinate') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesGenerateCoordinate()
            self.generate_coordinate = temp_model.from_map(m['GenerateCoordinate'])
        if m.get('NewsCoordinate') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesNewsCoordinate()
            self.news_coordinate = temp_model.from_map(m['NewsCoordinate'])
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceability(TeaModel):
    def __init__(
        self,
        coordinates: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinates] = None,
        duplicate: float = None,
    ):
        self.coordinates = coordinates
        self.duplicate = duplicate

    def validate(self):
        if self.coordinates:
            for k in self.coordinates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Coordinates'] = []
        if self.coordinates is not None:
            for k in self.coordinates:
                result['Coordinates'].append(k.to_map() if k else None)
        if self.duplicate is not None:
            result['Duplicate'] = self.duplicate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.coordinates = []
        if m.get('Coordinates') is not None:
            for k in m.get('Coordinates'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinates()
                self.coordinates.append(temp_model.from_map(k))
        if m.get('Duplicate') is not None:
            self.duplicate = m.get('Duplicate')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultArticle(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        search_source_name: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.search_source_name = search_source_name
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultClipInfos(TeaModel):
    def __init__(
        self,
        from_: float = None,
        score: float = None,
        text: str = None,
        to: float = None,
        type: str = None,
    ):
        self.from_ = from_
        self.score = score
        self.text = text
        self.to = to
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.score is not None:
            result['Score'] = self.score
        if self.text is not None:
            result['Text'] = self.text
        if self.to is not None:
            result['To'] = self.to
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('To') is not None:
            self.to = m.get('To')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResult(TeaModel):
    def __init__(
        self,
        article: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultArticle = None,
        clip_infos: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultClipInfos] = None,
        file_url: str = None,
        media_id: str = None,
        media_type: str = None,
    ):
        self.article = article
        self.clip_infos = clip_infos
        self.file_url = file_url
        self.media_id = media_id
        self.media_type = media_type

    def validate(self):
        if self.article:
            self.article.validate()
        if self.clip_infos:
            for k in self.clip_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article is not None:
            result['Article'] = self.article.to_map()
        result['ClipInfos'] = []
        if self.clip_infos is not None:
            for k in self.clip_infos:
                result['ClipInfos'].append(k.to_map() if k else None)
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Article') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultArticle()
            self.article = temp_model.from_map(m['Article'])
        self.clip_infos = []
        if m.get('ClipInfos') is not None:
            for k in m.get('ClipInfos'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultClipInfos()
                self.clip_infos.append(temp_model.from_map(k))
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultList(TeaModel):
    def __init__(
        self,
        search_result: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResult] = None,
        timeline_date_str: str = None,
    ):
        self.search_result = search_result
        self.timeline_date_str = timeline_date_str

    def validate(self):
        if self.search_result:
            for k in self.search_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchResult'] = []
        if self.search_result is not None:
            for k in self.search_result:
                result['SearchResult'].append(k.to_map() if k else None)
        if self.timeline_date_str is not None:
            result['TimelineDateStr'] = self.timeline_date_str
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.search_result = []
        if m.get('SearchResult') is not None:
            for k in m.get('SearchResult'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResult()
                self.search_result.append(temp_model.from_map(k))
        if m.get('TimelineDateStr') is not None:
            self.timeline_date_str = m.get('TimelineDateStr')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultReferenceList(TeaModel):
    def __init__(
        self,
        chunks: List[str] = None,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        score: float = None,
        search_source: str = None,
        search_source_name: str = None,
        search_source_type: str = None,
        select: bool = None,
        source: str = None,
        summary: str = None,
        title: str = None,
        traceability_id: int = None,
        url: str = None,
    ):
        self.chunks = chunks
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.score = score
        self.search_source = search_source
        self.search_source_name = search_source_name
        self.search_source_type = search_source_type
        self.select = select
        self.source = source
        self.summary = summary
        self.title = title
        self.traceability_id = traceability_id
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chunks is not None:
            result['Chunks'] = self.chunks
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.score is not None:
            result['Score'] = self.score
        if self.search_source is not None:
            result['SearchSource'] = self.search_source
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.search_source_type is not None:
            result['SearchSourceType'] = self.search_source_type
        if self.select is not None:
            result['Select'] = self.select
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.traceability_id is not None:
            result['TraceabilityId'] = self.traceability_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Chunks') is not None:
            self.chunks = m.get('Chunks')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('SearchSource') is not None:
            self.search_source = m.get('SearchSource')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('SearchSourceType') is not None:
            self.search_source_type = m.get('SearchSourceType')
        if m.get('Select') is not None:
            self.select = m.get('Select')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TraceabilityId') is not None:
            self.traceability_id = m.get('TraceabilityId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaListArticle(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        search_source_name: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.search_source_name = search_source_name
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaList(TeaModel):
    def __init__(
        self,
        article: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaListArticle = None,
        file_url: str = None,
        media_id: str = None,
        media_type: str = None,
    ):
        self.article = article
        self.file_url = file_url
        self.media_id = media_id
        self.media_type = media_type

    def validate(self):
        if self.article:
            self.article.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article is not None:
            result['Article'] = self.article.to_map()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Article') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaListArticle()
            self.article = temp_model.from_map(m['Article'])
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaList(TeaModel):
    def __init__(
        self,
        end: int = None,
        multimodal_media_list: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaList] = None,
        start: int = None,
    ):
        self.end = end
        self.multimodal_media_list = multimodal_media_list
        self.start = start

    def validate(self):
        if self.multimodal_media_list:
            for k in self.multimodal_media_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        result['MultimodalMediaList'] = []
        if self.multimodal_media_list is not None:
            for k in self.multimodal_media_list:
                result['MultimodalMediaList'].append(k.to_map() if k else None)
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        self.multimodal_media_list = []
        if m.get('MultimodalMediaList') is not None:
            for k in m.get('MultimodalMediaList'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaList()
                self.multimodal_media_list.append(temp_model.from_map(k))
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResult(TeaModel):
    def __init__(
        self,
        generate_finished: bool = None,
        generate_traceability: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceability = None,
        multimodal_search_result_list: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultList] = None,
        reason_text_generate: str = None,
        reference_list: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultReferenceList] = None,
        text_generate: str = None,
        text_generate_multimodal_media_list: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaList] = None,
    ):
        self.generate_finished = generate_finished
        self.generate_traceability = generate_traceability
        self.multimodal_search_result_list = multimodal_search_result_list
        self.reason_text_generate = reason_text_generate
        self.reference_list = reference_list
        self.text_generate = text_generate
        self.text_generate_multimodal_media_list = text_generate_multimodal_media_list

    def validate(self):
        if self.generate_traceability:
            self.generate_traceability.validate()
        if self.multimodal_search_result_list:
            for k in self.multimodal_search_result_list:
                if k:
                    k.validate()
        if self.reference_list:
            for k in self.reference_list:
                if k:
                    k.validate()
        if self.text_generate_multimodal_media_list:
            for k in self.text_generate_multimodal_media_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.generate_finished is not None:
            result['GenerateFinished'] = self.generate_finished
        if self.generate_traceability is not None:
            result['GenerateTraceability'] = self.generate_traceability.to_map()
        result['MultimodalSearchResultList'] = []
        if self.multimodal_search_result_list is not None:
            for k in self.multimodal_search_result_list:
                result['MultimodalSearchResultList'].append(k.to_map() if k else None)
        if self.reason_text_generate is not None:
            result['ReasonTextGenerate'] = self.reason_text_generate
        result['ReferenceList'] = []
        if self.reference_list is not None:
            for k in self.reference_list:
                result['ReferenceList'].append(k.to_map() if k else None)
        if self.text_generate is not None:
            result['TextGenerate'] = self.text_generate
        result['TextGenerateMultimodalMediaList'] = []
        if self.text_generate_multimodal_media_list is not None:
            for k in self.text_generate_multimodal_media_list:
                result['TextGenerateMultimodalMediaList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GenerateFinished') is not None:
            self.generate_finished = m.get('GenerateFinished')
        if m.get('GenerateTraceability') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceability()
            self.generate_traceability = temp_model.from_map(m['GenerateTraceability'])
        self.multimodal_search_result_list = []
        if m.get('MultimodalSearchResultList') is not None:
            for k in m.get('MultimodalSearchResultList'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultList()
                self.multimodal_search_result_list.append(temp_model.from_map(k))
        if m.get('ReasonTextGenerate') is not None:
            self.reason_text_generate = m.get('ReasonTextGenerate')
        self.reference_list = []
        if m.get('ReferenceList') is not None:
            for k in m.get('ReferenceList'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultReferenceList()
                self.reference_list.append(temp_model.from_map(k))
        if m.get('TextGenerate') is not None:
            self.text_generate = m.get('TextGenerate')
        self.text_generate_multimodal_media_list = []
        if m.get('TextGenerateMultimodalMediaList') is not None:
            for k in m.get('TextGenerateMultimodalMediaList'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaList()
                self.text_generate_multimodal_media_list.append(temp_model.from_map(k))
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultArticle(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        search_source_name: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.search_source_name = search_source_name
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultClipInfos(TeaModel):
    def __init__(
        self,
        from_: float = None,
        score: float = None,
        text: str = None,
        to: float = None,
        type: str = None,
    ):
        self.from_ = from_
        self.score = score
        self.text = text
        self.to = to
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.score is not None:
            result['Score'] = self.score
        if self.text is not None:
            result['Text'] = self.text
        if self.to is not None:
            result['To'] = self.to
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('To') is not None:
            self.to = m.get('To')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResult(TeaModel):
    def __init__(
        self,
        article: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultArticle = None,
        clip_infos: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultClipInfos] = None,
        file_url: str = None,
        media_id: str = None,
    ):
        self.article = article
        self.clip_infos = clip_infos
        self.file_url = file_url
        self.media_id = media_id

    def validate(self):
        if self.article:
            self.article.validate()
        if self.clip_infos:
            for k in self.clip_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article is not None:
            result['Article'] = self.article.to_map()
        result['ClipInfos'] = []
        if self.clip_infos is not None:
            for k in self.clip_infos:
                result['ClipInfos'].append(k.to_map() if k else None)
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Article') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultArticle()
            self.article = temp_model.from_map(m['Article'])
        self.clip_infos = []
        if m.get('ClipInfos') is not None:
            for k in m.get('ClipInfos'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultClipInfos()
                self.clip_infos.append(temp_model.from_map(k))
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResult(TeaModel):
    def __init__(
        self,
        search_result: List[RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResult] = None,
    ):
        self.search_result = search_result

    def validate(self):
        if self.search_result:
            for k in self.search_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchResult'] = []
        if self.search_result is not None:
            for k in self.search_result:
                result['SearchResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.search_result = []
        if m.get('SearchResult') is not None:
            for k in m.get('SearchResult'):
                temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResult()
                self.search_result.append(temp_model.from_map(k))
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContent(TeaModel):
    def __init__(
        self,
        cluster_topic_result: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResult = None,
        excerpt_result: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResult = None,
        image_search_result: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResult = None,
        news_element_result: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResult = None,
        text_generate_result: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResult = None,
        text_search_result: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResult = None,
        timeline_result: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResult = None,
        video_search_result: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResult = None,
    ):
        self.cluster_topic_result = cluster_topic_result
        self.excerpt_result = excerpt_result
        self.image_search_result = image_search_result
        self.news_element_result = news_element_result
        self.text_generate_result = text_generate_result
        self.text_search_result = text_search_result
        self.timeline_result = timeline_result
        self.video_search_result = video_search_result

    def validate(self):
        if self.cluster_topic_result:
            self.cluster_topic_result.validate()
        if self.excerpt_result:
            self.excerpt_result.validate()
        if self.image_search_result:
            self.image_search_result.validate()
        if self.news_element_result:
            self.news_element_result.validate()
        if self.text_generate_result:
            self.text_generate_result.validate()
        if self.text_search_result:
            self.text_search_result.validate()
        if self.timeline_result:
            self.timeline_result.validate()
        if self.video_search_result:
            self.video_search_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_topic_result is not None:
            result['ClusterTopicResult'] = self.cluster_topic_result.to_map()
        if self.excerpt_result is not None:
            result['ExcerptResult'] = self.excerpt_result.to_map()
        if self.image_search_result is not None:
            result['ImageSearchResult'] = self.image_search_result.to_map()
        if self.news_element_result is not None:
            result['NewsElementResult'] = self.news_element_result.to_map()
        if self.text_generate_result is not None:
            result['TextGenerateResult'] = self.text_generate_result.to_map()
        if self.text_search_result is not None:
            result['TextSearchResult'] = self.text_search_result.to_map()
        if self.timeline_result is not None:
            result['TimelineResult'] = self.timeline_result.to_map()
        if self.video_search_result is not None:
            result['VideoSearchResult'] = self.video_search_result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterTopicResult') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResult()
            self.cluster_topic_result = temp_model.from_map(m['ClusterTopicResult'])
        if m.get('ExcerptResult') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResult()
            self.excerpt_result = temp_model.from_map(m['ExcerptResult'])
        if m.get('ImageSearchResult') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResult()
            self.image_search_result = temp_model.from_map(m['ImageSearchResult'])
        if m.get('NewsElementResult') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResult()
            self.news_element_result = temp_model.from_map(m['NewsElementResult'])
        if m.get('TextGenerateResult') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResult()
            self.text_generate_result = temp_model.from_map(m['TextGenerateResult'])
        if m.get('TextSearchResult') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResult()
            self.text_search_result = temp_model.from_map(m['TextSearchResult'])
        if m.get('TimelineResult') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResult()
            self.timeline_result = temp_model.from_map(m['TimelineResult'])
        if m.get('VideoSearchResult') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResult()
            self.video_search_result = temp_model.from_map(m['VideoSearchResult'])
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextTokenCalculate(TeaModel):
    def __init__(
        self,
        first_token_time: float = None,
        output_avg_time: float = None,
        search_time: float = None,
        time: float = None,
        total_tokens: int = None,
    ):
        self.first_token_time = first_token_time
        self.output_avg_time = output_avg_time
        self.search_time = search_time
        self.time = time
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_token_time is not None:
            result['FirstTokenTime'] = self.first_token_time
        if self.output_avg_time is not None:
            result['OutputAvgTime'] = self.output_avg_time
        if self.search_time is not None:
            result['SearchTime'] = self.search_time
        if self.time is not None:
            result['Time'] = self.time
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirstTokenTime') is not None:
            self.first_token_time = m.get('FirstTokenTime')
        if m.get('OutputAvgTime') is not None:
            self.output_avg_time = m.get('OutputAvgTime')
        if m.get('SearchTime') is not None:
            self.search_time = m.get('SearchTime')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContext(TeaModel):
    def __init__(
        self,
        ask_user: str = None,
        ask_user_keywords: List[str] = None,
        current_step: str = None,
        generated_content: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContent = None,
        model_id: str = None,
        next_step: str = None,
        recommend_search_query_list: List[str] = None,
        search_keywords: List[str] = None,
        search_query_list: List[str] = None,
        supplement_data_type: str = None,
        supplement_enable: bool = None,
        token_calculate: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextTokenCalculate = None,
    ):
        self.ask_user = ask_user
        self.ask_user_keywords = ask_user_keywords
        self.current_step = current_step
        self.generated_content = generated_content
        self.model_id = model_id
        self.next_step = next_step
        self.recommend_search_query_list = recommend_search_query_list
        self.search_keywords = search_keywords
        self.search_query_list = search_query_list
        self.supplement_data_type = supplement_data_type
        self.supplement_enable = supplement_enable
        self.token_calculate = token_calculate

    def validate(self):
        if self.generated_content:
            self.generated_content.validate()
        if self.token_calculate:
            self.token_calculate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ask_user is not None:
            result['AskUser'] = self.ask_user
        if self.ask_user_keywords is not None:
            result['AskUserKeywords'] = self.ask_user_keywords
        if self.current_step is not None:
            result['CurrentStep'] = self.current_step
        if self.generated_content is not None:
            result['GeneratedContent'] = self.generated_content.to_map()
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.next_step is not None:
            result['NextStep'] = self.next_step
        if self.recommend_search_query_list is not None:
            result['RecommendSearchQueryList'] = self.recommend_search_query_list
        if self.search_keywords is not None:
            result['SearchKeywords'] = self.search_keywords
        if self.search_query_list is not None:
            result['SearchQueryList'] = self.search_query_list
        if self.supplement_data_type is not None:
            result['SupplementDataType'] = self.supplement_data_type
        if self.supplement_enable is not None:
            result['SupplementEnable'] = self.supplement_enable
        if self.token_calculate is not None:
            result['TokenCalculate'] = self.token_calculate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AskUser') is not None:
            self.ask_user = m.get('AskUser')
        if m.get('AskUserKeywords') is not None:
            self.ask_user_keywords = m.get('AskUserKeywords')
        if m.get('CurrentStep') is not None:
            self.current_step = m.get('CurrentStep')
        if m.get('GeneratedContent') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContent()
            self.generated_content = temp_model.from_map(m['GeneratedContent'])
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('NextStep') is not None:
            self.next_step = m.get('NextStep')
        if m.get('RecommendSearchQueryList') is not None:
            self.recommend_search_query_list = m.get('RecommendSearchQueryList')
        if m.get('SearchKeywords') is not None:
            self.search_keywords = m.get('SearchKeywords')
        if m.get('SearchQueryList') is not None:
            self.search_query_list = m.get('SearchQueryList')
        if m.get('SupplementDataType') is not None:
            self.supplement_data_type = m.get('SupplementDataType')
        if m.get('SupplementEnable') is not None:
            self.supplement_enable = m.get('SupplementEnable')
        if m.get('TokenCalculate') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextTokenCalculate()
            self.token_calculate = temp_model.from_map(m['TokenCalculate'])
        return self


class RunSearchGenerationResponseBodyPayloadOutputAgentContext(TeaModel):
    def __init__(
        self,
        biz_context: RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContext = None,
    ):
        self.biz_context = biz_context

    def validate(self):
        if self.biz_context:
            self.biz_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_context is not None:
            result['BizContext'] = self.biz_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizContext') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContext()
            self.biz_context = temp_model.from_map(m['BizContext'])
        return self


class RunSearchGenerationResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        agent_context: RunSearchGenerationResponseBodyPayloadOutputAgentContext = None,
    ):
        self.agent_context = agent_context

    def validate(self):
        if self.agent_context:
            self.agent_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_context is not None:
            result['AgentContext'] = self.agent_context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentContext') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutputAgentContext()
            self.agent_context = temp_model.from_map(m['AgentContext'])
        return self


class RunSearchGenerationResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunSearchGenerationResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunSearchGenerationResponseBodyPayloadOutput = None,
        usage: RunSearchGenerationResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunSearchGenerationResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunSearchGenerationResponseBody(TeaModel):
    def __init__(
        self,
        header: RunSearchGenerationResponseBodyHeader = None,
        payload: RunSearchGenerationResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunSearchGenerationResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunSearchGenerationResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunSearchGenerationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunSearchGenerationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunSearchGenerationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunSearchSimilarArticlesRequestChatConfigSearchParamSearchSources(TeaModel):
    def __init__(
        self,
        code: str = None,
        dataset_name: str = None,
        name: str = None,
    ):
        self.code = code
        self.dataset_name = dataset_name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class RunSearchSimilarArticlesRequestChatConfigSearchParam(TeaModel):
    def __init__(
        self,
        search_sources: List[RunSearchSimilarArticlesRequestChatConfigSearchParamSearchSources] = None,
    ):
        self.search_sources = search_sources

    def validate(self):
        if self.search_sources:
            for k in self.search_sources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchSources'] = []
        if self.search_sources is not None:
            for k in self.search_sources:
                result['SearchSources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.search_sources = []
        if m.get('SearchSources') is not None:
            for k in m.get('SearchSources'):
                temp_model = RunSearchSimilarArticlesRequestChatConfigSearchParamSearchSources()
                self.search_sources.append(temp_model.from_map(k))
        return self


class RunSearchSimilarArticlesRequestChatConfig(TeaModel):
    def __init__(
        self,
        search_param: RunSearchSimilarArticlesRequestChatConfigSearchParam = None,
    ):
        self.search_param = search_param

    def validate(self):
        if self.search_param:
            self.search_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.search_param is not None:
            result['SearchParam'] = self.search_param.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SearchParam') is not None:
            temp_model = RunSearchSimilarArticlesRequestChatConfigSearchParam()
            self.search_param = temp_model.from_map(m['SearchParam'])
        return self


class RunSearchSimilarArticlesRequest(TeaModel):
    def __init__(
        self,
        chat_config: RunSearchSimilarArticlesRequestChatConfig = None,
        doc_type: str = None,
        title: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.chat_config = chat_config
        self.doc_type = doc_type
        self.title = title
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.chat_config:
            self.chat_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chat_config is not None:
            result['ChatConfig'] = self.chat_config.to_map()
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChatConfig') is not None:
            temp_model = RunSearchSimilarArticlesRequestChatConfig()
            self.chat_config = temp_model.from_map(m['ChatConfig'])
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunSearchSimilarArticlesShrinkRequest(TeaModel):
    def __init__(
        self,
        chat_config_shrink: str = None,
        doc_type: str = None,
        title: str = None,
        url: str = None,
        workspace_id: str = None,
    ):
        self.chat_config_shrink = chat_config_shrink
        self.doc_type = doc_type
        self.title = title
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chat_config_shrink is not None:
            result['ChatConfig'] = self.chat_config_shrink
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChatConfig') is not None:
            self.chat_config_shrink = m.get('ChatConfig')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunSearchSimilarArticlesResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        session_id: str = None,
        task_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.session_id = session_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class RunSearchSimilarArticlesResponseBodyPayloadOutputArticles(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        search_source_name: str = None,
        source: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.search_source_name = search_source_name
        self.source = source
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunSearchSimilarArticlesResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        articles: List[RunSearchSimilarArticlesResponseBodyPayloadOutputArticles] = None,
        text: str = None,
    ):
        self.articles = articles
        self.text = text

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = RunSearchSimilarArticlesResponseBodyPayloadOutputArticles()
                self.articles.append(temp_model.from_map(k))
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunSearchSimilarArticlesResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunSearchSimilarArticlesResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunSearchSimilarArticlesResponseBodyPayloadOutput = None,
        usage: RunSearchSimilarArticlesResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunSearchSimilarArticlesResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunSearchSimilarArticlesResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunSearchSimilarArticlesResponseBody(TeaModel):
    def __init__(
        self,
        header: RunSearchSimilarArticlesResponseBodyHeader = None,
        payload: RunSearchSimilarArticlesResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunSearchSimilarArticlesResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunSearchSimilarArticlesResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunSearchSimilarArticlesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunSearchSimilarArticlesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunSearchSimilarArticlesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunStepByStepWritingRequestReferenceDataArticles(TeaModel):
    def __init__(
        self,
        author: str = None,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        media_url: str = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        tag: str = None,
        title: str = None,
        url: str = None,
    ):
        self.author = author
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.media_url = media_url
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.tag = tag
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.media_url is not None:
            result['MediaUrl'] = self.media_url
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('MediaUrl') is not None:
            self.media_url = m.get('MediaUrl')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunStepByStepWritingRequestReferenceDataOutlinesArticles(TeaModel):
    def __init__(
        self,
        content: str = None,
        title: str = None,
        url: str = None,
    ):
        self.content = content
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunStepByStepWritingRequestReferenceDataOutlines(TeaModel):
    def __init__(
        self,
        articles: List[RunStepByStepWritingRequestReferenceDataOutlinesArticles] = None,
        outline: str = None,
    ):
        self.articles = articles
        self.outline = outline

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        if self.outline is not None:
            result['Outline'] = self.outline
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = RunStepByStepWritingRequestReferenceDataOutlinesArticles()
                self.articles.append(temp_model.from_map(k))
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        return self


class RunStepByStepWritingRequestReferenceData(TeaModel):
    def __init__(
        self,
        articles: List[RunStepByStepWritingRequestReferenceDataArticles] = None,
        mini_doc: List[str] = None,
        outlines: List[RunStepByStepWritingRequestReferenceDataOutlines] = None,
        summarization: List[str] = None,
    ):
        self.articles = articles
        self.mini_doc = mini_doc
        self.outlines = outlines
        self.summarization = summarization

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        if self.mini_doc is not None:
            result['MiniDoc'] = self.mini_doc
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.summarization is not None:
            result['Summarization'] = self.summarization
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = RunStepByStepWritingRequestReferenceDataArticles()
                self.articles.append(temp_model.from_map(k))
        if m.get('MiniDoc') is not None:
            self.mini_doc = m.get('MiniDoc')
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = RunStepByStepWritingRequestReferenceDataOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Summarization') is not None:
            self.summarization = m.get('Summarization')
        return self


class RunStepByStepWritingRequestWritingConfigPromptTag(TeaModel):
    def __init__(
        self,
        necessary_tips: str = None,
        position: str = None,
        reverse_words: str = None,
        theme: str = None,
    ):
        self.necessary_tips = necessary_tips
        self.position = position
        self.reverse_words = reverse_words
        self.theme = theme

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.necessary_tips is not None:
            result['NecessaryTips'] = self.necessary_tips
        if self.position is not None:
            result['Position'] = self.position
        if self.reverse_words is not None:
            result['ReverseWords'] = self.reverse_words
        if self.theme is not None:
            result['Theme'] = self.theme
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NecessaryTips') is not None:
            self.necessary_tips = m.get('NecessaryTips')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('ReverseWords') is not None:
            self.reverse_words = m.get('ReverseWords')
        if m.get('Theme') is not None:
            self.theme = m.get('Theme')
        return self


class RunStepByStepWritingRequestWritingConfigTags(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        tag: str = None,
    ):
        self.keyword = keyword
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class RunStepByStepWritingRequestWritingConfig(TeaModel):
    def __init__(
        self,
        domain: str = None,
        keywords: List[str] = None,
        prompt_tag: RunStepByStepWritingRequestWritingConfigPromptTag = None,
        scene: str = None,
        step: str = None,
        summary_return_type: str = None,
        tags: List[RunStepByStepWritingRequestWritingConfigTags] = None,
        use_search: bool = None,
    ):
        self.domain = domain
        self.keywords = keywords
        self.prompt_tag = prompt_tag
        self.scene = scene
        self.step = step
        self.summary_return_type = summary_return_type
        self.tags = tags
        self.use_search = use_search

    def validate(self):
        if self.prompt_tag:
            self.prompt_tag.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        if self.prompt_tag is not None:
            result['PromptTag'] = self.prompt_tag.to_map()
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.step is not None:
            result['Step'] = self.step
        if self.summary_return_type is not None:
            result['SummaryReturnType'] = self.summary_return_type
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.use_search is not None:
            result['UseSearch'] = self.use_search
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        if m.get('PromptTag') is not None:
            temp_model = RunStepByStepWritingRequestWritingConfigPromptTag()
            self.prompt_tag = temp_model.from_map(m['PromptTag'])
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        if m.get('SummaryReturnType') is not None:
            self.summary_return_type = m.get('SummaryReturnType')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = RunStepByStepWritingRequestWritingConfigTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('UseSearch') is not None:
            self.use_search = m.get('UseSearch')
        return self


class RunStepByStepWritingRequest(TeaModel):
    def __init__(
        self,
        origin_session_id: str = None,
        prompt: str = None,
        reference_data: RunStepByStepWritingRequestReferenceData = None,
        session_id: str = None,
        task_id: str = None,
        workspace_id: str = None,
        writing_config: RunStepByStepWritingRequestWritingConfig = None,
    ):
        self.origin_session_id = origin_session_id
        # This parameter is required.
        self.prompt = prompt
        self.reference_data = reference_data
        self.session_id = session_id
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id
        self.writing_config = writing_config

    def validate(self):
        if self.reference_data:
            self.reference_data.validate()
        if self.writing_config:
            self.writing_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.origin_session_id is not None:
            result['OriginSessionId'] = self.origin_session_id
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.reference_data is not None:
            result['ReferenceData'] = self.reference_data.to_map()
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.writing_config is not None:
            result['WritingConfig'] = self.writing_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OriginSessionId') is not None:
            self.origin_session_id = m.get('OriginSessionId')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ReferenceData') is not None:
            temp_model = RunStepByStepWritingRequestReferenceData()
            self.reference_data = temp_model.from_map(m['ReferenceData'])
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('WritingConfig') is not None:
            temp_model = RunStepByStepWritingRequestWritingConfig()
            self.writing_config = temp_model.from_map(m['WritingConfig'])
        return self


class RunStepByStepWritingShrinkRequest(TeaModel):
    def __init__(
        self,
        origin_session_id: str = None,
        prompt: str = None,
        reference_data_shrink: str = None,
        session_id: str = None,
        task_id: str = None,
        workspace_id: str = None,
        writing_config_shrink: str = None,
    ):
        self.origin_session_id = origin_session_id
        # This parameter is required.
        self.prompt = prompt
        self.reference_data_shrink = reference_data_shrink
        self.session_id = session_id
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id
        self.writing_config_shrink = writing_config_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.origin_session_id is not None:
            result['OriginSessionId'] = self.origin_session_id
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.reference_data_shrink is not None:
            result['ReferenceData'] = self.reference_data_shrink
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.writing_config_shrink is not None:
            result['WritingConfig'] = self.writing_config_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OriginSessionId') is not None:
            self.origin_session_id = m.get('OriginSessionId')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ReferenceData') is not None:
            self.reference_data_shrink = m.get('ReferenceData')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('WritingConfig') is not None:
            self.writing_config_shrink = m.get('WritingConfig')
        return self


class RunStepByStepWritingResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        origin_session_id: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.origin_session_id = origin_session_id
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.origin_session_id is not None:
            result['OriginSessionId'] = self.origin_session_id
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('OriginSessionId') is not None:
            self.origin_session_id = m.get('OriginSessionId')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunStepByStepWritingResponseBodyPayloadOutputArticles(TeaModel):
    def __init__(
        self,
        author: str = None,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        media_url: str = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        tag: str = None,
        title: str = None,
        url: str = None,
    ):
        self.author = author
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.media_url = media_url
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.tag = tag
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.media_url is not None:
            result['MediaUrl'] = self.media_url
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('MediaUrl') is not None:
            self.media_url = m.get('MediaUrl')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunStepByStepWritingResponseBodyPayloadOutputExtraOutput(TeaModel):
    def __init__(
        self,
        summarization: List[str] = None,
    ):
        self.summarization = summarization

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.summarization is not None:
            result['summarization'] = self.summarization
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('summarization') is not None:
            self.summarization = m.get('summarization')
        return self


class RunStepByStepWritingResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        articles: List[RunStepByStepWritingResponseBodyPayloadOutputArticles] = None,
        extra_output: RunStepByStepWritingResponseBodyPayloadOutputExtraOutput = None,
        mini_doc: List[str] = None,
        search_query: str = None,
        text: str = None,
    ):
        self.articles = articles
        self.extra_output = extra_output
        self.mini_doc = mini_doc
        self.search_query = search_query
        self.text = text

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()
        if self.extra_output:
            self.extra_output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        if self.extra_output is not None:
            result['ExtraOutput'] = self.extra_output.to_map()
        if self.mini_doc is not None:
            result['MiniDoc'] = self.mini_doc
        if self.search_query is not None:
            result['SearchQuery'] = self.search_query
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = RunStepByStepWritingResponseBodyPayloadOutputArticles()
                self.articles.append(temp_model.from_map(k))
        if m.get('ExtraOutput') is not None:
            temp_model = RunStepByStepWritingResponseBodyPayloadOutputExtraOutput()
            self.extra_output = temp_model.from_map(m['ExtraOutput'])
        if m.get('MiniDoc') is not None:
            self.mini_doc = m.get('MiniDoc')
        if m.get('SearchQuery') is not None:
            self.search_query = m.get('SearchQuery')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunStepByStepWritingResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunStepByStepWritingResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunStepByStepWritingResponseBodyPayloadOutput = None,
        usage: RunStepByStepWritingResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunStepByStepWritingResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunStepByStepWritingResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunStepByStepWritingResponseBody(TeaModel):
    def __init__(
        self,
        header: RunStepByStepWritingResponseBodyHeader = None,
        payload: RunStepByStepWritingResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunStepByStepWritingResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunStepByStepWritingResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunStepByStepWritingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunStepByStepWritingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunStepByStepWritingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunStyleFeatureAnalysisRequest(TeaModel):
    def __init__(
        self,
        contents: List[str] = None,
        material_ids: List[int] = None,
        workspace_id: str = None,
    ):
        self.contents = contents
        self.material_ids = material_ids
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contents is not None:
            result['Contents'] = self.contents
        if self.material_ids is not None:
            result['MaterialIds'] = self.material_ids
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Contents') is not None:
            self.contents = m.get('Contents')
        if m.get('MaterialIds') is not None:
            self.material_ids = m.get('MaterialIds')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunStyleFeatureAnalysisShrinkRequest(TeaModel):
    def __init__(
        self,
        contents_shrink: str = None,
        material_ids_shrink: str = None,
        workspace_id: str = None,
    ):
        self.contents_shrink = contents_shrink
        self.material_ids_shrink = material_ids_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contents_shrink is not None:
            result['Contents'] = self.contents_shrink
        if self.material_ids_shrink is not None:
            result['MaterialIds'] = self.material_ids_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Contents') is not None:
            self.contents_shrink = m.get('Contents')
        if m.get('MaterialIds') is not None:
            self.material_ids_shrink = m.get('MaterialIds')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunStyleFeatureAnalysisResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunStyleFeatureAnalysisResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunStyleFeatureAnalysisResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunStyleFeatureAnalysisResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunStyleFeatureAnalysisResponseBodyPayloadOutput = None,
        usage: RunStyleFeatureAnalysisResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunStyleFeatureAnalysisResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunStyleFeatureAnalysisResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunStyleFeatureAnalysisResponseBody(TeaModel):
    def __init__(
        self,
        end: bool = None,
        header: RunStyleFeatureAnalysisResponseBodyHeader = None,
        payload: RunStyleFeatureAnalysisResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.end = end
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Header') is not None:
            temp_model = RunStyleFeatureAnalysisResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunStyleFeatureAnalysisResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunStyleFeatureAnalysisResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunStyleFeatureAnalysisResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunStyleFeatureAnalysisResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunSummaryGenerateRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        prompt: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.content = content
        self.prompt = prompt
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunSummaryGenerateResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        event_info: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.event_info = event_info
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.event_info is not None:
            result['EventInfo'] = self.event_info
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventInfo') is not None:
            self.event_info = m.get('EventInfo')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunSummaryGenerateResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunSummaryGenerateResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunSummaryGenerateResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunSummaryGenerateResponseBodyPayloadOutput = None,
        usage: RunSummaryGenerateResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunSummaryGenerateResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunSummaryGenerateResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunSummaryGenerateResponseBody(TeaModel):
    def __init__(
        self,
        end: bool = None,
        header: RunSummaryGenerateResponseBodyHeader = None,
        payload: RunSummaryGenerateResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.end = end
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Header') is not None:
            temp_model = RunSummaryGenerateResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunSummaryGenerateResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunSummaryGenerateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunSummaryGenerateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunSummaryGenerateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunTextPolishingRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        prompt: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.content = content
        self.prompt = prompt
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunTextPolishingResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        origin_session_id: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.origin_session_id = origin_session_id
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.origin_session_id is not None:
            result['OriginSessionId'] = self.origin_session_id
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('OriginSessionId') is not None:
            self.origin_session_id = m.get('OriginSessionId')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunTextPolishingResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunTextPolishingResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunTextPolishingResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunTextPolishingResponseBodyPayloadOutput = None,
        usage: RunTextPolishingResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunTextPolishingResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunTextPolishingResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunTextPolishingResponseBody(TeaModel):
    def __init__(
        self,
        header: RunTextPolishingResponseBodyHeader = None,
        payload: RunTextPolishingResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunTextPolishingResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunTextPolishingResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunTextPolishingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunTextPolishingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunTextPolishingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunTitleGenerationRequestReferenceData(TeaModel):
    def __init__(
        self,
        contents: List[str] = None,
    ):
        # This parameter is required.
        self.contents = contents

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contents is not None:
            result['Contents'] = self.contents
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Contents') is not None:
            self.contents = m.get('Contents')
        return self


class RunTitleGenerationRequest(TeaModel):
    def __init__(
        self,
        deduplicated_titles: List[str] = None,
        reference_data: RunTitleGenerationRequestReferenceData = None,
        task_id: str = None,
        title_count: str = None,
        workspace_id: str = None,
    ):
        self.deduplicated_titles = deduplicated_titles
        # This parameter is required.
        self.reference_data = reference_data
        self.task_id = task_id
        self.title_count = title_count
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.reference_data:
            self.reference_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deduplicated_titles is not None:
            result['DeduplicatedTitles'] = self.deduplicated_titles
        if self.reference_data is not None:
            result['ReferenceData'] = self.reference_data.to_map()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.title_count is not None:
            result['TitleCount'] = self.title_count
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeduplicatedTitles') is not None:
            self.deduplicated_titles = m.get('DeduplicatedTitles')
        if m.get('ReferenceData') is not None:
            temp_model = RunTitleGenerationRequestReferenceData()
            self.reference_data = temp_model.from_map(m['ReferenceData'])
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TitleCount') is not None:
            self.title_count = m.get('TitleCount')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunTitleGenerationShrinkRequest(TeaModel):
    def __init__(
        self,
        deduplicated_titles_shrink: str = None,
        reference_data_shrink: str = None,
        task_id: str = None,
        title_count: str = None,
        workspace_id: str = None,
    ):
        self.deduplicated_titles_shrink = deduplicated_titles_shrink
        # This parameter is required.
        self.reference_data_shrink = reference_data_shrink
        self.task_id = task_id
        self.title_count = title_count
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deduplicated_titles_shrink is not None:
            result['DeduplicatedTitles'] = self.deduplicated_titles_shrink
        if self.reference_data_shrink is not None:
            result['ReferenceData'] = self.reference_data_shrink
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.title_count is not None:
            result['TitleCount'] = self.title_count
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeduplicatedTitles') is not None:
            self.deduplicated_titles_shrink = m.get('DeduplicatedTitles')
        if m.get('ReferenceData') is not None:
            self.reference_data_shrink = m.get('ReferenceData')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TitleCount') is not None:
            self.title_count = m.get('TitleCount')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunTitleGenerationResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        session_id: str = None,
        status_code: int = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.session_id = session_id
        self.status_code = status_code
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunTitleGenerationResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunTitleGenerationResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunTitleGenerationResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunTitleGenerationResponseBodyPayloadOutput = None,
        usage: RunTitleGenerationResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunTitleGenerationResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunTitleGenerationResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunTitleGenerationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        header: RunTitleGenerationResponseBodyHeader = None,
        http_status_code: str = None,
        message: str = None,
        payload: RunTitleGenerationResponseBodyPayload = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.header = header
        self.http_status_code = http_status_code
        self.message = message
        self.payload = payload
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Header') is not None:
            temp_model = RunTitleGenerationResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Payload') is not None:
            temp_model = RunTitleGenerationResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RunTitleGenerationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunTitleGenerationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunTitleGenerationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunTranslateGenerationRequestReferenceData(TeaModel):
    def __init__(
        self,
        contents: List[str] = None,
    ):
        # This parameter is required.
        self.contents = contents

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contents is not None:
            result['Contents'] = self.contents
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Contents') is not None:
            self.contents = m.get('Contents')
        return self


class RunTranslateGenerationRequest(TeaModel):
    def __init__(
        self,
        prompt: str = None,
        reference_data: RunTranslateGenerationRequestReferenceData = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.prompt = prompt
        # This parameter is required.
        self.reference_data = reference_data
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.reference_data:
            self.reference_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.reference_data is not None:
            result['ReferenceData'] = self.reference_data.to_map()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ReferenceData') is not None:
            temp_model = RunTranslateGenerationRequestReferenceData()
            self.reference_data = temp_model.from_map(m['ReferenceData'])
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunTranslateGenerationShrinkRequest(TeaModel):
    def __init__(
        self,
        prompt: str = None,
        reference_data_shrink: str = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.prompt = prompt
        # This parameter is required.
        self.reference_data_shrink = reference_data_shrink
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.reference_data_shrink is not None:
            result['ReferenceData'] = self.reference_data_shrink
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ReferenceData') is not None:
            self.reference_data_shrink = m.get('ReferenceData')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunTranslateGenerationResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunTranslateGenerationResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunTranslateGenerationResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunTranslateGenerationResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunTranslateGenerationResponseBodyPayloadOutput = None,
        usage: RunTranslateGenerationResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunTranslateGenerationResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunTranslateGenerationResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunTranslateGenerationResponseBody(TeaModel):
    def __init__(
        self,
        header: RunTranslateGenerationResponseBodyHeader = None,
        payload: RunTranslateGenerationResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunTranslateGenerationResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunTranslateGenerationResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunTranslateGenerationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunTranslateGenerationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunTranslateGenerationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunWriteToneGenerationRequestReferenceData(TeaModel):
    def __init__(
        self,
        contents: List[str] = None,
    ):
        # This parameter is required.
        self.contents = contents

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contents is not None:
            result['Contents'] = self.contents
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Contents') is not None:
            self.contents = m.get('Contents')
        return self


class RunWriteToneGenerationRequest(TeaModel):
    def __init__(
        self,
        prompt: str = None,
        reference_data: RunWriteToneGenerationRequestReferenceData = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.prompt = prompt
        # This parameter is required.
        self.reference_data = reference_data
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.reference_data:
            self.reference_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.reference_data is not None:
            result['ReferenceData'] = self.reference_data.to_map()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ReferenceData') is not None:
            temp_model = RunWriteToneGenerationRequestReferenceData()
            self.reference_data = temp_model.from_map(m['ReferenceData'])
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunWriteToneGenerationShrinkRequest(TeaModel):
    def __init__(
        self,
        prompt: str = None,
        reference_data_shrink: str = None,
        task_id: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.prompt = prompt
        # This parameter is required.
        self.reference_data_shrink = reference_data_shrink
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.reference_data_shrink is not None:
            result['ReferenceData'] = self.reference_data_shrink
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ReferenceData') is not None:
            self.reference_data_shrink = m.get('ReferenceData')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class RunWriteToneGenerationResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        session_id: str = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.session_id = session_id
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunWriteToneGenerationResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunWriteToneGenerationResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunWriteToneGenerationResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunWriteToneGenerationResponseBodyPayloadOutput = None,
        usage: RunWriteToneGenerationResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunWriteToneGenerationResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunWriteToneGenerationResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunWriteToneGenerationResponseBody(TeaModel):
    def __init__(
        self,
        header: RunWriteToneGenerationResponseBodyHeader = None,
        payload: RunWriteToneGenerationResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Header') is not None:
            temp_model = RunWriteToneGenerationResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunWriteToneGenerationResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunWriteToneGenerationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunWriteToneGenerationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunWriteToneGenerationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunWritingRequestReferenceDataArticles(TeaModel):
    def __init__(
        self,
        author: str = None,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        tag: str = None,
        title: str = None,
        url: str = None,
    ):
        self.author = author
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.tag = tag
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunWritingRequestReferenceData(TeaModel):
    def __init__(
        self,
        articles: List[RunWritingRequestReferenceDataArticles] = None,
    ):
        self.articles = articles

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = RunWritingRequestReferenceDataArticles()
                self.articles.append(temp_model.from_map(k))
        return self


class RunWritingRequestWritingConfigPromptTag(TeaModel):
    def __init__(
        self,
        necessary_tips: str = None,
        position: str = None,
        reverse_words: str = None,
        theme: str = None,
    ):
        self.necessary_tips = necessary_tips
        self.position = position
        self.reverse_words = reverse_words
        self.theme = theme

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.necessary_tips is not None:
            result['NecessaryTips'] = self.necessary_tips
        if self.position is not None:
            result['Position'] = self.position
        if self.reverse_words is not None:
            result['ReverseWords'] = self.reverse_words
        if self.theme is not None:
            result['Theme'] = self.theme
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NecessaryTips') is not None:
            self.necessary_tips = m.get('NecessaryTips')
        if m.get('Position') is not None:
            self.position = m.get('Position')
        if m.get('ReverseWords') is not None:
            self.reverse_words = m.get('ReverseWords')
        if m.get('Theme') is not None:
            self.theme = m.get('Theme')
        return self


class RunWritingRequestWritingConfigTags(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        tag: str = None,
    ):
        self.keyword = keyword
        self.tag = tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class RunWritingRequestWritingConfig(TeaModel):
    def __init__(
        self,
        domain: str = None,
        prompt_tag: RunWritingRequestWritingConfigPromptTag = None,
        tags: List[RunWritingRequestWritingConfigTags] = None,
        use_search: bool = None,
    ):
        self.domain = domain
        self.prompt_tag = prompt_tag
        self.tags = tags
        self.use_search = use_search

    def validate(self):
        if self.prompt_tag:
            self.prompt_tag.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.prompt_tag is not None:
            result['PromptTag'] = self.prompt_tag.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.use_search is not None:
            result['UseSearch'] = self.use_search
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('PromptTag') is not None:
            temp_model = RunWritingRequestWritingConfigPromptTag()
            self.prompt_tag = temp_model.from_map(m['PromptTag'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = RunWritingRequestWritingConfigTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('UseSearch') is not None:
            self.use_search = m.get('UseSearch')
        return self


class RunWritingRequest(TeaModel):
    def __init__(
        self,
        origin_session_id: str = None,
        prompt: str = None,
        reference_data: RunWritingRequestReferenceData = None,
        session_id: str = None,
        task_id: str = None,
        workspace_id: str = None,
        writing_config: RunWritingRequestWritingConfig = None,
    ):
        self.origin_session_id = origin_session_id
        # This parameter is required.
        self.prompt = prompt
        self.reference_data = reference_data
        self.session_id = session_id
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id
        self.writing_config = writing_config

    def validate(self):
        if self.reference_data:
            self.reference_data.validate()
        if self.writing_config:
            self.writing_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.origin_session_id is not None:
            result['OriginSessionId'] = self.origin_session_id
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.reference_data is not None:
            result['ReferenceData'] = self.reference_data.to_map()
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.writing_config is not None:
            result['WritingConfig'] = self.writing_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OriginSessionId') is not None:
            self.origin_session_id = m.get('OriginSessionId')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ReferenceData') is not None:
            temp_model = RunWritingRequestReferenceData()
            self.reference_data = temp_model.from_map(m['ReferenceData'])
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('WritingConfig') is not None:
            temp_model = RunWritingRequestWritingConfig()
            self.writing_config = temp_model.from_map(m['WritingConfig'])
        return self


class RunWritingShrinkRequest(TeaModel):
    def __init__(
        self,
        origin_session_id: str = None,
        prompt: str = None,
        reference_data_shrink: str = None,
        session_id: str = None,
        task_id: str = None,
        workspace_id: str = None,
        writing_config_shrink: str = None,
    ):
        self.origin_session_id = origin_session_id
        # This parameter is required.
        self.prompt = prompt
        self.reference_data_shrink = reference_data_shrink
        self.session_id = session_id
        self.task_id = task_id
        # This parameter is required.
        self.workspace_id = workspace_id
        self.writing_config_shrink = writing_config_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.origin_session_id is not None:
            result['OriginSessionId'] = self.origin_session_id
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.reference_data_shrink is not None:
            result['ReferenceData'] = self.reference_data_shrink
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.writing_config_shrink is not None:
            result['WritingConfig'] = self.writing_config_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OriginSessionId') is not None:
            self.origin_session_id = m.get('OriginSessionId')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('ReferenceData') is not None:
            self.reference_data_shrink = m.get('ReferenceData')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('WritingConfig') is not None:
            self.writing_config_shrink = m.get('WritingConfig')
        return self


class RunWritingResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        origin_session_id: str = None,
        session_id: str = None,
        status_code: int = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.origin_session_id = origin_session_id
        self.session_id = session_id
        self.status_code = status_code
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.origin_session_id is not None:
            result['OriginSessionId'] = self.origin_session_id
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('OriginSessionId') is not None:
            self.origin_session_id = m.get('OriginSessionId')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunWritingResponseBodyPayloadOutputArticles(TeaModel):
    def __init__(
        self,
        author: str = None,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        tag: str = None,
        title: str = None,
        url: str = None,
    ):
        self.author = author
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.tag = tag
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunWritingResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        articles: List[RunWritingResponseBodyPayloadOutputArticles] = None,
        mini_doc: List[str] = None,
        search_query: str = None,
        text: str = None,
    ):
        self.articles = articles
        self.mini_doc = mini_doc
        self.search_query = search_query
        self.text = text

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        if self.mini_doc is not None:
            result['MiniDoc'] = self.mini_doc
        if self.search_query is not None:
            result['SearchQuery'] = self.search_query
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = RunWritingResponseBodyPayloadOutputArticles()
                self.articles.append(temp_model.from_map(k))
        if m.get('MiniDoc') is not None:
            self.mini_doc = m.get('MiniDoc')
        if m.get('SearchQuery') is not None:
            self.search_query = m.get('SearchQuery')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunWritingResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        token_map: Dict[str, int] = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.token_map = token_map
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.token_map is not None:
            result['TokenMap'] = self.token_map
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TokenMap') is not None:
            self.token_map = m.get('TokenMap')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunWritingResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunWritingResponseBodyPayloadOutput = None,
        usage: RunWritingResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunWritingResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunWritingResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunWritingResponseBody(TeaModel):
    def __init__(
        self,
        end: bool = None,
        header: RunWritingResponseBodyHeader = None,
        payload: RunWritingResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.end = end
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Header') is not None:
            temp_model = RunWritingResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunWritingResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunWritingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunWritingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunWritingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunWritingV2RequestArticles(TeaModel):
    def __init__(
        self,
        content: str = None,
        pub_time: str = None,
        search_source_name: str = None,
        source: str = None,
        title: str = None,
        url: str = None,
    ):
        self.content = content
        self.pub_time = pub_time
        self.search_source_name = search_source_name
        self.source = source
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.source is not None:
            result['Source'] = self.source
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunWritingV2RequestMiniDocs(TeaModel):
    def __init__(
        self,
        content: str = None,
        index: str = None,
        star: bool = None,
    ):
        self.content = content
        self.index = index
        self.star = star

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.index is not None:
            result['Index'] = self.index
        if self.star is not None:
            result['Star'] = self.star
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Star') is not None:
            self.star = m.get('Star')
        return self


class RunWritingV2RequestOutlinesArticles(TeaModel):
    def __init__(
        self,
        content: str = None,
        title: str = None,
        url: str = None,
    ):
        self.content = content
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunWritingV2RequestOutlines(TeaModel):
    def __init__(
        self,
        articles: List[RunWritingV2RequestOutlinesArticles] = None,
        outline: str = None,
    ):
        self.articles = articles
        self.outline = outline

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        if self.outline is not None:
            result['Outline'] = self.outline
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = RunWritingV2RequestOutlinesArticles()
                self.articles.append(temp_model.from_map(k))
        if m.get('Outline') is not None:
            self.outline = m.get('Outline')
        return self


class RunWritingV2RequestSearchSources(TeaModel):
    def __init__(
        self,
        code: str = None,
        dataset_name: str = None,
        name: str = None,
    ):
        self.code = code
        self.dataset_name = dataset_name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class RunWritingV2RequestSummarization(TeaModel):
    def __init__(
        self,
        event: str = None,
        message: str = None,
    ):
        self.event = event
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event is not None:
            result['Event'] = self.event
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class RunWritingV2Request(TeaModel):
    def __init__(
        self,
        articles: List[RunWritingV2RequestArticles] = None,
        distribute_writing: bool = None,
        gc_number_size: int = None,
        gc_number_size_tag: str = None,
        keywords: List[str] = None,
        language: str = None,
        mini_docs: List[RunWritingV2RequestMiniDocs] = None,
        outlines: List[RunWritingV2RequestOutlines] = None,
        prompt: str = None,
        prompt_mode: str = None,
        search_sources: List[RunWritingV2RequestSearchSources] = None,
        session_id: str = None,
        step: str = None,
        summarization: List[RunWritingV2RequestSummarization] = None,
        task_id: str = None,
        use_search: bool = None,
        workspace_id: str = None,
        writing_params: Dict[str, str] = None,
        writing_scene: str = None,
        writing_style: str = None,
    ):
        self.articles = articles
        self.distribute_writing = distribute_writing
        self.gc_number_size = gc_number_size
        self.gc_number_size_tag = gc_number_size_tag
        self.keywords = keywords
        self.language = language
        self.mini_docs = mini_docs
        self.outlines = outlines
        self.prompt = prompt
        self.prompt_mode = prompt_mode
        self.search_sources = search_sources
        self.session_id = session_id
        self.step = step
        self.summarization = summarization
        self.task_id = task_id
        self.use_search = use_search
        # This parameter is required.
        self.workspace_id = workspace_id
        self.writing_params = writing_params
        self.writing_scene = writing_scene
        self.writing_style = writing_style

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()
        if self.mini_docs:
            for k in self.mini_docs:
                if k:
                    k.validate()
        if self.outlines:
            for k in self.outlines:
                if k:
                    k.validate()
        if self.search_sources:
            for k in self.search_sources:
                if k:
                    k.validate()
        if self.summarization:
            for k in self.summarization:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        if self.distribute_writing is not None:
            result['DistributeWriting'] = self.distribute_writing
        if self.gc_number_size is not None:
            result['GcNumberSize'] = self.gc_number_size
        if self.gc_number_size_tag is not None:
            result['GcNumberSizeTag'] = self.gc_number_size_tag
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        if self.language is not None:
            result['Language'] = self.language
        result['MiniDocs'] = []
        if self.mini_docs is not None:
            for k in self.mini_docs:
                result['MiniDocs'].append(k.to_map() if k else None)
        result['Outlines'] = []
        if self.outlines is not None:
            for k in self.outlines:
                result['Outlines'].append(k.to_map() if k else None)
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.prompt_mode is not None:
            result['PromptMode'] = self.prompt_mode
        result['SearchSources'] = []
        if self.search_sources is not None:
            for k in self.search_sources:
                result['SearchSources'].append(k.to_map() if k else None)
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.step is not None:
            result['Step'] = self.step
        result['Summarization'] = []
        if self.summarization is not None:
            for k in self.summarization:
                result['Summarization'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.use_search is not None:
            result['UseSearch'] = self.use_search
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.writing_params is not None:
            result['WritingParams'] = self.writing_params
        if self.writing_scene is not None:
            result['WritingScene'] = self.writing_scene
        if self.writing_style is not None:
            result['WritingStyle'] = self.writing_style
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = RunWritingV2RequestArticles()
                self.articles.append(temp_model.from_map(k))
        if m.get('DistributeWriting') is not None:
            self.distribute_writing = m.get('DistributeWriting')
        if m.get('GcNumberSize') is not None:
            self.gc_number_size = m.get('GcNumberSize')
        if m.get('GcNumberSizeTag') is not None:
            self.gc_number_size_tag = m.get('GcNumberSizeTag')
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        self.mini_docs = []
        if m.get('MiniDocs') is not None:
            for k in m.get('MiniDocs'):
                temp_model = RunWritingV2RequestMiniDocs()
                self.mini_docs.append(temp_model.from_map(k))
        self.outlines = []
        if m.get('Outlines') is not None:
            for k in m.get('Outlines'):
                temp_model = RunWritingV2RequestOutlines()
                self.outlines.append(temp_model.from_map(k))
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('PromptMode') is not None:
            self.prompt_mode = m.get('PromptMode')
        self.search_sources = []
        if m.get('SearchSources') is not None:
            for k in m.get('SearchSources'):
                temp_model = RunWritingV2RequestSearchSources()
                self.search_sources.append(temp_model.from_map(k))
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        self.summarization = []
        if m.get('Summarization') is not None:
            for k in m.get('Summarization'):
                temp_model = RunWritingV2RequestSummarization()
                self.summarization.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('UseSearch') is not None:
            self.use_search = m.get('UseSearch')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('WritingParams') is not None:
            self.writing_params = m.get('WritingParams')
        if m.get('WritingScene') is not None:
            self.writing_scene = m.get('WritingScene')
        if m.get('WritingStyle') is not None:
            self.writing_style = m.get('WritingStyle')
        return self


class RunWritingV2ShrinkRequest(TeaModel):
    def __init__(
        self,
        articles_shrink: str = None,
        distribute_writing: bool = None,
        gc_number_size: int = None,
        gc_number_size_tag: str = None,
        keywords_shrink: str = None,
        language: str = None,
        mini_docs_shrink: str = None,
        outlines_shrink: str = None,
        prompt: str = None,
        prompt_mode: str = None,
        search_sources_shrink: str = None,
        session_id: str = None,
        step: str = None,
        summarization_shrink: str = None,
        task_id: str = None,
        use_search: bool = None,
        workspace_id: str = None,
        writing_params_shrink: str = None,
        writing_scene: str = None,
        writing_style: str = None,
    ):
        self.articles_shrink = articles_shrink
        self.distribute_writing = distribute_writing
        self.gc_number_size = gc_number_size
        self.gc_number_size_tag = gc_number_size_tag
        self.keywords_shrink = keywords_shrink
        self.language = language
        self.mini_docs_shrink = mini_docs_shrink
        self.outlines_shrink = outlines_shrink
        self.prompt = prompt
        self.prompt_mode = prompt_mode
        self.search_sources_shrink = search_sources_shrink
        self.session_id = session_id
        self.step = step
        self.summarization_shrink = summarization_shrink
        self.task_id = task_id
        self.use_search = use_search
        # This parameter is required.
        self.workspace_id = workspace_id
        self.writing_params_shrink = writing_params_shrink
        self.writing_scene = writing_scene
        self.writing_style = writing_style

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.articles_shrink is not None:
            result['Articles'] = self.articles_shrink
        if self.distribute_writing is not None:
            result['DistributeWriting'] = self.distribute_writing
        if self.gc_number_size is not None:
            result['GcNumberSize'] = self.gc_number_size
        if self.gc_number_size_tag is not None:
            result['GcNumberSizeTag'] = self.gc_number_size_tag
        if self.keywords_shrink is not None:
            result['Keywords'] = self.keywords_shrink
        if self.language is not None:
            result['Language'] = self.language
        if self.mini_docs_shrink is not None:
            result['MiniDocs'] = self.mini_docs_shrink
        if self.outlines_shrink is not None:
            result['Outlines'] = self.outlines_shrink
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.prompt_mode is not None:
            result['PromptMode'] = self.prompt_mode
        if self.search_sources_shrink is not None:
            result['SearchSources'] = self.search_sources_shrink
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.step is not None:
            result['Step'] = self.step
        if self.summarization_shrink is not None:
            result['Summarization'] = self.summarization_shrink
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.use_search is not None:
            result['UseSearch'] = self.use_search
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.writing_params_shrink is not None:
            result['WritingParams'] = self.writing_params_shrink
        if self.writing_scene is not None:
            result['WritingScene'] = self.writing_scene
        if self.writing_style is not None:
            result['WritingStyle'] = self.writing_style
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Articles') is not None:
            self.articles_shrink = m.get('Articles')
        if m.get('DistributeWriting') is not None:
            self.distribute_writing = m.get('DistributeWriting')
        if m.get('GcNumberSize') is not None:
            self.gc_number_size = m.get('GcNumberSize')
        if m.get('GcNumberSizeTag') is not None:
            self.gc_number_size_tag = m.get('GcNumberSizeTag')
        if m.get('Keywords') is not None:
            self.keywords_shrink = m.get('Keywords')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('MiniDocs') is not None:
            self.mini_docs_shrink = m.get('MiniDocs')
        if m.get('Outlines') is not None:
            self.outlines_shrink = m.get('Outlines')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('PromptMode') is not None:
            self.prompt_mode = m.get('PromptMode')
        if m.get('SearchSources') is not None:
            self.search_sources_shrink = m.get('SearchSources')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        if m.get('Summarization') is not None:
            self.summarization_shrink = m.get('Summarization')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('UseSearch') is not None:
            self.use_search = m.get('UseSearch')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('WritingParams') is not None:
            self.writing_params_shrink = m.get('WritingParams')
        if m.get('WritingScene') is not None:
            self.writing_scene = m.get('WritingScene')
        if m.get('WritingStyle') is not None:
            self.writing_style = m.get('WritingStyle')
        return self


class RunWritingV2ResponseBodyHeader(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        event: str = None,
        origin_session_id: str = None,
        session_id: str = None,
        status_code: int = None,
        task_id: str = None,
        trace_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.event = event
        self.origin_session_id = origin_session_id
        self.session_id = session_id
        self.status_code = status_code
        self.task_id = task_id
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.event is not None:
            result['Event'] = self.event
        if self.origin_session_id is not None:
            result['OriginSessionId'] = self.origin_session_id
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.status_code is not None:
            result['StatusCode'] = self.status_code
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('OriginSessionId') is not None:
            self.origin_session_id = m.get('OriginSessionId')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('StatusCode') is not None:
            self.status_code = m.get('StatusCode')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class RunWritingV2ResponseBodyPayloadOutputArticles(TeaModel):
    def __init__(
        self,
        author: str = None,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        tag: str = None,
        title: str = None,
        url: str = None,
    ):
        self.author = author
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.tag = tag
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RunWritingV2ResponseBodyPayloadOutput(TeaModel):
    def __init__(
        self,
        articles: List[RunWritingV2ResponseBodyPayloadOutputArticles] = None,
        mini_doc: List[str] = None,
        search_query: str = None,
        text: str = None,
    ):
        self.articles = articles
        self.mini_doc = mini_doc
        self.search_query = search_query
        self.text = text

    def validate(self):
        if self.articles:
            for k in self.articles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Articles'] = []
        if self.articles is not None:
            for k in self.articles:
                result['Articles'].append(k.to_map() if k else None)
        if self.mini_doc is not None:
            result['MiniDoc'] = self.mini_doc
        if self.search_query is not None:
            result['SearchQuery'] = self.search_query
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.articles = []
        if m.get('Articles') is not None:
            for k in m.get('Articles'):
                temp_model = RunWritingV2ResponseBodyPayloadOutputArticles()
                self.articles.append(temp_model.from_map(k))
        if m.get('MiniDoc') is not None:
            self.mini_doc = m.get('MiniDoc')
        if m.get('SearchQuery') is not None:
            self.search_query = m.get('SearchQuery')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class RunWritingV2ResponseBodyPayloadUsage(TeaModel):
    def __init__(
        self,
        input_tokens: int = None,
        output_tokens: int = None,
        token_map: Dict[str, int] = None,
        total_tokens: int = None,
    ):
        self.input_tokens = input_tokens
        self.output_tokens = output_tokens
        self.token_map = token_map
        self.total_tokens = total_tokens

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_tokens is not None:
            result['InputTokens'] = self.input_tokens
        if self.output_tokens is not None:
            result['OutputTokens'] = self.output_tokens
        if self.token_map is not None:
            result['TokenMap'] = self.token_map
        if self.total_tokens is not None:
            result['TotalTokens'] = self.total_tokens
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InputTokens') is not None:
            self.input_tokens = m.get('InputTokens')
        if m.get('OutputTokens') is not None:
            self.output_tokens = m.get('OutputTokens')
        if m.get('TokenMap') is not None:
            self.token_map = m.get('TokenMap')
        if m.get('TotalTokens') is not None:
            self.total_tokens = m.get('TotalTokens')
        return self


class RunWritingV2ResponseBodyPayload(TeaModel):
    def __init__(
        self,
        output: RunWritingV2ResponseBodyPayloadOutput = None,
        usage: RunWritingV2ResponseBodyPayloadUsage = None,
    ):
        self.output = output
        self.usage = usage

    def validate(self):
        if self.output:
            self.output.validate()
        if self.usage:
            self.usage.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = RunWritingV2ResponseBodyPayloadOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('Usage') is not None:
            temp_model = RunWritingV2ResponseBodyPayloadUsage()
            self.usage = temp_model.from_map(m['Usage'])
        return self


class RunWritingV2ResponseBody(TeaModel):
    def __init__(
        self,
        end: bool = None,
        header: RunWritingV2ResponseBodyHeader = None,
        payload: RunWritingV2ResponseBodyPayload = None,
        request_id: str = None,
    ):
        self.end = end
        self.header = header
        self.payload = payload
        self.request_id = request_id

    def validate(self):
        if self.header:
            self.header.validate()
        if self.payload:
            self.payload.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.header is not None:
            result['Header'] = self.header.to_map()
        if self.payload is not None:
            result['Payload'] = self.payload.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Header') is not None:
            temp_model = RunWritingV2ResponseBodyHeader()
            self.header = temp_model.from_map(m['Header'])
        if m.get('Payload') is not None:
            temp_model = RunWritingV2ResponseBodyPayload()
            self.payload = temp_model.from_map(m['Payload'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunWritingV2Response(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RunWritingV2ResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunWritingV2ResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveCustomTextRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        commodity_code: str = None,
        content: str = None,
        title: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.commodity_code = commodity_code
        self.content = content
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.content is not None:
            result['Content'] = self.content
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class SaveCustomTextResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: int = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SaveCustomTextResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveCustomTextResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveCustomTextResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveDataSourceOrderConfigRequestUserConfigDataSourceList(TeaModel):
    def __init__(
        self,
        code: str = None,
        enable: bool = None,
        name: str = None,
        number: int = None,
        type: str = None,
    ):
        # This parameter is required.
        self.code = code
        self.enable = enable
        self.name = name
        # This parameter is required.
        self.number = number
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.name is not None:
            result['Name'] = self.name
        if self.number is not None:
            result['Number'] = self.number
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Number') is not None:
            self.number = m.get('Number')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SaveDataSourceOrderConfigRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        generate_technology: str = None,
        product_code: str = None,
        user_config_data_source_list: List[SaveDataSourceOrderConfigRequestUserConfigDataSourceList] = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.generate_technology = generate_technology
        # This parameter is required.
        self.product_code = product_code
        # This parameter is required.
        self.user_config_data_source_list = user_config_data_source_list

    def validate(self):
        if self.user_config_data_source_list:
            for k in self.user_config_data_source_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.generate_technology is not None:
            result['GenerateTechnology'] = self.generate_technology
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        result['UserConfigDataSourceList'] = []
        if self.user_config_data_source_list is not None:
            for k in self.user_config_data_source_list:
                result['UserConfigDataSourceList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('GenerateTechnology') is not None:
            self.generate_technology = m.get('GenerateTechnology')
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        self.user_config_data_source_list = []
        if m.get('UserConfigDataSourceList') is not None:
            for k in m.get('UserConfigDataSourceList'):
                temp_model = SaveDataSourceOrderConfigRequestUserConfigDataSourceList()
                self.user_config_data_source_list.append(temp_model.from_map(k))
        return self


class SaveDataSourceOrderConfigShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        generate_technology: str = None,
        product_code: str = None,
        user_config_data_source_list_shrink: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.generate_technology = generate_technology
        # This parameter is required.
        self.product_code = product_code
        # This parameter is required.
        self.user_config_data_source_list_shrink = user_config_data_source_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.generate_technology is not None:
            result['GenerateTechnology'] = self.generate_technology
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        if self.user_config_data_source_list_shrink is not None:
            result['UserConfigDataSourceList'] = self.user_config_data_source_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('GenerateTechnology') is not None:
            self.generate_technology = m.get('GenerateTechnology')
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        if m.get('UserConfigDataSourceList') is not None:
            self.user_config_data_source_list_shrink = m.get('UserConfigDataSourceList')
        return self


class SaveDataSourceOrderConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SaveDataSourceOrderConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveDataSourceOrderConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveDataSourceOrderConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveMaterialDocumentRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        author: str = None,
        both_save_private_and_share: bool = None,
        doc_keywords: List[str] = None,
        doc_type: str = None,
        external_url: str = None,
        html_content: str = None,
        pub_time: str = None,
        share_attr: int = None,
        src_from: str = None,
        summary: str = None,
        text_content: str = None,
        title: str = None,
        url: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.author = author
        self.both_save_private_and_share = both_save_private_and_share
        self.doc_keywords = doc_keywords
        # This parameter is required.
        self.doc_type = doc_type
        self.external_url = external_url
        self.html_content = html_content
        self.pub_time = pub_time
        self.share_attr = share_attr
        self.src_from = src_from
        self.summary = summary
        self.text_content = text_content
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.author is not None:
            result['Author'] = self.author
        if self.both_save_private_and_share is not None:
            result['BothSavePrivateAndShare'] = self.both_save_private_and_share
        if self.doc_keywords is not None:
            result['DocKeywords'] = self.doc_keywords
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.external_url is not None:
            result['ExternalUrl'] = self.external_url
        if self.html_content is not None:
            result['HtmlContent'] = self.html_content
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.share_attr is not None:
            result['ShareAttr'] = self.share_attr
        if self.src_from is not None:
            result['SrcFrom'] = self.src_from
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.text_content is not None:
            result['TextContent'] = self.text_content
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('BothSavePrivateAndShare') is not None:
            self.both_save_private_and_share = m.get('BothSavePrivateAndShare')
        if m.get('DocKeywords') is not None:
            self.doc_keywords = m.get('DocKeywords')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('ExternalUrl') is not None:
            self.external_url = m.get('ExternalUrl')
        if m.get('HtmlContent') is not None:
            self.html_content = m.get('HtmlContent')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('ShareAttr') is not None:
            self.share_attr = m.get('ShareAttr')
        if m.get('SrcFrom') is not None:
            self.src_from = m.get('SrcFrom')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TextContent') is not None:
            self.text_content = m.get('TextContent')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class SaveMaterialDocumentShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        author: str = None,
        both_save_private_and_share: bool = None,
        doc_keywords_shrink: str = None,
        doc_type: str = None,
        external_url: str = None,
        html_content: str = None,
        pub_time: str = None,
        share_attr: int = None,
        src_from: str = None,
        summary: str = None,
        text_content: str = None,
        title: str = None,
        url: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.author = author
        self.both_save_private_and_share = both_save_private_and_share
        self.doc_keywords_shrink = doc_keywords_shrink
        # This parameter is required.
        self.doc_type = doc_type
        self.external_url = external_url
        self.html_content = html_content
        self.pub_time = pub_time
        self.share_attr = share_attr
        self.src_from = src_from
        self.summary = summary
        self.text_content = text_content
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.author is not None:
            result['Author'] = self.author
        if self.both_save_private_and_share is not None:
            result['BothSavePrivateAndShare'] = self.both_save_private_and_share
        if self.doc_keywords_shrink is not None:
            result['DocKeywords'] = self.doc_keywords_shrink
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.external_url is not None:
            result['ExternalUrl'] = self.external_url
        if self.html_content is not None:
            result['HtmlContent'] = self.html_content
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.share_attr is not None:
            result['ShareAttr'] = self.share_attr
        if self.src_from is not None:
            result['SrcFrom'] = self.src_from
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.text_content is not None:
            result['TextContent'] = self.text_content
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('BothSavePrivateAndShare') is not None:
            self.both_save_private_and_share = m.get('BothSavePrivateAndShare')
        if m.get('DocKeywords') is not None:
            self.doc_keywords_shrink = m.get('DocKeywords')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('ExternalUrl') is not None:
            self.external_url = m.get('ExternalUrl')
        if m.get('HtmlContent') is not None:
            self.html_content = m.get('HtmlContent')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('ShareAttr') is not None:
            self.share_attr = m.get('ShareAttr')
        if m.get('SrcFrom') is not None:
            self.src_from = m.get('SrcFrom')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TextContent') is not None:
            self.text_content = m.get('TextContent')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class SaveMaterialDocumentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: int = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SaveMaterialDocumentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveMaterialDocumentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveMaterialDocumentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveStyleLearningResultRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        aigc_result: str = None,
        custom_text_id_list: List[int] = None,
        material_id_list: List[int] = None,
        rewrite_result: str = None,
        style_name: str = None,
        task_id: str = None,
    ):
        self.agent_key = agent_key
        self.aigc_result = aigc_result
        self.custom_text_id_list = custom_text_id_list
        self.material_id_list = material_id_list
        self.rewrite_result = rewrite_result
        self.style_name = style_name
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.aigc_result is not None:
            result['AigcResult'] = self.aigc_result
        if self.custom_text_id_list is not None:
            result['CustomTextIdList'] = self.custom_text_id_list
        if self.material_id_list is not None:
            result['MaterialIdList'] = self.material_id_list
        if self.rewrite_result is not None:
            result['RewriteResult'] = self.rewrite_result
        if self.style_name is not None:
            result['StyleName'] = self.style_name
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('AigcResult') is not None:
            self.aigc_result = m.get('AigcResult')
        if m.get('CustomTextIdList') is not None:
            self.custom_text_id_list = m.get('CustomTextIdList')
        if m.get('MaterialIdList') is not None:
            self.material_id_list = m.get('MaterialIdList')
        if m.get('RewriteResult') is not None:
            self.rewrite_result = m.get('RewriteResult')
        if m.get('StyleName') is not None:
            self.style_name = m.get('StyleName')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SaveStyleLearningResultShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        aigc_result: str = None,
        custom_text_id_list_shrink: str = None,
        material_id_list_shrink: str = None,
        rewrite_result: str = None,
        style_name: str = None,
        task_id: str = None,
    ):
        self.agent_key = agent_key
        self.aigc_result = aigc_result
        self.custom_text_id_list_shrink = custom_text_id_list_shrink
        self.material_id_list_shrink = material_id_list_shrink
        self.rewrite_result = rewrite_result
        self.style_name = style_name
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.aigc_result is not None:
            result['AigcResult'] = self.aigc_result
        if self.custom_text_id_list_shrink is not None:
            result['CustomTextIdList'] = self.custom_text_id_list_shrink
        if self.material_id_list_shrink is not None:
            result['MaterialIdList'] = self.material_id_list_shrink
        if self.rewrite_result is not None:
            result['RewriteResult'] = self.rewrite_result
        if self.style_name is not None:
            result['StyleName'] = self.style_name
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('AigcResult') is not None:
            self.aigc_result = m.get('AigcResult')
        if m.get('CustomTextIdList') is not None:
            self.custom_text_id_list_shrink = m.get('CustomTextIdList')
        if m.get('MaterialIdList') is not None:
            self.material_id_list_shrink = m.get('MaterialIdList')
        if m.get('RewriteResult') is not None:
            self.rewrite_result = m.get('RewriteResult')
        if m.get('StyleName') is not None:
            self.style_name = m.get('StyleName')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SaveStyleLearningResultResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SaveStyleLearningResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveStyleLearningResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveStyleLearningResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchDatasetDocumentsRequest(TeaModel):
    def __init__(
        self,
        dataset_id: int = None,
        dataset_name: str = None,
        extend_1: str = None,
        include_content: bool = None,
        page_size: str = None,
        query: str = None,
        workspace_id: str = None,
    ):
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        self.extend_1 = extend_1
        self.include_content = include_content
        self.page_size = page_size
        # This parameter is required.
        self.query = query
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.extend_1 is not None:
            result['Extend1'] = self.extend_1
        if self.include_content is not None:
            result['IncludeContent'] = self.include_content
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query is not None:
            result['Query'] = self.query
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('Extend1') is not None:
            self.extend_1 = m.get('Extend1')
        if m.get('IncludeContent') is not None:
            self.include_content = m.get('IncludeContent')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SearchDatasetDocumentsResponseBodyDataDocuments(TeaModel):
    def __init__(
        self,
        content: str = None,
        doc_id: str = None,
        doc_uuid: str = None,
        pub_time: str = None,
        source_from: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.content = content
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.pub_time = pub_time
        self.source_from = source_from
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source_from is not None:
            result['SourceFrom'] = self.source_from
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('SourceFrom') is not None:
            self.source_from = m.get('SourceFrom')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class SearchDatasetDocumentsResponseBodyData(TeaModel):
    def __init__(
        self,
        documents: List[SearchDatasetDocumentsResponseBodyDataDocuments] = None,
    ):
        self.documents = documents

    def validate(self):
        if self.documents:
            for k in self.documents:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Documents'] = []
        if self.documents is not None:
            for k in self.documents:
                result['Documents'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.documents = []
        if m.get('Documents') is not None:
            for k in m.get('Documents'):
                temp_model = SearchDatasetDocumentsResponseBodyDataDocuments()
                self.documents.append(temp_model.from_map(k))
        return self


class SearchDatasetDocumentsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SearchDatasetDocumentsResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SearchDatasetDocumentsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SearchDatasetDocumentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchDatasetDocumentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchDatasetDocumentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchNewsRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        filter_not_null: bool = None,
        include_content: bool = None,
        page: int = None,
        page_size: int = None,
        query: str = None,
        search_sources: List[str] = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.filter_not_null = filter_not_null
        self.include_content = include_content
        self.page = page
        self.page_size = page_size
        self.query = query
        self.search_sources = search_sources

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.filter_not_null is not None:
            result['FilterNotNull'] = self.filter_not_null
        if self.include_content is not None:
            result['IncludeContent'] = self.include_content
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query is not None:
            result['Query'] = self.query
        if self.search_sources is not None:
            result['SearchSources'] = self.search_sources
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('FilterNotNull') is not None:
            self.filter_not_null = m.get('FilterNotNull')
        if m.get('IncludeContent') is not None:
            self.include_content = m.get('IncludeContent')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('SearchSources') is not None:
            self.search_sources = m.get('SearchSources')
        return self


class SearchNewsShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        filter_not_null: bool = None,
        include_content: bool = None,
        page: int = None,
        page_size: int = None,
        query: str = None,
        search_sources_shrink: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.filter_not_null = filter_not_null
        self.include_content = include_content
        self.page = page
        self.page_size = page_size
        self.query = query
        self.search_sources_shrink = search_sources_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.filter_not_null is not None:
            result['FilterNotNull'] = self.filter_not_null
        if self.include_content is not None:
            result['IncludeContent'] = self.include_content
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query is not None:
            result['Query'] = self.query
        if self.search_sources_shrink is not None:
            result['SearchSources'] = self.search_sources_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('FilterNotNull') is not None:
            self.filter_not_null = m.get('FilterNotNull')
        if m.get('IncludeContent') is not None:
            self.include_content = m.get('IncludeContent')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('SearchSources') is not None:
            self.search_sources_shrink = m.get('SearchSources')
        return self


class SearchNewsResponseBodyData(TeaModel):
    def __init__(
        self,
        author: str = None,
        content: str = None,
        doc_uuid: str = None,
        image_urls: List[str] = None,
        pub_time: str = None,
        search_source: str = None,
        search_source_name: str = None,
        source: str = None,
        summary: str = None,
        tag: str = None,
        title: str = None,
        update_time: str = None,
        url: str = None,
    ):
        self.author = author
        self.content = content
        self.doc_uuid = doc_uuid
        self.image_urls = image_urls
        self.pub_time = pub_time
        self.search_source = search_source
        self.search_source_name = search_source_name
        self.source = source
        self.summary = summary
        self.tag = tag
        self.title = title
        self.update_time = update_time
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.image_urls is not None:
            result['ImageUrls'] = self.image_urls
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.search_source is not None:
            result['SearchSource'] = self.search_source
        if self.search_source_name is not None:
            result['SearchSourceName'] = self.search_source_name
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('ImageUrls') is not None:
            self.image_urls = m.get('ImageUrls')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('SearchSource') is not None:
            self.search_source = m.get('SearchSource')
        if m.get('SearchSourceName') is not None:
            self.search_source_name = m.get('SearchSourceName')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class SearchNewsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current: int = None,
        data: List[SearchNewsResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        size: int = None,
        success: bool = None,
        total: int = None,
    ):
        self.code = code
        self.current = current
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.size = size
        self.success = success
        self.total = total

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current is not None:
            result['Current'] = self.current
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.size is not None:
            result['Size'] = self.size
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = SearchNewsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class SearchNewsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchNewsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchNewsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitAsyncTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        task_code: str = None,
        task_execute_time: str = None,
        task_name: str = None,
        task_param: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.task_code = task_code
        self.task_execute_time = task_execute_time
        self.task_name = task_name
        self.task_param = task_param

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.task_code is not None:
            result['TaskCode'] = self.task_code
        if self.task_execute_time is not None:
            result['TaskExecuteTime'] = self.task_execute_time
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_param is not None:
            result['TaskParam'] = self.task_param
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('TaskCode') is not None:
            self.task_code = m.get('TaskCode')
        if m.get('TaskExecuteTime') is not None:
            self.task_execute_time = m.get('TaskExecuteTime')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskParam') is not None:
            self.task_param = m.get('TaskParam')
        return self


class SubmitAsyncTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        task_intermediate_result: Any = None,
        task_name: str = None,
    ):
        self.task_id = task_id
        self.task_intermediate_result = task_intermediate_result
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_intermediate_result is not None:
            result['TaskIntermediateResult'] = self.task_intermediate_result
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskIntermediateResult') is not None:
            self.task_intermediate_result = m.get('TaskIntermediateResult')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class SubmitAsyncTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SubmitAsyncTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SubmitAsyncTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitAsyncTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitAsyncTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitAsyncTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitAuditNoteRequest(TeaModel):
    def __init__(
        self,
        file_key: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.file_key = file_key
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitAuditNoteResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitAuditNoteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitAuditNoteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitAuditNoteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitAuditTaskRequest(TeaModel):
    def __init__(
        self,
        article_id: str = None,
        content: str = None,
        html_content: str = None,
        title: str = None,
        workspace_id: str = None,
    ):
        self.article_id = article_id
        self.content = content
        self.html_content = html_content
        self.title = title
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.article_id is not None:
            result['ArticleId'] = self.article_id
        if self.content is not None:
            result['Content'] = self.content
        if self.html_content is not None:
            result['HtmlContent'] = self.html_content
        if self.title is not None:
            result['Title'] = self.title
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArticleId') is not None:
            self.article_id = m.get('ArticleId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('HtmlContent') is not None:
            self.html_content = m.get('HtmlContent')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitAuditTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SubmitAuditTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SubmitAuditTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SubmitAuditTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitAuditTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitAuditTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitAuditTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForCustomSummaryStyleConfig(TeaModel):
    def __init__(
        self,
        summary_image_count: int = None,
        summary_model: str = None,
        summary_prompt: str = None,
    ):
        self.summary_image_count = summary_image_count
        self.summary_model = summary_model
        self.summary_prompt = summary_prompt

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.summary_image_count is not None:
            result['SummaryImageCount'] = self.summary_image_count
        if self.summary_model is not None:
            result['SummaryModel'] = self.summary_model
        if self.summary_prompt is not None:
            result['SummaryPrompt'] = self.summary_prompt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SummaryImageCount') is not None:
            self.summary_image_count = m.get('SummaryImageCount')
        if m.get('SummaryModel') is not None:
            self.summary_model = m.get('SummaryModel')
        if m.get('SummaryPrompt') is not None:
            self.summary_prompt = m.get('SummaryPrompt')
        return self


class SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfigCustomHotValueWeights(TeaModel):
    def __init__(
        self,
        dimension: str = None,
        dimension_name: str = None,
        weight: int = None,
    ):
        self.dimension = dimension
        self.dimension_name = dimension_name
        self.weight = weight

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dimension is not None:
            result['Dimension'] = self.dimension
        if self.dimension_name is not None:
            result['DimensionName'] = self.dimension_name
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dimension') is not None:
            self.dimension = m.get('Dimension')
        if m.get('DimensionName') is not None:
            self.dimension_name = m.get('DimensionName')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfig(TeaModel):
    def __init__(
        self,
        categories: List[str] = None,
        custom_hot_value_weights: List[SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfigCustomHotValueWeights] = None,
        topic_count: int = None,
    ):
        self.categories = categories
        self.custom_hot_value_weights = custom_hot_value_weights
        self.topic_count = topic_count

    def validate(self):
        if self.custom_hot_value_weights:
            for k in self.custom_hot_value_weights:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.categories is not None:
            result['Categories'] = self.categories
        result['CustomHotValueWeights'] = []
        if self.custom_hot_value_weights is not None:
            for k in self.custom_hot_value_weights:
                result['CustomHotValueWeights'].append(k.to_map() if k else None)
        if self.topic_count is not None:
            result['TopicCount'] = self.topic_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Categories') is not None:
            self.categories = m.get('Categories')
        self.custom_hot_value_weights = []
        if m.get('CustomHotValueWeights') is not None:
            for k in m.get('CustomHotValueWeights'):
                temp_model = SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfigCustomHotValueWeights()
                self.custom_hot_value_weights.append(temp_model.from_map(k))
        if m.get('TopicCount') is not None:
            self.topic_count = m.get('TopicCount')
        return self


class SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfig(TeaModel):
    def __init__(
        self,
        step_for_custom_summary_style_config: SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForCustomSummaryStyleConfig = None,
        step_for_news_broadcast_content_config: SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfig = None,
    ):
        # This parameter is required.
        self.step_for_custom_summary_style_config = step_for_custom_summary_style_config
        # This parameter is required.
        self.step_for_news_broadcast_content_config = step_for_news_broadcast_content_config

    def validate(self):
        if self.step_for_custom_summary_style_config:
            self.step_for_custom_summary_style_config.validate()
        if self.step_for_news_broadcast_content_config:
            self.step_for_news_broadcast_content_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.step_for_custom_summary_style_config is not None:
            result['StepForCustomSummaryStyleConfig'] = self.step_for_custom_summary_style_config.to_map()
        if self.step_for_news_broadcast_content_config is not None:
            result['StepForNewsBroadcastContentConfig'] = self.step_for_news_broadcast_content_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('StepForCustomSummaryStyleConfig') is not None:
            temp_model = SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForCustomSummaryStyleConfig()
            self.step_for_custom_summary_style_config = temp_model.from_map(m['StepForCustomSummaryStyleConfig'])
        if m.get('StepForNewsBroadcastContentConfig') is not None:
            temp_model = SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfig()
            self.step_for_news_broadcast_content_config = temp_model.from_map(m['StepForNewsBroadcastContentConfig'])
        return self


class SubmitCustomHotTopicBroadcastJobRequest(TeaModel):
    def __init__(
        self,
        hot_topic_broadcast_config: SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfig = None,
        hot_topic_version: str = None,
        topics: List[str] = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.hot_topic_broadcast_config = hot_topic_broadcast_config
        self.hot_topic_version = hot_topic_version
        self.topics = topics
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.hot_topic_broadcast_config:
            self.hot_topic_broadcast_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hot_topic_broadcast_config is not None:
            result['HotTopicBroadcastConfig'] = self.hot_topic_broadcast_config.to_map()
        if self.hot_topic_version is not None:
            result['HotTopicVersion'] = self.hot_topic_version
        if self.topics is not None:
            result['Topics'] = self.topics
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HotTopicBroadcastConfig') is not None:
            temp_model = SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfig()
            self.hot_topic_broadcast_config = temp_model.from_map(m['HotTopicBroadcastConfig'])
        if m.get('HotTopicVersion') is not None:
            self.hot_topic_version = m.get('HotTopicVersion')
        if m.get('Topics') is not None:
            self.topics = m.get('Topics')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitCustomHotTopicBroadcastJobShrinkRequest(TeaModel):
    def __init__(
        self,
        hot_topic_broadcast_config_shrink: str = None,
        hot_topic_version: str = None,
        topics_shrink: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.hot_topic_broadcast_config_shrink = hot_topic_broadcast_config_shrink
        self.hot_topic_version = hot_topic_version
        self.topics_shrink = topics_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hot_topic_broadcast_config_shrink is not None:
            result['HotTopicBroadcastConfig'] = self.hot_topic_broadcast_config_shrink
        if self.hot_topic_version is not None:
            result['HotTopicVersion'] = self.hot_topic_version
        if self.topics_shrink is not None:
            result['Topics'] = self.topics_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HotTopicBroadcastConfig') is not None:
            self.hot_topic_broadcast_config_shrink = m.get('HotTopicBroadcastConfig')
        if m.get('HotTopicVersion') is not None:
            self.hot_topic_version = m.get('HotTopicVersion')
        if m.get('Topics') is not None:
            self.topics_shrink = m.get('Topics')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitCustomHotTopicBroadcastJobResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SubmitCustomHotTopicBroadcastJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SubmitCustomHotTopicBroadcastJobResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SubmitCustomHotTopicBroadcastJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitCustomHotTopicBroadcastJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitCustomHotTopicBroadcastJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitCustomHotTopicBroadcastJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitCustomSourceTopicAnalysisRequestNewsComments(TeaModel):
    def __init__(
        self,
        text: str = None,
    ):
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class SubmitCustomSourceTopicAnalysisRequestNews(TeaModel):
    def __init__(
        self,
        comments: List[SubmitCustomSourceTopicAnalysisRequestNewsComments] = None,
        content: str = None,
        pub_time: str = None,
        source: str = None,
        title: str = None,
        url: str = None,
    ):
        self.comments = comments
        self.content = content
        self.pub_time = pub_time
        self.source = source
        self.title = title
        self.url = url

    def validate(self):
        if self.comments:
            for k in self.comments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Comments'] = []
        if self.comments is not None:
            for k in self.comments:
                result['Comments'].append(k.to_map() if k else None)
        if self.content is not None:
            result['Content'] = self.content
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.comments = []
        if m.get('Comments') is not None:
            for k in m.get('Comments'):
                temp_model = SubmitCustomSourceTopicAnalysisRequestNewsComments()
                self.comments.append(temp_model.from_map(k))
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class SubmitCustomSourceTopicAnalysisRequest(TeaModel):
    def __init__(
        self,
        analysis_types: List[str] = None,
        file_type: str = None,
        file_url: str = None,
        max_topic_size: int = None,
        news: List[SubmitCustomSourceTopicAnalysisRequestNews] = None,
        workspace_id: str = None,
    ):
        self.analysis_types = analysis_types
        self.file_type = file_type
        self.file_url = file_url
        self.max_topic_size = max_topic_size
        self.news = news
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.news:
            for k in self.news:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_types is not None:
            result['AnalysisTypes'] = self.analysis_types
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.max_topic_size is not None:
            result['MaxTopicSize'] = self.max_topic_size
        result['News'] = []
        if self.news is not None:
            for k in self.news:
                result['News'].append(k.to_map() if k else None)
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisTypes') is not None:
            self.analysis_types = m.get('AnalysisTypes')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MaxTopicSize') is not None:
            self.max_topic_size = m.get('MaxTopicSize')
        self.news = []
        if m.get('News') is not None:
            for k in m.get('News'):
                temp_model = SubmitCustomSourceTopicAnalysisRequestNews()
                self.news.append(temp_model.from_map(k))
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitCustomSourceTopicAnalysisShrinkRequest(TeaModel):
    def __init__(
        self,
        analysis_types_shrink: str = None,
        file_type: str = None,
        file_url: str = None,
        max_topic_size: int = None,
        news_shrink: str = None,
        workspace_id: str = None,
    ):
        self.analysis_types_shrink = analysis_types_shrink
        self.file_type = file_type
        self.file_url = file_url
        self.max_topic_size = max_topic_size
        self.news_shrink = news_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.analysis_types_shrink is not None:
            result['AnalysisTypes'] = self.analysis_types_shrink
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.max_topic_size is not None:
            result['MaxTopicSize'] = self.max_topic_size
        if self.news_shrink is not None:
            result['News'] = self.news_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AnalysisTypes') is not None:
            self.analysis_types_shrink = m.get('AnalysisTypes')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('MaxTopicSize') is not None:
            self.max_topic_size = m.get('MaxTopicSize')
        if m.get('News') is not None:
            self.news_shrink = m.get('News')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitCustomSourceTopicAnalysisResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        task_name: str = None,
    ):
        self.task_id = task_id
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class SubmitCustomSourceTopicAnalysisResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SubmitCustomSourceTopicAnalysisResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SubmitCustomSourceTopicAnalysisResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitCustomSourceTopicAnalysisResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitCustomSourceTopicAnalysisResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitCustomSourceTopicAnalysisResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequestDocuments(TeaModel):
    def __init__(
        self,
        author: str = None,
        content: str = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.author = author
        # This parameter is required.
        self.content = content
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        if self.content is not None:
            result['Content'] = self.content
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        documents: List[SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequestDocuments] = None,
        prompt: str = None,
        topic: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.documents = documents
        # This parameter is required.
        self.prompt = prompt
        self.topic = topic

    def validate(self):
        if self.documents:
            for k in self.documents:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        result['Documents'] = []
        if self.documents is not None:
            for k in self.documents:
                result['Documents'].append(k.to_map() if k else None)
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        self.documents = []
        if m.get('Documents') is not None:
            for k in m.get('Documents'):
                temp_model = SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequestDocuments()
                self.documents.append(temp_model.from_map(k))
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class SubmitCustomTopicSelectionPerspectiveAnalysisTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        documents_shrink: str = None,
        prompt: str = None,
        topic: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.documents_shrink = documents_shrink
        # This parameter is required.
        self.prompt = prompt
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.documents_shrink is not None:
            result['Documents'] = self.documents_shrink
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Documents') is not None:
            self.documents_shrink = m.get('Documents')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitDocClusterTaskRequestDocuments(TeaModel):
    def __init__(
        self,
        content: str = None,
        doc_id: str = None,
        title: str = None,
    ):
        # This parameter is required.
        self.content = content
        self.doc_id = doc_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class SubmitDocClusterTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        documents: List[SubmitDocClusterTaskRequestDocuments] = None,
        summary_length: int = None,
        title_length: int = None,
        topic_count: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.documents = documents
        self.summary_length = summary_length
        self.title_length = title_length
        self.topic_count = topic_count

    def validate(self):
        if self.documents:
            for k in self.documents:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        result['Documents'] = []
        if self.documents is not None:
            for k in self.documents:
                result['Documents'].append(k.to_map() if k else None)
        if self.summary_length is not None:
            result['SummaryLength'] = self.summary_length
        if self.title_length is not None:
            result['TitleLength'] = self.title_length
        if self.topic_count is not None:
            result['TopicCount'] = self.topic_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        self.documents = []
        if m.get('Documents') is not None:
            for k in m.get('Documents'):
                temp_model = SubmitDocClusterTaskRequestDocuments()
                self.documents.append(temp_model.from_map(k))
        if m.get('SummaryLength') is not None:
            self.summary_length = m.get('SummaryLength')
        if m.get('TitleLength') is not None:
            self.title_length = m.get('TitleLength')
        if m.get('TopicCount') is not None:
            self.topic_count = m.get('TopicCount')
        return self


class SubmitDocClusterTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        documents_shrink: str = None,
        summary_length: int = None,
        title_length: int = None,
        topic_count: int = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        # This parameter is required.
        self.documents_shrink = documents_shrink
        self.summary_length = summary_length
        self.title_length = title_length
        self.topic_count = topic_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.documents_shrink is not None:
            result['Documents'] = self.documents_shrink
        if self.summary_length is not None:
            result['SummaryLength'] = self.summary_length
        if self.title_length is not None:
            result['TitleLength'] = self.title_length
        if self.topic_count is not None:
            result['TopicCount'] = self.topic_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Documents') is not None:
            self.documents_shrink = m.get('Documents')
        if m.get('SummaryLength') is not None:
            self.summary_length = m.get('SummaryLength')
        if m.get('TitleLength') is not None:
            self.title_length = m.get('TitleLength')
        if m.get('TopicCount') is not None:
            self.topic_count = m.get('TopicCount')
        return self


class SubmitDocClusterTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SubmitDocClusterTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SubmitDocClusterTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SubmitDocClusterTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitDocClusterTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitDocClusterTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitDocClusterTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitEnterpriseVocAnalysisTaskRequestContentTags(TeaModel):
    def __init__(
        self,
        tag_define_prompt: str = None,
        tag_name: str = None,
        tag_task_type: str = None,
        tag_value_define_prompt: str = None,
    ):
        self.tag_define_prompt = tag_define_prompt
        self.tag_name = tag_name
        self.tag_task_type = tag_task_type
        self.tag_value_define_prompt = tag_value_define_prompt

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_define_prompt is not None:
            result['TagDefinePrompt'] = self.tag_define_prompt
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.tag_task_type is not None:
            result['TagTaskType'] = self.tag_task_type
        if self.tag_value_define_prompt is not None:
            result['TagValueDefinePrompt'] = self.tag_value_define_prompt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagDefinePrompt') is not None:
            self.tag_define_prompt = m.get('TagDefinePrompt')
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('TagTaskType') is not None:
            self.tag_task_type = m.get('TagTaskType')
        if m.get('TagValueDefinePrompt') is not None:
            self.tag_value_define_prompt = m.get('TagValueDefinePrompt')
        return self


class SubmitEnterpriseVocAnalysisTaskRequestContents(TeaModel):
    def __init__(
        self,
        extra_info: str = None,
        text: str = None,
    ):
        self.extra_info = extra_info
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info
        if self.text is not None:
            result['Text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExtraInfo') is not None:
            self.extra_info = m.get('ExtraInfo')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        return self


class SubmitEnterpriseVocAnalysisTaskRequestFilterTags(TeaModel):
    def __init__(
        self,
        tag_define_prompt: str = None,
        tag_name: str = None,
        tag_type: str = None,
        tag_value_define_prompt: str = None,
    ):
        self.tag_define_prompt = tag_define_prompt
        self.tag_name = tag_name
        self.tag_type = tag_type
        self.tag_value_define_prompt = tag_value_define_prompt

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_define_prompt is not None:
            result['TagDefinePrompt'] = self.tag_define_prompt
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.tag_type is not None:
            result['TagType'] = self.tag_type
        if self.tag_value_define_prompt is not None:
            result['TagValueDefinePrompt'] = self.tag_value_define_prompt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagDefinePrompt') is not None:
            self.tag_define_prompt = m.get('TagDefinePrompt')
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('TagType') is not None:
            self.tag_type = m.get('TagType')
        if m.get('TagValueDefinePrompt') is not None:
            self.tag_value_define_prompt = m.get('TagValueDefinePrompt')
        return self


class SubmitEnterpriseVocAnalysisTaskRequest(TeaModel):
    def __init__(
        self,
        api_key: str = None,
        content_tags: List[SubmitEnterpriseVocAnalysisTaskRequestContentTags] = None,
        contents: List[SubmitEnterpriseVocAnalysisTaskRequestContents] = None,
        file_key: str = None,
        filter_tags: List[SubmitEnterpriseVocAnalysisTaskRequestFilterTags] = None,
        material_type: str = None,
        model_id: str = None,
        positive_sample: str = None,
        positive_sample_file_key: str = None,
        task_type: str = None,
        workspace_id: str = None,
    ):
        self.api_key = api_key
        # This parameter is required.
        self.content_tags = content_tags
        self.contents = contents
        self.file_key = file_key
        self.filter_tags = filter_tags
        self.material_type = material_type
        # This parameter is required.
        self.model_id = model_id
        self.positive_sample = positive_sample
        self.positive_sample_file_key = positive_sample_file_key
        self.task_type = task_type
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.content_tags:
            for k in self.content_tags:
                if k:
                    k.validate()
        if self.contents:
            for k in self.contents:
                if k:
                    k.validate()
        if self.filter_tags:
            for k in self.filter_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_key is not None:
            result['ApiKey'] = self.api_key
        result['ContentTags'] = []
        if self.content_tags is not None:
            for k in self.content_tags:
                result['ContentTags'].append(k.to_map() if k else None)
        result['Contents'] = []
        if self.contents is not None:
            for k in self.contents:
                result['Contents'].append(k.to_map() if k else None)
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        result['FilterTags'] = []
        if self.filter_tags is not None:
            for k in self.filter_tags:
                result['FilterTags'].append(k.to_map() if k else None)
        if self.material_type is not None:
            result['MaterialType'] = self.material_type
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.positive_sample is not None:
            result['PositiveSample'] = self.positive_sample
        if self.positive_sample_file_key is not None:
            result['PositiveSampleFileKey'] = self.positive_sample_file_key
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiKey') is not None:
            self.api_key = m.get('ApiKey')
        self.content_tags = []
        if m.get('ContentTags') is not None:
            for k in m.get('ContentTags'):
                temp_model = SubmitEnterpriseVocAnalysisTaskRequestContentTags()
                self.content_tags.append(temp_model.from_map(k))
        self.contents = []
        if m.get('Contents') is not None:
            for k in m.get('Contents'):
                temp_model = SubmitEnterpriseVocAnalysisTaskRequestContents()
                self.contents.append(temp_model.from_map(k))
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        self.filter_tags = []
        if m.get('FilterTags') is not None:
            for k in m.get('FilterTags'):
                temp_model = SubmitEnterpriseVocAnalysisTaskRequestFilterTags()
                self.filter_tags.append(temp_model.from_map(k))
        if m.get('MaterialType') is not None:
            self.material_type = m.get('MaterialType')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('PositiveSample') is not None:
            self.positive_sample = m.get('PositiveSample')
        if m.get('PositiveSampleFileKey') is not None:
            self.positive_sample_file_key = m.get('PositiveSampleFileKey')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitEnterpriseVocAnalysisTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        api_key: str = None,
        content_tags_shrink: str = None,
        contents_shrink: str = None,
        file_key: str = None,
        filter_tags_shrink: str = None,
        material_type: str = None,
        model_id: str = None,
        positive_sample: str = None,
        positive_sample_file_key: str = None,
        task_type: str = None,
        workspace_id: str = None,
    ):
        self.api_key = api_key
        # This parameter is required.
        self.content_tags_shrink = content_tags_shrink
        self.contents_shrink = contents_shrink
        self.file_key = file_key
        self.filter_tags_shrink = filter_tags_shrink
        self.material_type = material_type
        # This parameter is required.
        self.model_id = model_id
        self.positive_sample = positive_sample
        self.positive_sample_file_key = positive_sample_file_key
        self.task_type = task_type
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_key is not None:
            result['ApiKey'] = self.api_key
        if self.content_tags_shrink is not None:
            result['ContentTags'] = self.content_tags_shrink
        if self.contents_shrink is not None:
            result['Contents'] = self.contents_shrink
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        if self.filter_tags_shrink is not None:
            result['FilterTags'] = self.filter_tags_shrink
        if self.material_type is not None:
            result['MaterialType'] = self.material_type
        if self.model_id is not None:
            result['ModelId'] = self.model_id
        if self.positive_sample is not None:
            result['PositiveSample'] = self.positive_sample
        if self.positive_sample_file_key is not None:
            result['PositiveSampleFileKey'] = self.positive_sample_file_key
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiKey') is not None:
            self.api_key = m.get('ApiKey')
        if m.get('ContentTags') is not None:
            self.content_tags_shrink = m.get('ContentTags')
        if m.get('Contents') is not None:
            self.contents_shrink = m.get('Contents')
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        if m.get('FilterTags') is not None:
            self.filter_tags_shrink = m.get('FilterTags')
        if m.get('MaterialType') is not None:
            self.material_type = m.get('MaterialType')
        if m.get('ModelId') is not None:
            self.model_id = m.get('ModelId')
        if m.get('PositiveSample') is not None:
            self.positive_sample = m.get('PositiveSample')
        if m.get('PositiveSampleFileKey') is not None:
            self.positive_sample_file_key = m.get('PositiveSampleFileKey')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitEnterpriseVocAnalysisTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SubmitEnterpriseVocAnalysisTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SubmitEnterpriseVocAnalysisTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SubmitEnterpriseVocAnalysisTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitEnterpriseVocAnalysisTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitEnterpriseVocAnalysisTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitEnterpriseVocAnalysisTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitExportTermsTaskRequest(TeaModel):
    def __init__(
        self,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitExportTermsTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SubmitExportTermsTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SubmitExportTermsTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SubmitExportTermsTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitExportTermsTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitExportTermsTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitExportTermsTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitFactAuditUrlRequest(TeaModel):
    def __init__(
        self,
        url: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.url is not None:
            result['Url'] = self.url
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitFactAuditUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitFactAuditUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitFactAuditUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitFactAuditUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitImportTermsTaskRequest(TeaModel):
    def __init__(
        self,
        file_key: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.file_key = file_key
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitImportTermsTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SubmitImportTermsTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SubmitImportTermsTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SubmitImportTermsTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitImportTermsTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitImportTermsTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitImportTermsTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSmartAuditRequestImageUrlList(TeaModel):
    def __init__(
        self,
        id: str = None,
        url: str = None,
    ):
        self.id = id
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class SubmitSmartAuditRequestImageUrls(TeaModel):
    def __init__(
        self,
        id: str = None,
        url: str = None,
    ):
        self.id = id
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class SubmitSmartAuditRequest(TeaModel):
    def __init__(
        self,
        image_url_list: List[SubmitSmartAuditRequestImageUrlList] = None,
        sub_codes: List[str] = None,
        text: str = None,
        workspace_id: str = None,
        image_urls: List[SubmitSmartAuditRequestImageUrls] = None,
    ):
        self.image_url_list = image_url_list
        self.sub_codes = sub_codes
        self.text = text
        self.workspace_id = workspace_id
        self.image_urls = image_urls

    def validate(self):
        if self.image_url_list:
            for k in self.image_url_list:
                if k:
                    k.validate()
        if self.image_urls:
            for k in self.image_urls:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageUrlList'] = []
        if self.image_url_list is not None:
            for k in self.image_url_list:
                result['ImageUrlList'].append(k.to_map() if k else None)
        if self.sub_codes is not None:
            result['SubCodes'] = self.sub_codes
        if self.text is not None:
            result['Text'] = self.text
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        result['imageUrls'] = []
        if self.image_urls is not None:
            for k in self.image_urls:
                result['imageUrls'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.image_url_list = []
        if m.get('ImageUrlList') is not None:
            for k in m.get('ImageUrlList'):
                temp_model = SubmitSmartAuditRequestImageUrlList()
                self.image_url_list.append(temp_model.from_map(k))
        if m.get('SubCodes') is not None:
            self.sub_codes = m.get('SubCodes')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        self.image_urls = []
        if m.get('imageUrls') is not None:
            for k in m.get('imageUrls'):
                temp_model = SubmitSmartAuditRequestImageUrls()
                self.image_urls.append(temp_model.from_map(k))
        return self


class SubmitSmartAuditShrinkRequest(TeaModel):
    def __init__(
        self,
        image_url_list_shrink: str = None,
        sub_codes_shrink: str = None,
        text: str = None,
        workspace_id: str = None,
        image_urls_shrink: str = None,
    ):
        self.image_url_list_shrink = image_url_list_shrink
        self.sub_codes_shrink = sub_codes_shrink
        self.text = text
        self.workspace_id = workspace_id
        self.image_urls_shrink = image_urls_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_url_list_shrink is not None:
            result['ImageUrlList'] = self.image_url_list_shrink
        if self.sub_codes_shrink is not None:
            result['SubCodes'] = self.sub_codes_shrink
        if self.text is not None:
            result['Text'] = self.text
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        if self.image_urls_shrink is not None:
            result['imageUrls'] = self.image_urls_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ImageUrlList') is not None:
            self.image_url_list_shrink = m.get('ImageUrlList')
        if m.get('SubCodes') is not None:
            self.sub_codes_shrink = m.get('SubCodes')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        if m.get('imageUrls') is not None:
            self.image_urls_shrink = m.get('imageUrls')
        return self


class SubmitSmartAuditResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SubmitSmartAuditResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SubmitSmartAuditResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SubmitSmartAuditResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitSmartAuditResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitSmartAuditResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSmartAuditResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSmartClipTaskRequestEditingConfigBackgroundMusicConfig(TeaModel):
    def __init__(
        self,
        style: str = None,
        volume: float = None,
    ):
        self.style = style
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.style is not None:
            result['Style'] = self.style
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Style') is not None:
            self.style = m.get('Style')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class SubmitSmartClipTaskRequestEditingConfigMediaConfig(TeaModel):
    def __init__(
        self,
        volume: float = None,
    ):
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class SubmitSmartClipTaskRequestEditingConfigSpeechConfigAsrConfig(TeaModel):
    def __init__(
        self,
        alignment: str = None,
        font: str = None,
        font_color: str = None,
        font_size: str = None,
        spacing: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alignment = alignment
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.spacing = spacing
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alignment is not None:
            result['Alignment'] = self.alignment
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.spacing is not None:
            result['Spacing'] = self.spacing
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alignment') is not None:
            self.alignment = m.get('Alignment')
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Spacing') is not None:
            self.spacing = m.get('Spacing')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class SubmitSmartClipTaskRequestEditingConfigSpeechConfig(TeaModel):
    def __init__(
        self,
        asr_config: SubmitSmartClipTaskRequestEditingConfigSpeechConfigAsrConfig = None,
        speech_rate: float = None,
        style: str = None,
        voice: str = None,
        volume: float = None,
    ):
        self.asr_config = asr_config
        self.speech_rate = speech_rate
        self.style = style
        self.voice = voice
        self.volume = volume

    def validate(self):
        if self.asr_config:
            self.asr_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asr_config is not None:
            result['AsrConfig'] = self.asr_config.to_map()
        if self.speech_rate is not None:
            result['SpeechRate'] = self.speech_rate
        if self.style is not None:
            result['Style'] = self.style
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsrConfig') is not None:
            temp_model = SubmitSmartClipTaskRequestEditingConfigSpeechConfigAsrConfig()
            self.asr_config = temp_model.from_map(m['AsrConfig'])
        if m.get('SpeechRate') is not None:
            self.speech_rate = m.get('SpeechRate')
        if m.get('Style') is not None:
            self.style = m.get('Style')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class SubmitSmartClipTaskRequestEditingConfigTitleConfig(TeaModel):
    def __init__(
        self,
        alignment: str = None,
        timeline_in: float = None,
        timeline_out: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alignment = alignment
        self.timeline_in = timeline_in
        self.timeline_out = timeline_out
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alignment is not None:
            result['Alignment'] = self.alignment
        if self.timeline_in is not None:
            result['TimelineIn'] = self.timeline_in
        if self.timeline_out is not None:
            result['TimelineOut'] = self.timeline_out
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alignment') is not None:
            self.alignment = m.get('Alignment')
        if m.get('TimelineIn') is not None:
            self.timeline_in = m.get('TimelineIn')
        if m.get('TimelineOut') is not None:
            self.timeline_out = m.get('TimelineOut')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class SubmitSmartClipTaskRequestEditingConfig(TeaModel):
    def __init__(
        self,
        background_music_config: SubmitSmartClipTaskRequestEditingConfigBackgroundMusicConfig = None,
        media_config: SubmitSmartClipTaskRequestEditingConfigMediaConfig = None,
        speech_config: SubmitSmartClipTaskRequestEditingConfigSpeechConfig = None,
        title_config: SubmitSmartClipTaskRequestEditingConfigTitleConfig = None,
    ):
        self.background_music_config = background_music_config
        self.media_config = media_config
        self.speech_config = speech_config
        self.title_config = title_config

    def validate(self):
        if self.background_music_config:
            self.background_music_config.validate()
        if self.media_config:
            self.media_config.validate()
        if self.speech_config:
            self.speech_config.validate()
        if self.title_config:
            self.title_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background_music_config is not None:
            result['BackgroundMusicConfig'] = self.background_music_config.to_map()
        if self.media_config is not None:
            result['MediaConfig'] = self.media_config.to_map()
        if self.speech_config is not None:
            result['SpeechConfig'] = self.speech_config.to_map()
        if self.title_config is not None:
            result['TitleConfig'] = self.title_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackgroundMusicConfig') is not None:
            temp_model = SubmitSmartClipTaskRequestEditingConfigBackgroundMusicConfig()
            self.background_music_config = temp_model.from_map(m['BackgroundMusicConfig'])
        if m.get('MediaConfig') is not None:
            temp_model = SubmitSmartClipTaskRequestEditingConfigMediaConfig()
            self.media_config = temp_model.from_map(m['MediaConfig'])
        if m.get('SpeechConfig') is not None:
            temp_model = SubmitSmartClipTaskRequestEditingConfigSpeechConfig()
            self.speech_config = temp_model.from_map(m['SpeechConfig'])
        if m.get('TitleConfig') is not None:
            temp_model = SubmitSmartClipTaskRequestEditingConfigTitleConfig()
            self.title_config = temp_model.from_map(m['TitleConfig'])
        return self


class SubmitSmartClipTaskRequestInputConfigBackgroundMusics(TeaModel):
    def __init__(
        self,
        id: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.id = id
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitSmartClipTaskRequestInputConfigStickersStickerId(TeaModel):
    def __init__(
        self,
        id: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.id = id
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitSmartClipTaskRequestInputConfigStickers(TeaModel):
    def __init__(
        self,
        height: float = None,
        sticker_id: SubmitSmartClipTaskRequestInputConfigStickersStickerId = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        # This parameter is required.
        self.height = height
        # This parameter is required.
        self.sticker_id = sticker_id
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.sticker_id:
            self.sticker_id.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.sticker_id is not None:
            result['StickerId'] = self.sticker_id.to_map()
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('StickerId') is not None:
            temp_model = SubmitSmartClipTaskRequestInputConfigStickersStickerId()
            self.sticker_id = temp_model.from_map(m['StickerId'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class SubmitSmartClipTaskRequestInputConfigVideoIds(TeaModel):
    def __init__(
        self,
        id: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.id = id
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitSmartClipTaskRequestInputConfig(TeaModel):
    def __init__(
        self,
        background_musics: List[SubmitSmartClipTaskRequestInputConfigBackgroundMusics] = None,
        speech_texts: List[str] = None,
        stickers: List[SubmitSmartClipTaskRequestInputConfigStickers] = None,
        titles: List[str] = None,
        video_ids: List[SubmitSmartClipTaskRequestInputConfigVideoIds] = None,
    ):
        self.background_musics = background_musics
        self.speech_texts = speech_texts
        self.stickers = stickers
        self.titles = titles
        # This parameter is required.
        self.video_ids = video_ids

    def validate(self):
        if self.background_musics:
            for k in self.background_musics:
                if k:
                    k.validate()
        if self.stickers:
            for k in self.stickers:
                if k:
                    k.validate()
        if self.video_ids:
            for k in self.video_ids:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BackgroundMusics'] = []
        if self.background_musics is not None:
            for k in self.background_musics:
                result['BackgroundMusics'].append(k.to_map() if k else None)
        if self.speech_texts is not None:
            result['SpeechTexts'] = self.speech_texts
        result['Stickers'] = []
        if self.stickers is not None:
            for k in self.stickers:
                result['Stickers'].append(k.to_map() if k else None)
        if self.titles is not None:
            result['Titles'] = self.titles
        result['VideoIds'] = []
        if self.video_ids is not None:
            for k in self.video_ids:
                result['VideoIds'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.background_musics = []
        if m.get('BackgroundMusics') is not None:
            for k in m.get('BackgroundMusics'):
                temp_model = SubmitSmartClipTaskRequestInputConfigBackgroundMusics()
                self.background_musics.append(temp_model.from_map(k))
        if m.get('SpeechTexts') is not None:
            self.speech_texts = m.get('SpeechTexts')
        self.stickers = []
        if m.get('Stickers') is not None:
            for k in m.get('Stickers'):
                temp_model = SubmitSmartClipTaskRequestInputConfigStickers()
                self.stickers.append(temp_model.from_map(k))
        if m.get('Titles') is not None:
            self.titles = m.get('Titles')
        self.video_ids = []
        if m.get('VideoIds') is not None:
            for k in m.get('VideoIds'):
                temp_model = SubmitSmartClipTaskRequestInputConfigVideoIds()
                self.video_ids.append(temp_model.from_map(k))
        return self


class SubmitSmartClipTaskRequestOutputConfig(TeaModel):
    def __init__(
        self,
        count: int = None,
        file_name: str = None,
        height: int = None,
        max_duration: int = None,
        save_to_generated_content: bool = None,
        width: int = None,
    ):
        self.count = count
        self.file_name = file_name
        self.height = height
        self.max_duration = max_duration
        self.save_to_generated_content = save_to_generated_content
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.height is not None:
            result['Height'] = self.height
        if self.max_duration is not None:
            result['MaxDuration'] = self.max_duration
        if self.save_to_generated_content is not None:
            result['SaveToGeneratedContent'] = self.save_to_generated_content
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MaxDuration') is not None:
            self.max_duration = m.get('MaxDuration')
        if m.get('SaveToGeneratedContent') is not None:
            self.save_to_generated_content = m.get('SaveToGeneratedContent')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitSmartClipTaskRequest(TeaModel):
    def __init__(
        self,
        editing_config: SubmitSmartClipTaskRequestEditingConfig = None,
        extend_param: str = None,
        input_config: SubmitSmartClipTaskRequestInputConfig = None,
        output_config: SubmitSmartClipTaskRequestOutputConfig = None,
        workspace_id: str = None,
    ):
        self.editing_config = editing_config
        self.extend_param = extend_param
        # This parameter is required.
        self.input_config = input_config
        self.output_config = output_config
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.editing_config:
            self.editing_config.validate()
        if self.input_config:
            self.input_config.validate()
        if self.output_config:
            self.output_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config.to_map()
        if self.extend_param is not None:
            result['ExtendParam'] = self.extend_param
        if self.input_config is not None:
            result['InputConfig'] = self.input_config.to_map()
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config.to_map()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EditingConfig') is not None:
            temp_model = SubmitSmartClipTaskRequestEditingConfig()
            self.editing_config = temp_model.from_map(m['EditingConfig'])
        if m.get('ExtendParam') is not None:
            self.extend_param = m.get('ExtendParam')
        if m.get('InputConfig') is not None:
            temp_model = SubmitSmartClipTaskRequestInputConfig()
            self.input_config = temp_model.from_map(m['InputConfig'])
        if m.get('OutputConfig') is not None:
            temp_model = SubmitSmartClipTaskRequestOutputConfig()
            self.output_config = temp_model.from_map(m['OutputConfig'])
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitSmartClipTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        editing_config_shrink: str = None,
        extend_param: str = None,
        input_config_shrink: str = None,
        output_config_shrink: str = None,
        workspace_id: str = None,
    ):
        self.editing_config_shrink = editing_config_shrink
        self.extend_param = extend_param
        # This parameter is required.
        self.input_config_shrink = input_config_shrink
        self.output_config_shrink = output_config_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.editing_config_shrink is not None:
            result['EditingConfig'] = self.editing_config_shrink
        if self.extend_param is not None:
            result['ExtendParam'] = self.extend_param
        if self.input_config_shrink is not None:
            result['InputConfig'] = self.input_config_shrink
        if self.output_config_shrink is not None:
            result['OutputConfig'] = self.output_config_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EditingConfig') is not None:
            self.editing_config_shrink = m.get('EditingConfig')
        if m.get('ExtendParam') is not None:
            self.extend_param = m.get('ExtendParam')
        if m.get('InputConfig') is not None:
            self.input_config_shrink = m.get('InputConfig')
        if m.get('OutputConfig') is not None:
            self.output_config_shrink = m.get('OutputConfig')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class SubmitSmartClipTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class SubmitSmartClipTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SubmitSmartClipTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SubmitSmartClipTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitSmartClipTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitSmartClipTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSmartClipTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocumentsComments(TeaModel):
    def __init__(
        self,
        text: str = None,
        username: str = None,
    ):
        self.text = text
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.text is not None:
            result['Text'] = self.text
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocuments(TeaModel):
    def __init__(
        self,
        author: str = None,
        comments: List[SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocumentsComments] = None,
        content: str = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.author = author
        self.comments = comments
        # This parameter is required.
        self.content = content
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        if self.comments:
            for k in self.comments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['Author'] = self.author
        result['Comments'] = []
        if self.comments is not None:
            for k in self.comments:
                result['Comments'].append(k.to_map() if k else None)
        if self.content is not None:
            result['Content'] = self.content
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Author') is not None:
            self.author = m.get('Author')
        self.comments = []
        if m.get('Comments') is not None:
            for k in m.get('Comments'):
                temp_model = SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocumentsComments()
                self.comments.append(temp_model.from_map(k))
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class SubmitTopicSelectionPerspectiveAnalysisTaskRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        documents: List[SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocuments] = None,
        perspective_types: List[str] = None,
        topic: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.documents = documents
        self.perspective_types = perspective_types
        self.topic = topic

    def validate(self):
        if self.documents:
            for k in self.documents:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        result['Documents'] = []
        if self.documents is not None:
            for k in self.documents:
                result['Documents'].append(k.to_map() if k else None)
        if self.perspective_types is not None:
            result['PerspectiveTypes'] = self.perspective_types
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        self.documents = []
        if m.get('Documents') is not None:
            for k in m.get('Documents'):
                temp_model = SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocuments()
                self.documents.append(temp_model.from_map(k))
        if m.get('PerspectiveTypes') is not None:
            self.perspective_types = m.get('PerspectiveTypes')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class SubmitTopicSelectionPerspectiveAnalysisTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        documents_shrink: str = None,
        perspective_types_shrink: str = None,
        topic: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.documents_shrink = documents_shrink
        self.perspective_types_shrink = perspective_types_shrink
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.documents_shrink is not None:
            result['Documents'] = self.documents_shrink
        if self.perspective_types_shrink is not None:
            result['PerspectiveTypes'] = self.perspective_types_shrink
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Documents') is not None:
            self.documents_shrink = m.get('Documents')
        if m.get('PerspectiveTypes') is not None:
            self.perspective_types_shrink = m.get('PerspectiveTypes')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class SubmitTopicSelectionPerspectiveAnalysisTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
        task_name: str = None,
    ):
        self.task_id = task_id
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class SubmitTopicSelectionPerspectiveAnalysisTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SubmitTopicSelectionPerspectiveAnalysisTaskResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SubmitTopicSelectionPerspectiveAnalysisTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubmitTopicSelectionPerspectiveAnalysisTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubmitTopicSelectionPerspectiveAnalysisTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitTopicSelectionPerspectiveAnalysisTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCustomTextRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        commodity_code: str = None,
        content: str = None,
        id: int = None,
        title: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.commodity_code = commodity_code
        self.content = content
        # This parameter is required.
        self.id = id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.content is not None:
            result['Content'] = self.content
        if self.id is not None:
            result['Id'] = self.id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateCustomTextResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: int = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCustomTextResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCustomTextResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCustomTextResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        value_format: str = None,
        value_type: str = None,
    ):
        self.name = name
        self.value = value
        self.value_format = value_format
        self.value_type = value_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        if self.value_format is not None:
            result['ValueFormat'] = self.value_format
        if self.value_type is not None:
            result['ValueType'] = self.value_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('ValueFormat') is not None:
            self.value_format = m.get('ValueFormat')
        if m.get('ValueType') is not None:
            self.value_type = m.get('ValueType')
        return self


class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        value_format: str = None,
        value_type: str = None,
    ):
        self.name = name
        self.value = value
        self.value_format = value_format
        self.value_type = value_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        if self.value_format is not None:
            result['ValueFormat'] = self.value_format
        if self.value_type is not None:
            result['ValueType'] = self.value_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('ValueFormat') is not None:
            self.value_format = m.get('ValueFormat')
        if m.get('ValueType') is not None:
            self.value_type = m.get('ValueType')
        return self


class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig(TeaModel):
    def __init__(
        self,
        body: str = None,
        connect_timeout: int = None,
        headers: List[UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders] = None,
        method: str = None,
        params: List[UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams] = None,
        path_params_enable: bool = None,
        socket_timeout: int = None,
        url: str = None,
    ):
        self.body = body
        self.connect_timeout = connect_timeout
        self.headers = headers
        self.method = method
        self.params = params
        self.path_params_enable = path_params_enable
        self.socket_timeout = socket_timeout
        self.url = url

    def validate(self):
        if self.headers:
            for k in self.headers:
                if k:
                    k.validate()
        if self.params:
            for k in self.params:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['Body'] = self.body
        if self.connect_timeout is not None:
            result['ConnectTimeout'] = self.connect_timeout
        result['Headers'] = []
        if self.headers is not None:
            for k in self.headers:
                result['Headers'].append(k.to_map() if k else None)
        if self.method is not None:
            result['Method'] = self.method
        result['Params'] = []
        if self.params is not None:
            for k in self.params:
                result['Params'].append(k.to_map() if k else None)
        if self.path_params_enable is not None:
            result['PathParamsEnable'] = self.path_params_enable
        if self.socket_timeout is not None:
            result['SocketTimeout'] = self.socket_timeout
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Body') is not None:
            self.body = m.get('Body')
        if m.get('ConnectTimeout') is not None:
            self.connect_timeout = m.get('ConnectTimeout')
        self.headers = []
        if m.get('Headers') is not None:
            for k in m.get('Headers'):
                temp_model = UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders()
                self.headers.append(temp_model.from_map(k))
        if m.get('Method') is not None:
            self.method = m.get('Method')
        self.params = []
        if m.get('Params') is not None:
            for k in m.get('Params'):
                temp_model = UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams()
                self.params.append(temp_model.from_map(k))
        if m.get('PathParamsEnable') is not None:
            self.path_params_enable = m.get('PathParamsEnable')
        if m.get('SocketTimeout') is not None:
            self.socket_timeout = m.get('SocketTimeout')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes(TeaModel):
    def __init__(
        self,
        key: str = None,
        path: str = None,
        type: str = None,
    ):
        self.key = key
        self.path = path
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes(TeaModel):
    def __init__(
        self,
        jq_nodes: List[UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes] = None,
        key: str = None,
        path: str = None,
        type: str = None,
    ):
        self.jq_nodes = jq_nodes
        self.key = key
        self.path = path
        self.type = type

    def validate(self):
        if self.jq_nodes:
            for k in self.jq_nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JqNodes'] = []
        if self.jq_nodes is not None:
            for k in self.jq_nodes:
                result['JqNodes'].append(k.to_map() if k else None)
        if self.key is not None:
            result['Key'] = self.key
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jq_nodes = []
        if m.get('JqNodes') is not None:
            for k in m.get('JqNodes'):
                temp_model = UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes()
                self.jq_nodes.append(temp_model.from_map(k))
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes(TeaModel):
    def __init__(
        self,
        jq_nodes: List[UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes] = None,
        key: str = None,
        path: str = None,
        type: str = None,
    ):
        self.jq_nodes = jq_nodes
        self.key = key
        self.path = path
        self.type = type

    def validate(self):
        if self.jq_nodes:
            for k in self.jq_nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JqNodes'] = []
        if self.jq_nodes is not None:
            for k in self.jq_nodes:
                result['JqNodes'].append(k.to_map() if k else None)
        if self.key is not None:
            result['Key'] = self.key
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jq_nodes = []
        if m.get('JqNodes') is not None:
            for k in m.get('JqNodes'):
                temp_model = UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes()
                self.jq_nodes.append(temp_model.from_map(k))
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig(TeaModel):
    def __init__(
        self,
        jq_nodes: List[UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes] = None,
    ):
        self.jq_nodes = jq_nodes

    def validate(self):
        if self.jq_nodes:
            for k in self.jq_nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JqNodes'] = []
        if self.jq_nodes is not None:
            for k in self.jq_nodes:
                result['JqNodes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.jq_nodes = []
        if m.get('JqNodes') is not None:
            for k in m.get('JqNodes'):
                temp_model = UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes()
                self.jq_nodes.append(temp_model.from_map(k))
        return self


class UpdateDatasetRequestDatasetConfigSearchSourceConfigs(TeaModel):
    def __init__(
        self,
        demo_query: str = None,
        search_source_request_config: UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig = None,
        search_source_response_config: UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig = None,
        size: int = None,
    ):
        self.demo_query = demo_query
        self.search_source_request_config = search_source_request_config
        self.search_source_response_config = search_source_response_config
        self.size = size

    def validate(self):
        if self.search_source_request_config:
            self.search_source_request_config.validate()
        if self.search_source_response_config:
            self.search_source_response_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.demo_query is not None:
            result['DemoQuery'] = self.demo_query
        if self.search_source_request_config is not None:
            result['SearchSourceRequestConfig'] = self.search_source_request_config.to_map()
        if self.search_source_response_config is not None:
            result['SearchSourceResponseConfig'] = self.search_source_response_config.to_map()
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DemoQuery') is not None:
            self.demo_query = m.get('DemoQuery')
        if m.get('SearchSourceRequestConfig') is not None:
            temp_model = UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig()
            self.search_source_request_config = temp_model.from_map(m['SearchSourceRequestConfig'])
        if m.get('SearchSourceResponseConfig') is not None:
            temp_model = UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig()
            self.search_source_response_config = temp_model.from_map(m['SearchSourceResponseConfig'])
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class UpdateDatasetRequestDatasetConfig(TeaModel):
    def __init__(
        self,
        search_source_configs: List[UpdateDatasetRequestDatasetConfigSearchSourceConfigs] = None,
    ):
        self.search_source_configs = search_source_configs

    def validate(self):
        if self.search_source_configs:
            for k in self.search_source_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SearchSourceConfigs'] = []
        if self.search_source_configs is not None:
            for k in self.search_source_configs:
                result['SearchSourceConfigs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.search_source_configs = []
        if m.get('SearchSourceConfigs') is not None:
            for k in m.get('SearchSourceConfigs'):
                temp_model = UpdateDatasetRequestDatasetConfigSearchSourceConfigs()
                self.search_source_configs.append(temp_model.from_map(k))
        return self


class UpdateDatasetRequest(TeaModel):
    def __init__(
        self,
        dataset_config: UpdateDatasetRequestDatasetConfig = None,
        dataset_description: str = None,
        dataset_id: int = None,
        search_dataset_enable: int = None,
        workspace_id: str = None,
    ):
        self.dataset_config = dataset_config
        self.dataset_description = dataset_description
        self.dataset_id = dataset_id
        self.search_dataset_enable = search_dataset_enable
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.dataset_config:
            self.dataset_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_config is not None:
            result['DatasetConfig'] = self.dataset_config.to_map()
        if self.dataset_description is not None:
            result['DatasetDescription'] = self.dataset_description
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.search_dataset_enable is not None:
            result['SearchDatasetEnable'] = self.search_dataset_enable
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetConfig') is not None:
            temp_model = UpdateDatasetRequestDatasetConfig()
            self.dataset_config = temp_model.from_map(m['DatasetConfig'])
        if m.get('DatasetDescription') is not None:
            self.dataset_description = m.get('DatasetDescription')
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('SearchDatasetEnable') is not None:
            self.search_dataset_enable = m.get('SearchDatasetEnable')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateDatasetShrinkRequest(TeaModel):
    def __init__(
        self,
        dataset_config_shrink: str = None,
        dataset_description: str = None,
        dataset_id: int = None,
        search_dataset_enable: int = None,
        workspace_id: str = None,
    ):
        self.dataset_config_shrink = dataset_config_shrink
        self.dataset_description = dataset_description
        self.dataset_id = dataset_id
        self.search_dataset_enable = search_dataset_enable
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_config_shrink is not None:
            result['DatasetConfig'] = self.dataset_config_shrink
        if self.dataset_description is not None:
            result['DatasetDescription'] = self.dataset_description
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.search_dataset_enable is not None:
            result['SearchDatasetEnable'] = self.search_dataset_enable
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetConfig') is not None:
            self.dataset_config_shrink = m.get('DatasetConfig')
        if m.get('DatasetDescription') is not None:
            self.dataset_description = m.get('DatasetDescription')
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('SearchDatasetEnable') is not None:
            self.search_dataset_enable = m.get('SearchDatasetEnable')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateDatasetResponseBodyDataNewsArticleResultsData(TeaModel):
    def __init__(
        self,
        content: str = None,
        pub_time: str = None,
        source: str = None,
        summary: str = None,
        title: str = None,
        url: str = None,
    ):
        self.content = content
        self.pub_time = pub_time
        self.source = source
        self.summary = summary
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class UpdateDatasetResponseBodyDataNewsArticleResults(TeaModel):
    def __init__(
        self,
        code: str = None,
        current: int = None,
        data: List[UpdateDatasetResponseBodyDataNewsArticleResultsData] = None,
        message: str = None,
        size: int = None,
        total: int = None,
    ):
        self.code = code
        self.current = current
        self.data = data
        self.message = message
        self.size = size
        self.total = total

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current is not None:
            result['Current'] = self.current
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Current') is not None:
            self.current = m.get('Current')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = UpdateDatasetResponseBodyDataNewsArticleResultsData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class UpdateDatasetResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        create_user: str = None,
        dataset_description: str = None,
        dataset_id: int = None,
        dataset_name: str = None,
        dataset_type: str = None,
        news_article_results: List[UpdateDatasetResponseBodyDataNewsArticleResults] = None,
        search_dataset_enable: int = None,
    ):
        self.create_time = create_time
        self.create_user = create_user
        self.dataset_description = dataset_description
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        self.dataset_type = dataset_type
        self.news_article_results = news_article_results
        self.search_dataset_enable = search_dataset_enable

    def validate(self):
        if self.news_article_results:
            for k in self.news_article_results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.create_user is not None:
            result['CreateUser'] = self.create_user
        if self.dataset_description is not None:
            result['DatasetDescription'] = self.dataset_description
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.dataset_type is not None:
            result['DatasetType'] = self.dataset_type
        result['NewsArticleResults'] = []
        if self.news_article_results is not None:
            for k in self.news_article_results:
                result['NewsArticleResults'].append(k.to_map() if k else None)
        if self.search_dataset_enable is not None:
            result['SearchDatasetEnable'] = self.search_dataset_enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreateUser') is not None:
            self.create_user = m.get('CreateUser')
        if m.get('DatasetDescription') is not None:
            self.dataset_description = m.get('DatasetDescription')
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('DatasetType') is not None:
            self.dataset_type = m.get('DatasetType')
        self.news_article_results = []
        if m.get('NewsArticleResults') is not None:
            for k in m.get('NewsArticleResults'):
                temp_model = UpdateDatasetResponseBodyDataNewsArticleResults()
                self.news_article_results.append(temp_model.from_map(k))
        if m.get('SearchDatasetEnable') is not None:
            self.search_dataset_enable = m.get('SearchDatasetEnable')
        return self


class UpdateDatasetResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateDatasetResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateDatasetResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDatasetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDatasetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDatasetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDatasetDocumentRequestDocument(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        title: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateDatasetDocumentRequest(TeaModel):
    def __init__(
        self,
        dataset_id: int = None,
        dataset_name: str = None,
        document: UpdateDatasetDocumentRequestDocument = None,
        workspace_id: str = None,
    ):
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        # This parameter is required.
        self.document = document
        self.workspace_id = workspace_id

    def validate(self):
        if self.document:
            self.document.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.document is not None:
            result['Document'] = self.document.to_map()
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('Document') is not None:
            temp_model = UpdateDatasetDocumentRequestDocument()
            self.document = temp_model.from_map(m['Document'])
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateDatasetDocumentShrinkRequest(TeaModel):
    def __init__(
        self,
        dataset_id: int = None,
        dataset_name: str = None,
        document_shrink: str = None,
        workspace_id: str = None,
    ):
        self.dataset_id = dataset_id
        self.dataset_name = dataset_name
        # This parameter is required.
        self.document_shrink = document_shrink
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.dataset_name is not None:
            result['DatasetName'] = self.dataset_name
        if self.document_shrink is not None:
            result['Document'] = self.document_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('DatasetName') is not None:
            self.dataset_name = m.get('DatasetName')
        if m.get('Document') is not None:
            self.document_shrink = m.get('Document')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UpdateDatasetDocumentResponseBodyData(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        doc_uuid: str = None,
        title: str = None,
    ):
        self.doc_id = doc_id
        self.doc_uuid = doc_uuid
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['DocId'] = self.doc_id
        if self.doc_uuid is not None:
            result['DocUuid'] = self.doc_uuid
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocId') is not None:
            self.doc_id = m.get('DocId')
        if m.get('DocUuid') is not None:
            self.doc_uuid = m.get('DocUuid')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateDatasetDocumentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateDatasetDocumentResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateDatasetDocumentResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDatasetDocumentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDatasetDocumentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDatasetDocumentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGeneratedContentRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        content: str = None,
        content_text: str = None,
        id: int = None,
        keywords: List[str] = None,
        prompt: str = None,
        title: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.content = content
        self.content_text = content_text
        # This parameter is required.
        self.id = id
        self.keywords = keywords
        self.prompt = prompt
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.content is not None:
            result['Content'] = self.content
        if self.content_text is not None:
            result['ContentText'] = self.content_text
        if self.id is not None:
            result['Id'] = self.id
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentText') is not None:
            self.content_text = m.get('ContentText')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateGeneratedContentShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        content: str = None,
        content_text: str = None,
        id: int = None,
        keywords_shrink: str = None,
        prompt: str = None,
        title: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.content = content
        self.content_text = content_text
        # This parameter is required.
        self.id = id
        self.keywords_shrink = keywords_shrink
        self.prompt = prompt
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.content is not None:
            result['Content'] = self.content
        if self.content_text is not None:
            result['ContentText'] = self.content_text
        if self.id is not None:
            result['Id'] = self.id
        if self.keywords_shrink is not None:
            result['Keywords'] = self.keywords_shrink
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentText') is not None:
            self.content_text = m.get('ContentText')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Keywords') is not None:
            self.keywords_shrink = m.get('Keywords')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateGeneratedContentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateGeneratedContentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateGeneratedContentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateGeneratedContentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMaterialDocumentRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        author: str = None,
        doc_keywords: List[str] = None,
        doc_type: str = None,
        external_url: str = None,
        html_content: str = None,
        id: int = None,
        pub_time: str = None,
        region_id: str = None,
        share_attr: int = None,
        src_from: str = None,
        summary: str = None,
        text_content: str = None,
        title: str = None,
        url: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.author = author
        self.doc_keywords = doc_keywords
        # This parameter is required.
        self.doc_type = doc_type
        self.external_url = external_url
        self.html_content = html_content
        # This parameter is required.
        self.id = id
        self.pub_time = pub_time
        self.region_id = region_id
        self.share_attr = share_attr
        self.src_from = src_from
        self.summary = summary
        self.text_content = text_content
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.author is not None:
            result['Author'] = self.author
        if self.doc_keywords is not None:
            result['DocKeywords'] = self.doc_keywords
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.external_url is not None:
            result['ExternalUrl'] = self.external_url
        if self.html_content is not None:
            result['HtmlContent'] = self.html_content
        if self.id is not None:
            result['Id'] = self.id
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.share_attr is not None:
            result['ShareAttr'] = self.share_attr
        if self.src_from is not None:
            result['SrcFrom'] = self.src_from
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.text_content is not None:
            result['TextContent'] = self.text_content
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('DocKeywords') is not None:
            self.doc_keywords = m.get('DocKeywords')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('ExternalUrl') is not None:
            self.external_url = m.get('ExternalUrl')
        if m.get('HtmlContent') is not None:
            self.html_content = m.get('HtmlContent')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShareAttr') is not None:
            self.share_attr = m.get('ShareAttr')
        if m.get('SrcFrom') is not None:
            self.src_from = m.get('SrcFrom')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TextContent') is not None:
            self.text_content = m.get('TextContent')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class UpdateMaterialDocumentShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_key: str = None,
        author: str = None,
        doc_keywords_shrink: str = None,
        doc_type: str = None,
        external_url: str = None,
        html_content: str = None,
        id: int = None,
        pub_time: str = None,
        region_id: str = None,
        share_attr: int = None,
        src_from: str = None,
        summary: str = None,
        text_content: str = None,
        title: str = None,
        url: str = None,
    ):
        # This parameter is required.
        self.agent_key = agent_key
        self.author = author
        self.doc_keywords_shrink = doc_keywords_shrink
        # This parameter is required.
        self.doc_type = doc_type
        self.external_url = external_url
        self.html_content = html_content
        # This parameter is required.
        self.id = id
        self.pub_time = pub_time
        self.region_id = region_id
        self.share_attr = share_attr
        self.src_from = src_from
        self.summary = summary
        self.text_content = text_content
        self.title = title
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_key is not None:
            result['AgentKey'] = self.agent_key
        if self.author is not None:
            result['Author'] = self.author
        if self.doc_keywords_shrink is not None:
            result['DocKeywords'] = self.doc_keywords_shrink
        if self.doc_type is not None:
            result['DocType'] = self.doc_type
        if self.external_url is not None:
            result['ExternalUrl'] = self.external_url
        if self.html_content is not None:
            result['HtmlContent'] = self.html_content
        if self.id is not None:
            result['Id'] = self.id
        if self.pub_time is not None:
            result['PubTime'] = self.pub_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.share_attr is not None:
            result['ShareAttr'] = self.share_attr
        if self.src_from is not None:
            result['SrcFrom'] = self.src_from
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.text_content is not None:
            result['TextContent'] = self.text_content
        if self.title is not None:
            result['Title'] = self.title
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentKey') is not None:
            self.agent_key = m.get('AgentKey')
        if m.get('Author') is not None:
            self.author = m.get('Author')
        if m.get('DocKeywords') is not None:
            self.doc_keywords_shrink = m.get('DocKeywords')
        if m.get('DocType') is not None:
            self.doc_type = m.get('DocType')
        if m.get('ExternalUrl') is not None:
            self.external_url = m.get('ExternalUrl')
        if m.get('HtmlContent') is not None:
            self.html_content = m.get('HtmlContent')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('PubTime') is not None:
            self.pub_time = m.get('PubTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShareAttr') is not None:
            self.share_attr = m.get('ShareAttr')
        if m.get('SrcFrom') is not None:
            self.src_from = m.get('SrcFrom')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('TextContent') is not None:
            self.text_content = m.get('TextContent')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class UpdateMaterialDocumentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: int = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateMaterialDocumentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMaterialDocumentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMaterialDocumentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UploadBookRequestDocs(TeaModel):
    def __init__(
        self,
        doc_name: str = None,
        file_url: str = None,
    ):
        self.doc_name = doc_name
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_name is not None:
            result['DocName'] = self.doc_name
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocName') is not None:
            self.doc_name = m.get('DocName')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class UploadBookRequest(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        docs: List[UploadBookRequestDocs] = None,
        workspace_id: str = None,
    ):
        self.category_id = category_id
        # This parameter is required.
        self.docs = docs
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.docs:
            for k in self.docs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        result['Docs'] = []
        if self.docs is not None:
            for k in self.docs:
                result['Docs'].append(k.to_map() if k else None)
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        self.docs = []
        if m.get('Docs') is not None:
            for k in m.get('Docs'):
                temp_model = UploadBookRequestDocs()
                self.docs.append(temp_model.from_map(k))
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UploadBookShrinkRequest(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        docs_shrink: str = None,
        workspace_id: str = None,
    ):
        self.category_id = category_id
        # This parameter is required.
        self.docs_shrink = docs_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.docs_shrink is not None:
            result['Docs'] = self.docs_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('Docs') is not None:
            self.docs_shrink = m.get('Docs')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UploadBookResponseBodyData(TeaModel):
    def __init__(
        self,
        doc_ids: List[str] = None,
        existed_ids: List[str] = None,
    ):
        self.doc_ids = doc_ids
        self.existed_ids = existed_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_ids is not None:
            result['DocIds'] = self.doc_ids
        if self.existed_ids is not None:
            result['ExistedIds'] = self.existed_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocIds') is not None:
            self.doc_ids = m.get('DocIds')
        if m.get('ExistedIds') is not None:
            self.existed_ids = m.get('ExistedIds')
        return self


class UploadBookResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UploadBookResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UploadBookResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UploadBookResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UploadBookResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UploadBookResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UploadDocRequestDocs(TeaModel):
    def __init__(
        self,
        doc_name: str = None,
        file_url: str = None,
    ):
        # This parameter is required.
        self.doc_name = doc_name
        # This parameter is required.
        self.file_url = file_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_name is not None:
            result['DocName'] = self.doc_name
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocName') is not None:
            self.doc_name = m.get('DocName')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        return self


class UploadDocRequest(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        docs: List[UploadDocRequestDocs] = None,
        workspace_id: str = None,
    ):
        self.category_id = category_id
        # This parameter is required.
        self.docs = docs
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        if self.docs:
            for k in self.docs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        result['Docs'] = []
        if self.docs is not None:
            for k in self.docs:
                result['Docs'].append(k.to_map() if k else None)
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        self.docs = []
        if m.get('Docs') is not None:
            for k in m.get('Docs'):
                temp_model = UploadDocRequestDocs()
                self.docs.append(temp_model.from_map(k))
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UploadDocShrinkRequest(TeaModel):
    def __init__(
        self,
        category_id: str = None,
        docs_shrink: str = None,
        workspace_id: str = None,
    ):
        self.category_id = category_id
        # This parameter is required.
        self.docs_shrink = docs_shrink
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_id is not None:
            result['CategoryId'] = self.category_id
        if self.docs_shrink is not None:
            result['Docs'] = self.docs_shrink
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryId') is not None:
            self.category_id = m.get('CategoryId')
        if m.get('Docs') is not None:
            self.docs_shrink = m.get('Docs')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class UploadDocResponseBodyData(TeaModel):
    def __init__(
        self,
        doc_ids: List[str] = None,
        existed_ids: List[str] = None,
    ):
        self.doc_ids = doc_ids
        self.existed_ids = existed_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_ids is not None:
            result['DocIds'] = self.doc_ids
        if self.existed_ids is not None:
            result['ExistedIds'] = self.existed_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DocIds') is not None:
            self.doc_ids = m.get('DocIds')
        if m.get('ExistedIds') is not None:
            self.existed_ids = m.get('ExistedIds')
        return self


class UploadDocResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UploadDocResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UploadDocResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UploadDocResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UploadDocResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UploadDocResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ValidateUploadTemplateRequest(TeaModel):
    def __init__(
        self,
        file_key: str = None,
        task_type: str = None,
        template_type: str = None,
        workspace_id: str = None,
    ):
        # This parameter is required.
        self.file_key = file_key
        self.task_type = task_type
        # This parameter is required.
        self.template_type = template_type
        # This parameter is required.
        self.workspace_id = workspace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_key is not None:
            result['FileKey'] = self.file_key
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.workspace_id is not None:
            result['WorkspaceId'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileKey') is not None:
            self.file_key = m.get('FileKey')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('WorkspaceId') is not None:
            self.workspace_id = m.get('WorkspaceId')
        return self


class ValidateUploadTemplateResponseBodyData(TeaModel):
    def __init__(
        self,
        comment_count: int = None,
        dialogue_count: int = None,
        total_count: int = None,
    ):
        self.comment_count = comment_count
        self.dialogue_count = dialogue_count
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment_count is not None:
            result['CommentCount'] = self.comment_count
        if self.dialogue_count is not None:
            result['DialogueCount'] = self.dialogue_count
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommentCount') is not None:
            self.comment_count = m.get('CommentCount')
        if m.get('DialogueCount') is not None:
            self.dialogue_count = m.get('DialogueCount')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ValidateUploadTemplateResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ValidateUploadTemplateResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.http_status_code = http_status_code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ValidateUploadTemplateResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ValidateUploadTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ValidateUploadTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ValidateUploadTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


